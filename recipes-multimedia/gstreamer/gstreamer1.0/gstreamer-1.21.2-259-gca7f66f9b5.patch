diff --git a/subprojects/gstreamer/docs/plugins/gst_plugins_cache.json b/subprojects/gstreamer/docs/plugins/gst_plugins_cache.json
index 67927f5652..cbe32ab038 100644
--- a/subprojects/gstreamer/docs/plugins/gst_plugins_cache.json
+++ b/subprojects/gstreamer/docs/plugins/gst_plugins_cache.json
@@ -1332,6 +1332,18 @@
                         "type": "gboolean",
                         "writable": true
                     },
+                    "drop-backwards": {
+                        "blurb": "Drop backwards buffers on pad switch",
+                        "conditionally-available": false,
+                        "construct": false,
+                        "construct-only": false,
+                        "controllable": false,
+                        "default": "false",
+                        "mutable": "ready",
+                        "readable": true,
+                        "type": "gboolean",
+                        "writable": true
+                    },
                     "n-pads": {
                         "blurb": "The number of sink pads",
                         "conditionally-available": false,
diff --git a/subprojects/gstreamer/gst/gstallocator.c b/subprojects/gstreamer/gst/gstallocator.c
index 6b3047636d..f3cd20e86d 100644
--- a/subprojects/gstreamer/gst/gstallocator.c
+++ b/subprojects/gstreamer/gst/gstallocator.c
@@ -233,13 +233,14 @@ gst_allocator_register (const gchar * name, GstAllocator * allocator)
   g_rw_lock_writer_lock (&lock);
   /* The ref will never be released */
   GST_OBJECT_FLAG_SET (allocator, GST_OBJECT_FLAG_MAY_BE_LEAKED);
-  g_hash_table_insert (allocators, (gpointer) name, (gpointer) allocator);
+  g_hash_table_insert (allocators, (gpointer) g_strdup (name),
+      (gpointer) allocator);
   g_rw_lock_writer_unlock (&lock);
 }
 
 /**
  * gst_allocator_find:
- * @name: (allow-none): the name of the allocator
+ * @name: (nullable): the name of the allocator
  *
  * Find a previously registered allocator with @name. When @name is %NULL, the
  * default allocator will be returned.
@@ -289,9 +290,9 @@ gst_allocator_set_default (GstAllocator * allocator)
 
 /**
  * gst_allocator_alloc:
- * @allocator: (transfer none) (allow-none): a #GstAllocator to use
+ * @allocator: (transfer none) (nullable): a #GstAllocator to use
  * @size: size of the visible memory area
- * @params: (transfer none) (allow-none): optional parameters
+ * @params: (transfer none) (nullable): optional parameters
  *
  * Use @allocator to allocate a new memory block with memory that is at least
  * @size big.
@@ -599,7 +600,7 @@ void
 _priv_gst_allocator_initialize (void)
 {
   g_rw_lock_init (&lock);
-  allocators = g_hash_table_new_full (g_str_hash, g_str_equal, NULL,
+  allocators = g_hash_table_new_full (g_str_hash, g_str_equal, g_free,
       gst_object_unref);
 
 #ifdef HAVE_GETPAGESIZE
@@ -642,8 +643,8 @@ _priv_gst_allocator_cleanup (void)
  * @maxsize: allocated size of @data
  * @offset: offset in @data
  * @size: size of valid data
- * @user_data: (allow-none): user_data
- * @notify: (allow-none) (scope async) (closure user_data): called with @user_data when the memory is freed
+ * @user_data: (nullable): user_data
+ * @notify: (nullable) (scope async) (closure user_data): called with @user_data when the memory is freed
  *
  * Allocate a new memory block that wraps the given @data.
  *
diff --git a/subprojects/gstreamer/gst/gstchildproxy.c b/subprojects/gstreamer/gst/gstchildproxy.c
index f229045eb7..fc4f7421ac 100644
--- a/subprojects/gstreamer/gst/gstchildproxy.c
+++ b/subprojects/gstreamer/gst/gstchildproxy.c
@@ -57,7 +57,7 @@ static guint signals[LAST_SIGNAL] = { 0 };
 
 /**
  * gst_child_proxy_get_child_by_name_recurse:
- * @parent: the parent object to get the child from
+ * @child_proxy: the parent object to get the child from
  * @name: the full-path child's name
  *
  * Looks up a child element by the given full-path name.
diff --git a/subprojects/gstreamer/gst/gstevent.c b/subprojects/gstreamer/gst/gstevent.c
index 29d15a0abf..6ab77b3d85 100644
--- a/subprojects/gstreamer/gst/gstevent.c
+++ b/subprojects/gstreamer/gst/gstevent.c
@@ -213,6 +213,33 @@ gst_event_type_get_flags (GstEventType type)
   return ret;
 }
 
+/**
+ * gst_event_type_to_sticky_ordering
+ * @type: a #GstEventType
+ *
+ * Converts the #GstEventType to an unsigned integer that
+ * represents the ordering of sticky events when re-sending them.
+ * A lower value represents a higher-priority event.
+ *
+ * Returns: an unsigned integer
+ * Since: 1.22
+ */
+/* FIXME 2.0: Remove the sticky event order overrides once
+ * the event type numbers are fixed */
+guint
+gst_event_type_to_sticky_ordering (GstEventType type)
+{
+  guint sticky_order = type;
+
+  /* Fix up the sticky event ordering for events where the
+   * type was chosen poorly */
+  if (type == GST_EVENT_INSTANT_RATE_CHANGE) {
+    sticky_order = GST_EVENT_SEGMENT + 1;
+  }
+
+  return sticky_order;
+}
+
 static void
 _gst_event_free (GstEvent * event)
 {
@@ -1920,7 +1947,7 @@ gst_event_parse_group_id (GstEvent * event, guint * group_id)
 
 /**
  * gst_event_new_stream_collection:
- * @collection: Active collection for this data flow
+ * @collection: (transfer none): Active collection for this data flow
  *
  * Create a new STREAM_COLLECTION event. The stream collection event can only
  * travel downstream synchronized with the buffer flow.
diff --git a/subprojects/gstreamer/gst/gstevent.h b/subprojects/gstreamer/gst/gstevent.h
index e036a34ad4..a58eb40aa8 100644
--- a/subprojects/gstreamer/gst/gstevent.h
+++ b/subprojects/gstreamer/gst/gstevent.h
@@ -169,6 +169,7 @@ typedef enum {
   GST_EVENT_GAP                   = GST_EVENT_MAKE_TYPE (160, _FLAG(DOWNSTREAM) | _FLAG(SERIALIZED)),
 
   /* sticky downstream non-serialized */
+  /* FIXME 2.0: change to value 72 and move after the GST_EVENT_SEGMENT event */
   GST_EVENT_INSTANT_RATE_CHANGE   = GST_EVENT_MAKE_TYPE (180, _FLAG(DOWNSTREAM) | _FLAG(STICKY)),
 
   /* upstream events */
@@ -417,6 +418,10 @@ GST_API
 GstEventTypeFlags
                 gst_event_type_get_flags        (GstEventType type);
 
+
+GST_API
+guint gst_event_type_to_sticky_ordering (GstEventType type) G_GNUC_CONST;
+
 #ifndef GST_DISABLE_MINIOBJECT_INLINE_FUNCTIONS
 /* refcounting */
 static inline GstEvent *
diff --git a/subprojects/gstreamer/gst/gstpad.c b/subprojects/gstreamer/gst/gstpad.c
index 994f13f5b7..db9893352a 100644
--- a/subprojects/gstreamer/gst/gstpad.c
+++ b/subprojects/gstreamer/gst/gstpad.c
@@ -128,6 +128,7 @@ enum
 typedef struct
 {
   gboolean received;
+  guint sticky_order;
   GstEvent *event;
 } PadEvent;
 
@@ -459,6 +460,8 @@ remove_events (GstPad * pad)
   }
 }
 
+#define _to_sticky_order(t) gst_event_type_to_sticky_ordering(t)
+
 /* should be called with object lock */
 static PadEvent *
 find_event_by_type (GstPad * pad, GstEventType type, guint idx)
@@ -466,6 +469,7 @@ find_event_by_type (GstPad * pad, GstEventType type, guint idx)
   guint i, len;
   GArray *events;
   PadEvent *ev;
+  guint last_sticky_order = _to_sticky_order (type);
 
   events = pad->priv->events;
   len = events->len;
@@ -479,7 +483,7 @@ find_event_by_type (GstPad * pad, GstEventType type, guint idx)
       if (idx == 0)
         goto found;
       idx--;
-    } else if (GST_EVENT_TYPE (ev->event) > type) {
+    } else if (ev->sticky_order > last_sticky_order) {
       break;
     }
   }
@@ -499,11 +503,12 @@ find_event (GstPad * pad, GstEvent * event)
   events = pad->priv->events;
   len = events->len;
 
+  guint sticky_order = _to_sticky_order (GST_EVENT_TYPE (event));
   for (i = 0; i < len; i++) {
     ev = &g_array_index (events, PadEvent, i);
     if (event == ev->event)
       goto found;
-    else if (GST_EVENT_TYPE (ev->event) > GST_EVENT_TYPE (event))
+    else if (ev->sticky_order > sticky_order)
       break;
   }
   ev = NULL;
@@ -522,13 +527,15 @@ remove_event_by_type (GstPad * pad, GstEventType type)
   events = pad->priv->events;
   len = events->len;
 
+  guint last_sticky_order = _to_sticky_order (type);
+
   i = 0;
   while (i < len) {
     ev = &g_array_index (events, PadEvent, i);
     if (ev->event == NULL)
       goto next;
 
-    if (GST_EVENT_TYPE (ev->event) > type)
+    if (ev->sticky_order > last_sticky_order)
       break;
     else if (GST_EVENT_TYPE (ev->event) != type)
       goto next;
@@ -599,6 +606,7 @@ restart:
       goto next;
 
     /* take additional ref, func might release the lock */
+    ev_ret.sticky_order = ev->sticky_order;
     ev_ret.event = gst_event_ref (ev->event);
     ev_ret.received = ev->received;
 
@@ -4033,12 +4041,17 @@ push_sticky (GstPad * pad, PadEvent * ev, gpointer user_data)
     return TRUE;
   }
 
+  guint data_sticky_order = 0;
+  if (data->event) {
+    data_sticky_order = _to_sticky_order (GST_EVENT_TYPE (data->event));
+  }
+
   /* If we're called because of an sticky event, only forward
    * events that would come before this new event and the
    * event itself */
   if (data->event && GST_EVENT_IS_STICKY (data->event) &&
-      GST_EVENT_TYPE (data->event) <= GST_EVENT_SEGMENT &&
-      GST_EVENT_TYPE (data->event) < GST_EVENT_TYPE (event)) {
+      data_sticky_order <= _to_sticky_order (GST_EVENT_SEGMENT) &&
+      data_sticky_order < ev->sticky_order) {
     data->ret = GST_FLOW_CUSTOM_SUCCESS_1;
   } else {
     data->ret = gst_pad_push_event_unchecked (pad, gst_event_ref (event),
@@ -4969,11 +4982,11 @@ flushing:
   }
 wrong_mode:
   {
-    g_critical ("getrange on pad %s:%s but it was not activated in pull mode",
-        GST_DEBUG_PAD_NAME (pad));
     pad->ABI.abi.last_flowret = GST_FLOW_ERROR;
     GST_OBJECT_UNLOCK (pad);
     GST_PAD_STREAM_UNLOCK (pad);
+    g_critical ("getrange on pad %s:%s but it was not activated in pull mode",
+        GST_DEBUG_PAD_NAME (pad));
     return GST_FLOW_ERROR;
   }
 events_error:
@@ -5295,6 +5308,7 @@ store_sticky_event (GstPad * pad, GstEvent * event)
   gboolean insert = TRUE;
 
   type = GST_EVENT_TYPE (event);
+  guint sticky_order = _to_sticky_order (type);
 
   /* Store all sticky events except SEGMENT/EOS when we're flushing,
    * otherwise they can be dropped and nothing would ever resend them.
@@ -5343,11 +5357,11 @@ store_sticky_event (GstPad * pad, GstEvent * event)
       break;
     }
 
-    if (type < GST_EVENT_TYPE (ev->event) || (type != GST_EVENT_TYPE (ev->event)
+    if (sticky_order < ev->sticky_order || (type != GST_EVENT_TYPE (ev->event)
             && GST_EVENT_TYPE (ev->event) == GST_EVENT_EOS)) {
       /* STREAM_START, CAPS and SEGMENT must be delivered in this order. By
        * storing the sticky ordered we can check that this is respected. */
-      if (G_UNLIKELY (GST_EVENT_TYPE (ev->event) <= GST_EVENT_SEGMENT
+      if (G_UNLIKELY (ev->sticky_order <= _to_sticky_order (GST_EVENT_SEGMENT)
               || GST_EVENT_TYPE (ev->event) == GST_EVENT_EOS))
         g_warning (G_STRLOC
             ":%s:<%s:%s> Sticky event misordering, got '%s' before '%s'",
@@ -5359,6 +5373,7 @@ store_sticky_event (GstPad * pad, GstEvent * event)
   }
   if (insert) {
     PadEvent ev;
+    ev.sticky_order = sticky_order;
     ev.event = gst_event_ref (event);
     ev.received = FALSE;
     g_array_insert_val (events, i, ev);
@@ -5438,7 +5453,7 @@ sticky_changed (GstPad * pad, PadEvent * ev, gpointer user_data)
 
   /* Forward all sticky events before our current one that are pending */
   if (ev->event != data->event
-      && GST_EVENT_TYPE (ev->event) < GST_EVENT_TYPE (data->event))
+      && ev->sticky_order < _to_sticky_order (GST_EVENT_TYPE (data->event)))
     return push_sticky (pad, ev, data);
 
   return TRUE;
diff --git a/subprojects/gstreamer/gst/gststreams.c b/subprojects/gstreamer/gst/gststreams.c
index 1a021870ee..a6bf5d901e 100644
--- a/subprojects/gstreamer/gst/gststreams.c
+++ b/subprojects/gstreamer/gst/gststreams.c
@@ -191,6 +191,7 @@ gst_stream_finalize (GObject * object)
       (GstMiniObject *) NULL);
   gst_caps_replace (&stream->priv->caps, NULL);
   g_free ((gchar *) stream->stream_id);
+  stream->stream_id = NULL;
 
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
diff --git a/subprojects/gstreamer/gst/gstvalue.c b/subprojects/gstreamer/gst/gstvalue.c
index 11554ffef1..cf256fcfbc 100644
--- a/subprojects/gstreamer/gst/gstvalue.c
+++ b/subprojects/gstreamer/gst/gstvalue.c
@@ -2332,6 +2332,8 @@ _priv_gst_value_get_abbrs (gint * n_abbrs)
       ,
       {"datetime", GST_TYPE_DATE_TIME}
       ,
+      {"gdatetime", G_TYPE_DATE_TIME}
+      ,
       {"bitmask", GST_TYPE_BITMASK}
       ,
       {"flagset", GST_TYPE_FLAG_SET}
@@ -7283,9 +7285,9 @@ gst_value_deserialize_date (GValue * dest, const gchar * s)
   return TRUE;
 }
 
-/*************
+/***************
  * GstDateTime *
- *************/
+ ***************/
 
 static gint
 gst_value_compare_date_time (const GValue * value1, const GValue * value2)
@@ -7348,6 +7350,60 @@ gst_value_transform_string_date (const GValue * src_value, GValue * dest_value)
   gst_value_deserialize_date (dest_value, src_value->data[0].v_pointer);
 }
 
+/*************
+ * GDateTime *
+ *************/
+
+static gint
+gst_value_compare_g_date_time (const GValue * value1, const GValue * value2)
+{
+  const GDateTime *date1 = (const GDateTime *) g_value_get_boxed (value1);
+  const GDateTime *date2 = (const GDateTime *) g_value_get_boxed (value2);
+
+  if (date1 == date2)
+    return GST_VALUE_EQUAL;
+
+  if ((date1 == NULL) && (date2 != NULL)) {
+    return GST_VALUE_LESS_THAN;
+  }
+  if ((date2 == NULL) && (date1 != NULL)) {
+    return GST_VALUE_LESS_THAN;
+  }
+
+  return g_date_time_compare (date1, date2);
+}
+
+static gchar *
+gst_value_serialize_g_date_time (const GValue * val)
+{
+  GDateTime *date = (GDateTime *) g_value_get_boxed (val);
+
+  if (date == NULL)
+    return g_strdup ("null");
+
+  return g_date_time_format_iso8601 (date);
+}
+
+static gboolean
+gst_value_deserialize_g_date_time (GValue * dest, const gchar * s)
+{
+  GDateTime *datetime;
+
+  if (!s || strcmp (s, "null") == 0) {
+    return FALSE;
+  }
+
+  /* The Gstreamer iso8601 parser is a bit more forgiving */
+  datetime =
+      gst_date_time_to_g_date_time (gst_date_time_new_from_iso8601_string (s));
+  if (datetime != NULL) {
+    g_value_take_boxed (dest, datetime);
+    return TRUE;
+  }
+  GST_WARNING ("Failed to deserialize date time string '%s' to GLibDateTime",
+      s);
+  return FALSE;
+}
 
 /*********
  * bytes *
@@ -8142,6 +8198,7 @@ _priv_gst_value_initialize (void)
   REGISTER_SERIALIZATION (G_TYPE_DATE, date);
   REGISTER_SERIALIZATION (G_TYPE_BYTES, bytes);
   REGISTER_SERIALIZATION (gst_date_time_get_type (), date_time);
+  REGISTER_SERIALIZATION (G_TYPE_DATE_TIME, g_date_time);
   REGISTER_SERIALIZATION (gst_bitmask_get_type (), bitmask);
   REGISTER_SERIALIZATION (gst_structure_get_type (), structure);
   REGISTER_SERIALIZATION (gst_flagset_get_type (), flagset);
diff --git a/subprojects/gstreamer/libs/gst/base/gstaggregator.c b/subprojects/gstreamer/libs/gst/base/gstaggregator.c
index d51ac5647d..abd711052d 100644
--- a/subprojects/gstreamer/libs/gst/base/gstaggregator.c
+++ b/subprojects/gstreamer/libs/gst/base/gstaggregator.c
@@ -371,6 +371,7 @@ struct _GstAggregatorPrivate
   gboolean send_segment;
   gboolean flushing;
   gboolean send_eos;            /* protected by srcpad stream lock */
+  gboolean got_eos_event;       /* protected by srcpad stream lock */
 
   GstCaps *srccaps;             /* protected by the srcpad stream lock */
 
@@ -409,8 +410,16 @@ struct _GstAggregatorPrivate
   gint64 latency;               /* protected by both src_lock and all pad locks */
   gboolean emit_signals;
   gboolean ignore_inactive_pads;
+  gboolean force_live;          /* Construct only, doesn't need any locking */
 };
 
+/* With SRC_LOCK */
+static gboolean
+is_live_unlocked (GstAggregator * self)
+{
+  return self->priv->peer_latency_live || self->priv->force_live;
+}
+
 /* Seek event forwarding helper */
 typedef struct
 {
@@ -429,6 +438,7 @@ typedef struct
 #define DEFAULT_START_TIME_SELECTION GST_AGGREGATOR_START_TIME_SELECTION_ZERO
 #define DEFAULT_START_TIME           (-1)
 #define DEFAULT_EMIT_SIGNALS         FALSE
+#define DEFAULT_FORCE_LIVE           FALSE
 
 enum
 {
@@ -501,7 +511,7 @@ gst_aggregator_check_pads_ready (GstAggregator * self,
       break;
     }
 
-    if (self->priv->ignore_inactive_pads && self->priv->peer_latency_live &&
+    if (self->priv->ignore_inactive_pads && is_live_unlocked (self) &&
         pad->priv->waited_once && pad->priv->first_buffer && !pad->priv->eos) {
       PAD_UNLOCK (pad);
       GST_LOG_OBJECT (pad, "Ignoring inactive pad");
@@ -528,7 +538,7 @@ gst_aggregator_check_pads_ready (GstAggregator * self,
     } else {
       GST_TRACE_OBJECT (pad, "Have %" GST_TIME_FORMAT " queued in %u buffers",
           GST_TIME_ARGS (pad->priv->time_level), pad->priv->num_buffers);
-      if (self->priv->peer_latency_live) {
+      if (is_live_unlocked (self)) {
         /* In live mode, having a single pad with buffers is enough to
          * generate a start time from it. In non-live mode all pads need
          * to have a buffer
@@ -541,7 +551,7 @@ gst_aggregator_check_pads_ready (GstAggregator * self,
     PAD_UNLOCK (pad);
   }
 
-  if (self->priv->ignore_inactive_pads && self->priv->peer_latency_live
+  if (self->priv->ignore_inactive_pads && is_live_unlocked (self)
       && n_ready == 0)
     goto no_sinkpads;
 
@@ -1388,10 +1398,15 @@ gst_aggregator_aggregate_func (GstAggregator * self)
     if ((flow_return = events_query_data.flow_ret) != GST_FLOW_OK)
       goto handle_error;
 
-    if (self->priv->peer_latency_live)
+    if (is_live_unlocked (self))
       gst_element_foreach_sink_pad (GST_ELEMENT_CAST (self),
           gst_aggregator_pad_skip_buffers, NULL);
 
+    if (self->priv->got_eos_event) {
+      gst_aggregator_push_eos (self);
+      continue;
+    }
+
     /* Ensure we have buffers ready (either in clipped_buffer or at the head of
      * the queue */
     if (!gst_aggregator_wait_and_check (self, &timeout)) {
@@ -1478,6 +1493,7 @@ gst_aggregator_start (GstAggregator * self)
   self->priv->send_stream_start = TRUE;
   self->priv->send_segment = TRUE;
   self->priv->send_eos = TRUE;
+  self->priv->got_eos_event = FALSE;
   self->priv->srccaps = NULL;
 
   self->priv->has_peer_latency = FALSE;
@@ -1699,6 +1715,7 @@ gst_aggregator_default_sink_event (GstAggregator * self,
         event = NULL;
         SRC_LOCK (self);
         priv->send_eos = TRUE;
+        priv->got_eos_event = FALSE;
         SRC_BROADCAST (self);
         SRC_UNLOCK (self);
 
@@ -1977,6 +1994,14 @@ gst_aggregator_change_state (GstElement * element, GstStateChange transition)
       SRC_LOCK (self);
       SRC_BROADCAST (self);
       SRC_UNLOCK (self);
+      if (self->priv->force_live) {
+        ret = GST_STATE_CHANGE_NO_PREROLL;
+      }
+      break;
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      if (self->priv->force_live) {
+        ret = GST_STATE_CHANGE_NO_PREROLL;
+      }
       break;
     default:
       break;
@@ -2195,12 +2220,18 @@ gst_aggregator_get_latency_unlocked (GstAggregator * self)
 
     ret = gst_aggregator_query_latency_unlocked (self, query);
     gst_query_unref (query);
-    if (!ret)
+    /* If we've been set to live, we don't wait for a peer latency, we will
+     * simply query it again next time around */
+    if (!ret && !self->priv->force_live)
       return GST_CLOCK_TIME_NONE;
   }
 
-  if (!self->priv->has_peer_latency || !self->priv->peer_latency_live)
-    return GST_CLOCK_TIME_NONE;
+  /* If we've been set to live, we don't wait for a peer latency, we will
+   * simply query it again next time around */
+  if (!self->priv->force_live) {
+    if (!self->priv->has_peer_latency || !self->priv->peer_latency_live)
+      return GST_CLOCK_TIME_NONE;
+  }
 
   /* latency_min is never GST_CLOCK_TIME_NONE by construction */
   latency = self->priv->peer_latency_min;
@@ -2262,8 +2293,17 @@ gst_aggregator_send_event (GstElement * element, GstEvent * event)
 
     GST_DEBUG_OBJECT (element, "Storing segment %" GST_PTR_FORMAT, event);
   }
+
   GST_STATE_UNLOCK (element);
 
+
+  if (GST_EVENT_TYPE (event) == GST_EVENT_EOS) {
+    SRC_LOCK (self);
+    self->priv->got_eos_event = TRUE;
+    SRC_BROADCAST (self);
+    SRC_UNLOCK (self);
+  }
+
   return GST_ELEMENT_CLASS (aggregator_parent_class)->send_event (element,
       event);
 }
@@ -2627,6 +2667,16 @@ flushing:
   return FALSE;
 }
 
+static void
+gst_aggregator_constructed (GObject * object)
+{
+  GstAggregator *agg = GST_AGGREGATOR (object);
+
+  if (agg->priv->force_live) {
+    GST_OBJECT_FLAG_SET (agg, GST_ELEMENT_FLAG_SOURCE);
+  }
+}
+
 static void
 gst_aggregator_finalize (GObject * object)
 {
@@ -2818,6 +2868,7 @@ gst_aggregator_class_init (GstAggregatorClass * klass)
 
   gobject_class->set_property = gst_aggregator_set_property;
   gobject_class->get_property = gst_aggregator_get_property;
+  gobject_class->constructed = gst_aggregator_constructed;
   gobject_class->finalize = gst_aggregator_finalize;
 
   g_object_class_install_property (gobject_class, PROP_LATENCY,
@@ -2955,6 +3006,7 @@ gst_aggregator_init (GstAggregator * self, GstAggregatorClass * klass)
   self->priv->latency = DEFAULT_LATENCY;
   self->priv->start_time_selection = DEFAULT_START_TIME_SELECTION;
   self->priv->start_time = DEFAULT_START_TIME;
+  self->priv->force_live = DEFAULT_FORCE_LIVE;
 
   g_mutex_init (&self->priv->src_lock);
   g_cond_init (&self->priv->src_cond);
@@ -3007,7 +3059,7 @@ gst_aggregator_pad_has_space (GstAggregator * self, GstAggregatorPad * aggpad)
 
   /* We also want at least two buffers, one is being processed and one is ready
    * for the next iteration when we operate in live mode. */
-  if (self->priv->peer_latency_live && aggpad->priv->num_buffers < 2)
+  if (is_live_unlocked (self) && aggpad->priv->num_buffers < 2)
     return TRUE;
 
   /* On top of our latency, we also want to allow buffering up to the
@@ -3648,7 +3700,7 @@ gst_aggregator_pad_is_inactive (GstAggregatorPad * pad)
   g_assert_nonnull (self);
 
   PAD_LOCK (pad);
-  inactive = self->priv->ignore_inactive_pads && self->priv->peer_latency_live
+  inactive = self->priv->ignore_inactive_pads && is_live_unlocked (self)
       && pad->priv->first_buffer;
   PAD_UNLOCK (pad);
 
@@ -3933,3 +3985,33 @@ gst_aggregator_get_ignore_inactive_pads (GstAggregator * self)
 
   return ret;
 }
+
+/**
+ * gst_aggregator_get_force_live:
+ *
+ * Subclasses may use the return value to inform whether they should return
+ * %GST_FLOW_EOS from their aggregate implementation.
+ *
+ * Returns: whether live status was forced on @self.
+ *
+ * Since: 1.22
+ */
+gboolean
+gst_aggregator_get_force_live (GstAggregator * self)
+{
+  return self->priv->force_live;
+}
+
+/**
+ * gst_aggregator_set_force_live:
+ *
+ * Subclasses should call this at construction time in order for @self to
+ * aggregate on a timeout even when no live source is connected.
+ *
+ * Since: 1.22
+ */
+void
+gst_aggregator_set_force_live (GstAggregator * self, gboolean force_live)
+{
+  self->priv->force_live = force_live;
+}
diff --git a/subprojects/gstreamer/libs/gst/base/gstaggregator.h b/subprojects/gstreamer/libs/gst/base/gstaggregator.h
index 45ced12d39..bbac9e4c04 100644
--- a/subprojects/gstreamer/libs/gst/base/gstaggregator.h
+++ b/subprojects/gstreamer/libs/gst/base/gstaggregator.h
@@ -434,6 +434,13 @@ void            gst_aggregator_set_ignore_inactive_pads (GstAggregator * self,
 GST_BASE_API
 gboolean        gst_aggregator_get_ignore_inactive_pads (GstAggregator * self);
 
+GST_BASE_API
+gboolean        gst_aggregator_get_force_live       (GstAggregator *self);
+
+GST_BASE_API
+void            gst_aggregator_set_force_live       (GstAggregator *self,
+                                                     gboolean force_live);
+
 /**
  * GstAggregatorStartTimeSelection:
  * @GST_AGGREGATOR_START_TIME_SELECTION_ZERO: Start at running time 0.
diff --git a/subprojects/gstreamer/libs/gst/base/gsttypefindhelper.c b/subprojects/gstreamer/libs/gst/base/gsttypefindhelper.c
index 56003d500a..f385e806e3 100644
--- a/subprojects/gstreamer/libs/gst/base/gsttypefindhelper.c
+++ b/subprojects/gstreamer/libs/gst/base/gsttypefindhelper.c
@@ -94,8 +94,8 @@ helper_find_peek (gpointer data, gint64 offset, guint size)
 
   helper = (GstTypeFindHelper *) data;
 
-  GST_LOG_OBJECT (helper->obj, "'%s' called peek (%" G_GINT64_FORMAT
-      ", %u)", GST_OBJECT_NAME (helper->factory), offset, size);
+  GST_LOG_OBJECT (helper->obj, "Typefind factory called peek (%" G_GINT64_FORMAT
+      ", %u)", offset, size);
 
   if (size == 0)
     return NULL;
@@ -229,8 +229,8 @@ helper_find_suggest (gpointer data, guint probability, GstCaps * caps)
   GstTypeFindHelper *helper = (GstTypeFindHelper *) data;
 
   GST_LOG_OBJECT (helper->obj,
-      "'%s' called suggest (%u, %" GST_PTR_FORMAT ")",
-      GST_OBJECT_NAME (helper->factory), probability, caps);
+      "Typefind factory called suggest (%u, %" GST_PTR_FORMAT ")",
+      probability, caps);
 
   if (probability > helper->best_probability) {
     gst_caps_replace (&helper->caps, caps);
@@ -243,8 +243,8 @@ helper_find_get_length (gpointer data)
 {
   GstTypeFindHelper *helper = (GstTypeFindHelper *) data;
 
-  GST_LOG_OBJECT (helper->obj, "'%s' called get_length, returning %"
-      G_GUINT64_FORMAT, GST_OBJECT_NAME (helper->factory), helper->size);
+  GST_LOG_OBJECT (helper->obj, "Typefind factory called get_length, returning %"
+      G_GUINT64_FORMAT, helper->size);
 
   return helper->size;
 }
@@ -303,12 +303,12 @@ prioritize_extension (GstObject * obj, GList * type_list,
 /**
  * gst_type_find_helper_get_range:
  * @obj: A #GstObject that will be passed as first argument to @func
- * @parent: (allow-none): the parent of @obj or %NULL
+ * @parent: (nullable): the parent of @obj or %NULL
  * @func: (scope call): A generic #GstTypeFindHelperGetRangeFunction that will
  *        be used to access data at random offsets when doing the typefinding
  * @size: The length in bytes
- * @extension: (allow-none): extension of the media, or %NULL
- * @prob: (out) (allow-none): location to store the probability of the found
+ * @extension: (nullable): extension of the media, or %NULL
+ * @prob: (out) (optional): location to store the probability of the found
  *     caps, or %NULL
  *
  * Utility function to do pull-based typefinding. Unlike gst_type_find_helper()
@@ -345,13 +345,13 @@ gst_type_find_helper_get_range (GstObject * obj, GstObject * parent,
 /**
  * gst_type_find_helper_get_range_full:
  * @obj: A #GstObject that will be passed as first argument to @func
- * @parent: (allow-none): the parent of @obj or %NULL
+ * @parent: (nullable): the parent of @obj or %NULL
  * @func: (scope call): A generic #GstTypeFindHelperGetRangeFunction that will
  *        be used to access data at random offsets when doing the typefinding
  * @size: The length in bytes
- * @extension: (allow-none): extension of the media, or %NULL
+ * @extension: (nullable): extension of the media, or %NULL
  * @caps: (out) (transfer full): returned caps
- * @prob: (out) (allow-none): location to store the probability of the found
+ * @prob: (out) (optional): location to store the probability of the found
  *     caps, or %NULL
  *
  * Utility function to do pull-based typefinding. Unlike gst_type_find_helper()
@@ -495,10 +495,23 @@ typedef struct
   gsize size;
   GstTypeFindProbability best_probability;
   GstCaps *caps;
-  GstTypeFindFactory *factory;  /* for logging */
   GstObject *obj;               /* for logging */
 } GstTypeFindBufHelper;
 
+/**
+ * GstTypeFindData:
+ *
+ * The opaque #GstTypeFindData structure.
+ *
+ * Since: 1.22
+ *
+ */
+struct _GstTypeFindData
+{
+  GstTypeFind find;
+  GstTypeFindBufHelper helper;
+};
+
 /*
  * buf_helper_find_peek:
  * @data: helper data struct
@@ -516,15 +529,15 @@ buf_helper_find_peek (gpointer data, gint64 off, guint size)
   GstTypeFindBufHelper *helper;
 
   helper = (GstTypeFindBufHelper *) data;
-  GST_LOG_OBJECT (helper->obj, "'%s' called peek (%" G_GINT64_FORMAT ", %u)",
-      GST_OBJECT_NAME (helper->factory), off, size);
+  GST_LOG_OBJECT (helper->obj,
+      "Typefind factory called peek (%" G_GINT64_FORMAT ", %u)", off, size);
 
   if (size == 0)
     return NULL;
 
   if (off < 0) {
-    GST_LOG_OBJECT (helper->obj, "'%s' wanted to peek at end; not supported",
-        GST_OBJECT_NAME (helper->factory));
+    GST_LOG_OBJECT (helper->obj,
+        "Typefind factory wanted to peek at end; not supported");
     return NULL;
   }
 
@@ -556,8 +569,8 @@ buf_helper_find_suggest (gpointer data, guint probability, GstCaps * caps)
   GstTypeFindBufHelper *helper = (GstTypeFindBufHelper *) data;
 
   GST_LOG_OBJECT (helper->obj,
-      "'%s' called suggest (%u, %" GST_PTR_FORMAT ")",
-      GST_OBJECT_NAME (helper->factory), probability, caps);
+      "Typefind factory called suggest (%u, %" GST_PTR_FORMAT ")",
+      probability, caps);
 
   /* Note: not >= as we call typefinders in order of rank, highest first */
   if (probability > helper->best_probability) {
@@ -568,10 +581,10 @@ buf_helper_find_suggest (gpointer data, guint probability, GstCaps * caps)
 
 /**
  * gst_type_find_helper_for_data:
- * @obj: (allow-none): object doing the typefinding, or %NULL (used for logging)
+ * @obj: (nullable): object doing the typefinding, or %NULL (used for logging)
  * @data: (transfer none) (array length=size): * a pointer with data to typefind
  * @size: the size of @data
- * @prob: (out) (allow-none): location to store the probability of the found
+ * @prob: (out) (optional): location to store the probability of the found
  *     caps, or %NULL
  *
  * Tries to find what type of data is contained in the given @data, the
@@ -601,11 +614,11 @@ gst_type_find_helper_for_data (GstObject * obj, const guint8 * data, gsize size,
 
 /**
  * gst_type_find_helper_for_data_with_extension:
- * @obj: (allow-none): object doing the typefinding, or %NULL (used for logging)
+ * @obj: (nullable): object doing the typefinding, or %NULL (used for logging)
  * @data: (transfer none) (array length=size): * a pointer with data to typefind
  * @size: the size of @data
- * @extension: (allow-none): extension of the media, or %NULL
- * @prob: (out) (allow-none): location to store the probability of the found
+ * @extension: (nullable): extension of the media, or %NULL
+ * @prob: (out) (optional): location to store the probability of the found
  *     caps, or %NULL
  *
  * Tries to find what type of data is contained in the given @data, the
@@ -638,6 +651,7 @@ gst_type_find_helper_for_data_with_extension (GstObject * obj,
     GstTypeFindProbability * prob)
 {
   GstTypeFindBufHelper helper;
+  GstTypeFindFactory *factory;
   GstTypeFind find;
   GList *l, *type_list;
   GstCaps *result = NULL;
@@ -662,8 +676,8 @@ gst_type_find_helper_for_data_with_extension (GstObject * obj,
   type_list = prioritize_extension (obj, type_list, extension);
 
   for (l = type_list; l; l = l->next) {
-    helper.factory = GST_TYPE_FIND_FACTORY (l->data);
-    gst_type_find_factory_call_function (helper.factory, &find);
+    factory = GST_TYPE_FIND_FACTORY (l->data);
+    gst_type_find_factory_call_function (factory, &find);
     if (helper.best_probability >= GST_TYPE_FIND_MAXIMUM)
       break;
   }
@@ -681,11 +695,98 @@ gst_type_find_helper_for_data_with_extension (GstObject * obj,
   return result;
 }
 
+/**
+ * gst_type_find_helper_for_data_with_caps:
+ * @obj: (nullable): object doing the typefinding, or %NULL (used for logging)
+ * @data: (transfer none) (array length=size): a pointer with data to typefind
+ * @size: the size of @data
+ * @caps: caps of the media
+ * @prob: (out) (optional): location to store the probability of the found
+ *     caps, or %NULL
+ *
+ * Tries to find if type of media contained in the given @data, matches the
+ * @caps specified, assumption being that the data represents the beginning
+ * of the stream or file.
+ *
+ * Only the typefinder matching the given caps will be called, if found. The
+ * caps with the highest probability will be returned, or %NULL if the content
+ * of the @data could not be identified.
+ *
+ * Free-function: gst_caps_unref
+ *
+ * Returns: (transfer full) (nullable): the #GstCaps corresponding to the data,
+ *     or %NULL if no type could be found. The caller should free the caps
+ *     returned with gst_caps_unref().
+ *
+ * Since: 1.22
+ *
+ */
+GstCaps *
+gst_type_find_helper_for_data_with_caps (GstObject * obj,
+    const guint8 * data, gsize size, GstCaps * caps,
+    GstTypeFindProbability * prob)
+{
+  GstTypeFind *find;
+  GstTypeFindData *find_data;
+  GstTypeFindFactory *factory;
+  GList *l, *factories = NULL;
+  GstCaps *result = NULL;
+  GstTypeFindProbability found_probability, last_found_probability;
+
+  g_return_val_if_fail (data != NULL, NULL);
+  g_return_val_if_fail (caps != NULL, NULL);
+  g_return_val_if_fail (size != 0, NULL);
+
+  find_data = gst_type_find_data_new (obj, data, size);
+  find = gst_type_find_data_get_typefind (find_data);
+
+  factories = gst_type_find_list_factories_for_caps (obj, caps);
+  if (!factories) {
+    GST_ERROR_OBJECT (obj, "Failed to typefind for caps: %" GST_PTR_FORMAT,
+        caps);
+    goto out;
+  }
+
+  found_probability = GST_TYPE_FIND_NONE;
+  last_found_probability = GST_TYPE_FIND_NONE;
+
+  for (l = factories; l; l = l->next) {
+    factory = GST_TYPE_FIND_FACTORY (l->data);
+
+    gst_type_find_factory_call_function (factory, find);
+
+    found_probability = gst_type_find_data_get_probability (find_data);
+
+    if (found_probability > last_found_probability) {
+      last_found_probability = found_probability;
+      result = gst_type_find_data_get_caps (find_data);
+
+      GST_DEBUG_OBJECT (obj, "Found %" GST_PTR_FORMAT " (probability = %u)",
+          result, (guint) last_found_probability);
+      if (last_found_probability >= GST_TYPE_FIND_MAXIMUM)
+        break;
+    }
+  }
+
+  if (prob)
+    *prob = last_found_probability;
+
+  GST_LOG_OBJECT (obj, "Returning %" GST_PTR_FORMAT " (probability = %u)",
+      result, (guint) last_found_probability);
+
+out:
+  g_list_free_full (factories, (GDestroyNotify) gst_object_unref);
+
+  gst_type_find_data_free (find_data);
+
+  return result;
+}
+
 /**
  * gst_type_find_helper_for_buffer:
- * @obj: (allow-none): object doing the typefinding, or %NULL (used for logging)
+ * @obj: (nullable): object doing the typefinding, or %NULL (used for logging)
  * @buf: (in) (transfer none): a #GstBuffer with data to typefind
- * @prob: (out) (allow-none): location to store the probability of the found
+ * @prob: (out) (optional): location to store the probability of the found
  *     caps, or %NULL
  *
  * Tries to find what type of data is contained in the given #GstBuffer, the
@@ -714,10 +815,10 @@ gst_type_find_helper_for_buffer (GstObject * obj, GstBuffer * buf,
 
 /**
  * gst_type_find_helper_for_buffer_with_extension:
- * @obj: (allow-none): object doing the typefinding, or %NULL (used for logging)
+ * @obj: (nullable): object doing the typefinding, or %NULL (used for logging)
  * @buf: (in) (transfer none): a #GstBuffer with data to typefind
- * @extension: (allow-none): extension of the media, or %NULL
- * @prob: (out) (allow-none): location to store the probability of the found
+ * @extension: (nullable): extension of the media, or %NULL
+ * @prob: (out) (optional): location to store the probability of the found
  *     caps, or %NULL
  *
  * Tries to find what type of data is contained in the given #GstBuffer, the
@@ -766,9 +867,63 @@ gst_type_find_helper_for_buffer_with_extension (GstObject * obj,
   return result;
 }
 
+/**
+ * gst_type_find_helper_for_buffer_with_caps:
+ * @obj: (nullable): object doing the typefinding, or %NULL (used for logging)
+ * @buf: (transfer none): a #GstBuffer with data to typefind
+ * @caps: caps of the media
+ * @prob: (out) (optional): location to store the probability of the found
+ *     caps, or %NULL
+ *
+ * Tries to find if type of media contained in the given #GstBuffer, matches
+ * @caps specified, assumption being that the buffer represents the beginning
+ * of the stream or file.
+ *
+ * Tries to find what type of data is contained in the given @data, the
+ * assumption being that the data represents the beginning of the stream or
+ * file.
+ *
+ * Only the typefinder matching the given caps will be called, if found. The
+ * caps with the highest probability will be returned, or %NULL if the content
+ * of the @data could not be identified.
+ *
+ * Free-function: gst_caps_unref
+ *
+ * Returns: (transfer full) (nullable): the #GstCaps corresponding to the data,
+ *     or %NULL if no type could be found. The caller should free the caps
+ *     returned with gst_caps_unref().
+ *
+ * Since: 1.22
+ *
+ */
+GstCaps *
+gst_type_find_helper_for_buffer_with_caps (GstObject * obj,
+    GstBuffer * buf, GstCaps * caps, GstTypeFindProbability * prob)
+{
+  GstCaps *result;
+  GstMapInfo info;
+
+  g_return_val_if_fail (caps != NULL, NULL);
+  g_return_val_if_fail (buf != NULL, NULL);
+  g_return_val_if_fail (GST_IS_BUFFER (buf), NULL);
+  g_return_val_if_fail (GST_BUFFER_OFFSET (buf) == 0 ||
+      GST_BUFFER_OFFSET (buf) == GST_BUFFER_OFFSET_NONE, NULL);
+
+  if (!gst_buffer_map (buf, &info, GST_MAP_READ))
+    return NULL;
+
+  result =
+      gst_type_find_helper_for_data_with_caps (obj, info.data, info.size,
+      caps, prob);
+
+  gst_buffer_unmap (buf, &info);
+
+  return result;
+}
+
 /**
  * gst_type_find_helper_for_extension:
- * @obj: (allow-none): object doing the typefinding, or %NULL (used for logging)
+ * @obj: (nullable): object doing the typefinding, or %NULL (used for logging)
  * @extension: an extension
  *
  * Tries to find the best #GstCaps associated with @extension.
@@ -830,3 +985,170 @@ done:
 
   return result;
 }
+
+/**
+ * gst_type_find_list_factories_for_caps:
+ * @obj: (nullable): object doing the typefinding, or %NULL (used for logging)
+ * @caps: caps of the media
+ *
+ * Tries to find the best #GstTypeFindFactory associated with @caps.
+ *
+ * The typefinder that can handle @caps will be returned.
+ *
+ * Free-function: g_list_free
+ *
+ * Returns: (transfer full) (nullable) (element-type Gst.TypeFindFactory): the list of #GstTypeFindFactory
+ *          corresponding to @caps, or %NULL if no typefinder could be
+ *          found. Caller should free the returned list with g_list_free()
+ *          and list elements with gst_object_unref().
+ *
+ * Since: 1.22
+ *
+ */
+GList *
+gst_type_find_list_factories_for_caps (GstObject * obj, GstCaps * caps)
+{
+  GList *l, *type_list, *factories = NULL;
+
+  g_return_val_if_fail (caps != NULL, NULL);
+
+  GST_LOG_OBJECT (obj, "finding factory for caps %" GST_PTR_FORMAT, caps);
+
+  type_list = gst_type_find_factory_get_list ();
+
+  for (l = type_list; l; l = g_list_next (l)) {
+    GstTypeFindFactory *factory;
+    GstCaps *factory_caps;
+
+    factory = GST_TYPE_FIND_FACTORY (l->data);
+
+    /* We only want to check those factories without a function */
+    if (gst_type_find_factory_has_function (factory))
+      continue;
+
+    /* Get the caps that this typefind factory can handle */
+    factory_caps = gst_type_find_factory_get_caps (factory);
+    if (!factory_caps)
+      continue;
+
+    if (gst_caps_can_intersect (factory_caps, caps)) {
+      factory = gst_object_ref (factory);
+      factories = g_list_prepend (factories, factory);
+    }
+  }
+
+  gst_plugin_feature_list_free (type_list);
+
+  return g_list_reverse (factories);
+}
+
+/**
+ * gst_type_find_data_new: (skip)
+ * @obj: (nullable): object doing the typefinding, or %NULL (used for logging)
+ * @data: (transfer none) (array length=size): a pointer with data to typefind
+ * @size: the size of @data
+ *
+ * Free-function: gst_type_find_data_free
+ *
+ * Returns: (transfer full): the #GstTypeFindData. The caller should free
+ *          the returned #GstTypeFindData with gst_type_find_data_free().
+ *
+ * Since: 1.22
+ *
+ */
+GstTypeFindData *
+gst_type_find_data_new (GstObject * obj, const guint8 * data, gsize size)
+{
+  GstTypeFindData *find_data;
+
+  g_return_val_if_fail (data != NULL, NULL);
+  g_return_val_if_fail (size != 0, NULL);
+
+  find_data = g_new0 (GstTypeFindData, 1);
+
+  find_data->helper.data = data;
+  find_data->helper.size = size;
+  find_data->helper.best_probability = GST_TYPE_FIND_NONE;
+  find_data->helper.caps = NULL;
+  find_data->helper.obj = obj;
+
+  find_data->find.data = (gpointer) (&find_data->helper);
+  find_data->find.peek = buf_helper_find_peek;
+  find_data->find.suggest = buf_helper_find_suggest;
+  find_data->find.get_length = NULL;
+
+  return find_data;
+}
+
+/**
+ * gst_type_find_data_get_caps: (skip)
+ * @data: GstTypeFindData *
+ *
+ * Returns #GstCaps associated with #GstTypeFindData
+ *
+ * Returns: (transfer full) (nullable): #GstCaps.
+ *
+ * Since: 1.22
+ *
+ */
+GstCaps *
+gst_type_find_data_get_caps (GstTypeFindData * data)
+{
+  g_return_val_if_fail (data != NULL, NULL);
+
+  return gst_caps_ref (data->helper.caps);
+}
+
+/**
+ * gst_type_find_data_get_probability: (skip)
+ * @data: GstTypeFindData *
+ *
+ * Returns #GstTypeFindProbability associated with #GstTypeFindData
+ *
+ * Returns: #GstTypeFindProbability.
+ *
+ * Since: 1.22
+ *
+ */
+GstTypeFindProbability
+gst_type_find_data_get_probability (GstTypeFindData * data)
+{
+  g_return_val_if_fail (data != NULL, GST_TYPE_FIND_NONE);
+
+  return data->helper.best_probability;
+}
+
+/**
+ * gst_type_find_data_get_typefind: (skip)
+ * @data: GstTypeFindData *
+ *
+ * Returns #GstTypeFind associated with #GstTypeFindData
+ *
+ * Returns: #GstTypeFind.
+ *
+ * Since: 1.22
+ *
+ */
+GstTypeFind *
+gst_type_find_data_get_typefind (GstTypeFindData * data)
+{
+  g_return_val_if_fail (data != NULL, NULL);
+
+  return &data->find;
+}
+
+/**
+ * gst_type_find_data_free: (skip)
+ * @data: GstTypeFindData * to free
+ *
+ * Since: 1.22
+ *
+ */
+void
+gst_type_find_data_free (GstTypeFindData * data)
+{
+  if (data && data->helper.caps)
+    gst_caps_unref (data->helper.caps);
+
+  g_free (data);
+}
diff --git a/subprojects/gstreamer/libs/gst/base/gsttypefindhelper.h b/subprojects/gstreamer/libs/gst/base/gsttypefindhelper.h
index bda346cac1..503dd84856 100644
--- a/subprojects/gstreamer/libs/gst/base/gsttypefindhelper.h
+++ b/subprojects/gstreamer/libs/gst/base/gsttypefindhelper.h
@@ -29,6 +29,15 @@
 
 G_BEGIN_DECLS
 
+typedef struct _GstTypeFindData GstTypeFindData;
+
+GstTypeFindData * gst_type_find_data_new (GstObject * obj,
+    const guint8 * data, gsize size);
+GstCaps * gst_type_find_data_get_caps (GstTypeFindData * data);
+GstTypeFindProbability gst_type_find_data_get_probability (GstTypeFindData * data);
+GstTypeFind * gst_type_find_data_get_typefind (GstTypeFindData * data);
+void gst_type_find_data_free (GstTypeFindData * data);
+
 GST_BASE_API
 GstCaps * gst_type_find_helper (GstPad *src, guint64 size);
 
@@ -45,6 +54,13 @@ GstCaps * gst_type_find_helper_for_data_with_extension (GstObject              *
                                                         const gchar            *extension,
                                                         GstTypeFindProbability *prob);
 
+GST_BASE_API
+GstCaps * gst_type_find_helper_for_data_with_caps (GstObject              *obj,
+                                                   const guint8           *data,
+                                                   gsize                   size,
+                                                   GstCaps                *caps,
+                                                   GstTypeFindProbability *prob);
+
 GST_BASE_API
 GstCaps * gst_type_find_helper_for_buffer (GstObject              *obj,
                                            GstBuffer              *buf,
@@ -56,10 +72,20 @@ GstCaps * gst_type_find_helper_for_buffer_with_extension (GstObject
                                                           const gchar            *extension,
                                                           GstTypeFindProbability *prob);
 
+GST_BASE_API
+GstCaps * gst_type_find_helper_for_buffer_with_caps (GstObject              *obj,
+                                                     GstBuffer              *buf,
+                                                     GstCaps                *caps,
+                                                     GstTypeFindProbability *prob);
+
 GST_BASE_API
 GstCaps * gst_type_find_helper_for_extension (GstObject * obj,
                                               const gchar * extension);
 
+GST_BASE_API
+GList * gst_type_find_list_factories_for_caps (GstObject * obj,
+                                               GstCaps * caps);
+
 /**
  * GstTypeFindHelperGetRangeFunction:
  * @obj: a #GstObject that will handle the getrange request
diff --git a/subprojects/gstreamer/meson.build b/subprojects/gstreamer/meson.build
index d312f2bd14..33ab344401 100644
--- a/subprojects/gstreamer/meson.build
+++ b/subprojects/gstreamer/meson.build
@@ -1,5 +1,5 @@
 project('gstreamer', 'c',
-  version : '1.21.2',
+  version : '1.21.2.1',
   meson_version : '>= 0.62',
   default_options : [ 'warning_level=1',
                       'buildtype=debugoptimized' ])
diff --git a/subprojects/gstreamer/plugins/elements/gstfakesrc.c b/subprojects/gstreamer/plugins/elements/gstfakesrc.c
index 24c2766178..7142e2c43d 100644
--- a/subprojects/gstreamer/plugins/elements/gstfakesrc.c
+++ b/subprojects/gstreamer/plugins/elements/gstfakesrc.c
@@ -805,9 +805,11 @@ gst_fake_src_create (GstBaseSrc * basesrc, guint64 offset, guint length,
   GST_BUFFER_OFFSET (buf) = offset;
 
   if (src->datarate > 0) {
-    time = (src->bytes_sent * GST_SECOND) / src->datarate;
+    time =
+        gst_util_uint64_scale_int (src->bytes_sent, GST_SECOND, src->datarate);
 
-    GST_BUFFER_DURATION (buf) = size * GST_SECOND / src->datarate;
+    GST_BUFFER_DURATION (buf) =
+        gst_util_uint64_scale_int (size, GST_SECOND, src->datarate);
   } else if (gst_base_src_is_live (basesrc)) {
     GstClock *clock;
 
diff --git a/subprojects/gstreamer/plugins/elements/gstinputselector.c b/subprojects/gstreamer/plugins/elements/gstinputselector.c
index 069e7329f0..e33651951b 100644
--- a/subprojects/gstreamer/plugins/elements/gstinputselector.c
+++ b/subprojects/gstreamer/plugins/elements/gstinputselector.c
@@ -101,13 +101,15 @@ enum
   PROP_ACTIVE_PAD,
   PROP_SYNC_STREAMS,
   PROP_SYNC_MODE,
-  PROP_CACHE_BUFFERS
+  PROP_CACHE_BUFFERS,
+  PROP_DROP_BACKWARDS
 };
 
 #define DEFAULT_SYNC_STREAMS TRUE
 #define DEFAULT_SYNC_MODE GST_INPUT_SELECTOR_SYNC_MODE_ACTIVE_SEGMENT
 #define DEFAULT_CACHE_BUFFERS FALSE
 #define DEFAULT_PAD_ALWAYS_OK TRUE
+#define DEFAULT_DROP_BACKWARDS FALSE
 
 enum
 {
@@ -165,6 +167,8 @@ struct _GstSelectorPad
 
   gboolean sending_cached_buffers;
   GQueue *cached_buffers;
+
+  GstClockID clock_id;
 };
 
 struct _GstSelectorPadCachedBuffer
@@ -345,6 +349,11 @@ gst_selector_pad_reset (GstSelectorPad * pad)
   gst_segment_init (&pad->segment, GST_FORMAT_UNDEFINED);
   pad->sending_cached_buffers = FALSE;
   gst_selector_pad_free_cached_buffers (pad);
+  if (pad->clock_id) {
+    gst_clock_id_unschedule (pad->clock_id);
+    gst_clock_id_unref (pad->clock_id);
+  }
+  pad->clock_id = NULL;
   GST_OBJECT_UNLOCK (pad);
 }
 
@@ -474,6 +483,10 @@ gst_input_selector_eos_wait (GstInputSelector * self, GstSelectorPad * pad,
 
       gst_pad_push_event (self->srcpad, gst_event_ref (eos_event));
       GST_INPUT_SELECTOR_LOCK (self);
+      if (pad->clock_id) {
+        GST_DEBUG_OBJECT (pad, "unlock clock wait");
+        gst_clock_id_unschedule (pad->clock_id);
+      }
       /* Wake up other pads so they can continue when syncing to
        * running time, as this pad just switched to EOS and
        * may enable others to progress */
@@ -558,10 +571,15 @@ gst_selector_pad_event (GstPad * pad, GstObject * parent, GstEvent * event)
       selpad->flushing = TRUE;
       sel->eos = FALSE;
       selpad->group_done = FALSE;
+      if (selpad->clock_id) {
+        GST_DEBUG_OBJECT (selpad, "unlock clock wait");
+        gst_clock_id_unschedule (selpad->clock_id);
+      }
       GST_INPUT_SELECTOR_BROADCAST (sel);
       break;
     case GST_EVENT_FLUSH_STOP:
       gst_selector_pad_reset (selpad);
+      sel->last_output_ts = GST_CLOCK_TIME_NONE;
       break;
     case GST_EVENT_SEGMENT:
     {
@@ -750,7 +768,6 @@ gst_input_selector_wait_running_time (GstInputSelector * sel,
   while (TRUE) {
     GstPad *active_sinkpad;
     GstSelectorPad *active_selpad;
-    GstClock *clock;
     gint64 cur_running_time;
     GstClockTime running_time;
 
@@ -774,21 +791,7 @@ gst_input_selector_wait_running_time (GstInputSelector * sel,
     }
 
     cur_running_time = GST_CLOCK_TIME_NONE;
-    if (sel->sync_mode == GST_INPUT_SELECTOR_SYNC_MODE_CLOCK) {
-      clock = gst_element_get_clock (GST_ELEMENT_CAST (sel));
-      if (clock) {
-        GstClockTime base_time;
-
-        cur_running_time = gst_clock_get_time (clock);
-        base_time = gst_element_get_base_time (GST_ELEMENT_CAST (sel));
-        if (base_time <= cur_running_time)
-          cur_running_time -= base_time;
-        else
-          cur_running_time = 0;
-
-        gst_object_unref (clock);
-      }
-    } else {
+    if (sel->sync_mode != GST_INPUT_SELECTOR_SYNC_MODE_CLOCK) {
       GstSegment *active_seg;
 
       active_seg = &active_selpad->segment;
@@ -818,9 +821,61 @@ gst_input_selector_wait_running_time (GstInputSelector * sel,
       break;
     }
 
-    if (selpad != active_selpad && !sel->eos && !sel->flushing
-        && !selpad->flushing && (cur_running_time == GST_CLOCK_TIME_NONE
-            || running_time >= cur_running_time)) {
+    if (selpad == active_selpad || sel->eos || sel->flushing
+        || selpad->flushing) {
+      GST_DEBUG_OBJECT (selpad, "Waiting aborted. Unblocking");
+      GST_INPUT_SELECTOR_UNLOCK (sel);
+      break;
+    }
+
+    if (sel->sync_mode == GST_INPUT_SELECTOR_SYNC_MODE_CLOCK
+        && GST_CLOCK_TIME_IS_VALID (running_time)) {
+      GstClock *clock;
+      GstClockReturn cret;
+      GstClockTime base_time;
+      GstClockTimeDiff jitter;
+      GstClockID clock_id;
+
+      base_time = gst_element_get_base_time (GST_ELEMENT_CAST (sel));
+      if (!GST_CLOCK_TIME_IS_VALID (base_time)) {
+        GST_DEBUG_OBJECT (selpad, "sync-mode=clock but no base time. Blocking");
+        GST_INPUT_SELECTOR_WAIT (sel);
+        continue;
+      }
+
+      clock = gst_element_get_clock (GST_ELEMENT_CAST (sel));
+      if (!clock) {
+        GST_DEBUG_OBJECT (selpad, "sync-mode=clock but no clock. Blocking");
+        GST_INPUT_SELECTOR_WAIT (sel);
+        continue;
+      }
+
+      /* FIXME: If no upstream latency was queried yet, do one now */
+      clock_id =
+          gst_clock_new_single_shot_id (clock,
+          running_time + base_time + sel->upstream_latency);
+      selpad->clock_id = gst_clock_id_ref (clock_id);
+      GST_INPUT_SELECTOR_UNLOCK (sel);
+
+      gst_object_unref (clock);
+      cret = gst_clock_id_wait (clock_id, &jitter);
+      gst_clock_id_unref (clock_id);
+
+      GST_DEBUG_OBJECT (sel, "Clock returned %d, jitter %" GST_STIME_FORMAT,
+          cret, GST_STIME_ARGS (jitter));
+
+      GST_INPUT_SELECTOR_LOCK (sel);
+      if (selpad->clock_id) {
+        gst_clock_id_unref (selpad->clock_id);
+        selpad->clock_id = NULL;
+      }
+      if (cret == GST_CLOCK_OK ||
+          cret == GST_CLOCK_EARLY || cret == GST_CLOCK_DONE) {
+        GST_INPUT_SELECTOR_UNLOCK (sel);
+        break;
+      }
+    } else if (!GST_CLOCK_TIME_IS_VALID (cur_running_time)
+        || running_time >= cur_running_time) {
       GST_DEBUG_OBJECT (selpad,
           "Waiting for active streams to advance. %" GST_TIME_FORMAT " >= %"
           GST_TIME_FORMAT, GST_TIME_ARGS (running_time),
@@ -989,6 +1044,8 @@ gst_selector_pad_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
   GstPad *active_sinkpad;
   GstPad *prev_active_sinkpad = NULL;
   GstSelectorPad *selpad;
+  GstSegment seg;
+  GstClockTime running_time = GST_CLOCK_TIME_NONE;
 
   sel = GST_INPUT_SELECTOR (parent);
   selpad = GST_SELECTOR_PAD_CAST (pad);
@@ -1113,7 +1170,25 @@ gst_selector_pad_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
     prev_active_sinkpad = NULL;
   }
 
+  seg = selpad->segment;
+  if (seg.format == GST_FORMAT_TIME)
+    running_time =
+        gst_segment_to_running_time (&seg, GST_FORMAT_TIME,
+        GST_BUFFER_DTS_OR_PTS (buf));
+
   if (selpad->discont) {
+    GST_INPUT_SELECTOR_LOCK (sel);
+    if (sel->sync_streams && sel->drop_backwards
+        && GST_CLOCK_TIME_IS_VALID (running_time)) {
+      /* Just switched. Make sure timestamps don't go backwards */
+      if (running_time < sel->last_output_ts
+          && GST_CLOCK_TIME_IS_VALID (sel->last_output_ts)) {
+        GST_DEBUG_OBJECT (pad, "Discarding buffer %p with backwards timestamp",
+            buf);
+        goto ignore;
+      }
+    }
+    GST_INPUT_SELECTOR_UNLOCK (sel);
     buf = gst_buffer_make_writable (buf);
 
     GST_DEBUG_OBJECT (pad, "Marking discont buffer %p", buf);
@@ -1124,6 +1199,7 @@ gst_selector_pad_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
   /* forward */
   GST_LOG_OBJECT (pad, "Forwarding buffer %p with timestamp %" GST_TIME_FORMAT,
       buf, GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
+  sel->last_output_ts = running_time;
 
   /* Only make the buffer read-only when necessary */
   if (sel->sync_streams && sel->cache_buffers)
@@ -1292,6 +1368,22 @@ gst_input_selector_class_init (GstInputSelectorClass * klass)
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
           GST_PARAM_MUTABLE_READY));
 
+  /**
+   * GstInputSelector:drop-backwards
+   *
+   * If set to %TRUE and GstInputSelector:sync-streams is also set to %TRUE,
+   * every time the input is switched, buffers that would go backwards related
+   * to the last output buffer pre-switch will be dropped.
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class, PROP_DROP_BACKWARDS,
+      g_param_spec_boolean ("drop-backwards", "Drop Backwards Buffers",
+          "Drop backwards buffers on pad switch",
+          DEFAULT_DROP_BACKWARDS,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
+          GST_PARAM_MUTABLE_READY));
+
   gst_element_class_set_static_metadata (gstelement_class, "Input selector",
       "Generic", "N-to-1 input stream selector",
       "Julien Moutte <julien@moutte.net>, "
@@ -1333,6 +1425,9 @@ gst_input_selector_init (GstInputSelector * sel)
   g_cond_init (&sel->cond);
   sel->eos = FALSE;
 
+  sel->upstream_latency = 0;
+  sel->last_output_ts = GST_CLOCK_TIME_NONE;
+
   /* lets give a change for downstream to do something on
    * active-pad change before we start pushing new buffers */
   g_signal_connect_data (sel, "notify::active-pad",
@@ -1460,6 +1555,11 @@ gst_input_selector_set_property (GObject * object, guint prop_id,
       sel->cache_buffers = g_value_get_boolean (value);
       GST_INPUT_SELECTOR_UNLOCK (object);
       break;
+    case PROP_DROP_BACKWARDS:
+      GST_INPUT_SELECTOR_LOCK (object);
+      sel->drop_backwards = g_value_get_boolean (value);
+      GST_INPUT_SELECTOR_UNLOCK (object);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1508,6 +1608,11 @@ gst_input_selector_get_property (GObject * object, guint prop_id,
       g_value_set_boolean (value, sel->cache_buffers);
       GST_INPUT_SELECTOR_UNLOCK (object);
       break;
+    case PROP_DROP_BACKWARDS:
+      GST_INPUT_SELECTOR_LOCK (object);
+      g_value_set_boolean (value, sel->drop_backwards);
+      GST_INPUT_SELECTOR_UNLOCK (object);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1714,7 +1819,16 @@ retry:
       GST_ERROR_OBJECT (pad, "minimum latency bigger than maximum latency");
     }
 
-    gst_query_set_latency (query, fold_data.live, fold_data.min, fold_data.max);
+    GST_INPUT_SELECTOR_LOCK (sel);
+    if (fold_data.live)
+      sel->upstream_latency = fold_data.min;
+    else
+      sel->upstream_latency = 0;
+
+    gst_query_set_latency (query, fold_data.live
+        || (sel->sync_mode == GST_INPUT_SELECTOR_SYNC_MODE_CLOCK),
+        fold_data.min, fold_data.max);
+    GST_INPUT_SELECTOR_UNLOCK (sel);
   } else {
     GST_LOG_OBJECT (pad, "latency query failed");
   }
@@ -1876,6 +1990,8 @@ gst_input_selector_reset (GstInputSelector * sel)
     }
   }
   sel->have_group_id = TRUE;
+  sel->upstream_latency = 0;
+  sel->last_output_ts = GST_CLOCK_TIME_NONE;
   GST_INPUT_SELECTOR_UNLOCK (sel);
 }
 
@@ -1902,6 +2018,19 @@ gst_input_selector_change_state (GstElement * element,
       GST_INPUT_SELECTOR_BROADCAST (self);
       GST_INPUT_SELECTOR_UNLOCK (self);
       break;
+    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:{
+      GList *walk;
+
+      for (walk = GST_ELEMENT_CAST (self)->sinkpads; walk;
+          walk = g_list_next (walk)) {
+        GstSelectorPad *selpad = GST_SELECTOR_PAD_CAST (walk->data);
+        if (selpad->clock_id) {
+          GST_DEBUG_OBJECT (selpad, "unlock clock wait");
+          gst_clock_id_unschedule (selpad->clock_id);
+        }
+      }
+      break;
+    }
     default:
       break;
   }
diff --git a/subprojects/gstreamer/plugins/elements/gstinputselector.h b/subprojects/gstreamer/plugins/elements/gstinputselector.h
index 9d2eb6aa5c..039f6285b0 100644
--- a/subprojects/gstreamer/plugins/elements/gstinputselector.h
+++ b/subprojects/gstreamer/plugins/elements/gstinputselector.h
@@ -72,6 +72,7 @@ struct _GstInputSelector {
   gboolean sync_streams;
   GstInputSelectorSyncMode sync_mode;
   gboolean cache_buffers;
+  gboolean drop_backwards;
 
   gboolean have_group_id;
 
@@ -80,6 +81,9 @@ struct _GstInputSelector {
   gboolean eos;
   gboolean eos_sent;
   gboolean flushing;
+
+  GstClockTime upstream_latency;
+  GstClockTime last_output_ts;
 };
 
 struct _GstInputSelectorClass {
diff --git a/subprojects/gstreamer/plugins/elements/gstmultiqueue.c b/subprojects/gstreamer/plugins/elements/gstmultiqueue.c
index 10ad20382c..bbe29e5e7f 100644
--- a/subprojects/gstreamer/plugins/elements/gstmultiqueue.c
+++ b/subprojects/gstreamer/plugins/elements/gstmultiqueue.c
@@ -147,6 +147,15 @@ struct _GstSingleQueue
   /* TRUE if either position needs to be recalculated */
   gboolean sink_tainted, src_tainted;
 
+  /* stream group id */
+  guint32 sink_stream_gid;
+  guint32 src_stream_gid;
+
+  /* TRUE if the stream group-id changed. Resetted to FALSE the next time the
+   * segment is calculated */
+  gboolean sink_stream_gid_changed;
+  gboolean src_stream_gid_changed;
+
   /* queue of data */
   GstDataQueue *queue;
   GstDataQueueSize max_size, extra_size;
@@ -876,6 +885,7 @@ gst_multi_queue_init (GstMultiQueue * mqueue)
   mqueue->high_time = GST_CLOCK_STIME_NONE;
 
   g_mutex_init (&mqueue->qlock);
+  g_mutex_init (&mqueue->reconf_lock);
   g_mutex_init (&mqueue->buffering_post_lock);
 }
 
@@ -890,6 +900,7 @@ gst_multi_queue_finalize (GObject * object)
 
   /* free/unref instance data */
   g_mutex_clear (&mqueue->qlock);
+  g_mutex_clear (&mqueue->reconf_lock);
   g_mutex_clear (&mqueue->buffering_post_lock);
 
   G_OBJECT_CLASS (parent_class)->finalize (object);
@@ -1190,8 +1201,10 @@ gst_multi_queue_request_new_pad (GstElement * element, GstPadTemplate * temp,
     GST_LOG_OBJECT (element, "name : %s (id %d)", GST_STR_NULL (name), temp_id);
   }
 
+  g_mutex_lock (&mqueue->reconf_lock);
   /* Create a new single queue, add the sink and source pad and return the sink pad */
   squeue = gst_single_queue_new (mqueue, temp_id);
+  g_mutex_unlock (&mqueue->reconf_lock);
 
   new_pad = squeue ? g_weak_ref_get (&squeue->sinkpad) : NULL;
   /* request pad assumes the element is owning the ref of the pad it returns */
@@ -1238,6 +1251,11 @@ gst_multi_queue_release_pad (GstElement * element, GstPad * pad)
   /* FIXME: The removal of the singlequeue should probably not happen until it
    * finishes draining */
 
+  /* Take the reconfiguration lock before removing the singlequeue from
+   * the list, to prevent overlapping release/request from causing
+   * problems */
+  g_mutex_lock (&mqueue->reconf_lock);
+
   /* remove it from the list */
   mqueue->queues = g_list_delete_link (mqueue->queues, tmp);
   mqueue->queues_cookie++;
@@ -1254,6 +1272,8 @@ gst_multi_queue_release_pad (GstElement * element, GstPad * pad)
   gst_element_remove_pad (element, sinkpad);
   gst_object_unref (srcpad);
   gst_object_unref (sinkpad);
+
+  g_mutex_unlock (&mqueue->reconf_lock);
 }
 
 static GstStateChangeReturn
@@ -1343,6 +1363,9 @@ gst_single_queue_pause (GstMultiQueue * mq, GstSingleQueue * sq)
   }
 
   sq->sink_tainted = sq->src_tainted = TRUE;
+  sq->sink_stream_gid = sq->src_stream_gid = GST_GROUP_ID_INVALID;
+  sq->sink_stream_gid_changed = FALSE;
+  sq->src_stream_gid_changed = FALSE;
   return result;
 }
 
@@ -1358,6 +1381,9 @@ gst_single_queue_stop (GstMultiQueue * mq, GstSingleQueue * sq)
     gst_object_unref (srcpad);
   }
   sq->sink_tainted = sq->src_tainted = TRUE;
+  sq->sink_stream_gid = sq->src_stream_gid = GST_GROUP_ID_INVALID;
+  sq->sink_stream_gid_changed = FALSE;
+  sq->src_stream_gid_changed = FALSE;
   return result;
 }
 
@@ -1762,6 +1788,23 @@ static void
 apply_segment (GstMultiQueue * mq, GstSingleQueue * sq, GstEvent * event,
     GstSegment * segment)
 {
+  GstClockTimeDiff ppos = 0;
+
+  /* If we switched groups, grab the previous position */
+  if (segment->rate > 0.0) {
+    if (segment == &sq->sink_segment && sq->sink_stream_gid_changed) {
+      ppos =
+          gst_segment_to_running_time (segment, GST_FORMAT_TIME,
+          segment->position);
+      sq->sink_stream_gid_changed = FALSE;
+    } else if (segment == &sq->src_segment && sq->src_stream_gid_changed) {
+      ppos =
+          gst_segment_to_running_time (segment, GST_FORMAT_TIME,
+          segment->position);
+      sq->src_stream_gid_changed = FALSE;
+    }
+  }
+
   gst_event_copy_segment (event, segment);
 
   /* now configure the values, we use these to track timestamps on the
@@ -1776,12 +1819,19 @@ apply_segment (GstMultiQueue * mq, GstSingleQueue * sq, GstEvent * event,
   }
   GST_MULTI_QUEUE_MUTEX_LOCK (mq);
 
+  if (ppos) {
+    GST_DEBUG_OBJECT (mq, "queue %d, Applying base of %" GST_TIME_FORMAT,
+        sq->id, GST_TIME_ARGS (ppos));
+    segment->base = ppos;
+  }
+
   /* Make sure we have a valid initial segment position (and not garbage
    * from upstream) */
   if (segment->rate > 0.0)
     segment->position = segment->start;
   else
     segment->position = segment->stop;
+
   if (segment == &sq->sink_segment)
     sq->sink_tainted = TRUE;
   else {
@@ -1982,10 +2032,21 @@ gst_single_queue_push_one (GstMultiQueue * mq, GstSingleQueue * sq,
           *allow_drop = FALSE;
         break;
       case GST_EVENT_STREAM_START:
+      {
+        guint32 group_id;
+        if (gst_event_parse_group_id (event, &group_id)) {
+          if (sq->src_stream_gid == GST_GROUP_ID_INVALID) {
+            sq->src_stream_gid = group_id;
+          } else if (group_id != sq->src_stream_gid) {
+            sq->src_stream_gid = group_id;
+            sq->src_stream_gid_changed = TRUE;
+          }
+        }
         result = GST_FLOW_OK;
         if (G_UNLIKELY (*allow_drop))
           *allow_drop = FALSE;
         break;
+      }
       case GST_EVENT_SEGMENT:
         apply_segment (mq, sq, event, &sq->src_segment);
         /* Applying the segment may have made the queue non-full again, unblock it if needed */
@@ -2607,6 +2668,15 @@ gst_multi_queue_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
   switch (type) {
     case GST_EVENT_STREAM_START:
     {
+      guint32 group_id;
+      if (gst_event_parse_group_id (event, &group_id)) {
+        if (sq->sink_stream_gid == GST_GROUP_ID_INVALID) {
+          sq->sink_stream_gid = group_id;
+        } else if (group_id != sq->sink_stream_gid) {
+          sq->sink_stream_gid = group_id;
+          sq->sink_stream_gid_changed = TRUE;
+        }
+      }
       if (mq->sync_by_running_time) {
         GstStreamFlags stream_flags;
         gst_event_parse_stream_flags (event, &stream_flags);
@@ -3473,6 +3543,10 @@ gst_single_queue_new (GstMultiQueue * mqueue, guint id)
   sq->sink_tainted = TRUE;
   sq->src_tainted = TRUE;
 
+  sq->sink_stream_gid = sq->src_stream_gid = GST_GROUP_ID_INVALID;
+  sq->sink_stream_gid_changed = FALSE;
+  sq->src_stream_gid_changed = FALSE;
+
   name = g_strdup_printf ("sink_%u", sq->id);
   templ = gst_static_pad_template_get (&sinktemplate);
   sinkpad = g_object_new (GST_TYPE_MULTIQUEUE_PAD, "name", name,
diff --git a/subprojects/gstreamer/plugins/elements/gstmultiqueue.h b/subprojects/gstreamer/plugins/elements/gstmultiqueue.h
index 8c89a17a64..53ceacbd0c 100644
--- a/subprojects/gstreamer/plugins/elements/gstmultiqueue.h
+++ b/subprojects/gstreamer/plugins/elements/gstmultiqueue.h
@@ -78,6 +78,8 @@ struct _GstMultiQueue {
 			/* queues lock). Protects nbqueues, queues, global */
 			/* GstMultiQueueSize, counter and highid */
 
+  GMutex   reconf_lock;	/* Reconfiguration lock, held during request/release pads */
+
   gint numwaiting;	/* number of not-linked pads waiting */
 
   gboolean buffering_percent_changed;
diff --git a/subprojects/gstreamer/plugins/tracers/gstlatency.c b/subprojects/gstreamer/plugins/tracers/gstlatency.c
index 5cfb551e7e..9b0e8a72d4 100644
--- a/subprojects/gstreamer/plugins/tracers/gstlatency.c
+++ b/subprojects/gstreamer/plugins/tracers/gstlatency.c
@@ -26,10 +26,10 @@
  * events at sources and process them at sinks. This elements supports tracing
  * the entire pipeline latency and per element latency. By default, only
  * pipeline latency is traced. The 'flags' parameter can be used to enabled
- * element tracing.
+ * element tracing and/or the latency reported by each element.
  *
  * ```
- * GST_TRACERS="latency(flags=pipeline+element)" GST_DEBUG=GST_TRACER:7 ./...
+ * GST_TRACERS="latency(flags=pipeline+element+reported)" GST_DEBUG=GST_TRACER:7 ./...
  * ```
  */
 /* TODO(ensonic): if there are two sources feeding into a mixer/muxer and later
diff --git a/subprojects/gstreamer/tests/check/gst/gstpad.c b/subprojects/gstreamer/tests/check/gst/gstpad.c
index 1b1afe6833..0b545eec91 100644
--- a/subprojects/gstreamer/tests/check/gst/gstpad.c
+++ b/subprojects/gstreamer/tests/check/gst/gstpad.c
@@ -2591,6 +2591,12 @@ test_sticky_events_handler (GstPad * pad, GstObject * parent, GstEvent * event)
     case 2:
       fail_unless (GST_EVENT_TYPE (event) == GST_EVENT_SEGMENT);
       break;
+    case 3:
+      fail_unless (GST_EVENT_TYPE (event) == GST_EVENT_INSTANT_RATE_CHANGE);
+      break;
+    case 4:
+      fail_unless (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_COLLECTION);
+      break;
     default:
       fail_unless (FALSE);
       break;
@@ -2642,6 +2648,15 @@ GST_START_TEST (test_sticky_events)
   gst_segment_init (&seg, GST_FORMAT_TIME);
   gst_pad_push_event (srcpad, gst_event_new_segment (&seg));
 
+  /* Push a stream collection */
+  GstStreamCollection *collection = gst_stream_collection_new (0);
+  gst_pad_push_event (srcpad, gst_event_new_stream_collection (collection));
+  gst_object_unref (collection);
+
+  /* Push an instant rate change, which should be sent earlier than the preceding stream collection */
+  gst_pad_push_event (srcpad, gst_event_new_instant_rate_change (1.0,
+          GST_SEGMENT_FLAG_NONE));
+
   /* now make a sinkpad */
   sinkpad = gst_pad_new ("sink", GST_PAD_SINK);
   fail_unless (sinkpad != NULL);
@@ -2662,13 +2677,13 @@ GST_START_TEST (test_sticky_events)
   gst_pad_push_event (srcpad, gst_event_new_caps (caps));
   gst_caps_unref (caps);
 
-  /* should have triggered 2 events, the segment event is still pending */
+  /* should have triggered 2 events, the segment, stream collection and instant-rate events are still pending */
   fail_unless_equals_int (sticky_count, 2);
 
   fail_unless (gst_pad_push (srcpad, gst_buffer_new ()) == GST_FLOW_OK);
 
-  /* should have triggered 3 events */
-  fail_unless_equals_int (sticky_count, 3);
+  /* should have triggered 5 events */
+  fail_unless_equals_int (sticky_count, 5);
 
   gst_object_unref (srcpad);
   gst_object_unref (sinkpad);
diff --git a/subprojects/gstreamer/tests/check/libs/aggregator.c b/subprojects/gstreamer/tests/check/libs/aggregator.c
index 23ca1adb51..215b06186c 100644
--- a/subprojects/gstreamer/tests/check/libs/aggregator.c
+++ b/subprojects/gstreamer/tests/check/libs/aggregator.c
@@ -26,6 +26,7 @@
 
 #include <stdlib.h>
 #include <gst/check/gstcheck.h>
+#include <gst/check/gstharness.h>
 #include <gst/base/gstaggregator.h>
 
 /* dummy aggregator based element */
@@ -143,10 +144,12 @@ gst_test_aggregator_aggregate (GstAggregator * aggregator, gboolean timeout)
   }
   gst_iterator_free (iter);
 
-  if (all_eos == TRUE) {
-    GST_INFO_OBJECT (testagg, "no data available, must be EOS");
-    gst_pad_push_event (aggregator->srcpad, gst_event_new_eos ());
-    return GST_FLOW_EOS;
+  if (!gst_aggregator_get_force_live (aggregator)) {
+    if (all_eos == TRUE) {
+      GST_INFO_OBJECT (testagg, "no data available, must be EOS");
+      gst_pad_push_event (aggregator->srcpad, gst_event_new_eos ());
+      return GST_FLOW_EOS;
+    }
   }
 
   buf = gst_buffer_new ();
@@ -188,6 +191,8 @@ gst_test_aggregator_class_init (GstTestAggregatorClass * klass)
 
   base_aggregator_class->aggregate =
       GST_DEBUG_FUNCPTR (gst_test_aggregator_aggregate);
+
+  base_aggregator_class->get_next_time = gst_aggregator_simple_get_next_time;
 }
 
 static void
@@ -846,8 +851,8 @@ GST_START_TEST (test_flushing_seek)
   GST_BUFFER_TIMESTAMP (buf) = 0;
   _chain_data_init (&data2, test.aggregator, buf, NULL);
 
-  gst_segment_init (&GST_AGGREGATOR_PAD (GST_AGGREGATOR (test.
-              aggregator)->srcpad)->segment, GST_FORMAT_TIME);
+  gst_segment_init (&GST_AGGREGATOR_PAD (GST_AGGREGATOR (test.aggregator)->
+          srcpad)->segment, GST_FORMAT_TIME);
 
   /* now do a successful flushing seek */
   event = gst_event_new_seek (1, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH,
@@ -1353,6 +1358,29 @@ GST_START_TEST (test_remove_pad_on_aggregate)
 
 GST_END_TEST;
 
+GST_START_TEST (test_force_live)
+{
+  GstElement *agg;
+  GstHarness *h;
+  GstBuffer *buf;
+
+  agg = gst_check_setup_element ("testaggregator");
+  g_object_set (agg, "latency", GST_USECOND, NULL);
+  gst_aggregator_set_force_live (GST_AGGREGATOR (agg), TRUE);
+  h = gst_harness_new_with_element (agg, NULL, "src");
+
+  gst_harness_play (h);
+
+  gst_harness_crank_single_clock_wait (h);
+  buf = gst_harness_pull (h);
+
+  gst_buffer_unref (buf);
+  gst_harness_teardown (h);
+  gst_object_unref (agg);
+}
+
+GST_END_TEST;
+
 static Suite *
 gst_aggregator_suite (void)
 {
@@ -1382,6 +1410,7 @@ gst_aggregator_suite (void)
   tcase_add_test (general, test_change_state_intensive);
   tcase_add_test (general, test_flush_on_aggregate);
   tcase_add_test (general, test_remove_pad_on_aggregate);
+  tcase_add_test (general, test_force_live);
 
   return suite;
 }
diff --git a/subprojects/gstreamer/tools/gst-inspect.c b/subprojects/gstreamer/tools/gst-inspect.c
index d50bf65c9a..6d50d7b8f4 100644
--- a/subprojects/gstreamer/tools/gst-inspect.c
+++ b/subprojects/gstreamer/tools/gst-inspect.c
@@ -744,6 +744,15 @@ print_object_properties_info (GObject * obj, GObjectClass * obj_class,
         } else if (param->value_type == GST_TYPE_ARRAY) {
           GstParamSpecArray *parray = GST_PARAM_SPEC_ARRAY_LIST (param);
 
+          if (GST_VALUE_HOLDS_ARRAY (&value)) {
+            gchar *def = gst_value_serialize (&value);
+
+            n_print ("%sDefault%s: \"%s\"\n", PROP_ATTR_VALUE_COLOR,
+                RESET_COLOR, def);
+
+            g_free (def);
+          }
+
           if (parray->element_spec) {
             n_print ("%sGstValueArray of GValues of type%s %s\"%s\"%s",
                 PROP_VALUE_COLOR, RESET_COLOR, DATATYPE_COLOR,
