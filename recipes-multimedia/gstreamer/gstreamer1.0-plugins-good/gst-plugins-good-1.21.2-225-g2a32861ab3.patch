diff --git a/subprojects/gst-plugins-good/docs/gst_plugins_cache.json b/subprojects/gst-plugins-good/docs/gst_plugins_cache.json
index e2c5054c5d..0b03c5bd5d 100644
--- a/subprojects/gst-plugins-good/docs/gst_plugins_cache.json
+++ b/subprojects/gst-plugins-good/docs/gst_plugins_cache.json
@@ -7027,7 +7027,7 @@
                         "construct": false,
                         "construct-only": false,
                         "controllable": false,
-                        "default": "GStreamer 1.21.2 FLV muxer",
+                        "default": "GStreamer 1.21.2.1 FLV muxer",
                         "mutable": "null",
                         "readable": true,
                         "type": "gchararray",
@@ -7039,7 +7039,7 @@
                         "construct": false,
                         "construct-only": false,
                         "controllable": false,
-                        "default": "GStreamer 1.21.2 FLV muxer",
+                        "default": "GStreamer 1.21.2.1 FLV muxer",
                         "mutable": "null",
                         "readable": true,
                         "type": "gchararray",
@@ -21196,7 +21196,7 @@
                         "construct": false,
                         "construct-only": false,
                         "controllable": false,
-                        "default": "GStreamer/1.21.2",
+                        "default": "GStreamer/1.21.2.1",
                         "mutable": "null",
                         "readable": true,
                         "type": "gchararray",
@@ -21342,6 +21342,21 @@
                         "return-type": "GstFlowReturn",
                         "when": "last"
                     },
+                    "push-backchannel-sample": {
+                        "action": true,
+                        "args": [
+                            {
+                                "name": "arg0",
+                                "type": "guint"
+                            },
+                            {
+                                "name": "arg1",
+                                "type": "GstSample"
+                            }
+                        ],
+                        "return-type": "GstFlowReturn",
+                        "when": "last"
+                    },
                     "request-rtcp-key": {
                         "args": [
                             {
@@ -21740,7 +21755,7 @@
                         "construct": false,
                         "construct-only": false,
                         "controllable": false,
-                        "default": "GStreamer 1.21.2",
+                        "default": "GStreamer 1.21.2.1",
                         "mutable": "null",
                         "readable": true,
                         "type": "gchararray",
@@ -23177,7 +23192,7 @@
                         "construct": false,
                         "construct-only": false,
                         "controllable": false,
-                        "default": "GStreamer souphttpsrc 1.21.2 ",
+                        "default": "GStreamer souphttpsrc 1.21.2.1 ",
                         "mutable": "null",
                         "readable": true,
                         "type": "gchararray",
diff --git a/subprojects/gst-plugins-good/ext/adaptivedemux2/dash/gstmpdclient.c b/subprojects/gst-plugins-good/ext/adaptivedemux2/dash/gstmpdclient.c
index 50af5ea15a..c245012ed0 100644
--- a/subprojects/gst-plugins-good/ext/adaptivedemux2/dash/gstmpdclient.c
+++ b/subprojects/gst-plugins-good/ext/adaptivedemux2/dash/gstmpdclient.c
@@ -2045,9 +2045,7 @@ gst_mpd_client2_get_next_fragment (GstMPDClient2 * client,
 
     GST_DEBUG ("currentChunk->SegmentURL = %p", currentChunk->SegmentURL);
     if (currentChunk->SegmentURL != NULL) {
-      mediaURL =
-          g_strdup (gst_mpdparser_get_mediaURL (stream,
-              currentChunk->SegmentURL));
+      mediaURL = gst_mpdparser_get_mediaURL (stream, currentChunk->SegmentURL);
       indexURL = g_strdup (currentChunk->SegmentURL->index);
     } else if (stream->cur_seg_template != NULL) {
       mediaURL =
@@ -2320,9 +2318,8 @@ gst_mpd_client2_get_next_header (GstMPDClient2 * client, gchar ** uri,
   *uri = NULL;
   if (stream->cur_segment_base) {
     if (stream->cur_segment_base->Initialization) {
-      *uri =
-          g_strdup (gst_mpdparser_get_initializationURL (stream,
-              stream->cur_segment_base->Initialization));
+      *uri = gst_mpdparser_get_initializationURL (stream,
+          stream->cur_segment_base->Initialization);
       if (stream->cur_segment_base->Initialization->range) {
         *range_start =
             stream->cur_segment_base->Initialization->range->first_byte_pos;
@@ -2330,9 +2327,8 @@ gst_mpd_client2_get_next_header (GstMPDClient2 * client, gchar ** uri,
             stream->cur_segment_base->Initialization->range->last_byte_pos;
       }
     } else if (stream->cur_segment_base->indexRange) {
-      *uri =
-          g_strdup (gst_mpdparser_get_initializationURL (stream,
-              stream->cur_segment_base->Initialization));
+      *uri = gst_mpdparser_get_initializationURL (stream,
+          stream->cur_segment_base->Initialization);
       *range_start = 0;
       *range_end = stream->cur_segment_base->indexRange->first_byte_pos - 1;
     }
@@ -2367,9 +2363,8 @@ gst_mpd_client2_get_next_header_index (GstMPDClient2 * client, gchar ** uri,
   GST_DEBUG ("Looking for current representation index");
   *uri = NULL;
   if (stream->cur_segment_base && stream->cur_segment_base->indexRange) {
-    *uri =
-        g_strdup (gst_mpdparser_get_initializationURL (stream,
-            stream->cur_segment_base->RepresentationIndex));
+    *uri = gst_mpdparser_get_initializationURL (stream,
+        stream->cur_segment_base->RepresentationIndex);
     *range_start = stream->cur_segment_base->indexRange->first_byte_pos;
     *range_end = stream->cur_segment_base->indexRange->last_byte_pos;
   } else if (stream->cur_seg_template && stream->cur_seg_template->index) {
diff --git a/subprojects/gst-plugins-good/ext/adaptivedemux2/dash/gstmpdparser.c b/subprojects/gst-plugins-good/ext/adaptivedemux2/dash/gstmpdparser.c
index 8e7ed18acb..431b374d57 100644
--- a/subprojects/gst-plugins-good/ext/adaptivedemux2/dash/gstmpdparser.c
+++ b/subprojects/gst-plugins-good/ext/adaptivedemux2/dash/gstmpdparser.c
@@ -1397,34 +1397,56 @@ gst_mpdparser_free_active_stream (GstActiveStream * active_stream)
   }
 }
 
-const gchar *
+static gchar *
+get_base_url_with_query (GstActiveStream * stream)
+{
+  GstUri *uri;
+  gchar *uri_str;
+
+  if (!stream->queryURL)
+    return g_strdup (stream->baseURL);
+
+  uri = gst_uri_from_string (stream->baseURL);
+  gst_uri_set_query_string (uri, stream->queryURL);
+  uri_str = gst_uri_to_string (uri);
+
+  gst_uri_unref (uri);
+  return uri_str;
+}
+
+/*
+ * gst_mpdparser_get_initializationURL:
+ *
+ * Returns: (transfer full): stream initializationURL if available,
+ *   baseURL combined with queryURL otherwise.
+ */
+gchar *
 gst_mpdparser_get_initializationURL (GstActiveStream * stream,
     GstMPDURLTypeNode * InitializationURL)
 {
-  const gchar *url_prefix;
-
   g_return_val_if_fail (stream != NULL, NULL);
 
-  url_prefix = (InitializationURL
-      && InitializationURL->sourceURL) ? InitializationURL->sourceURL : stream->
-      baseURL;
-
-  return url_prefix;
+  return (InitializationURL && InitializationURL->sourceURL)
+      ? g_strdup (InitializationURL->sourceURL)
+      : get_base_url_with_query (stream);
 }
 
+/*
+ * gst_mpdparser_get_mediaURL:
+ *
+ * Returns: (transfer full): stream mediaURL if available,
+ *   baseURL combined with queryURL otherwise.
+ */
 gchar *
 gst_mpdparser_get_mediaURL (GstActiveStream * stream,
     GstMPDSegmentURLNode * segmentURL)
 {
-  const gchar *url_prefix;
-
   g_return_val_if_fail (stream != NULL, NULL);
   g_return_val_if_fail (segmentURL != NULL, NULL);
 
-  url_prefix = segmentURL->media ? segmentURL->media : stream->baseURL;
-  g_return_val_if_fail (url_prefix != NULL, NULL);
-
-  return segmentURL->media;
+  return (segmentURL->media)
+      ? g_strdup (segmentURL->media)
+      : get_base_url_with_query (stream);
 }
 
 /* navigation functions */
diff --git a/subprojects/gst-plugins-good/ext/adaptivedemux2/dash/gstmpdparser.h b/subprojects/gst-plugins-good/ext/adaptivedemux2/dash/gstmpdparser.h
index 7dd6f9638d..7ffadb2aed 100644
--- a/subprojects/gst-plugins-good/ext/adaptivedemux2/dash/gstmpdparser.h
+++ b/subprojects/gst-plugins-good/ext/adaptivedemux2/dash/gstmpdparser.h
@@ -165,7 +165,7 @@ void gst_mpdparser_media_fragment_info_clear (GstMediaFragmentInfo * fragment);
 /* Active stream methods*/
 void gst_mpdparser_init_active_stream_segments (GstActiveStream * stream);
 gchar *gst_mpdparser_get_mediaURL (GstActiveStream * stream, GstMPDSegmentURLNode * segmentURL);
-const gchar *gst_mpdparser_get_initializationURL (GstActiveStream * stream, GstMPDURLTypeNode * InitializationURL);
+gchar *gst_mpdparser_get_initializationURL (GstActiveStream * stream, GstMPDURLTypeNode * InitializationURL);
 gchar *gst_mpdparser_build_URL_from_template (const gchar * url_template, const gchar * id, guint number, guint bandwidth, guint64 time);
 
 G_END_DECLS
diff --git a/subprojects/gst-plugins-good/ext/adaptivedemux2/gstadaptivedemux.c b/subprojects/gst-plugins-good/ext/adaptivedemux2/gstadaptivedemux.c
index 622ebf225f..09385d7675 100644
--- a/subprojects/gst-plugins-good/ext/adaptivedemux2/gstadaptivedemux.c
+++ b/subprojects/gst-plugins-good/ext/adaptivedemux2/gstadaptivedemux.c
@@ -549,6 +549,7 @@ gst_adaptive_demux_init (GstAdaptiveDemux * demux,
   gst_segment_init (&demux->segment, GST_FORMAT_TIME);
   demux->instant_rate_multiplier = 1.0;
 
+  GST_OBJECT_FLAG_SET (demux, GST_BIN_FLAG_STREAMS_AWARE);
   gst_bin_set_suppressed_flags (GST_BIN_CAST (demux),
       GST_ELEMENT_FLAG_SOURCE | GST_ELEMENT_FLAG_SINK);
 
@@ -652,7 +653,10 @@ gst_adaptive_demux_check_streams_aware (GstAdaptiveDemux * demux)
   gboolean ret = FALSE;
   GstObject *parent = gst_object_get_parent (GST_OBJECT (demux));
 
-  ret = (parent && GST_OBJECT_FLAG_IS_SET (parent, GST_BIN_FLAG_STREAMS_AWARE));
+  if (parent) {
+    ret = GST_OBJECT_FLAG_IS_SET (parent, GST_BIN_FLAG_STREAMS_AWARE);
+    gst_object_unref (parent);
+  }
 
   return ret;
 }
diff --git a/subprojects/gst-plugins-good/ext/adaptivedemux2/gstadaptivedemuxutils.c b/subprojects/gst-plugins-good/ext/adaptivedemux2/gstadaptivedemuxutils.c
index b27e029248..f9598194e2 100644
--- a/subprojects/gst-plugins-good/ext/adaptivedemux2/gstadaptivedemuxutils.c
+++ b/subprojects/gst-plugins-good/ext/adaptivedemux2/gstadaptivedemuxutils.c
@@ -500,6 +500,7 @@ typedef struct
 {
   gboolean delivered;
   GstEvent *event;
+  guint sticky_order;
 } PadEvent;
 
 void
@@ -541,12 +542,12 @@ gst_event_store_insert_event (GstEventStore * store, GstEvent * event,
     gboolean delivered)
 {
   guint i, len;
-  GstEventType type;
   GArray *events;
   GQuark name_id = 0;
   gboolean insert = TRUE;
 
-  type = GST_EVENT_TYPE (event);
+  GstEventType type = GST_EVENT_TYPE (event);
+  guint event_sticky_order = gst_event_type_to_sticky_ordering (type);
 
   if (type & GST_EVENT_TYPE_STICKY_MULTI)
     name_id = gst_structure_get_name_id (gst_event_get_structure (event));
@@ -578,23 +579,27 @@ gst_event_store_insert_event (GstEventStore * store, GstEvent * event,
       break;
     }
 
-    if (type < GST_EVENT_TYPE (ev->event) || (type != GST_EVENT_TYPE (ev->event)
+    if (event_sticky_order < ev->sticky_order
+        || (type != GST_EVENT_TYPE (ev->event)
             && GST_EVENT_TYPE (ev->event) == GST_EVENT_EOS)) {
       /* STREAM_START, CAPS and SEGMENT must be delivered in this order. By
        * storing the sticky ordered we can check that this is respected. */
-      if (G_UNLIKELY (GST_EVENT_TYPE (ev->event) <= GST_EVENT_SEGMENT
-              || GST_EVENT_TYPE (ev->event) == GST_EVENT_EOS))
+      if (G_UNLIKELY (ev->sticky_order <=
+              gst_event_type_to_sticky_ordering (GST_EVENT_SEGMENT)
+              || GST_EVENT_TYPE (ev->event) == GST_EVENT_EOS)) {
         g_warning (G_STRLOC
             ":%s:<store %p> Sticky event misordering, got '%s' before '%s'",
             G_STRFUNC, store,
             gst_event_type_get_name (GST_EVENT_TYPE (ev->event)),
             gst_event_type_get_name (type));
+      }
       break;
     }
   }
   if (insert) {
     PadEvent ev;
     ev.event = gst_event_ref (event);
+    ev.sticky_order = event_sticky_order;
     ev.delivered = delivered;
     g_array_insert_val (events, i, ev);
 
diff --git a/subprojects/gst-plugins-good/ext/adaptivedemux2/hls/gsthlsdemux.c b/subprojects/gst-plugins-good/ext/adaptivedemux2/hls/gsthlsdemux.c
index 280a420489..0cf7a346bc 100644
--- a/subprojects/gst-plugins-good/ext/adaptivedemux2/hls/gsthlsdemux.c
+++ b/subprojects/gst-plugins-good/ext/adaptivedemux2/hls/gsthlsdemux.c
@@ -192,6 +192,7 @@ gst_hls_demux_stream_init (GstHLSDemuxStream * stream)
   stream->do_typefind = TRUE;
   stream->reset_pts = TRUE;
   stream->presentation_offset = 60 * GST_SECOND;
+  stream->pdt_tag_sent = FALSE;
 }
 
 typedef struct _GstHLSDemux2 GstHLSDemux2;
@@ -1683,8 +1684,9 @@ gst_hls_demux_stream_data_received (GstAdaptiveDemux2Stream * stream,
 {
   GstHLSDemuxStream *hls_stream = GST_HLS_DEMUX_STREAM_CAST (stream);
   GstHLSDemux *hlsdemux = GST_HLS_DEMUX_CAST (stream->demux);
+  GstM3U8MediaSegment *file = hls_stream->current_segment;
 
-  if (hls_stream->current_segment == NULL)
+  if (file == NULL)
     return GST_ADAPTIVE_DEMUX_FLOW_LOST_SYNC;
 
   if (hls_stream->current_offset == -1)
@@ -1727,6 +1729,14 @@ gst_hls_demux_stream_data_received (GstAdaptiveDemux2Stream * stream,
       return GST_FLOW_OK;
   }
 
+  if (!hls_stream->pdt_tag_sent && file != NULL && file->datetime != NULL) {
+    gst_adaptive_demux2_stream_set_tags (stream,
+        gst_tag_list_new (GST_TAG_DATE_TIME,
+            gst_date_time_new_from_g_date_time (g_date_time_ref
+                (file->datetime)), NULL));
+    hls_stream->pdt_tag_sent = TRUE;
+  }
+
   return gst_hls_demux_stream_handle_buffer (stream, buffer, FALSE);
 }
 
@@ -2598,6 +2608,14 @@ gst_hls_demux_reset (GstAdaptiveDemux * ademux)
 
   GST_DEBUG_OBJECT (demux, "resetting");
 
+  if (ademux->input_period) {
+    GList *walk;
+    for (walk = ademux->input_period->streams; walk != NULL; walk = walk->next) {
+      GstHLSDemuxStream *hls_stream = GST_HLS_DEMUX_STREAM_CAST (walk->data);
+      hls_stream->pdt_tag_sent = FALSE;
+    }
+  }
+
   if (demux->master) {
     gst_hls_master_playlist_unref (demux->master);
     demux->master = NULL;
diff --git a/subprojects/gst-plugins-good/ext/adaptivedemux2/hls/gsthlsdemux.h b/subprojects/gst-plugins-good/ext/adaptivedemux2/hls/gsthlsdemux.h
index 1d7f7dbbab..d4acf754c3 100644
--- a/subprojects/gst-plugins-good/ext/adaptivedemux2/hls/gsthlsdemux.h
+++ b/subprojects/gst-plugins-good/ext/adaptivedemux2/hls/gsthlsdemux.h
@@ -168,6 +168,8 @@ struct _GstHLSDemuxStream
    * "output" stream times. Not enabled (i.e 0) if variant is ISOBMFF
    */
   GstClockTime presentation_offset;
+
+  gboolean pdt_tag_sent;
 };
 
 typedef struct {
diff --git a/subprojects/gst-plugins-good/ext/gdk_pixbuf/gstgdkpixbufoverlay.c b/subprojects/gst-plugins-good/ext/gdk_pixbuf/gstgdkpixbufoverlay.c
index a2585f385d..0d6b746a3e 100644
--- a/subprojects/gst-plugins-good/ext/gdk_pixbuf/gstgdkpixbufoverlay.c
+++ b/subprojects/gst-plugins-good/ext/gdk_pixbuf/gstgdkpixbufoverlay.c
@@ -21,17 +21,15 @@
  * SECTION:element-gdkpixbufoverlay
  * @title: gdkpixbufoverlay
  *
- * The gdkpixbufoverlay element overlays an image loaded from file onto
- * a video stream.
+ * The gdkpixbufoverlay element overlays a provided GdkPixbuf or an image
+ * loaded from file onto a video stream.
  *
  * Changing the positioning or overlay width and height properties at runtime
  * is supported, but it might be prudent to to protect the property setting
  * code with GST_BASE_TRANSFORM_LOCK and GST_BASE_TRANSFORM_UNLOCK, as
  * g_object_set() is not atomic for multiple properties passed in one go.
  *
- * Changing the image at runtime is currently not supported.
- *
- * Negative offsets are also not yet supported.
+ * Changing the image at runtime is supported.
  *
  * ## Example launch line
  * |[
diff --git a/subprojects/gst-plugins-good/gst/isomp4/atoms.c b/subprojects/gst-plugins-good/gst/isomp4/atoms.c
index 2e8b4444d6..829d0e5ef7 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/atoms.c
+++ b/subprojects/gst-plugins-good/gst/isomp4/atoms.c
@@ -4825,30 +4825,23 @@ atom_trun_set_offset (AtomTRUN * trun, gint32 offset)
 }
 
 static gboolean
-atom_trun_can_append_samples_to_entry (AtomTRUN * trun,
-    TRUNSampleEntry * nentry, guint32 nsamples, guint32 delta, guint32 size,
-    guint32 flags, gint32 data_offset, gint64 pts_offset)
+atom_trun_can_append (AtomTRUN * trun, gint32 data_offset)
 {
-  if (pts_offset != 0)
-    return FALSE;
-  if (nentry->sample_flags != flags)
-    return FALSE;
-  if (trun->data_offset + nentry->sample_size != data_offset)
-    return FALSE;
-  if (nentry->sample_size != size)
-    return FALSE;
-  if (nentry->sample_duration != delta)
-    return FALSE;
+  gsize trun_data_offset_end = trun->data_offset;
+  int i, n;
 
-  /* FIXME: this should be TRUE but currently fails on demuxing */
-  return FALSE;
-}
+  if (data_offset == 0)
+    return TRUE;
 
-static void
-atom_trun_append_samples (AtomTRUN * trun, TRUNSampleEntry * nentry,
-    guint32 nsamples, guint32 delta, guint32 size)
-{
-  trun->sample_count += nsamples;
+  n = atom_array_get_len (&trun->entries);
+  for (i = 0; i < n; i++) {
+    TRUNSampleEntry *entry = &atom_array_index (&trun->entries, i);
+    trun_data_offset_end += entry->sample_size;
+  }
+  if (trun_data_offset_end != data_offset)
+    return FALSE;
+
+  return TRUE;
 }
 
 static void
@@ -4919,7 +4912,6 @@ atom_traf_add_samples (AtomTRAF * traf, guint32 nsamples,
 {
   GList *l = NULL;
   AtomTRUN *prev_trun, *trun = NULL;
-  TRUNSampleEntry *nentry = NULL;
   guint32 flags;
 
   /* 0x10000 is sample-is-difference-sample flag
@@ -4928,16 +4920,9 @@ atom_traf_add_samples (AtomTRAF * traf, guint32 nsamples,
 
   if (traf->truns) {
     trun = g_list_last (traf->truns)->data;
-    nentry =
-        &atom_array_index (&trun->entries,
-        atom_array_get_len (&trun->entries) - 1);
 
-    if (!atom_trun_can_append_samples_to_entry (trun, nentry, nsamples, delta,
-            size, flags, data_offset, pts_offset)) {
-      /* if we can't add to the previous trun, write a new one */
+    if (!atom_trun_can_append (trun, data_offset))
       trun = NULL;
-      nentry = NULL;
-    }
   }
   prev_trun = trun;
 
@@ -4986,11 +4971,7 @@ atom_traf_add_samples (AtomTRAF * traf, guint32 nsamples,
     }
   }
 
-  if (prev_trun == trun) {
-    atom_trun_append_samples (trun, nentry, nsamples, delta, size);
-  } else {
-    atom_trun_add_samples (trun, nsamples, delta, size, flags, pts_offset);
-  }
+  atom_trun_add_samples (trun, nsamples, delta, size, flags, pts_offset);
 
   if (traf->sdtps)
     atom_sdtp_add_samples (traf->sdtps->data, 0x10 | ((flags & 0xff) >> 4));
diff --git a/subprojects/gst-plugins-good/gst/matroska/matroska-demux.c b/subprojects/gst-plugins-good/gst/matroska/matroska-demux.c
index 773a306343..38e4e4d8ee 100644
--- a/subprojects/gst-plugins-good/gst/matroska/matroska-demux.c
+++ b/subprojects/gst-plugins-good/gst/matroska/matroska-demux.c
@@ -1839,9 +1839,10 @@ gst_matroska_demux_query (GstMatroskaDemux * demux, GstPad * pad,
 
       gst_query_parse_duration (query, &format, NULL);
 
-      res = TRUE;
       if (format == GST_FORMAT_TIME) {
-        res = gst_pad_query_default (pad, GST_OBJECT_CAST (demux), query);
+        res = FALSE;
+        if (pad)
+          res = gst_pad_query_default (pad, GST_OBJECT_CAST (demux), query);
         if (!res) {
           GST_OBJECT_LOCK (demux);
           gst_query_set_duration (query, GST_FORMAT_TIME,
@@ -1852,6 +1853,8 @@ gst_matroska_demux_query (GstMatroskaDemux * demux, GstPad * pad,
         }
       } else if (format == GST_FORMAT_DEFAULT && context
           && context->default_duration) {
+        res = TRUE;
+
         GST_OBJECT_LOCK (demux);
         gst_query_set_duration (query, GST_FORMAT_DEFAULT,
             demux->common.segment.duration / context->default_duration);
diff --git a/subprojects/gst-plugins-good/gst/multifile/gstimagesequencesrc.c b/subprojects/gst-plugins-good/gst/multifile/gstimagesequencesrc.c
index 90dc9fff05..8581e73e3a 100644
--- a/subprojects/gst-plugins-good/gst/multifile/gstimagesequencesrc.c
+++ b/subprojects/gst-plugins-good/gst/multifile/gstimagesequencesrc.c
@@ -531,6 +531,8 @@ gst_image_sequence_src_set_caps (GstImageSequenceSrc * self, GstCaps * caps)
   gst_pad_set_caps (GST_BASE_SRC_PAD (self), new_caps);
 
   GST_DEBUG_OBJECT (self, "Setting new caps: %" GST_PTR_FORMAT, new_caps);
+
+  gst_caps_unref (new_caps);
 }
 
 /* Call with LOCK */
diff --git a/subprojects/gst-plugins-good/gst/multifile/gstsplitmuxsink.c b/subprojects/gst-plugins-good/gst/multifile/gstsplitmuxsink.c
index 5e4ae02e31..ad6c3d3782 100644
--- a/subprojects/gst-plugins-good/gst/multifile/gstsplitmuxsink.c
+++ b/subprojects/gst-plugins-good/gst/multifile/gstsplitmuxsink.c
@@ -3178,11 +3178,13 @@ handle_mq_input (GstPad * pad, GstPadProbeInfo * info, MqStreamCtx * ctx)
         }
         break;
       case SPLITMUX_INPUT_STATE_WAITING_GOP_COLLECT:{
-        /* We're collecting a GOP, this is only ever called for non-reference
+        /* We're collecting a GOP, this is normally only called for non-reference
          * contexts as the reference context would be waiting inside
          * check_completed_gop() */
-
-        g_assert (!ctx->is_reference);
+        if (G_UNLIKELY (ctx->is_reference)) {
+          check_completed_gop (splitmux, ctx);
+          break;
+        }
 
         /* If we overran the target timestamp, it might be time to process
          * the GOP, otherwise bail out for more data. */
diff --git a/subprojects/gst-plugins-good/gst/rtpmanager/gstrtpjitterbuffer.c b/subprojects/gst-plugins-good/gst/rtpmanager/gstrtpjitterbuffer.c
index 600ec62345..063e39b9f7 100644
--- a/subprojects/gst-plugins-good/gst/rtpmanager/gstrtpjitterbuffer.c
+++ b/subprojects/gst-plugins-good/gst/rtpmanager/gstrtpjitterbuffer.c
@@ -232,6 +232,13 @@ enum
   (priv)->waiting_timer--;                                \
   GST_DEBUG ("waiting timer done");                       \
 } G_STMT_END
+#define JBUF_WAIT_TIMER_CHECK(priv, label) G_STMT_START { \
+    if (G_UNLIKELY (priv->srcresult != GST_FLOW_OK))	  \
+      goto label;					  \
+    JBUF_WAIT_TIMER (priv);				  \
+    if (G_UNLIKELY (priv->srcresult != GST_FLOW_OK))	  \
+      goto label;					  \
+  } G_STMT_END
 #define JBUF_SIGNAL_TIMER(priv) G_STMT_START {            \
   if (G_UNLIKELY ((priv)->waiting_timer)) {               \
     GST_DEBUG ("signal timer, %d waiters", (priv)->waiting_timer); \
@@ -1704,6 +1711,7 @@ gst_rtp_jitter_buffer_flush_start (GstRtpJitterBuffer * jitterbuffer)
   JBUF_SIGNAL_EVENT (priv);
   JBUF_SIGNAL_QUERY (priv, FALSE);
   JBUF_SIGNAL_QUEUE (priv);
+  JBUF_SIGNAL_TIMER (priv);
   JBUF_UNLOCK (priv);
 }
 
@@ -2266,10 +2274,9 @@ update_timer_offsets (GstRtpJitterBuffer * jitterbuffer)
         test->timeout = GST_CLOCK_TIME_NONE;
         test->offset = 0;
       }
-      /* as we apply the offset on all timers, the order of timers won't
-       * change and we can skip updating the timer queue */
     }
 
+    rtp_timer_queue_reschedule (priv->timers, test);
     test = rtp_timer_get_next (test);
   }
 }
@@ -3851,7 +3858,7 @@ pop_and_push_next (GstRtpJitterBuffer * jitterbuffer, guint seqnum)
     while (rtp_timer_queue_length (priv->timers) > 0) {
       /* Stopping timers */
       unschedule_current_timer (jitterbuffer);
-      JBUF_WAIT_TIMER (priv);
+      JBUF_WAIT_TIMER_CHECK (priv, out_flushing_wait);
     }
   }
 
@@ -3918,6 +3925,12 @@ out_flushing:
   {
     return priv->srcresult;
   }
+
+out_flushing_wait:
+  {
+    rtp_jitter_buffer_free_item (item);
+    return priv->srcresult;
+  }
 }
 
 #define GST_FLOW_WAIT GST_FLOW_CUSTOM_SUCCESS
diff --git a/subprojects/gst-plugins-good/gst/rtsp/gstrtspsrc.c b/subprojects/gst-plugins-good/gst/rtsp/gstrtspsrc.c
index 6922deabe0..bcaf9b0511 100644
--- a/subprojects/gst-plugins-good/gst/rtsp/gstrtspsrc.c
+++ b/subprojects/gst-plugins-good/gst/rtsp/gstrtspsrc.c
@@ -151,6 +151,7 @@ enum
   SIGNAL_GET_PARAMETER,
   SIGNAL_GET_PARAMETERS,
   SIGNAL_SET_PARAMETER,
+  SIGNAL_PUSH_BACKCHANNEL_SAMPLE,
   LAST_SIGNAL
 };
 
@@ -467,6 +468,9 @@ static gboolean set_parameter (GstRTSPSrc * src, const gchar * name,
 static GstFlowReturn gst_rtspsrc_push_backchannel_buffer (GstRTSPSrc * src,
     guint id, GstSample * sample);
 
+static GstFlowReturn gst_rtspsrc_push_backchannel_sample (GstRTSPSrc * src,
+    guint id, GstSample * sample);
+
 typedef struct
 {
   guint8 pt;
@@ -1226,15 +1230,34 @@ gst_rtspsrc_class_init (GstRTSPSrcClass * klass)
   /**
    * GstRTSPSrc::push-backchannel-buffer:
    * @rtspsrc: a #GstRTSPSrc
+   * @id: stream ID where the sample should be sent
    * @sample: RTP sample to send back
    *
+   * Deprecated: 1.22: Use action signal GstRTSPSrc::push-backchannel-sample instead.
+   * IMPORTANT: Please note that this signal decrements the reference count 
+   *            of sample internally! So it cannot be used from other
+   *            language bindings in general.
    *
    */
   gst_rtspsrc_signals[SIGNAL_PUSH_BACKCHANNEL_BUFFER] =
       g_signal_new ("push-backchannel-buffer", G_TYPE_FROM_CLASS (klass),
-      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION, G_STRUCT_OFFSET (GstRTSPSrcClass,
-          push_backchannel_buffer), NULL, NULL, NULL,
-      GST_TYPE_FLOW_RETURN, 2, G_TYPE_UINT, GST_TYPE_SAMPLE);
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION | G_SIGNAL_DEPRECATED,
+      G_STRUCT_OFFSET (GstRTSPSrcClass, push_backchannel_buffer), NULL, NULL,
+      NULL, GST_TYPE_FLOW_RETURN, 2, G_TYPE_UINT, GST_TYPE_SAMPLE);
+
+  /**
+   * GstRTSPSrc::push-backchannel-sample:
+   * @rtspsrc: a #GstRTSPSrc
+   * @id: stream ID where the sample should be sent
+   * @sample: RTP sample to send back
+   *
+   * Since: 1.22
+   */
+  gst_rtspsrc_signals[SIGNAL_PUSH_BACKCHANNEL_SAMPLE] =
+      g_signal_new ("push-backchannel-sample", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION | G_SIGNAL_DEPRECATED,
+      G_STRUCT_OFFSET (GstRTSPSrcClass, push_backchannel_buffer), NULL, NULL,
+      NULL, GST_TYPE_FLOW_RETURN, 2, G_TYPE_UINT, GST_TYPE_SAMPLE);
 
   /**
    * GstRTSPSrc::get-parameter:
@@ -1307,6 +1330,7 @@ gst_rtspsrc_class_init (GstRTSPSrcClass * klass)
   gstbin_class->handle_message = gst_rtspsrc_handle_message;
 
   klass->push_backchannel_buffer = gst_rtspsrc_push_backchannel_buffer;
+  klass->push_backchannel_sample = gst_rtspsrc_push_backchannel_sample;
   klass->get_parameter = GST_DEBUG_FUNCPTR (get_parameter);
   klass->get_parameters = GST_DEBUG_FUNCPTR (get_parameters);
   klass->set_parameter = GST_DEBUG_FUNCPTR (set_parameter);
@@ -2755,8 +2779,7 @@ gst_rtspsrc_set_state (GstRTSPSrc * src, GstState state)
 }
 
 static void
-gst_rtspsrc_flush (GstRTSPSrc * src, gboolean flush, gboolean playing,
-    guint32 seqnum)
+gst_rtspsrc_flush (GstRTSPSrc * src, gboolean flush, gboolean playing)
 {
   GstEvent *event;
   gint cmd;
@@ -2764,13 +2787,11 @@ gst_rtspsrc_flush (GstRTSPSrc * src, gboolean flush, gboolean playing,
 
   if (flush) {
     event = gst_event_new_flush_start ();
-    gst_event_set_seqnum (event, seqnum);
     GST_DEBUG_OBJECT (src, "start flush");
     cmd = CMD_WAIT;
     state = GST_STATE_PAUSED;
   } else {
     event = gst_event_new_flush_stop (TRUE);
-    gst_event_set_seqnum (event, seqnum);
     GST_DEBUG_OBJECT (src, "stop flush; playing %d", playing);
     cmd = CMD_LOOP;
     if (playing)
@@ -2903,7 +2924,7 @@ gst_rtspsrc_perform_seek (GstRTSPSrc * src, GstEvent * event)
    * blocking in preroll). */
   if (flush) {
     GST_DEBUG_OBJECT (src, "starting flush");
-    gst_rtspsrc_flush (src, TRUE, FALSE, gst_event_get_seqnum (event));
+    gst_rtspsrc_flush (src, TRUE, FALSE);
   } else {
     if (src->task) {
       gst_task_pause (src->task);
@@ -2953,7 +2974,7 @@ gst_rtspsrc_perform_seek (GstRTSPSrc * src, GstEvent * event)
   if (flush) {
     /* if we started flush, we stop now */
     GST_DEBUG_OBJECT (src, "stopping flush");
-    gst_rtspsrc_flush (src, FALSE, playing, gst_event_get_seqnum (event));
+    gst_rtspsrc_flush (src, FALSE, playing);
   }
 
   /* now we did the seek and can activate the new segment values */
@@ -3084,15 +3105,10 @@ gst_rtspsrc_stream_start_event_add_group_id (GstRTSPSrc * src, GstEvent * event)
   gst_event_set_group_id (event, src->group_id);
 }
 
-static gboolean
-gst_rtspsrc_handle_src_sink_event (GstPad * pad, GstObject * parent,
+static GstEvent *
+gst_rtspsrc_update_src_event (GstRTSPSrc * self, GstRTSPStream * stream,
     GstEvent * event)
 {
-  GstRTSPStream *stream;
-  GstRTSPSrc *self = GST_RTSPSRC (GST_OBJECT_PARENT (parent));
-
-  stream = gst_pad_get_element_private (pad);
-
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_STREAM_START:{
       GChecksum *cs;
@@ -3112,16 +3128,30 @@ gst_rtspsrc_handle_src_sink_event (GstPad * pad, GstObject * parent,
       event = gst_event_new_stream_start (stream_id);
       gst_rtspsrc_stream_start_event_add_group_id (self, event);
       g_free (stream_id);
+
+      gst_event_set_seqnum (event, self->seek_seqnum);
       break;
     }
-    case GST_EVENT_SEGMENT:
-      if (self->seek_seqnum != GST_SEQNUM_INVALID)
-        GST_EVENT_SEQNUM (event) = self->seek_seqnum;
-      break;
     default:
+      event = gst_event_make_writable (event);
+      gst_event_set_seqnum (event, self->seek_seqnum);
       break;
   }
 
+  return event;
+}
+
+static gboolean
+gst_rtspsrc_handle_src_sink_event (GstPad * pad, GstObject * parent,
+    GstEvent * event)
+{
+  GstRTSPStream *stream;
+  GstRTSPSrc *self = GST_RTSPSRC (GST_OBJECT_PARENT (parent));
+
+  stream = gst_pad_get_element_private (pad);
+
+  event = gst_rtspsrc_update_src_event (self, stream, event);
+
   return gst_pad_push_event (stream->srcpad, event);
 }
 
@@ -3330,6 +3360,19 @@ gst_rtspsrc_sink_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
 static GstFlowReturn
 gst_rtspsrc_push_backchannel_buffer (GstRTSPSrc * src, guint id,
     GstSample * sample)
+{
+  GstFlowReturn res;
+
+  res = gst_rtspsrc_push_backchannel_sample (src, id, sample);
+
+  gst_sample_unref (sample);
+
+  return res;
+}
+
+static GstFlowReturn
+gst_rtspsrc_push_backchannel_sample (GstRTSPSrc * src, guint id,
+    GstSample * sample)
 {
   GstFlowReturn res = GST_FLOW_OK;
   GstRTSPStream *stream;
@@ -3376,8 +3419,6 @@ gst_rtspsrc_push_backchannel_buffer (GstRTSPSrc * src, guint id,
   }
 
 out:
-  gst_sample_unref (sample);
-
   return res;
 }
 
@@ -3415,10 +3456,8 @@ udpsrc_probe_cb (GstPad * pad, GstPadProbeInfo * info, gpointer user_data)
 
   switch (GST_EVENT_TYPE (info->data)) {
     case GST_EVENT_SEGMENT:
-      if (!gst_event_is_writable (info->data))
-        info->data = gst_event_make_writable (info->data);
-
       *segment_seqnum = gst_event_get_seqnum (info->data);
+      break;
     default:
       break;
   }
@@ -3426,13 +3465,24 @@ udpsrc_probe_cb (GstPad * pad, GstPadProbeInfo * info, gpointer user_data)
   return GST_PAD_PROBE_OK;
 }
 
+typedef struct
+{
+  GstRTSPSrc *src;
+  GstRTSPStream *stream;
+} CopyStickyEventsData;
+
 static gboolean
 copy_sticky_events (GstPad * pad, GstEvent ** event, gpointer user_data)
 {
-  GstPad *gpad = GST_PAD_CAST (user_data);
+  CopyStickyEventsData *data = user_data;
+  GstEvent *new_event;
 
-  GST_DEBUG_OBJECT (gpad, "store sticky event %" GST_PTR_FORMAT, *event);
-  gst_pad_store_sticky_event (gpad, *event);
+  GST_DEBUG_OBJECT (data->stream->srcpad, "send sticky event %" GST_PTR_FORMAT,
+      *event);
+  new_event =
+      gst_rtspsrc_update_src_event (data->src, data->stream,
+      gst_event_ref (*event));
+  gst_pad_store_sticky_event (data->stream->srcpad, new_event);
 
   return TRUE;
 }
@@ -3478,6 +3528,7 @@ new_manager_pad (GstElement * manager, GstPad * pad, GstRTSPSrc * src)
   GstRTSPStream *stream;
   gboolean all_added;
   GstPad *internal_src;
+  CopyStickyEventsData copy_sticky_events_data;
 
   GST_DEBUG_OBJECT (src, "got new manager pad %" GST_PTR_FORMAT, pad);
 
@@ -3527,12 +3578,17 @@ new_manager_pad (GstElement * manager, GstPad * pad, GstRTSPSrc * src)
       GST_PAD (gst_proxy_pad_get_internal (GST_PROXY_PAD (stream->srcpad)));
   gst_pad_set_element_private (internal_src, stream);
   gst_pad_set_event_function (internal_src, gst_rtspsrc_handle_src_sink_event);
-  gst_object_unref (internal_src);
 
   gst_pad_set_event_function (stream->srcpad, gst_rtspsrc_handle_src_event);
   gst_pad_set_query_function (stream->srcpad, gst_rtspsrc_handle_src_query);
   gst_pad_set_active (stream->srcpad, TRUE);
-  gst_pad_sticky_events_foreach (pad, copy_sticky_events, stream->srcpad);
+
+  copy_sticky_events_data.src = src;
+  copy_sticky_events_data.stream = stream;
+  gst_pad_sticky_events_foreach (pad, copy_sticky_events,
+      &copy_sticky_events_data);
+
+  gst_object_unref (internal_src);
 
   /* don't add the srcpad if this is a sendonly stream */
   if (stream->is_backchannel)
@@ -3605,19 +3661,7 @@ gst_rtspsrc_do_stream_eos (GstRTSPSrc * src, GstRTSPStream * stream)
 {
   GST_DEBUG_OBJECT (src, "setting stream for session %u to EOS", stream->id);
 
-  if (stream->eos)
-    goto was_eos;
-
-  stream->eos = TRUE;
   gst_rtspsrc_stream_push_event (src, stream, gst_event_new_eos ());
-  return;
-
-  /* ERRORS */
-was_eos:
-  {
-    GST_DEBUG_OBJECT (src, "stream for session %u was already EOS", stream->id);
-    return;
-  }
 }
 
 static void
@@ -4425,25 +4469,29 @@ element_make_from_addr (const GstURIType type, const char *addr_s,
   char *uri = NULL;
 
   addr = g_inet_address_new_from_string (addr_s);
-
-  switch (g_inet_address_get_family (addr)) {
-    case G_SOCKET_FAMILY_IPV6:
-      uri = g_strdup_printf ("udp://[%s]:%i", addr_s, port);
-      break;
-    case G_SOCKET_FAMILY_INVALID:
-      GST_ERROR ("Unknown family type for %s", addr_s);
-      goto out;
-    case G_SOCKET_FAMILY_UNIX:
-      GST_ERROR ("Unexpected family type UNIX for %s", addr_s);
-      goto out;
-    case G_SOCKET_FAMILY_IPV4:
-      uri = g_strdup_printf ("udp://%s:%i", addr_s, port);
-      break;
+  if (addr == NULL) {
+    /* Address is a hostname, not an IP address */
+    uri = g_strdup_printf ("udp://%s:%i", addr_s, port);
+  } else {
+    switch (g_inet_address_get_family (addr)) {
+      case G_SOCKET_FAMILY_IPV6:
+        uri = g_strdup_printf ("udp://[%s]:%i", addr_s, port);
+        break;
+      case G_SOCKET_FAMILY_INVALID:
+        GST_ERROR ("Unknown family type for %s", addr_s);
+        goto out;
+      case G_SOCKET_FAMILY_UNIX:
+        GST_ERROR ("Unexpected family type UNIX for %s", addr_s);
+        goto out;
+      case G_SOCKET_FAMILY_IPV4:
+        uri = g_strdup_printf ("udp://%s:%i", addr_s, port);
+        break;
+    }
   }
 
   element = gst_element_make_from_uri (type, uri, name, error);
 out:
-  g_object_unref (addr);
+  g_clear_object (&addr);
   g_free (uri);
   return element;
 }
@@ -4884,6 +4932,8 @@ gst_rtspsrc_stream_configure_transport (GstRTSPStream * stream,
     add_backchannel_fakesink (src, stream, outpad);
     gst_object_unref (outpad);
   } else if (outpad) {
+    GstPad *internal_src;
+
     GST_DEBUG_OBJECT (src, "creating ghostpad for stream %p", stream);
 
     gst_pad_use_fixed_caps (outpad);
@@ -4898,6 +4948,17 @@ gst_rtspsrc_stream_configure_transport (GstRTSPStream * stream,
     gst_object_unref (template);
     g_free (name);
 
+    /* We intercept and modify the stream start event */
+    internal_src =
+        GST_PAD (gst_proxy_pad_get_internal (GST_PROXY_PAD (stream->srcpad)));
+    gst_pad_set_element_private (internal_src, stream);
+    gst_pad_set_event_function (internal_src,
+        gst_rtspsrc_handle_src_sink_event);
+    gst_object_unref (internal_src);
+
+    gst_pad_set_event_function (stream->srcpad, gst_rtspsrc_handle_src_event);
+    gst_pad_set_query_function (stream->srcpad, gst_rtspsrc_handle_src_query);
+
     gst_object_unref (outpad);
   }
   /* mark pad as ok */
@@ -5120,11 +5181,22 @@ gst_rtspsrc_stream_push_event (GstRTSPSrc * src, GstRTSPStream * stream,
   if (!stream->setup)
     goto done;
 
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_EOS:
+      stream->eos = TRUE;
+      break;
+    case GST_EVENT_FLUSH_STOP:
+      stream->eos = FALSE;
+      break;
+    default:
+      break;
+  }
+
   if (stream->udpsrc[0]) {
     GstEvent *sent_event;
 
-    if (GST_EVENT_TYPE (event) == GST_EVENT_EOS) {
-      sent_event = gst_event_new_eos ();
+    if (stream->segment_seqnum[0] != GST_SEQNUM_INVALID) {
+      sent_event = gst_event_copy (event);
       gst_event_set_seqnum (sent_event, stream->segment_seqnum[0]);
     } else {
       sent_event = gst_event_ref (event);
@@ -5132,32 +5204,38 @@ gst_rtspsrc_stream_push_event (GstRTSPSrc * src, GstRTSPStream * stream,
 
     res = gst_element_send_event (stream->udpsrc[0], sent_event);
   } else if (stream->channelpad[0]) {
-    gst_event_ref (event);
+    GstEvent *sent_event;
+
+    sent_event = gst_event_copy (event);
+    gst_event_set_seqnum (sent_event, src->seek_seqnum);
+
     if (GST_PAD_IS_SRC (stream->channelpad[0]))
-      res = gst_pad_push_event (stream->channelpad[0], event);
+      res = gst_pad_push_event (stream->channelpad[0], sent_event);
     else
-      res = gst_pad_send_event (stream->channelpad[0], event);
+      res = gst_pad_send_event (stream->channelpad[0], sent_event);
   }
 
   if (stream->udpsrc[1]) {
     GstEvent *sent_event;
 
-    if (GST_EVENT_TYPE (event) == GST_EVENT_EOS) {
-      sent_event = gst_event_new_eos ();
-      if (stream->segment_seqnum[1] != GST_SEQNUM_INVALID) {
-        gst_event_set_seqnum (sent_event, stream->segment_seqnum[1]);
-      }
+    if (stream->segment_seqnum[1] != GST_SEQNUM_INVALID) {
+      sent_event = gst_event_copy (event);
+      gst_event_set_seqnum (sent_event, stream->segment_seqnum[1]);
     } else {
       sent_event = gst_event_ref (event);
     }
 
     res &= gst_element_send_event (stream->udpsrc[1], sent_event);
   } else if (stream->channelpad[1]) {
-    gst_event_ref (event);
+    GstEvent *sent_event;
+
+    sent_event = gst_event_copy (event);
+    gst_event_set_seqnum (sent_event, src->seek_seqnum);
+
     if (GST_PAD_IS_SRC (stream->channelpad[1]))
-      res &= gst_pad_push_event (stream->channelpad[1], event);
+      res &= gst_pad_push_event (stream->channelpad[1], sent_event);
     else
-      res &= gst_pad_send_event (stream->channelpad[1], event);
+      res &= gst_pad_send_event (stream->channelpad[1], sent_event);
   }
 
 done:
@@ -9387,6 +9465,7 @@ gst_rtspsrc_change_state (GstElement * element, GstStateChange transition)
         goto start_failed;
       break;
     case GST_STATE_CHANGE_READY_TO_PAUSED:
+      rtspsrc->seek_seqnum = gst_util_seqnum_next ();
       /* init some state */
       rtspsrc->cur_protocols = rtspsrc->protocols;
       /* first attempt, don't ignore timeouts */
diff --git a/subprojects/gst-plugins-good/gst/rtsp/gstrtspsrc.h b/subprojects/gst-plugins-good/gst/rtsp/gstrtspsrc.h
index 93ad288fd1..9457972b56 100644
--- a/subprojects/gst-plugins-good/gst/rtsp/gstrtspsrc.h
+++ b/subprojects/gst-plugins-good/gst/rtsp/gstrtspsrc.h
@@ -339,6 +339,7 @@ struct _GstRTSPSrcClass {
   gboolean (*get_parameters) (GstRTSPSrc *rtsp, gchar **parameters, const gchar *content_type, GstPromise *promise);
   gboolean (*set_parameter) (GstRTSPSrc *rtsp, const gchar *name, const gchar *value, const gchar *content_type, GstPromise *promise);
   GstFlowReturn (*push_backchannel_buffer) (GstRTSPSrc *src, guint id, GstSample *sample);
+  GstFlowReturn (*push_backchannel_sample) (GstRTSPSrc *src, guint id, GstSample *sample);
 };
 
 GType gst_rtspsrc_get_type(void);
diff --git a/subprojects/gst-plugins-good/gst/videobox/gstvideobox.c b/subprojects/gst-plugins-good/gst/videobox/gstvideobox.c
index 302e714260..5267c9180c 100644
--- a/subprojects/gst-plugins-good/gst/videobox/gstvideobox.c
+++ b/subprojects/gst-plugins-good/gst/videobox/gstvideobox.c
@@ -3189,29 +3189,25 @@ static gboolean
 gst_video_box_src_event (GstBaseTransform * trans, GstEvent * event)
 {
   GstVideoBox *video_box = GST_VIDEO_BOX (trans);
-  GstNavigationEventType type;
-  gdouble pointer_x;
-  gdouble pointer_y;
+  gdouble x, y, new_x, new_y;
 
   GST_OBJECT_LOCK (video_box);
-  type = gst_navigation_event_get_type (event);
-  if (GST_EVENT_TYPE (event) == GST_EVENT_NAVIGATION &&
-      (video_box->box_left != 0 || video_box->box_top != 0) &&
-      (type == GST_NAVIGATION_EVENT_MOUSE_MOVE
-          || type == GST_NAVIGATION_EVENT_MOUSE_BUTTON_PRESS
-          || type == GST_NAVIGATION_EVENT_MOUSE_BUTTON_RELEASE)) {
-    if (gst_navigation_event_get_coordinates (event, &pointer_x, &pointer_y)) {
-      gdouble new_pointer_x, new_pointer_y;
-
-      event = gst_event_make_writable (event);
-      new_pointer_x = pointer_x + video_box->box_left;
-      new_pointer_y = pointer_y + video_box->box_top;
-
-      gst_navigation_event_set_coordinates (event, new_pointer_x,
-          new_pointer_y);
-    } else {
-      GST_WARNING_OBJECT (video_box, "Failed to read navigation event");
-    }
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_NAVIGATION:
+      if ((video_box->box_left != 0 || video_box->box_top != 0)
+          && gst_navigation_event_get_coordinates (event, &x, &y)) {
+
+        event = gst_event_make_writable (event);
+        new_x = x + video_box->box_left;
+        new_y = y + video_box->box_top;
+
+        GST_TRACE_OBJECT (video_box, "from %fx%f to %fx%f", x, y, new_x, new_y);
+        gst_navigation_event_set_coordinates (event, new_x, new_y);
+      }
+      break;
+    default:
+      break;
   }
   GST_OBJECT_UNLOCK (video_box);
 
diff --git a/subprojects/gst-plugins-good/gst/videocrop/gstvideocrop.c b/subprojects/gst-plugins-good/gst/videocrop/gstvideocrop.c
index 9ef4d1e55d..b87ee96198 100644
--- a/subprojects/gst-plugins-good/gst/videocrop/gstvideocrop.c
+++ b/subprojects/gst-plugins-good/gst/videocrop/gstvideocrop.c
@@ -123,26 +123,27 @@ static GstFlowReturn gst_video_crop_transform_ip (GstBaseTransform * trans,
 static gboolean
 gst_video_crop_src_event (GstBaseTransform * trans, GstEvent * event)
 {
-  GstNavigationEventType type;
-  double pointer_x;
-  double pointer_y;
+  double x, y, new_x, new_y;
 
   GstVideoCrop *vcrop = GST_VIDEO_CROP (trans);
   GST_OBJECT_LOCK (vcrop);
 
-  type = gst_navigation_event_get_type (event);
-  if (GST_EVENT_TYPE (event) == GST_EVENT_NAVIGATION &&
-      (vcrop->crop_left != 0 || vcrop->crop_top != 0) &&
-      (type == GST_NAVIGATION_EVENT_MOUSE_MOVE
-          || type == GST_NAVIGATION_EVENT_MOUSE_BUTTON_PRESS
-          || type == GST_NAVIGATION_EVENT_MOUSE_BUTTON_RELEASE)) {
-    if (gst_navigation_event_get_coordinates (event, &pointer_x, &pointer_y)) {
-      event = gst_event_make_writable (event);
-      gst_navigation_event_set_coordinates (event, pointer_x + vcrop->crop_left,
-          pointer_y + vcrop->crop_top);
-    } else {
-      GST_WARNING_OBJECT (vcrop, "Failed to read navigation event");
-    }
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_NAVIGATION:
+      if ((vcrop->crop_left != 0 || vcrop->crop_top != 0)
+          && gst_navigation_event_get_coordinates (event, &x, &y)) {
+
+        new_x = x + vcrop->crop_left;
+        new_y = y + vcrop->crop_top;
+
+        event = gst_event_make_writable (event);
+
+        GST_TRACE_OBJECT (vcrop, "from %fx%f to %fx%f", x, y, new_x, new_y);
+        gst_navigation_event_set_coordinates (event, new_x, new_y);
+      }
+      break;
+    default:
+      break;
   }
 
   GST_OBJECT_UNLOCK (vcrop);
diff --git a/subprojects/gst-plugins-good/gst/videofilter/gstvideoflip.c b/subprojects/gst-plugins-good/gst/videofilter/gstvideoflip.c
index 69d9a5e43e..07db89969d 100644
--- a/subprojects/gst-plugins-good/gst/videofilter/gstvideoflip.c
+++ b/subprojects/gst-plugins-good/gst/videofilter/gstvideoflip.c
@@ -1777,7 +1777,7 @@ gst_video_flip_sink_event (GstBaseTransform * trans, GstEvent * event)
 {
   GstVideoFlip *vf = GST_VIDEO_FLIP (trans);
   GstTagList *taglist;
-  gchar *orientation;
+  GstVideoOrientationMethod method;
   gboolean ret;
 
   GST_DEBUG_OBJECT (vf, "handling %s event", GST_EVENT_TYPE_NAME (event));
@@ -1786,25 +1786,8 @@ gst_video_flip_sink_event (GstBaseTransform * trans, GstEvent * event)
     case GST_EVENT_TAG:
       gst_event_parse_tag (event, &taglist);
 
-      if (gst_tag_list_get_string (taglist, "image-orientation", &orientation)) {
-        if (!g_strcmp0 ("rotate-0", orientation))
-          gst_video_flip_set_method (vf, GST_VIDEO_ORIENTATION_IDENTITY, TRUE);
-        else if (!g_strcmp0 ("rotate-90", orientation))
-          gst_video_flip_set_method (vf, GST_VIDEO_ORIENTATION_90R, TRUE);
-        else if (!g_strcmp0 ("rotate-180", orientation))
-          gst_video_flip_set_method (vf, GST_VIDEO_ORIENTATION_180, TRUE);
-        else if (!g_strcmp0 ("rotate-270", orientation))
-          gst_video_flip_set_method (vf, GST_VIDEO_ORIENTATION_90L, TRUE);
-        else if (!g_strcmp0 ("flip-rotate-0", orientation))
-          gst_video_flip_set_method (vf, GST_VIDEO_ORIENTATION_HORIZ, TRUE);
-        else if (!g_strcmp0 ("flip-rotate-90", orientation))
-          gst_video_flip_set_method (vf, GST_VIDEO_ORIENTATION_UL_LR, TRUE);
-        else if (!g_strcmp0 ("flip-rotate-180", orientation))
-          gst_video_flip_set_method (vf, GST_VIDEO_ORIENTATION_VERT, TRUE);
-        else if (!g_strcmp0 ("flip-rotate-270", orientation))
-          gst_video_flip_set_method (vf, GST_VIDEO_ORIENTATION_UR_LL, TRUE);
-
-        g_free (orientation);
+      if (gst_video_orientation_from_tag (taglist, &method)) {
+        gst_video_flip_set_method (vf, method, TRUE);
       }
       break;
     default:
diff --git a/subprojects/gst-plugins-good/gst/wavparse/gstwavparse.c b/subprojects/gst-plugins-good/gst/wavparse/gstwavparse.c
index 0c624c4599..1b71ccab77 100644
--- a/subprojects/gst-plugins-good/gst/wavparse/gstwavparse.c
+++ b/subprojects/gst-plugins-good/gst/wavparse/gstwavparse.c
@@ -1923,11 +1923,12 @@ gst_wavparse_add_src_pad (GstWavParse * wav, GstBuffer * buf)
   if (s && gst_structure_has_name (s, "audio/x-raw") && buf != NULL
       && (GST_BUFFER_OFFSET (buf) == 0 || !GST_BUFFER_OFFSET_IS_VALID (buf))) {
     GstTypeFindProbability prob;
-    GstCaps *tf_caps;
+    GstCaps *tf_caps, *dts_caps;
 
+    dts_caps = gst_caps_from_string ("audio/x-dts");
     tf_caps =
-        gst_type_find_helper_for_buffer_with_extension (GST_OBJECT (wav), buf,
-        "dts", &prob);
+        gst_type_find_helper_for_buffer_with_caps (GST_OBJECT (wav), buf,
+        dts_caps, &prob);
     if (tf_caps != NULL) {
       GST_LOG ("typefind caps = %" GST_PTR_FORMAT ", P=%d", tf_caps, prob);
       if (gst_wavparse_have_dts_caps (tf_caps, prob)) {
@@ -1943,6 +1944,7 @@ gst_wavparse_add_src_pad (GstWavParse * wav, GstBuffer * buf)
         gst_caps_unref (tf_caps);
       }
     }
+    gst_caps_unref (dts_caps);
   }
 
   gst_pad_set_caps (wav->srcpad, wav->caps);
diff --git a/subprojects/gst-plugins-good/meson.build b/subprojects/gst-plugins-good/meson.build
index 8950a05f44..942b38eb88 100644
--- a/subprojects/gst-plugins-good/meson.build
+++ b/subprojects/gst-plugins-good/meson.build
@@ -1,5 +1,5 @@
 project('gst-plugins-good', 'c',
-  version : '1.21.2',
+  version : '1.21.2.1',
   meson_version : '>= 0.62',
   default_options : [ 'warning_level=1',
                       'buildtype=debugoptimized' ])
diff --git a/subprojects/gst-plugins-good/sys/v4l2/gstv4l2bufferpool.c b/subprojects/gst-plugins-good/sys/v4l2/gstv4l2bufferpool.c
index 4c471f184f..c5da1f8a5b 100644
--- a/subprojects/gst-plugins-good/sys/v4l2/gstv4l2bufferpool.c
+++ b/subprojects/gst-plugins-good/sys/v4l2/gstv4l2bufferpool.c
@@ -259,16 +259,9 @@ gst_v4l2_buffer_pool_import_userptr (GstV4l2BufferPool * pool,
     for (i = 0; i < GST_VIDEO_FORMAT_INFO_N_PLANES (finfo); i++) {
       if (GST_VIDEO_FORMAT_INFO_IS_TILED (finfo)) {
         gint tinfo = GST_VIDEO_FRAME_PLANE_STRIDE (&data->frame, i);
-        gint pstride;
-        guint pheight;
-
-        pstride = GST_VIDEO_TILE_X_TILES (tinfo) <<
-            GST_VIDEO_FORMAT_INFO_TILE_WS (finfo);
-
-        pheight = GST_VIDEO_TILE_Y_TILES (tinfo) <<
-            GST_VIDEO_FORMAT_INFO_TILE_HS (finfo);
-
-        size[i] = pstride * pheight;
+        size[i] = GST_VIDEO_TILE_X_TILES (tinfo) *
+            GST_VIDEO_TILE_Y_TILES (tinfo) *
+            GST_VIDEO_FORMAT_INFO_TILE_SIZE (finfo, i);
       } else {
         size[i] = GST_VIDEO_FRAME_PLANE_STRIDE (&data->frame, i) *
             GST_VIDEO_FRAME_COMP_HEIGHT (&data->frame, i);
diff --git a/subprojects/gst-plugins-good/sys/v4l2/gstv4l2object.c b/subprojects/gst-plugins-good/sys/v4l2/gstv4l2object.c
index 4e6aaf9472..8899d1f1a2 100644
--- a/subprojects/gst-plugins-good/sys/v4l2/gstv4l2object.c
+++ b/subprojects/gst-plugins-good/sys/v4l2/gstv4l2object.c
@@ -3245,23 +3245,16 @@ gst_v4l2_object_set_stride (GstVideoInfo * info, GstVideoAlignment * align,
   const GstVideoFormatInfo *finfo = info->finfo;
 
   if (GST_VIDEO_FORMAT_INFO_IS_TILED (finfo)) {
-    gint x_tiles, y_tiles, ws, hs, tile_height, padded_height;
+    gint x_tiles, y_tiles, tile_height, padded_height;
 
-    ws = GST_VIDEO_FORMAT_INFO_TILE_WS (finfo);
-    hs = GST_VIDEO_FORMAT_INFO_TILE_HS (finfo);
-
-    /* this only works for what we support, NV12 subsampled tiles */
-    if (GST_VIDEO_FORMAT_INFO_HAS_SUBTILES (finfo) && plane == 1)
-      hs -= 1;
-
-    tile_height = 1 << hs;
+    tile_height = GST_VIDEO_FORMAT_INFO_TILE_HEIGHT (finfo, plane);
 
     padded_height = GST_VIDEO_FORMAT_INFO_SCALE_HEIGHT (finfo, plane,
         info->height + align->padding_top + align->padding_bottom);
-    padded_height = GST_ROUND_UP_N (padded_height, tile_height);
+    padded_height = (padded_height + tile_height - 1) / tile_height;
 
-    x_tiles = stride >> ws;
-    y_tiles = padded_height >> hs;
+    x_tiles = stride / GST_VIDEO_FORMAT_INFO_TILE_STRIDE (finfo, plane);
+    y_tiles = padded_height / tile_height;
     info->stride[plane] = GST_VIDEO_TILE_MAKE_STRIDE (x_tiles, y_tiles);
   } else {
     info->stride[plane] = stride;
@@ -3348,12 +3341,9 @@ gst_v4l2_object_save_format (GstV4l2Object * v4l2object,
   padded_height = format->fmt.pix.height;
 
   if (GST_VIDEO_FORMAT_INFO_IS_TILED (finfo)) {
-    guint hs, tile_height;
-
-    hs = GST_VIDEO_FORMAT_INFO_TILE_HS (finfo);
-    tile_height = 1 << hs;
-
-    padded_height = GST_ROUND_UP_N (padded_height, tile_height);
+    guint tile_height;
+    tile_height = GST_VIDEO_FORMAT_INFO_TILE_HEIGHT (finfo, 0);
+    padded_height = (padded_height + tile_height - 1) / tile_height;
   }
 
   align->padding_bottom =
@@ -3764,8 +3754,8 @@ gst_v4l2_object_set_format_full (GstV4l2Object * v4l2object, GstCaps * caps,
       gint stride = GST_VIDEO_INFO_PLANE_STRIDE (&info, i);
 
       if (GST_VIDEO_FORMAT_INFO_IS_TILED (info.finfo))
-        stride = GST_VIDEO_TILE_X_TILES (stride) <<
-            GST_VIDEO_FORMAT_INFO_TILE_WS (info.finfo);
+        stride = GST_VIDEO_TILE_X_TILES (stride) *
+            GST_VIDEO_FORMAT_INFO_TILE_STRIDE (info.finfo, i);
 
       format.fmt.pix_mp.plane_fmt[i].bytesperline = stride;
     }
@@ -3783,8 +3773,8 @@ gst_v4l2_object_set_format_full (GstV4l2Object * v4l2object, GstCaps * caps,
     format.fmt.pix.field = field;
 
     if (GST_VIDEO_FORMAT_INFO_IS_TILED (info.finfo))
-      stride = GST_VIDEO_TILE_X_TILES (stride) <<
-          GST_VIDEO_FORMAT_INFO_TILE_WS (info.finfo);
+      stride = GST_VIDEO_TILE_X_TILES (stride) *
+          GST_VIDEO_FORMAT_INFO_TILE_STRIDE (info.finfo, i);
 
     /* try to ask our preferred stride */
     format.fmt.pix.bytesperline = stride;
@@ -4804,8 +4794,8 @@ gst_v4l2_object_match_buffer_layout (GstV4l2Object * obj, guint n_planes,
         gint plane_stride = stride[i];
 
         if (GST_VIDEO_FORMAT_INFO_IS_TILED (obj->info.finfo))
-          plane_stride = GST_VIDEO_TILE_X_TILES (plane_stride) <<
-              GST_VIDEO_FORMAT_INFO_TILE_WS (obj->info.finfo);
+          plane_stride = GST_VIDEO_TILE_X_TILES (plane_stride) *
+              GST_VIDEO_FORMAT_INFO_TILE_STRIDE (obj->info.finfo, i);
 
         format.fmt.pix_mp.plane_fmt[i].bytesperline = plane_stride;
         format.fmt.pix_mp.height = padded_height;
@@ -4818,8 +4808,8 @@ gst_v4l2_object_match_buffer_layout (GstV4l2Object * obj, guint n_planes,
       GST_DEBUG_OBJECT (obj->dbg_obj, "Wanted stride: %i", plane_stride);
 
       if (GST_VIDEO_FORMAT_INFO_IS_TILED (obj->info.finfo))
-        plane_stride = GST_VIDEO_TILE_X_TILES (plane_stride) <<
-            GST_VIDEO_FORMAT_INFO_TILE_WS (obj->info.finfo);
+        plane_stride = GST_VIDEO_TILE_X_TILES (plane_stride) *
+            GST_VIDEO_FORMAT_INFO_TILE_STRIDE (obj->info.finfo, 0);
 
       format.fmt.pix.bytesperline = plane_stride;
       format.fmt.pix.height = padded_height;
diff --git a/subprojects/gst-plugins-good/sys/v4l2/gstv4l2videodec.c b/subprojects/gst-plugins-good/sys/v4l2/gstv4l2videodec.c
index 9f6fa7bbee..2a110e5e4a 100644
--- a/subprojects/gst-plugins-good/sys/v4l2/gstv4l2videodec.c
+++ b/subprojects/gst-plugins-good/sys/v4l2/gstv4l2videodec.c
@@ -675,11 +675,9 @@ gst_v4l2_video_dec_loop (GstVideoDecoder * decoder)
   GstVideoCodecFrame *frame;
   GstBuffer *buffer = NULL;
   GstFlowReturn ret;
-  gint capture_configuration_change;
 
   GST_VIDEO_DECODER_STREAM_LOCK (decoder);
-  if ((capture_configuration_change =
-          g_atomic_int_get (&self->capture_configuration_change))) {
+  if (g_atomic_int_get (&self->capture_configuration_change)) {
     gst_v4l2_object_stop (self->v4l2capture);
     ret = gst_v4l2_video_dec_setup_capture (decoder);
     if (ret != GST_FLOW_OK) {
@@ -761,36 +759,38 @@ gst_v4l2_video_dec_loop (GstVideoDecoder * decoder)
     while ((oldest_frame = gst_video_decoder_get_oldest_frame (decoder)) &&
         check_system_frame_number_too_old (frame->system_frame_number,
             oldest_frame->system_frame_number)) {
-      gst_video_decoder_drop_frame (decoder, oldest_frame);
-      oldest_frame = NULL;
-
-      if (!warned) {
-        g_warning ("%s: Too old frames, bug in decoder -- please file a bug",
-            GST_ELEMENT_NAME (decoder));
-        warned = TRUE;
-      }
-    }
-
-    /* If the initial frame triggered a Caps renegotiation, but with no actual change in 
-     * resolution, already-correctly-decoded frames may incorrectly be dropped by the driver.
-     * This has been observed to occur in at least one driver.  These frames will never dequeue.
-     * As a workaround, drop all pending frames older than the current frame now. */
-    if (capture_configuration_change && oldest_frame
-        && oldest_frame->system_frame_number == 0
-        && frame->system_frame_number) {
-      gint counter = 0;
-      while (oldest_frame) {
-        counter++;
+      if (oldest_frame->system_frame_number > 0) {
         gst_video_decoder_drop_frame (decoder, oldest_frame);
-        oldest_frame = gst_video_decoder_get_oldest_frame (decoder);
-        if (oldest_frame->system_frame_number == frame->system_frame_number) {
-          gst_video_codec_frame_unref (oldest_frame);
-          oldest_frame = NULL;
+        oldest_frame = NULL;
+
+        if (!warned) {
+          g_warning ("%s: Too old frames, bug in decoder -- please file a bug",
+              GST_ELEMENT_NAME (decoder));
+          warned = TRUE;
+        }
+      } else {
+        /* special treatment when oldest_frame->system_frame_number = 0:
+         * if a consecutive sequence 0, 1, 2,..., n < frame->system_frame_number
+         * is pending, drop them all at this time. (This has been seen to occur
+         * as a driver bug when the initial frame triggered a Caps re-negotiation,
+         * and the driver dropped these frames) */
+        guint32 counter = 0;
+        while (oldest_frame) {
+          gst_video_decoder_drop_frame (decoder, oldest_frame);
+          counter++;
+          oldest_frame = gst_video_decoder_get_oldest_frame (decoder);
+          if (oldest_frame &&
+              (oldest_frame->system_frame_number > counter ||
+                  oldest_frame->system_frame_number >=
+                  frame->system_frame_number)) {
+            gst_video_codec_frame_unref (oldest_frame);
+            oldest_frame = NULL;
+          }
         }
+        g_warning
+            ("%s: %i initial frames were not dequeued: bug in decoder -- please file a bug",
+            GST_ELEMENT_NAME (decoder), counter);
       }
-      g_warning
-          ("%s: %i initial frames before frame %u were not dequeued: bug in decoder -- please file a bug",
-          GST_ELEMENT_NAME (decoder), counter, frame->system_frame_number);
     }
     if (oldest_frame)
       gst_video_codec_frame_unref (oldest_frame);
diff --git a/subprojects/gst-plugins-good/tests/check/elements/dash_mpd.c b/subprojects/gst-plugins-good/tests/check/elements/dash_mpd.c
index d45ee7dedc..bda2787df9 100644
--- a/subprojects/gst-plugins-good/tests/check/elements/dash_mpd.c
+++ b/subprojects/gst-plugins-good/tests/check/elements/dash_mpd.c
@@ -4108,6 +4108,57 @@ GST_START_TEST (dash_mpdparser_get_baseURL8)
 
 GST_END_TEST;
 
+/*
+ * Test getting baseURL with query
+ *
+ */
+GST_START_TEST (dash_mpdparser_get_baseURL_with_query)
+{
+  gboolean ret;
+  gchar *uri;
+  gint64 range_start, range_end;
+  const gchar *xml =
+      "<?xml version=\"1.0\"?>"
+      "<MPD xmlns=\"urn:mpeg:dash:schema:mpd:2011\""
+      "     profiles=\"urn:mpeg:dash:profile:isoff-main:2011\">"
+      "  <Period id=\"Period0\" duration=\"P0Y0M1DT1H1M1S\">"
+      "    <AdaptationSet id=\"1\" mimeType=\"audio\" lang=\"en\">"
+      "      <Representation id=\"1\" bandwidth=\"250000\">"
+      "        <BaseURL>http://example.com/test?param1=value1&amp;param2=value2</BaseURL>"
+      "        <SegmentBase indexRange=\"100-200\" indexRangeExact=\"true\">"
+      "          <Initialization range=\"0-100\" />"
+      "        </SegmentBase>"
+      "      </Representation></AdaptationSet></Period></MPD>";
+
+  GstMPDClient2 *mpdclient = setup_mpd_client (xml);
+
+  /* get segment url and range from segment Initialization */
+  ret =
+      gst_mpd_client2_get_next_header (mpdclient, &uri, 0, &range_start,
+      &range_end);
+  assert_equals_int (ret, TRUE);
+  assert_equals_string (uri,
+      "http://example.com/test?param1=value1&param2=value2");
+  assert_equals_int64 (range_start, 0);
+  assert_equals_int64 (range_end, 100);
+  g_free (uri);
+
+  /* get segment url and range from segment indexRange */
+  ret =
+      gst_mpd_client2_get_next_header_index (mpdclient, &uri, 0, &range_start,
+      &range_end);
+  assert_equals_int (ret, TRUE);
+  assert_equals_string (uri,
+      "http://example.com/test?param1=value1&param2=value2");
+  assert_equals_int64 (range_start, 100);
+  assert_equals_int64 (range_end, 200);
+  g_free (uri);
+
+  gst_mpd_client2_free (mpdclient);
+}
+
+GST_END_TEST;
+
 /*
  * Test getting mediaPresentationDuration
  *
@@ -6425,6 +6476,7 @@ dash_suite (void)
   tcase_add_test (tc_complexMPD, dash_mpdparser_get_baseURL6);
   tcase_add_test (tc_complexMPD, dash_mpdparser_get_baseURL7);
   tcase_add_test (tc_complexMPD, dash_mpdparser_get_baseURL8);
+  tcase_add_test (tc_complexMPD, dash_mpdparser_get_baseURL_with_query);
   tcase_add_test (tc_complexMPD, dash_mpdparser_get_mediaPresentationDuration);
   tcase_add_test (tc_complexMPD, dash_mpdparser_get_streamPresentationOffset);
   tcase_add_test (tc_complexMPD, dash_mpdparser_segments);
diff --git a/subprojects/gst-plugins-good/tests/check/elements/rtpjitterbuffer.c b/subprojects/gst-plugins-good/tests/check/elements/rtpjitterbuffer.c
index 1712399939..2ae1904b8e 100644
--- a/subprojects/gst-plugins-good/tests/check/elements/rtpjitterbuffer.c
+++ b/subprojects/gst-plugins-good/tests/check/elements/rtpjitterbuffer.c
@@ -2697,6 +2697,48 @@ GST_START_TEST (test_deadline_ts_offset)
 
 GST_END_TEST;
 
+GST_START_TEST (test_deadline_ts_offset_overflow)
+{
+  GstHarness *h = gst_harness_new ("rtpjitterbuffer");
+  GstTestClock *testclock;
+  GstClockID id;
+  const gint jb_latency_ms = 10;
+
+  gst_harness_set_src_caps (h, generate_caps ());
+  testclock = gst_harness_get_testclock (h);
+
+  g_object_set (h->element, "latency", jb_latency_ms, NULL);
+
+  /* push the first buffer in */
+  fail_unless_equals_int (GST_FLOW_OK,
+      gst_harness_push (h, generate_test_buffer (0)));
+
+  /* wait_next_timeout() syncs on the deadline timer */
+  gst_test_clock_wait_for_next_pending_id (testclock, &id);
+  fail_unless_equals_uint64 (jb_latency_ms * GST_MSECOND,
+      gst_clock_id_get_time (id));
+  gst_clock_id_unref (id);
+
+  /* add ts-offset while waiting, this reschedules the deadline to a negative time */
+  g_object_set (h->element, "ts-offset", -20 * GST_MSECOND, NULL);
+
+  /* wait_next_timeout() syncs on the new deadline timer, which is scheduled
+   * to the jitterbuffer latency due to being in the past */
+  gst_test_clock_wait_for_next_pending_id (testclock, &id);
+  fail_unless_equals_uint64 (jb_latency_ms * GST_MSECOND,
+      gst_clock_id_get_time (id));
+  gst_clock_id_unref (id);
+
+  gst_test_clock_set_time_and_process (testclock, jb_latency_ms * GST_MSECOND);
+
+  gst_buffer_unref (gst_harness_pull (h));
+
+  gst_object_unref (testclock);
+  gst_harness_teardown (h);
+}
+
+GST_END_TEST;
+
 GST_START_TEST (test_big_gap_seqnum)
 {
   GstHarness *h = gst_harness_new ("rtpjitterbuffer");
@@ -3515,6 +3557,7 @@ rtpjitterbuffer_suite (void)
   tcase_add_test (tc_chain, test_dont_drop_packet_based_on_skew);
 
   tcase_add_test (tc_chain, test_deadline_ts_offset);
+  tcase_add_test (tc_chain, test_deadline_ts_offset_overflow);
   tcase_add_test (tc_chain, test_big_gap_seqnum);
   tcase_add_test (tc_chain, test_big_gap_arrival_time);
   tcase_add_test (tc_chain, test_fill_queue);
diff --git a/subprojects/gst-plugins-good/tests/examples/rtsp/test-onvif.c b/subprojects/gst-plugins-good/tests/examples/rtsp/test-onvif.c
index 2f47445e4b..ddaaeee52d 100644
--- a/subprojects/gst-plugins-good/tests/examples/rtsp/test-onvif.c
+++ b/subprojects/gst-plugins-good/tests/examples/rtsp/test-onvif.c
@@ -14,15 +14,21 @@ new_sample (GstElement * appsink, GstElement * rtspsrc)
 
   g_assert (stream_id != -1);
 
+  /* get the sample from appsink */
   g_signal_emit_by_name (appsink, "pull-sample", &sample);
 
   if (!sample)
-    goto out;
+    goto nosample;
 
-  g_signal_emit_by_name (rtspsrc, "push-backchannel-buffer", stream_id, sample,
+  g_signal_emit_by_name (rtspsrc, "push-backchannel-sample", stream_id, sample,
       &ret);
 
-out:
+  /* Action signal callbacks don't take ownership of the arguments passed, so we must unref the sample here.
+   * (The "push-backchannel-buffer" callback unrefs the sample, which is wrong and doesn't work with bindings
+   * but could not be changed, hence the new "push-backchannel-sample" callback that behaves correctly.)  */
+  gst_sample_unref (sample);
+
+nosample:
   return ret;
 }
 
