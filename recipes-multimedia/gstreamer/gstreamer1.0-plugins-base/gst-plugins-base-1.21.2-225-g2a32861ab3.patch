diff --git a/subprojects/gst-plugins-base/docs/plugins/gst_plugins_cache.json b/subprojects/gst-plugins-base/docs/plugins/gst_plugins_cache.json
index 0609ebc994..c3d8b03ad1 100644
--- a/subprojects/gst-plugins-base/docs/plugins/gst_plugins_cache.json
+++ b/subprojects/gst-plugins-base/docs/plugins/gst_plugins_cache.json
@@ -10364,6 +10364,18 @@
                         "type": "gboolean",
                         "writable": true
                     },
+                    "instant-uri": {
+                        "blurb": "When enabled, URI changes are applied immediately",
+                        "conditionally-available": false,
+                        "construct": false,
+                        "construct-only": false,
+                        "controllable": false,
+                        "default": "false",
+                        "mutable": "null",
+                        "readable": true,
+                        "type": "gboolean",
+                        "writable": true
+                    },
                     "mute": {
                         "blurb": "Mute the audio channel without changing the volume",
                         "conditionally-available": false,
@@ -11415,6 +11427,18 @@
                         "type": "gboolean",
                         "writable": true
                     },
+                    "instant-uri": {
+                        "blurb": "When enabled, URI changes are applied immediately",
+                        "conditionally-available": false,
+                        "construct": false,
+                        "construct-only": false,
+                        "controllable": false,
+                        "default": "false",
+                        "mutable": "null",
+                        "readable": true,
+                        "type": "gboolean",
+                        "writable": true
+                    },
                     "ring-buffer-max-size": {
                         "blurb": "Max. amount of data in the ring buffer (bytes, 0 = ring buffer disabled)",
                         "conditionally-available": false,
@@ -11594,7 +11618,7 @@
                         "construct": false,
                         "construct-only": false,
                         "controllable": false,
-                        "default": "0.99",
+                        "default": "0.6",
                         "max": "1",
                         "min": "0",
                         "mutable": "null",
@@ -11616,6 +11640,18 @@
                         "type": "gdouble",
                         "writable": true
                     },
+                    "parse-streams": {
+                        "blurb": "Extract the elementary streams of non-raw sources",
+                        "conditionally-available": false,
+                        "construct": false,
+                        "construct-only": false,
+                        "controllable": false,
+                        "default": "false",
+                        "mutable": "null",
+                        "readable": true,
+                        "type": "gboolean",
+                        "writable": true
+                    },
                     "ring-buffer-max-size": {
                         "blurb": "Max. amount of data in the ring buffer (bytes, 0 = ring buffer disabled)",
                         "conditionally-available": false,
@@ -13699,7 +13735,7 @@
         "elements": {
             "videoconvert": {
                 "author": "Wim Taymans <wim.taymans@gmail.com>",
-                "description": "Resizes video and allow color conversion",
+                "description": "Converts video from one colorspace to another",
                 "hierarchy": [
                     "GstVideoConvert",
                     "GstVideoConvertScale",
@@ -13728,7 +13764,7 @@
             },
             "videoconvertscale": {
                 "author": "Wim Taymans <wim.taymans@gmail.com>",
-                "description": "Converts video from one colorspace to another",
+                "description": "Resizes video and converts from one colorspace to another",
                 "hierarchy": [
                     "GstVideoConvertScale",
                     "GstVideoFilter",
diff --git a/subprojects/gst-plugins-base/ext/ogg/gstoggdemux.c b/subprojects/gst-plugins-base/ext/ogg/gstoggdemux.c
index 649f63d593..d088d645ee 100644
--- a/subprojects/gst-plugins-base/ext/ogg/gstoggdemux.c
+++ b/subprojects/gst-plugins-base/ext/ogg/gstoggdemux.c
@@ -2524,6 +2524,7 @@ gst_ogg_demux_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
           GST_DEBUG_OBJECT (ogg, "Error seeking back after duration check: %d",
               res);
         }
+        gst_event_unref (event);
         res = TRUE;
         break;
       } else {
@@ -2538,6 +2539,8 @@ gst_ogg_demux_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
       }
       if (!drop)
         res = gst_ogg_demux_send_event (ogg, event);
+      else
+        gst_event_unref (event);
       if (ogg->current_chain == NULL) {
         GST_WARNING_OBJECT (ogg,
             "EOS while trying to retrieve chain, seeking disabled");
diff --git a/subprojects/gst-plugins-base/gst-libs/gst/audio/gstaudioaggregator.c b/subprojects/gst-plugins-base/gst-libs/gst/audio/gstaudioaggregator.c
index a811c4789d..784c047cf3 100644
--- a/subprojects/gst-plugins-base/gst-libs/gst/audio/gstaudioaggregator.c
+++ b/subprojects/gst-plugins-base/gst-libs/gst/audio/gstaudioaggregator.c
@@ -537,6 +537,7 @@ static GstSample *gst_audio_aggregator_peek_next_sample (GstAggregator * agg,
 #define DEFAULT_DISCONT_WAIT (1 * GST_SECOND)
 #define DEFAULT_OUTPUT_BUFFER_DURATION_N (1)
 #define DEFAULT_OUTPUT_BUFFER_DURATION_D (100)
+#define DEFAULT_FORCE_LIVE FALSE
 
 enum
 {
@@ -546,6 +547,7 @@ enum
   PROP_DISCONT_WAIT,
   PROP_OUTPUT_BUFFER_DURATION_FRACTION,
   PROP_IGNORE_INACTIVE_PADS,
+  PROP_FORCE_LIVE,
 };
 
 G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE (GstAudioAggregator, gst_audio_aggregator,
@@ -728,6 +730,23 @@ gst_audio_aggregator_class_init (GstAudioAggregatorClass * klass)
           "Ignore inactive pads",
           "Avoid timing out waiting for inactive pads", FALSE,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstAudioAggregator:force-live:
+   *
+   * Causes the element to aggregate on a timeout even when no live source is
+   * connected to its sinks. See #GstAggregator:min-upstream-latency for a
+   * companion property: in the vast majority of cases where you plan to plug in
+   * live sources with a non-zero latency, you should set it to a non-zero value.
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class, PROP_FORCE_LIVE,
+      g_param_spec_boolean ("force-live", "Force live",
+          "Always operate in live mode and aggregate on timeout regardless of "
+          "whether any live sources are linked upstream",
+          DEFAULT_FORCE_LIVE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT_ONLY));
 }
 
 static void
@@ -797,6 +816,10 @@ gst_audio_aggregator_set_property (GObject * object, guint prop_id,
       gst_aggregator_set_ignore_inactive_pads (GST_AGGREGATOR (object),
           g_value_get_boolean (value));
       break;
+    case PROP_FORCE_LIVE:
+      gst_aggregator_set_force_live (GST_AGGREGATOR (object),
+          g_value_get_boolean (value));
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -829,6 +852,10 @@ gst_audio_aggregator_get_property (GObject * object, guint prop_id,
       g_value_set_boolean (value,
           gst_aggregator_get_ignore_inactive_pads (GST_AGGREGATOR (object)));
       break;
+    case PROP_FORCE_LIVE:
+      g_value_set_boolean (value,
+          gst_aggregator_get_force_live (GST_AGGREGATOR (object)));
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -2195,7 +2222,7 @@ gst_audio_aggregator_aggregate (GstAggregator * agg, gboolean timeout)
   gint64 next_timestamp;
   gint rate, bpf;
   gboolean dropped = FALSE;
-  gboolean is_eos = TRUE;
+  gboolean is_eos = !gst_aggregator_get_force_live (agg);
   gboolean is_done = TRUE;
   guint blocksize;
   GstAudioAggregatorPad *srcpad = GST_AUDIO_AGGREGATOR_PAD (agg->srcpad);
diff --git a/subprojects/gst-plugins-base/gst-libs/gst/gl/egl/gsteglimage.c b/subprojects/gst-plugins-base/gst-libs/gst/gl/egl/gsteglimage.c
index f97d85b7d6..179abe9762 100644
--- a/subprojects/gst-plugins-base/gst-libs/gst/gl/egl/gsteglimage.c
+++ b/subprojects/gst-plugins-base/gst-libs/gst/gl/egl/gsteglimage.c
@@ -615,14 +615,12 @@ get_egl_stride (const GstVideoInfo * info, gint plane)
 {
   const GstVideoFormatInfo *finfo = info->finfo;
   gint stride = info->stride[plane];
-  guint ws;
 
   if (!GST_VIDEO_FORMAT_INFO_IS_TILED (finfo))
     return stride;
 
-  gst_video_format_info_get_tile_sizes (finfo, plane, &ws, NULL);
-
-  return GST_VIDEO_TILE_X_TILES (stride) << ws;
+  return GST_VIDEO_TILE_X_TILES (stride) *
+      GST_VIDEO_FORMAT_INFO_TILE_STRIDE (finfo, plane);
 }
 
 /**
diff --git a/subprojects/gst-plugins-base/gst-libs/gst/gl/gstglcolorconvert.c b/subprojects/gst-plugins-base/gst-libs/gst/gl/gstglcolorconvert.c
index f3656cf403..6ccfb143ad 100644
--- a/subprojects/gst-plugins-base/gst-libs/gst/gl/gstglcolorconvert.c
+++ b/subprojects/gst-plugins-base/gst-libs/gst/gl/gstglcolorconvert.c
@@ -2691,15 +2691,16 @@ _init_convert (GstGLColorConvert * convert)
   }
 
   if (GST_VIDEO_FORMAT_INFO_IS_TILED (convert->in_info.finfo)) {
-    guint ws, hs;
+    guint tile_width, tile_height;
     gsize stride;
     gfloat width, height;
 
     stride = GST_VIDEO_INFO_PLANE_STRIDE (&convert->in_info, 0);
-    gst_video_format_info_get_tile_sizes (convert->in_info.finfo, 0, &ws, &hs);
+    tile_width = GST_VIDEO_FORMAT_INFO_TILE_WIDTH (convert->in_info.finfo, 0);
+    tile_height = GST_VIDEO_FORMAT_INFO_TILE_HEIGHT (convert->in_info.finfo, 0);
 
-    width = GST_VIDEO_TILE_X_TILES (stride) << ws;
-    height = GST_VIDEO_TILE_Y_TILES (stride) << hs;
+    width = GST_VIDEO_TILE_X_TILES (stride) * tile_width;
+    height = GST_VIDEO_TILE_Y_TILES (stride) * tile_height;
 
     gst_gl_shader_set_uniform_1f (convert->shader, "width", width);
     gst_gl_shader_set_uniform_1f (convert->shader, "height", height);
@@ -3055,6 +3056,18 @@ _do_convert (GstGLContext * context, GstGLColorConvert * convert)
       gst_gl_color_convert_reset_shader (convert);
   }
 
+  if (GST_VIDEO_FORMAT_INFO_IS_TILED (convert->in_info.finfo)) {
+    GstVideoMeta *vmeta = gst_buffer_get_video_meta (convert->inbuf);
+    gsize stride;
+
+    stride = GST_VIDEO_INFO_PLANE_STRIDE (&convert->in_info, 0);
+
+    if (vmeta && vmeta->stride[0] != stride) {
+      GST_VIDEO_INFO_PLANE_STRIDE (&convert->in_info, 0) = vmeta->stride[0];
+      gst_gl_color_convert_reset_shader (convert);
+    }
+  }
+
   if (!_init_convert (convert)) {
     convert->priv->result = FALSE;
     return;
diff --git a/subprojects/gst-plugins-base/gst-libs/gst/gl/gstglmemory.c b/subprojects/gst-plugins-base/gst-libs/gst/gl/gstglmemory.c
index 118f07eff2..7658ea1f32 100644
--- a/subprojects/gst-plugins-base/gst-libs/gst/gl/gstglmemory.c
+++ b/subprojects/gst-plugins-base/gst-libs/gst/gl/gstglmemory.c
@@ -123,13 +123,13 @@ static inline guint
 _get_plane_height (const GstVideoInfo * info, guint plane)
 {
   if (GST_VIDEO_FORMAT_INFO_IS_TILED (info->finfo)) {
-    guint hs;
+    guint tile_height;
     gsize stride;
 
-    gst_video_format_info_get_tile_sizes (info->finfo, plane, NULL, &hs);
+    tile_height = GST_VIDEO_FORMAT_INFO_TILE_HEIGHT (info->finfo, plane);
     stride = GST_VIDEO_INFO_PLANE_STRIDE (info, plane);
 
-    return GST_VIDEO_TILE_Y_TILES (stride) << hs;
+    return GST_VIDEO_TILE_Y_TILES (stride) * tile_height;
   }
 
   if (GST_VIDEO_INFO_IS_YUV (info)) {
@@ -151,8 +151,8 @@ _get_mem_stride (GstGLMemory * gl_mem)
   if (!GST_VIDEO_FORMAT_INFO_IS_TILED (finfo))
     return stride;
 
-  return
-      GST_VIDEO_TILE_X_TILES (stride) << GST_VIDEO_FORMAT_INFO_TILE_WS (finfo);
+  return GST_VIDEO_TILE_X_TILES (stride) *
+      GST_VIDEO_FORMAT_INFO_TILE_STRIDE (finfo, gl_mem->plane);
 }
 
 static inline void
diff --git a/subprojects/gst-plugins-base/gst-libs/gst/gl/gstglupload.c b/subprojects/gst-plugins-base/gst-libs/gst/gl/gstglupload.c
index eaae86e919..5d17ec1dfc 100644
--- a/subprojects/gst-plugins-base/gst-libs/gst/gl/gstglupload.c
+++ b/subprojects/gst-plugins-base/gst-libs/gst/gl/gstglupload.c
@@ -676,6 +676,21 @@ _dma_buf_upload_accept (gpointer impl, GstBuffer * buffer, GstCaps * in_caps,
     dmabuf->out_caps = out_caps;
     if (!gst_video_info_from_caps (out_info, out_caps))
       return FALSE;
+
+    /*
+     * When we zero-copy tiles, we need to propagate the strides, which contains
+     * the tile dimension. This is because the shader needs to know the padded
+     * size in order to correctly sample into these special buffer.
+     */
+    if (meta && GST_VIDEO_FORMAT_INFO_IS_TILED (out_info->finfo)) {
+      out_info->width = meta->width;
+      out_info->height = meta->height;
+
+      for (i = 0; i < meta->n_planes; i++) {
+        out_info->offset[i] = meta->offset[i];
+        out_info->stride[i] = meta->stride[i];
+      }
+    }
   }
 
   if (dmabuf->params)
diff --git a/subprojects/gst-plugins-base/gst-libs/gst/gl/gstglutils.c b/subprojects/gst-plugins-base/gst-libs/gst/gl/gstglutils.c
index 570d0e1076..e1bec0fe13 100644
--- a/subprojects/gst-plugins-base/gst-libs/gst/gl/gstglutils.c
+++ b/subprojects/gst-plugins-base/gst-libs/gst/gl/gstglutils.c
@@ -633,11 +633,10 @@ gst_gl_get_plane_data_size (const GstVideoInfo * info,
     gint x_tiles, y_tiles;
     gint tile_size;
 
-    tile_size = gst_video_format_info_get_tile_sizes (finfo, plane, NULL, NULL);
-
     stride = GST_VIDEO_INFO_PLANE_STRIDE (info, plane);
     x_tiles = GST_VIDEO_TILE_X_TILES (stride);
     y_tiles = GST_VIDEO_TILE_Y_TILES (stride);
+    tile_size = GST_VIDEO_FORMAT_INFO_TILE_SIZE (info->finfo, plane);
 
     plane_size = x_tiles * y_tiles * tile_size;
   } else {
diff --git a/subprojects/gst-plugins-base/gst-libs/gst/pbutils/codec-utils.c b/subprojects/gst-plugins-base/gst-libs/gst/pbutils/codec-utils.c
index 0167210f32..a89f3b051e 100644
--- a/subprojects/gst-plugins-base/gst-libs/gst/pbutils/codec-utils.c
+++ b/subprojects/gst-plugins-base/gst-libs/gst/pbutils/codec-utils.c
@@ -2520,7 +2520,10 @@ vp9_caps_get_mime_codec (GstCaps * caps)
     GstVideoChromaSite chroma_site;
 
     chroma_site_str = gst_structure_get_string (caps_st, "chroma-site");
-    chroma_site = gst_video_chroma_site_from_string (chroma_site_str);
+    if (chroma_site_str)
+      chroma_site = gst_video_chroma_site_from_string (chroma_site_str);
+    else
+      chroma_site = GST_VIDEO_CHROMA_SITE_UNKNOWN;
     if (chroma_site == GST_VIDEO_CHROMA_SITE_V_COSITED) {
       chroma_format = 0;
     } else if (chroma_site == GST_VIDEO_CHROMA_SITE_COSITED) {
diff --git a/subprojects/gst-plugins-base/gst-libs/gst/pbutils/encoding-profile.c b/subprojects/gst-plugins-base/gst-libs/gst/pbutils/encoding-profile.c
index 11bbbf3f6d..390f9e171b 100644
--- a/subprojects/gst-plugins-base/gst-libs/gst/pbutils/encoding-profile.c
+++ b/subprojects/gst-plugins-base/gst-libs/gst/pbutils/encoding-profile.c
@@ -1826,9 +1826,9 @@ create_encoding_stream_profile (gchar * serialized_profile,
   GstCaps *caps;
   guint presence = 0;
   gboolean single_segment = FALSE;
-  gchar *strcaps, *strpresence, **strprops_v, **restriction_format,
-      **preset_v, *preset_name = NULL, *factory_name = NULL,
-      *variable_framerate = NULL;
+  gchar *strcaps = NULL, *strpresence, **strprops_v =
+      NULL, **restriction_format, **preset_v = NULL, *preset_name =
+      NULL, *factory_name = NULL, *variable_framerate = NULL;
   GstStructure *element_properties = NULL;
   GstCaps *restrictioncaps = NULL;
   GstEncodingProfile *profile = NULL;
@@ -1885,8 +1885,8 @@ create_encoding_stream_profile (gchar * serialized_profile,
       if (propv[1] && propv[2]) {
         g_warning ("Wrong format for property: %s, only 1 `=` is expected",
             prop);
-
-        return NULL;
+        g_strfreev (propv);
+        goto cleanup;
       }
 
       if (!propv[1]) {
@@ -1902,15 +1902,16 @@ create_encoding_stream_profile (gchar * serialized_profile,
         if (!gst_value_deserialize (&v, propv[1])) {
           g_warning ("Invalid value for property 'single-segment': %s",
               propv[1]);
-
-          return NULL;
+          g_strfreev (propv);
+          goto cleanup;
         }
 
         single_segment = g_value_get_boolean (&v);
         g_value_reset (&v);
       } else {
         g_warning ("Unsupported property: %s", propv[0]);
-        return NULL;
+        g_strfreev (propv);
+        goto cleanup;
       }
 
       if (presence_str) {
@@ -1918,9 +1919,11 @@ create_encoding_stream_profile (gchar * serialized_profile,
 
         if (endptr == strprops_v[1]) {
           g_warning ("Wrong presence %s", presence_str);
-          return NULL;
+          g_strfreev (propv);
+          goto cleanup;
         }
       }
+      g_strfreev (propv);
     }
   } else {                      /* We have no presence */
     if (preset_v[1]) {          /* Not presence but preset */
@@ -1929,8 +1932,6 @@ create_encoding_stream_profile (gchar * serialized_profile,
       strcaps = g_strdup (preset_v[0]);
     }                           /* Else we have no presence nor preset */
   }
-  g_strfreev (strprops_v);
-  g_strfreev (preset_v);
 
   GST_DEBUG ("Creating preset with restrictions: %" GST_PTR_FORMAT
       ", caps: %s, preset %s, presence %d", restrictioncaps, strcaps,
@@ -1958,11 +1959,6 @@ create_encoding_stream_profile (gchar * serialized_profile,
       gst_caps_unref (caps);
     }
   }
-  g_free (preset_name);
-  g_free (strcaps);
-
-  if (restrictioncaps)
-    gst_caps_unref (restrictioncaps);
 
   if (variable_framerate) {
     if (GST_IS_ENCODING_VIDEO_PROFILE (profile)) {
@@ -1983,19 +1979,26 @@ create_encoding_stream_profile (gchar * serialized_profile,
       GST_WARNING
           ("Variable framerate specified on a non video encoding profile");
     }
-
-    g_free (variable_framerate);
   }
 
   if (profile == NULL) {
     GST_ERROR ("No way to create a profile for description: %s",
         serialized_profile);
-
-    return NULL;
+  } else if (element_properties) {
+    gst_encoding_profile_set_element_properties (profile,
+        g_steal_pointer (&element_properties));
   }
 
+cleanup:
+  g_free (strcaps);
+  g_free (variable_framerate);
+  g_strfreev (strprops_v);
+  g_strfreev (preset_v);
+  g_free (preset_name);
   if (element_properties)
-    gst_encoding_profile_set_element_properties (profile, element_properties);
+    gst_structure_free (element_properties);
+  if (restrictioncaps)
+    gst_caps_unref (restrictioncaps);
 
   return profile;
 }
diff --git a/subprojects/gst-plugins-base/gst-libs/gst/rtp/gstrtpbasedepayload.c b/subprojects/gst-plugins-base/gst-libs/gst/rtp/gstrtpbasedepayload.c
index 1520581b4e..0fd2d827a5 100644
--- a/subprojects/gst-plugins-base/gst-libs/gst/rtp/gstrtpbasedepayload.c
+++ b/subprojects/gst-plugins-base/gst-libs/gst/rtp/gstrtpbasedepayload.c
@@ -36,6 +36,9 @@
 GST_DEBUG_CATEGORY_STATIC (rtpbasedepayload_debug);
 #define GST_CAT_DEFAULT (rtpbasedepayload_debug)
 
+static GstStaticCaps ntp_reference_timestamp_caps =
+GST_STATIC_CAPS ("timestamp/x-ntp");
+
 struct _GstRTPBaseDepayloadPrivate
 {
   GstClockTime npt_start;
@@ -50,6 +53,8 @@ struct _GstRTPBaseDepayloadPrivate
   GstClockTime dts;
   GstClockTime duration;
 
+  GstClockTime ref_ts;
+
   guint32 last_ssrc;
   guint32 last_seqnum;
   guint32 last_rtptime;
@@ -395,6 +400,7 @@ gst_rtp_base_depayload_init (GstRTPBaseDepayload * filter,
   priv->dts = -1;
   priv->pts = -1;
   priv->duration = -1;
+  priv->ref_ts = -1;
   priv->source_info = DEFAULT_SOURCE_INFO;
   priv->max_reorder = DEFAULT_MAX_REORDER;
   priv->auto_hdr_ext = DEFAULT_AUTO_HEADER_EXTENSION;
@@ -679,6 +685,8 @@ gst_rtp_base_depayload_handle_buffer (GstRTPBaseDepayload * filter,
   gboolean discont, buf_discont;
   gint gap;
   GstRTPBuffer rtp = { NULL };
+  GstReferenceTimestampMeta *meta;
+  GstCaps *ref_caps;
 
   priv = filter->priv;
   priv->process_flow_ret = GST_FLOW_OK;
@@ -690,6 +698,21 @@ gst_rtp_base_depayload_handle_buffer (GstRTPBaseDepayload * filter,
   if (G_UNLIKELY (!priv->negotiated))
     goto not_negotiated;
 
+  /* Check for duplicate reference timestamp metadata */
+  ref_caps = gst_static_caps_get (&ntp_reference_timestamp_caps);
+  meta = gst_buffer_get_reference_timestamp_meta (in, ref_caps);
+  gst_caps_unref (ref_caps);
+  if (meta) {
+    guint64 ref_ts = meta->timestamp;
+    if (ref_ts == priv->ref_ts) {
+      /* Drop the redundant/duplicate reference timstamp metadata */
+      in = gst_buffer_make_writable (in);
+      gst_buffer_remove_meta (in, GST_META_CAST (meta));
+    } else {
+      priv->ref_ts = ref_ts;
+    }
+  }
+
   if (G_UNLIKELY (!gst_rtp_buffer_map (in, GST_MAP_READ, &rtp)))
     goto invalid_buffer;
 
@@ -923,6 +946,7 @@ gst_rtp_base_depayload_handle_event (GstRTPBaseDepayload * filter,
 
       filter->need_newsegment = !filter->priv->onvif_mode;
       filter->priv->next_seqnum = -1;
+      filter->priv->ref_ts = -1;
       gst_event_replace (&filter->priv->segment_event, NULL);
       break;
     case GST_EVENT_CAPS:
@@ -1542,6 +1566,7 @@ gst_rtp_base_depayload_change_state (GstElement * element,
       priv->play_speed = 1.0;
       priv->play_scale = 1.0;
       priv->clock_base = -1;
+      priv->ref_ts = -1;
       priv->onvif_mode = FALSE;
       priv->next_seqnum = -1;
       priv->negotiated = FALSE;
diff --git a/subprojects/gst-plugins-base/gst-libs/gst/video/gstvideoaggregator.c b/subprojects/gst-plugins-base/gst-libs/gst/video/gstvideoaggregator.c
index 31e9d700e6..ffbf69d401 100644
--- a/subprojects/gst-plugins-base/gst-libs/gst/video/gstvideoaggregator.c
+++ b/subprojects/gst-plugins-base/gst-libs/gst/video/gstvideoaggregator.c
@@ -955,7 +955,13 @@ static void
         g_thread_self());                                      \
   } G_STMT_END
 
+enum
+{
+  PROP_0,
+  PROP_FORCE_LIVE,
+};
 
+#define DEFAULT_FORCE_LIVE              FALSE
 
 /* Can't use the G_DEFINE_TYPE macros because we need the
  * videoaggregator class in the _init to be able to set
@@ -1717,7 +1723,7 @@ gst_video_aggregator_fill_queues (GstVideoAggregator * vagg,
     GstClockTime output_end_running_time, gboolean timeout)
 {
   GList *l;
-  gboolean eos = TRUE;
+  gboolean eos = !gst_aggregator_get_force_live (GST_AGGREGATOR (vagg));
   gboolean repeat_pad_eos = FALSE;
   gboolean has_no_repeat_pads = FALSE;
   gboolean need_more_data = FALSE;
@@ -3002,6 +3008,10 @@ gst_video_aggregator_get_property (GObject * object,
     guint prop_id, GValue * value, GParamSpec * pspec)
 {
   switch (prop_id) {
+    case PROP_FORCE_LIVE:
+      g_value_set_boolean (value,
+          gst_aggregator_get_force_live (GST_AGGREGATOR (object)));
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -3013,6 +3023,10 @@ gst_video_aggregator_set_property (GObject * object,
     guint prop_id, const GValue * value, GParamSpec * pspec)
 {
   switch (prop_id) {
+    case PROP_FORCE_LIVE:
+      gst_aggregator_set_force_live (GST_AGGREGATOR (object),
+          g_value_get_boolean (value));
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -3070,6 +3084,23 @@ gst_video_aggregator_class_init (GstVideoAggregatorClass * klass)
 
   /* Register the pad class */
   g_type_class_ref (GST_TYPE_VIDEO_AGGREGATOR_PAD);
+
+  /**
+   * GstVideoAggregator:force-live:
+   *
+   * Causes the element to aggregate on a timeout even when no live source is
+   * connected to its sinks. See #GstAggregator:min-upstream-latency for a
+   * companion property: in the vast majority of cases where you plan to plug in
+   * live sources with a non-zero latency, you should set it to a non-zero value.
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class, PROP_FORCE_LIVE,
+      g_param_spec_boolean ("force-live", "Force live",
+          "Always operate in live mode and aggregate on timeout regardless of "
+          "whether any live sources are linked upstream",
+          DEFAULT_FORCE_LIVE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT_ONLY));
 }
 
 static void
diff --git a/subprojects/gst-plugins-base/gst-libs/gst/video/gstvideodecoder.c b/subprojects/gst-plugins-base/gst-libs/gst/video/gstvideodecoder.c
index f1ce52fd1f..016aa7dd9f 100644
--- a/subprojects/gst-plugins-base/gst-libs/gst/video/gstvideodecoder.c
+++ b/subprojects/gst-plugins-base/gst-libs/gst/video/gstvideodecoder.c
@@ -3270,6 +3270,9 @@ gst_video_decoder_drop_frame (GstVideoDecoder * dec, GstVideoCodecFrame * frame)
   /* now free the frame */
   gst_video_decoder_release_frame (dec, frame);
 
+  /* store that we have valid decoded data */
+  dec->priv->had_output_data = TRUE;
+
   GST_VIDEO_DECODER_STREAM_UNLOCK (dec);
 
   return GST_FLOW_OK;
diff --git a/subprojects/gst-plugins-base/gst-libs/gst/video/video-format.c b/subprojects/gst-plugins-base/gst-libs/gst/video/video-format.c
index 4e4ff8796b..d869f9a1ff 100644
--- a/subprojects/gst-plugins-base/gst-libs/gst/video/video-format.c
+++ b/subprojects/gst-plugins-base/gst-libs/gst/video/video-format.c
@@ -4747,46 +4747,33 @@ pack_A422_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 }
 
 static void
-get_tile_NV12 (gint tile_width, gint ts, gint tx, gint ty,
-    GstVideoTileMode mode,
+get_tile_NV12 (const GstVideoFormatInfo * info, gint tx, gint ty,
     const gpointer data[GST_VIDEO_MAX_PLANES],
     const gint stride[GST_VIDEO_MAX_PLANES],
     gpointer tile_data[GST_VIDEO_MAX_PLANES],
     gint tile_stride[GST_VIDEO_MAX_PLANES])
 {
-  gsize offset;
+  GstVideoTileMode mode = GST_VIDEO_FORMAT_INFO_TILE_MODE (info);
+  gsize index, offset;
 
   /* index of Y tile */
-  offset = gst_video_tile_get_index (mode,
-      tx, ty, GST_VIDEO_TILE_X_TILES (stride[0]),
-      GST_VIDEO_TILE_Y_TILES (stride[0]));
-  offset <<= ts;
+  index = gst_video_tile_get_index (mode, tx, ty,
+      GST_VIDEO_TILE_X_TILES (stride[0]), GST_VIDEO_TILE_Y_TILES (stride[0]));
+  offset = index * GST_VIDEO_FORMAT_INFO_TILE_SIZE (info, 0);
   tile_data[0] = ((guint8 *) data[0]) + offset;
 
-  /* index of UV tile */
-  if (stride[0] != stride[1]) {
-    offset = gst_video_tile_get_index (mode,
-        tx, ty >> 1, GST_VIDEO_TILE_X_TILES (stride[1]),
-        GST_VIDEO_TILE_Y_TILES (stride[1]));
-
-    offset <<= ts;
+  index = gst_video_tile_get_index (mode, tx,
+      GST_VIDEO_FORMAT_INFO_HAS_SUBTILES (info) ? ty : ty / 2,
+      GST_VIDEO_TILE_X_TILES (stride[1]), GST_VIDEO_TILE_Y_TILES (stride[1]));
+  offset = index * GST_VIDEO_FORMAT_INFO_TILE_SIZE (info, 1);
 
-    /* On odd rows we return the second part of the UV tile */
-    offset |= (ty & 1) << (ts - 1);
-  } else {
-    /* handle subsampled tiles, with type of tiles will have the same number
-     * of tiles on both planes, but the height of the tiles are half. */
-    offset = gst_video_tile_get_index (mode,
-        tx, ty, GST_VIDEO_TILE_X_TILES (stride[1]),
-        GST_VIDEO_TILE_Y_TILES (stride[1]));
-
-    /* For subsampled tile Subsampled tile size */
-    offset <<= (ts - 1);
-  }
+  if (!GST_VIDEO_FORMAT_INFO_HAS_SUBTILES (info) && (ty & 1))
+    offset += GST_VIDEO_FORMAT_INFO_TILE_SIZE (info, 1) / 2;
 
   tile_data[1] = ((guint8 *) data[1]) + offset;
 
-  tile_stride[0] = tile_stride[1] = tile_width;
+  tile_stride[0] = GST_VIDEO_FORMAT_INFO_TILE_STRIDE (info, 0);
+  tile_stride[1] = GST_VIDEO_FORMAT_INFO_TILE_STRIDE (info, 1);
 }
 
 #define PACK_NV12_TILED GST_VIDEO_FORMAT_AYUV, unpack_NV12_TILED, 1, pack_NV12_TILED
@@ -4795,49 +4782,46 @@ unpack_NV12_TILED (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 {
-  const GstVideoFormatInfo *unpack_info, *finfo;
+  const GstVideoFormatInfo *unpack_info, *tile_finfo;
   guint8 *line = dest;
-  gint ws, hs, ts, tile_width;
+  gint tile_width, tile_height;
   gint ntx, tx, ty;
   gint unpack_pstride;
 
-  ws = GST_VIDEO_FORMAT_INFO_TILE_WS (info);
-  hs = GST_VIDEO_FORMAT_INFO_TILE_HS (info);
-  ts = ws + hs;
-
-  tile_width = 1 << ws;
+  tile_width = GST_VIDEO_FORMAT_INFO_TILE_WIDTH (info, 0);
+  tile_height = GST_VIDEO_FORMAT_INFO_TILE_HEIGHT (info, 0);
 
   /* we reuse these unpack functions */
-  finfo = gst_video_format_get_info (GST_VIDEO_FORMAT_NV12);
+  tile_finfo = gst_video_format_get_info (GST_VIDEO_FORMAT_NV12);
 
   /* get pstride of unpacked format */
   unpack_info = gst_video_format_get_info (info->unpack_format);
   unpack_pstride = GST_VIDEO_FORMAT_INFO_PSTRIDE (unpack_info, 0);
 
   /* first x tile to convert */
-  tx = x >> ws;
+  tx = x / tile_width;
   /* Last tile to convert */
-  ntx = ((x + width - 1) >> ws) + 1;
+  ntx = ((x + width - 1) / tile_width) + 1;
   /* The row we are going to convert */
-  ty = y >> hs;
+  ty = y / tile_height;
 
   /* y position in a tile */
-  y = y & ((1 << hs) - 1);
+  y = y % tile_height;
   /* x position in a tile */
-  x = x & (tile_width - 1);
+  x = x % tile_width;
 
   for (; tx < ntx; tx++) {
     gpointer tdata[GST_VIDEO_MAX_PLANES];
     gint tstride[GST_VIDEO_MAX_PLANES];
     gint unpack_width;
 
-    get_tile_NV12 (tile_width, ts, tx, ty, info->tile_mode,
-        data, stride, tdata, tstride);
+    get_tile_NV12 (info, tx, ty, data, stride, tdata, tstride);
 
     /* the number of bytes left to unpack */
     unpack_width = MIN (width - x, tile_width - x);
 
-    finfo->unpack_func (finfo, flags, line, tdata, tstride, x, y, unpack_width);
+    tile_finfo->unpack_func (tile_finfo, flags, line, tdata, tstride, x, y,
+        unpack_width);
 
     x = 0;
     width -= unpack_width;
@@ -4851,45 +4835,41 @@ pack_NV12_TILED (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
     gint y, gint width)
 {
-  const GstVideoFormatInfo *pack_info, *finfo;
+  const GstVideoFormatInfo *pack_info, *tile_finfo;
   guint8 *line = src;
-  gint ws, hs, ts, tile_width;
+  gint tile_width, tile_height;
   gint ntx, tx, ty;
   gint pack_pstride;
 
-  ws = GST_VIDEO_FORMAT_INFO_TILE_WS (info);
-  hs = GST_VIDEO_FORMAT_INFO_TILE_HS (info);
-  ts = ws + hs;
-
-  tile_width = 1 << ws;
+  tile_width = GST_VIDEO_FORMAT_INFO_TILE_WIDTH (info, 0);
+  tile_height = GST_VIDEO_FORMAT_INFO_TILE_HEIGHT (info, 0);
 
   /* we reuse these pack functions */
-  finfo = gst_video_format_get_info (GST_VIDEO_FORMAT_NV12);
+  tile_finfo = gst_video_format_get_info (GST_VIDEO_FORMAT_NV12);
 
   /* get pstride of packed format */
   pack_info = gst_video_format_get_info (info->unpack_format);
   pack_pstride = GST_VIDEO_FORMAT_INFO_PSTRIDE (pack_info, 0);
 
   /* Last tile to convert */
-  ntx = ((width - 1) >> ws) + 1;
+  ntx = ((width - 1) / tile_width) + 1;
   /* The row we are going to convert */
-  ty = y >> hs;
+  ty = y / tile_height;
 
   /* y position in a tile */
-  y = y & ((1 << hs) - 1);
+  y = y % tile_height;
 
   for (tx = 0; tx < ntx; tx++) {
     gpointer tdata[GST_VIDEO_MAX_PLANES];
     gint tstride[GST_VIDEO_MAX_PLANES];
     gint pack_width;
 
-    get_tile_NV12 (tile_width, ts, tx, ty, info->tile_mode,
-        data, stride, tdata, tstride);
+    get_tile_NV12 (info, tx, ty, data, stride, tdata, tstride);
 
-    /* the number of bytes left to pack */
+    /* the number of pixels left to pack */
     pack_width = MIN (width, tile_width);
 
-    finfo->pack_func (finfo, flags, line, sstride, tdata, tstride,
+    tile_finfo->pack_func (tile_finfo, flags, line, sstride, tdata, tstride,
         chroma_site, y, pack_width);
 
     width -= pack_width;
@@ -6820,8 +6800,8 @@ unpack_NV12_10BE_8L128 (const GstVideoFormatInfo * info,
   int i;
   int j;
 
-  ws = GST_VIDEO_FORMAT_INFO_TILE_WS (info);
-  hs = GST_VIDEO_FORMAT_INFO_TILE_HS (info);
+  ws = 3;
+  hs = 7;
   ts = ws + hs;
   ty = y >> hs;
   y = y & ((1 << hs) - 1);
@@ -6874,8 +6854,8 @@ pack_NV12_10BE_8L128 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
   guint16 mask[2];
   int i;
 
-  ws = GST_VIDEO_FORMAT_INFO_TILE_WS (info);
-  hs = GST_VIDEO_FORMAT_INFO_TILE_HS (info);
+  ws = 3;
+  hs = 7;
   ts = ws + hs;
   ty = y >> hs;
   y = y & ((1 << hs) - 1);
@@ -6999,12 +6979,13 @@ typedef struct
 #define SUB4204           { 0, 1, 1, 0 }, { 0, 1, 1, 0 }
 #define SUB4224           { 0, 1, 1, 0 }, { 0, 0, 0, 0 }
 
-/* tile_mode, tile_ws (width shift), tile_hs (height shift) */
-#define TILE_4x4(mode) GST_VIDEO_TILE_MODE_ ##mode, 2, 2
-#define TILE_16x32(mode) GST_VIDEO_TILE_MODE_ ##mode, 4, 5
-#define TILE_32x32(mode) GST_VIDEO_TILE_MODE_ ##mode, 5, 5
-#define TILE_64x32(mode) GST_VIDEO_TILE_MODE_ ##mode, 6, 5
-#define TILE_8x128(mode) GST_VIDEO_TILE_MODE_ ##mode, 3, 7
+/* tile_mode, tile_ws (width shift), tile_hs (height shift), tile_info[] */
+#define TILE_4x4(mode) GST_VIDEO_TILE_MODE_ ##mode, 2, 2, { {4, 4, 4, 16}, {4, 4, 4, 16}, }
+#define TILE_16x32s(mode) GST_VIDEO_TILE_MODE_ ##mode, 4, 5, { {16, 32, 16, 512}, {16, 16, 16, 256}, }
+#define TILE_32x32(mode) GST_VIDEO_TILE_MODE_ ##mode, 5, 5, { {32, 32, 32, 1024}, {32, 32, 32, 1024}, }
+#define TILE_64x32(mode) GST_VIDEO_TILE_MODE_ ##mode, 6, 5, { {64, 32, 64, 2048}, {64, 32, 64, 2048}, }
+#define TILE_8x128(mode) GST_VIDEO_TILE_MODE_ ##mode, 3, 7, { {8, 128, 8, 1024}, {8, 128, 8, 1024}, }
+#define TILE_10bit_8x128(mode) GST_VIDEO_TILE_MODE_ ##mode, 3, 7, { {0, 128, 8, 1024}, {0, 128, 8, 1024}, }
 
 #define MAKE_YUV_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack ) \
  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV, depth, pstride, plane, offs, sub, pack } }
@@ -7049,6 +7030,7 @@ typedef struct
 #define MAKE_GRAY_C_LE_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_GRAY | GST_VIDEO_FORMAT_FLAG_COMPLEX | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
 
+G_GNUC_BEGIN_IGNORE_DEPRECATIONS;
 static const VideoFormat formats[] = {
   {0x00000000, {GST_VIDEO_FORMAT_UNKNOWN, "UNKNOWN", "unknown video", 0, DPTH0,
           PSTR0, PLANE_NA, OFFS0}},
@@ -7304,15 +7286,17 @@ static const VideoFormat formats[] = {
       OFFS6420, SUB4444, PACK_ABGR64_BE),
   MAKE_YUV_ST_FORMAT (NV12_16L32S, "raw video",
       GST_MAKE_FOURCC ('M', 'M', '2', '1'), DPTH888, PSTR122, PLANE011,
-      OFFS001, SUB420, PACK_NV12_TILED, TILE_16x32 (LINEAR)),
+      OFFS001, SUB420, PACK_NV12_TILED, TILE_16x32s (LINEAR)),
   MAKE_YUV_T_FORMAT (NV12_8L128, "raw video",
       GST_MAKE_FOURCC ('N', 'A', '1', '2'), DPTH888, PSTR122, PLANE011,
       OFFS001, SUB420, PACK_NV12_TILED, TILE_8x128 (LINEAR)),
   MAKE_YUV_T_FORMAT (NV12_10BE_8L128, "raw video",
-      GST_MAKE_FOURCC ('N', 'T', '1', '2'), DPTH10_10_10, PSTR122, PLANE011,
-      OFFS001, SUB420, PACK_NV12_10BE_8L128, TILE_8x128 (LINEAR)),
+      GST_MAKE_FOURCC ('N', 'T', '1', '2'), DPTH10_10_10, PSTR0, PLANE011,
+      OFFS001, SUB420, PACK_NV12_10BE_8L128, TILE_10bit_8x128 (LINEAR)),
 };
 
+G_GNUC_END_IGNORE_DEPRECATIONS;
+
 static GstVideoFormat
 gst_video_format_from_rgb32_masks (int red_mask, int green_mask, int blue_mask)
 {
@@ -7898,62 +7882,3 @@ gst_video_make_raw_caps_with_features (const GstVideoFormat formats[],
 
   return caps;
 }
-
-static void
-scale_tile_shifts (const GstVideoFormatInfo * finfo, gint plane, guint * ws,
-    guint * hs)
-{
-  gint comp[GST_VIDEO_MAX_COMPONENTS];
-  gint i;
-
-  gst_video_format_info_component (finfo, plane, comp);
-
-  /* scale the tile size according to the subsampling */
-  *ws -= finfo->w_sub[comp[0]];
-  *hs -= finfo->h_sub[comp[0]];
-
-  /* for each additional component in the same plane, double the tile width,
-   * this should provide the appropriate tile size when the tile size varies
-   * base on the subsampling. */
-  for (i = 1; i < GST_VIDEO_MAX_COMPONENTS && comp[i] >= 0; i++)
-    *ws += 1;
-}
-
-/**
- * gst_video_format_info_get_tile_sizes:
- * @finfo: #GstVideoFormatInfo
- * @plane: The plane to read the tile sizes for.
- * @out_ws: (nullable): Set to the scaled tile width shift
- * @out_hs: (nullable): Set to the scaled tile height shift
- *
- * This function will read the width and height tile dimension shifts from
- * @info and scale it according to the tiling type and @plane. The results
- * will written into @out_hs and @out_ws. It also computes the size of a tile
- * in bytes.
- *
- * Returns: The size of a tile in bytes.
- *
- * Since: 1.22
- */
-guint
-gst_video_format_info_get_tile_sizes (const GstVideoFormatInfo * finfo,
-    guint plane, guint * out_ws, guint * out_hs)
-{
-  guint ws, hs;
-
-  g_return_val_if_fail (GST_VIDEO_FORMAT_INFO_IS_TILED (finfo), 0);
-
-  ws = GST_VIDEO_FORMAT_INFO_TILE_WS (finfo);
-  hs = GST_VIDEO_FORMAT_INFO_TILE_HS (finfo);
-
-  if (GST_VIDEO_FORMAT_INFO_HAS_SUBTILES (finfo))
-    scale_tile_shifts (finfo, plane, &ws, &hs);
-
-  if (out_ws)
-    *out_ws = ws;
-
-  if (out_hs)
-    *out_hs = hs;
-
-  return 1 << (ws + hs);
-}
diff --git a/subprojects/gst-plugins-base/gst-libs/gst/video/video-format.h b/subprojects/gst-plugins-base/gst-libs/gst/video/video-format.h
index da78552340..11388d0038 100644
--- a/subprojects/gst-plugins-base/gst-libs/gst/video/video-format.h
+++ b/subprojects/gst-plugins-base/gst-libs/gst/video/video-format.h
@@ -596,8 +596,11 @@ typedef void (*GstVideoFormatPack)           (const GstVideoFormatInfo *info,
  * @pack_lines: the amount of lines that will be packed
  * @pack_func: an pack function for this format
  * @tile_mode: The tiling mode
- * @tile_ws: The width of a tile, in bytes, represented as a shift
- * @tile_hs: The height of a tile, in bytes, represented as a shift
+ * @tile_ws: The width of a tile, in bytes, represented as a shift. DEPRECATED,
+ * use tile_info[] array instead.
+ * @tile_hs: The height of a tile, in bytes, represented as a shift. DEPREACTED,
+ * use tile_info[] array instead.
+ * @tile_info: Per-plane tile information
  *
  * Information for a video format.
  */
@@ -623,11 +626,17 @@ struct _GstVideoFormatInfo {
   GstVideoFormatPack pack_func;
 
   GstVideoTileMode tile_mode;
-  guint tile_ws;
-  guint tile_hs;
+  G_DEPRECATED_FOR(tile_info) guint tile_ws;
+  G_DEPRECATED_FOR(tile_info) guint tile_hs;
 
-  /*< private >*/
-  gpointer _gst_reserved[GST_PADDING];
+  /**
+   * GstVideoFormatInfo.tile_info:
+   *
+   * Information about the tiles for each of the planes.
+   *
+   * Since: 1.22
+   */
+  GstVideoTileInfo tile_info[GST_VIDEO_MAX_PLANES];
 };
 
 #define GST_VIDEO_FORMAT_INFO_FORMAT(info)       ((info)->format)
@@ -728,6 +737,60 @@ struct _GstVideoFormatInfo {
 #define GST_VIDEO_FORMAT_INFO_TILE_WS(info) ((info)->tile_ws)
 #define GST_VIDEO_FORMAT_INFO_TILE_HS(info) ((info)->tile_hs)
 
+/**
+ * GST_VIDEO_FORMAT_INFO_TILE_SIZE:
+ * @info: a #GstVideoFormatInfo
+ * @plane: the plane index
+ *
+ * Provides the size in bytes of a tile in the specified @plane. This replaces
+ * the width and height shift, which was limited to power of two dimensions.
+ *
+ * Since: 1.22
+ */
+#define GST_VIDEO_FORMAT_INFO_TILE_SIZE(info,plane) ((info)->tile_info[plane].size)
+
+/**
+ * GST_VIDEO_FORMAT_INFO_TILE_WIDTH:
+ * @info: a #GstVideoFormatInfo
+ * @plane: the plane index
+ *
+ * See #GstVideoTileInfo.width.
+ *
+ * Return the width of one tile in pixels, zero if its not an integer.
+ *
+ * Since: 1.22
+ */
+#define GST_VIDEO_FORMAT_INFO_TILE_WIDTH(info,plane) ((info)->tile_info[plane].width)
+
+/**
+ * GST_VIDEO_FORMAT_INFO_TILE_HEIGHT:
+ * @info: a #GstVideoFormatInfo
+ * @plane: the plane index
+ *
+ * See #GstVideoTileInfo.height.
+ *
+ * Returns the tile height.
+ *
+ * Since: 1.22
+ */
+#define GST_VIDEO_FORMAT_INFO_TILE_HEIGHT(info,plane) ((info)->tile_info[plane].height)
+
+/**
+ * GST_VIDEO_FORMAT_INFO_TILE_STRIDE:
+ * @info: a #GstVideoFormatInfo
+ * @plane: the plane index
+ *
+ * See #GstVideoTileInfo.stride.
+ *
+ * Returns the stride of one tile, regardless of the internal details of the
+ * tile (could be a complex system with subtile) the tiles size should alway
+ * match the tile width multiplied by the tile stride.
+ *
+ * Since: 1.22
+ */
+#define GST_VIDEO_FORMAT_INFO_TILE_STRIDE(info,plane) ((info)->tile_info[plane].stride)
+
+
 GST_VIDEO_API
 void gst_video_format_info_component                  (const GstVideoFormatInfo *info, guint plane, gint components[GST_VIDEO_MAX_COMPONENTS]);
 
@@ -861,12 +924,6 @@ GST_VIDEO_API
 GstCaps * gst_video_make_raw_caps_with_features (const GstVideoFormat formats[], guint len,
                                                  GstCapsFeatures * features);
 
-GST_VIDEO_API
-guint     gst_video_format_info_get_tile_sizes  (const GstVideoFormatInfo * finfo,
-                                                 guint plane,
-                                                 guint * out_ws, guint * out_hs);
-
-
 
 G_END_DECLS
 
diff --git a/subprojects/gst-plugins-base/gst-libs/gst/video/video-frame.c b/subprojects/gst-plugins-base/gst-libs/gst/video/video-frame.c
index 95adf3643f..bfb57e47e1 100644
--- a/subprojects/gst-plugins-base/gst-libs/gst/video/video-frame.c
+++ b/subprojects/gst-plugins-base/gst-libs/gst/video/video-frame.c
@@ -349,11 +349,10 @@ gst_video_frame_copy_plane (GstVideoFrame * dest, const GstVideoFrame * src,
   if (GST_VIDEO_FORMAT_INFO_IS_TILED (finfo)) {
     gint tile_size;
     gint sx_tiles, sy_tiles, dx_tiles, dy_tiles;
-    guint i, j, ws, hs, ts;
+    guint i, j;
     GstVideoTileMode mode;
 
-    tile_size = gst_video_format_info_get_tile_sizes (finfo, plane, &ws, &hs);
-    ts = ws + hs;
+    tile_size = GST_VIDEO_FORMAT_INFO_TILE_SIZE (finfo, plane);
 
     mode = GST_VIDEO_FORMAT_INFO_TILE_MODE (finfo);
 
@@ -364,8 +363,8 @@ gst_video_frame_copy_plane (GstVideoFrame * dest, const GstVideoFrame * src,
     dy_tiles = GST_VIDEO_TILE_Y_TILES (ds);
 
     /* this is the amount of tiles to copy */
-    w = ((w - 1) >> ws) + 1;
-    h = ((h - 1) >> hs) + 1;
+    w = MIN (sx_tiles, dx_tiles);
+    h = MIN (sy_tiles, dy_tiles);
 
     /* FIXME can possibly do better when no retiling is needed, it depends on
      * the stride and the tile_size */
@@ -376,7 +375,7 @@ gst_video_frame_copy_plane (GstVideoFrame * dest, const GstVideoFrame * src,
         si = gst_video_tile_get_index (mode, i, j, sx_tiles, sy_tiles);
         di = gst_video_tile_get_index (mode, i, j, dx_tiles, dy_tiles);
 
-        memcpy (dp + (di << ts), sp + (si << ts), tile_size);
+        memcpy (dp + (di * tile_size), sp + (si * tile_size), tile_size);
       }
     }
   } else {
diff --git a/subprojects/gst-plugins-base/gst-libs/gst/video/video-info.c b/subprojects/gst-plugins-base/gst-libs/gst/video/video-info.c
index e1fb452eba..d543e31267 100644
--- a/subprojects/gst-plugins-base/gst-libs/gst/video/video-info.c
+++ b/subprojects/gst-plugins-base/gst-libs/gst/video/video-info.c
@@ -1097,39 +1097,40 @@ fill_planes (GstVideoInfo * info, gsize plane_size[GST_VIDEO_MAX_PLANES])
     case GST_VIDEO_FORMAT_NV12_4L4:
     case GST_VIDEO_FORMAT_NV12_32L32:
     {
-      gint ws = GST_VIDEO_FORMAT_INFO_TILE_WS (info->finfo);
-      gint hs = GST_VIDEO_FORMAT_INFO_TILE_HS (info->finfo);
-      info->stride[0] =
-          GST_VIDEO_TILE_MAKE_STRIDE (GST_ROUND_UP_N (width, 1 << ws) >> ws,
-          GST_ROUND_UP_N (height, 1 << hs) >> hs);
-      info->stride[1] =
-          GST_VIDEO_TILE_MAKE_STRIDE (GST_ROUND_UP_N (width, 1 << ws) >> ws,
-          GST_ROUND_UP_N (height, 1 << (hs + 1)) >> (hs + 1));
-      info->offset[0] = 0;
-      info->offset[1] =
-          GST_ROUND_UP_N (width, 1 << ws) * GST_ROUND_UP_N (height, 1 << hs);
+      const gsize tile_size = GST_VIDEO_FORMAT_INFO_TILE_SIZE (info->finfo, 0);
+      gint tile_width = GST_VIDEO_FORMAT_INFO_TILE_WIDTH (info->finfo, 0);
+      gint tile_height = GST_VIDEO_FORMAT_INFO_TILE_HEIGHT (info->finfo, 0);
+      gint n_tile_x = GST_ROUND_UP_N (info->width, tile_width) / tile_width;
+      gint n_tile_y = GST_ROUND_UP_N (info->height, tile_height) / tile_height;
+
+      info->stride[0] = GST_VIDEO_TILE_MAKE_STRIDE (n_tile_x, n_tile_y);
+      info->stride[1] = GST_VIDEO_TILE_MAKE_STRIDE (n_tile_x,
+          GST_ROUND_UP_2 (n_tile_y) / 2);
+      info->offset[1] = n_tile_x * n_tile_y * tile_size;
       info->size = info->offset[1] +
-          GST_ROUND_UP_N (width, 1 << ws) *
-          (GST_ROUND_UP_N (height, 1 << (hs + 1)) / 2);
+          n_tile_x * GST_ROUND_UP_2 (n_tile_y) / 2 * tile_size;
       break;
     }
     case GST_VIDEO_FORMAT_NV12_16L32S:
     {
-      gint ws = GST_VIDEO_FORMAT_INFO_TILE_WS (info->finfo);
-      gint hs = GST_VIDEO_FORMAT_INFO_TILE_HS (info->finfo);
-      info->stride[0] =
-          GST_VIDEO_TILE_MAKE_STRIDE (GST_ROUND_UP_N (width, 1 << ws) >> ws,
-          GST_ROUND_UP_N (height, 1 << hs) >> hs);
+      const gsize y_tile_size =
+          GST_VIDEO_FORMAT_INFO_TILE_SIZE (info->finfo, 0);
+      const gsize uv_tile_size =
+          GST_VIDEO_FORMAT_INFO_TILE_SIZE (info->finfo, 0);
+      gint tile_width = GST_VIDEO_FORMAT_INFO_TILE_WIDTH (info->finfo, 0);
+      gint tile_height = GST_VIDEO_FORMAT_INFO_TILE_HEIGHT (info->finfo, 0);
+      gint n_tile_x = GST_ROUND_UP_N (info->width, tile_width) / tile_width;
+      gint n_tile_y = GST_ROUND_UP_N (info->height, tile_height) / tile_height;
+
+      info->stride[0] = GST_VIDEO_TILE_MAKE_STRIDE (n_tile_x, n_tile_y);
       /*
        * size of UV plane tiles is subsample, hence have the same number of
        * tiles in both directions.
        */
       info->stride[1] = info->stride[0];
       info->offset[0] = 0;
-      info->offset[1] =
-          GST_ROUND_UP_N (width, 1 << ws) * GST_ROUND_UP_N (height, 1 << hs);
-      info->size = info->offset[1] + GST_ROUND_UP_N (width, 1 << ws) *
-          GST_ROUND_UP_N (height, 1 << hs) / 2;
+      info->offset[1] = n_tile_x * n_tile_y * y_tile_size;
+      info->size = info->offset[1] + n_tile_x * n_tile_y * uv_tile_size;
       break;
     }
     case GST_VIDEO_FORMAT_A420_10LE:
@@ -1220,47 +1221,49 @@ fill_planes (GstVideoInfo * info, gsize plane_size[GST_VIDEO_MAX_PLANES])
       break;
     case GST_VIDEO_FORMAT_NV12_8L128:
     {
-      gint ws = GST_VIDEO_FORMAT_INFO_TILE_WS (info->finfo);
-      gint hs = GST_VIDEO_FORMAT_INFO_TILE_HS (info->finfo);
-      gint ALIGN_W = 1 << ws;
-      gint ALIGN_H = 1 << hs;
+      gint tile_size = GST_VIDEO_FORMAT_INFO_TILE_SIZE (info->finfo, 0);
+      gint tile_width = GST_VIDEO_FORMAT_INFO_TILE_WIDTH (info->finfo, 0);
+      gint tile_height = GST_VIDEO_FORMAT_INFO_TILE_HEIGHT (info->finfo, 0);
+      gint ALIGN_W = tile_width;
+      gint ALIGN_H = tile_height;
+      guint n_tile_x, y_n_tile_y, uv_n_tile_y;
 
       if (GST_VIDEO_INFO_IS_INTERLACED (info))
-        ALIGN_H = (ALIGN_H << 1);
-      info->stride[0] =
-          GST_VIDEO_TILE_MAKE_STRIDE (GST_ROUND_UP_N (width, ALIGN_W) >> ws,
-          GST_ROUND_UP_N (height, ALIGN_H) >> hs);
-      info->stride[1] =
-          GST_VIDEO_TILE_MAKE_STRIDE (GST_ROUND_UP_N (width, ALIGN_W) >> ws,
-          GST_ROUND_UP_N (height, ALIGN_H << 1) >> (hs + 1));
+        ALIGN_H *= 2;
+
+      n_tile_x = GST_ROUND_UP_N (width, ALIGN_W) / tile_width;
+      y_n_tile_y = GST_ROUND_UP_N (height, ALIGN_H) / tile_height;
+      uv_n_tile_y = GST_ROUND_UP_2 (y_n_tile_y) / 2;
+
+      info->stride[0] = GST_VIDEO_TILE_MAKE_STRIDE (n_tile_x, y_n_tile_y);
+      info->stride[1] = GST_VIDEO_TILE_MAKE_STRIDE (n_tile_x, uv_n_tile_y);
       info->offset[0] = 0;
-      info->offset[1] =
-          GST_ROUND_UP_N (width, ALIGN_W) * GST_ROUND_UP_N (height, ALIGN_H);
-      cr_h = GST_ROUND_UP_N (height, ALIGN_H << 1) / 2;
-      info->size = info->offset[1] + GST_ROUND_UP_N (width, ALIGN_W) * cr_h;
+      info->offset[1] = n_tile_x * y_n_tile_y * tile_size;
+      info->size = info->offset[1] + n_tile_x * uv_n_tile_y * tile_size;
       break;
     }
     case GST_VIDEO_FORMAT_NV12_10BE_8L128:
     {
-      gint ws = GST_VIDEO_FORMAT_INFO_TILE_WS (info->finfo);
-      gint hs = GST_VIDEO_FORMAT_INFO_TILE_HS (info->finfo);
-      gint ALIGN_W = 1 << ws;
-      gint ALIGN_H = 1 << hs;
+      gint tile_size = GST_VIDEO_FORMAT_INFO_TILE_SIZE (info->finfo, 0);
+      gint tile_stride = GST_VIDEO_FORMAT_INFO_TILE_STRIDE (info->finfo, 0);
+      gint tile_height = GST_VIDEO_FORMAT_INFO_TILE_HEIGHT (info->finfo, 0);
       gint stride = GST_ROUND_UP_8 (width * 10) >> 3;
+      gint ALIGN_W = tile_stride;
+      gint ALIGN_H = tile_height;
+      guint n_tile_x, y_n_tile_y, uv_n_tile_y;
 
       if (GST_VIDEO_INFO_IS_INTERLACED (info))
-        ALIGN_H = (ALIGN_H << 1);
-      info->stride[0] =
-          GST_VIDEO_TILE_MAKE_STRIDE (GST_ROUND_UP_N (stride, ALIGN_W) >> ws,
-          GST_ROUND_UP_N (height, ALIGN_H) >> hs);
-      info->stride[1] =
-          GST_VIDEO_TILE_MAKE_STRIDE (GST_ROUND_UP_N (stride, ALIGN_W) >> ws,
-          GST_ROUND_UP_N (height, ALIGN_H << 1) >> (hs + 1));
+        ALIGN_H *= 2;
+
+      n_tile_x = GST_ROUND_UP_N (stride, ALIGN_W) / tile_stride;
+      y_n_tile_y = GST_ROUND_UP_N (height, ALIGN_H) / tile_height;
+      uv_n_tile_y = GST_ROUND_UP_2 (y_n_tile_y) / 2;
+
+      info->stride[0] = GST_VIDEO_TILE_MAKE_STRIDE (n_tile_x, y_n_tile_y);
+      info->stride[1] = GST_VIDEO_TILE_MAKE_STRIDE (n_tile_x, uv_n_tile_y);
       info->offset[0] = 0;
-      info->offset[1] =
-          GST_ROUND_UP_N (stride, ALIGN_W) * GST_ROUND_UP_N (height, ALIGN_H);
-      cr_h = GST_ROUND_UP_N (height, ALIGN_H << 1) / 2;
-      info->size = info->offset[1] + GST_ROUND_UP_N (stride, ALIGN_W) * cr_h;
+      info->offset[1] = n_tile_x * y_n_tile_y * tile_size;
+      info->size = info->offset[1] + n_tile_x * uv_n_tile_y * tile_size;
       break;
     }
     case GST_VIDEO_FORMAT_ENCODED:
@@ -1275,15 +1278,22 @@ fill_planes (GstVideoInfo * info, gsize plane_size[GST_VIDEO_MAX_PLANES])
   if (plane_size) {
     for (i = 0; i < GST_VIDEO_MAX_PLANES; i++) {
       if (i < GST_VIDEO_INFO_N_PLANES (info)) {
-        gint comp[GST_VIDEO_MAX_COMPONENTS];
-        guint plane_height;
-
-        /* Convert plane index to component index */
-        gst_video_format_info_component (info->finfo, i, comp);
-        plane_height =
-            GST_VIDEO_FORMAT_INFO_SCALE_HEIGHT (info->finfo, comp[0],
-            GST_VIDEO_INFO_FIELD_HEIGHT (info));
-        plane_size[i] = plane_height * GST_VIDEO_INFO_PLANE_STRIDE (info, i);
+        if (GST_VIDEO_FORMAT_INFO_IS_TILED (info->finfo)) {
+          guint x_tiles = GST_VIDEO_TILE_X_TILES (info->stride[i]);
+          guint y_tiles = GST_VIDEO_TILE_Y_TILES (info->stride[i]);
+          plane_size[i] = x_tiles * y_tiles *
+              GST_VIDEO_FORMAT_INFO_TILE_SIZE (info->finfo, i);
+        } else {
+          gint comp[GST_VIDEO_MAX_COMPONENTS];
+          guint plane_height;
+
+          /* Convert plane index to component index */
+          gst_video_format_info_component (info->finfo, i, comp);
+          plane_height =
+              GST_VIDEO_FORMAT_INFO_SCALE_HEIGHT (info->finfo, comp[0],
+              GST_VIDEO_INFO_FIELD_HEIGHT (info));
+          plane_size[i] = plane_height * GST_VIDEO_INFO_PLANE_STRIDE (info, i);
+        }
       } else {
         plane_size[i] = 0;
       }
diff --git a/subprojects/gst-plugins-base/gst-libs/gst/video/video-tile.h b/subprojects/gst-plugins-base/gst-libs/gst/video/video-tile.h
index f1000e8dfa..0cdbaf8a62 100644
--- a/subprojects/gst-plugins-base/gst-libs/gst/video/video-tile.h
+++ b/subprojects/gst-plugins-base/gst-libs/gst/video/video-tile.h
@@ -105,6 +105,8 @@ typedef enum
  */
 #define GST_VIDEO_TILE_Y_TILES(stride) ((stride) >> GST_VIDEO_TILE_Y_TILES_SHIFT)
 
+typedef struct _GstVideoTileInfo GstVideoTileInfo;
+
 /**
  * GstVideoTileMode:
  * @GST_VIDEO_TILE_MODE_UNKNOWN: Unknown or unset tile mode
@@ -132,6 +134,63 @@ typedef enum
   GST_VIDEO_TILE_MODE_LINEAR = GST_VIDEO_TILE_MAKE_MODE (2, INDEXED),
 } GstVideoTileMode;
 
+
+/**
+ * GstVideoTileInfo:
+ *
+ * Description of a tile. This structure allow to describe arbitrary tile
+ * dimensions and sizes.
+ *
+ * Since: 1.22
+ */
+struct _GstVideoTileInfo
+{
+  /**
+   * GstVideoTileInfo.width:
+   *
+   * The width in pixels of a tile. This value can be zero if the number of
+   * pixels per line is not an integer value.
+   *
+   * Since: 1.22
+   */
+  guint width;
+
+  /**
+   * GstVideoTileInfo::height:
+   *
+   * The width in pixels of a tile. This value can be zero if the number of
+   * pixels per line is not an integer value.
+   *
+   * Since: 1.22
+   */
+  guint height;
+
+  /**
+   * GstVideoTileInfo.stride:
+   *
+   * The stride (in bytes) of a tile line. Regardless if the tile have sub-tiles
+   * this stride multiplied by the height should be equal to
+   * #GstVideoTileInfo.size. This value is used to translate into linear stride
+   * when older APIs are being used to expose this format.
+   *
+   * Since: 1.22
+   */
+  guint stride;
+
+  /**
+   * GstVideoTileInfo.size:
+   *
+   * The size in bytes of a tile. This value must be divisible by
+   * #GstVideoTileInfo.stride.
+   *
+   * Since: 1.22
+   */
+  guint size;
+
+  /* <private> */
+  guint32 padding[GST_PADDING];
+};
+
 GST_VIDEO_API
 guint           gst_video_tile_get_index                (GstVideoTileMode mode, gint x, gint y,
                                                          gint x_tiles, gint y_tiles);
diff --git a/subprojects/gst-plugins-base/gst/encoding/gstencodebasebin.c b/subprojects/gst-plugins-base/gst/encoding/gstencodebasebin.c
index e8b7af2c1f..85a4913e14 100644
--- a/subprojects/gst-plugins-base/gst/encoding/gstencodebasebin.c
+++ b/subprojects/gst-plugins-base/gst/encoding/gstencodebasebin.c
@@ -2220,6 +2220,7 @@ create_elements_and_pads (GstEncodeBaseBin * ebin)
       if (!pad)
         goto no_muxer_ghost_pad;
 
+      gst_object_unref (muxerpad);
       gst_element_add_pad (GST_ELEMENT (ebin), pad);
     }
 
diff --git a/subprojects/gst-plugins-base/gst/playback/gstdecodebin2.c b/subprojects/gst-plugins-base/gst/playback/gstdecodebin2.c
index 532824f4f1..7dcad5411a 100644
--- a/subprojects/gst-plugins-base/gst/playback/gstdecodebin2.c
+++ b/subprojects/gst-plugins-base/gst/playback/gstdecodebin2.c
@@ -5015,7 +5015,7 @@ source_pad_event_probe (GstPad * pad, GstPadProbeInfo * info,
   GstDecodePad *dpad = user_data;
   gboolean res = TRUE;
 
-  GST_LOG_OBJECT (pad, "%s dpad:%p", GST_EVENT_TYPE_NAME (event), dpad);
+  GST_LOG_OBJECT (pad, "event %s", GST_EVENT_TYPE_NAME (event));
 
   if (GST_EVENT_TYPE (event) == GST_EVENT_EOS) {
     GST_DEBUG_OBJECT (pad, "we received EOS");
@@ -5162,8 +5162,8 @@ gst_decode_pad_query (GstPad * pad, GstObject * parent, GstQuery * query)
 
     ret = FALSE;
     GST_DEBUG_OBJECT (dpad->dbin,
-        "calling autoplug-query for %s (element %s): %" GST_PTR_FORMAT,
-        GST_PAD_NAME (dpad), GST_ELEMENT_NAME (delem->element), query);
+        "calling autoplug-query for %" GST_PTR_FORMAT " (element %s): %"
+        GST_PTR_FORMAT, dpad, GST_ELEMENT_NAME (delem->element), query);
     g_signal_emit (G_OBJECT (dpad->dbin),
         gst_decode_bin_signals[SIGNAL_AUTOPLUG_QUERY], 0, dpad, delem->element,
         query, &ret);
diff --git a/subprojects/gst-plugins-base/gst/playback/gstdecodebin3-parse.c b/subprojects/gst-plugins-base/gst/playback/gstdecodebin3-parse.c
index 6675aae9d5..95b8e865e0 100644
--- a/subprojects/gst-plugins-base/gst/playback/gstdecodebin3-parse.c
+++ b/subprojects/gst-plugins-base/gst/playback/gstdecodebin3-parse.c
@@ -49,49 +49,36 @@ _custom_eos_quark_get (void)
   return g_quark;
 }
 
-/* Streams that come from demuxers (input/upstream) */
+/* Streams that come from parsebin or identity */
 /* FIXME : All this is hardcoded. Switch to tree of chains */
 struct _DecodebinInputStream
 {
   GstDecodebin3 *dbin;
-  GstStream *pending_stream;    /* Extra ref */
+
   GstStream *active_stream;
 
   DecodebinInput *input;
 
-  GstPad *srcpad;               /* From demuxer */
+  GstPad *srcpad;               /* From parsebin or identity */
 
   /* id of the pad event probe */
   gulong output_event_probe_id;
 
-  /* id of the buffer blocking probe on the input (demuxer src) pad */
-  gulong input_buffer_probe_id;
+  /* id of the buffer blocking probe on the parsebin srcpad pad */
+  gulong buffer_probe_id;
 
   /* Whether we saw an EOS on input. This should be treated accordingly
    * when the stream is no longer used */
   gboolean saw_eos;
 };
 
+static void unblock_pending_input (DecodebinInput * input,
+    gboolean unblock_other_inputs);
 static void parsebin_pad_added_cb (GstElement * demux, GstPad * pad,
     DecodebinInput * input);
 static void parsebin_pad_removed_cb (GstElement * demux, GstPad * pad,
     DecodebinInput * input);
 
-/* WITH SELECTION_LOCK TAKEN! */
-static gboolean
-pending_pads_are_eos (DecodebinInput * input)
-{
-  GList *tmp;
-
-  for (tmp = input->pending_pads; tmp; tmp = tmp->next) {
-    PendingPad *ppad = (PendingPad *) tmp->data;
-    if (ppad->saw_eos == FALSE)
-      return FALSE;
-  }
-
-  return TRUE;
-}
-
 /* WITH SELECTION_LOCK TAKEN! */
 static gboolean
 all_inputs_are_eos (GstDecodebin3 * dbin)
@@ -104,13 +91,6 @@ all_inputs_are_eos (GstDecodebin3 * dbin)
       return FALSE;
   }
 
-  /* Check pending pads */
-  if (!pending_pads_are_eos (dbin->main_input))
-    return FALSE;
-  for (tmp = dbin->other_inputs; tmp; tmp = tmp->next)
-    if (!pending_pads_are_eos ((DecodebinInput *) tmp->data))
-      return FALSE;
-
   GST_DEBUG_OBJECT (dbin, "All streams are EOS");
   return TRUE;
 }
@@ -139,7 +119,7 @@ check_all_streams_for_eos (GstDecodebin3 * dbin, GstEvent * event)
   }
 
   SELECTION_UNLOCK (dbin);
-  /*  */
+
   for (tmp = outputpads; tmp; tmp = tmp->next) {
     GstPad *peer = (GstPad *) tmp->data;
 
@@ -288,6 +268,15 @@ parse_chain_output_probe (GstPad * pad, GstPadProbeInfo * info,
         }
       }
         break;
+      case GST_EVENT_GAP:
+      {
+        /* If we are still waiting to be unblocked and we get a gap, unblock */
+        if (input->buffer_probe_id) {
+          GST_DEBUG_OBJECT (pad, "Got a gap event! Unblocking input(s) !");
+          unblock_pending_input (input->input, TRUE);
+        }
+        break;
+      }
       case GST_EVENT_CAPS:
       {
         GstCaps *caps = NULL;
@@ -366,19 +355,28 @@ parse_chain_output_probe (GstPad * pad, GstPadProbeInfo * info,
   return ret;
 }
 
-static DecodebinInputStream *
-create_input_stream (GstDecodebin3 * dbin, GstStream * stream, GstPad * pad,
+static GstPadProbeReturn
+parsebin_buffer_probe (GstPad * pad, GstPadProbeInfo * info,
     DecodebinInput * input)
+{
+  /* We have at least one buffer pending, unblock parsebin(s) */
+  GST_DEBUG_OBJECT (pad, "Got a buffer ! unblocking");
+  unblock_pending_input (input, TRUE);
+
+  return GST_PAD_PROBE_OK;
+}
+
+/* Call with selection lock */
+static DecodebinInputStream *
+create_input_stream (GstDecodebin3 * dbin, GstPad * pad, DecodebinInput * input)
 {
   DecodebinInputStream *res = g_new0 (DecodebinInputStream, 1);
 
-  GST_DEBUG_OBJECT (pad, "Creating input stream for stream %p %s (input:%p)",
-      stream, gst_stream_get_stream_id (stream), input);
+  GST_DEBUG_OBJECT (dbin, "Creating input stream for %" GST_PTR_FORMAT, pad);
 
   res->dbin = dbin;
   res->input = input;
-  res->pending_stream = gst_object_ref (stream);
-  res->srcpad = pad;
+  res->srcpad = gst_object_ref (pad);
 
   /* Put probe on output source pad (for detecting EOS/STREAM_START/FLUSH) */
   res->output_event_probe_id =
@@ -387,10 +385,14 @@ create_input_stream (GstDecodebin3 * dbin, GstStream * stream, GstPad * pad,
       | GST_PAD_PROBE_TYPE_EVENT_FLUSH,
       (GstPadProbeCallback) parse_chain_output_probe, res, NULL);
 
+  /* Install a blocking buffer probe */
+  res->buffer_probe_id =
+      gst_pad_add_probe (pad,
+      GST_PAD_PROBE_TYPE_BLOCK | GST_PAD_PROBE_TYPE_BUFFER,
+      (GstPadProbeCallback) parsebin_buffer_probe, input, NULL);
+
   /* Add to list of current input streams */
-  SELECTION_LOCK (dbin);
   dbin->input_streams = g_list_append (dbin->input_streams, res);
-  SELECTION_UNLOCK (dbin);
   GST_DEBUG_OBJECT (pad, "Done creating input stream");
 
   return res;
@@ -406,6 +408,8 @@ remove_input_stream (GstDecodebin3 * dbin, DecodebinInputStream * stream)
       stream->active_stream ? gst_stream_get_stream_id (stream->active_stream) :
       "<NONE>");
 
+  gst_object_replace ((GstObject **) & stream->active_stream, NULL);
+
   /* Unlink from slot */
   if (stream->srcpad) {
     GstPad *peer;
@@ -414,6 +418,9 @@ remove_input_stream (GstDecodebin3 * dbin, DecodebinInputStream * stream)
       gst_pad_unlink (stream->srcpad, peer);
       gst_object_unref (peer);
     }
+    if (stream->buffer_probe_id)
+      gst_pad_remove_probe (stream->srcpad, stream->buffer_probe_id);
+    gst_object_unref (stream->srcpad);
   }
 
   slot = get_slot_for_input (dbin, stream);
@@ -423,32 +430,31 @@ remove_input_stream (GstDecodebin3 * dbin, DecodebinInputStream * stream)
     GST_DEBUG_OBJECT (dbin, "slot %p cleared", slot);
   }
 
-  if (stream->active_stream)
-    gst_object_unref (stream->active_stream);
-  if (stream->pending_stream)
-    gst_object_unref (stream->pending_stream);
-
   dbin->input_streams = g_list_remove (dbin->input_streams, stream);
 
   g_free (stream);
 }
 
 static void
-unblock_pending_input (DecodebinInput * input)
+unblock_pending_input (DecodebinInput * input, gboolean unblock_other_inputs)
 {
   GstDecodebin3 *dbin = input->dbin;
   GList *tmp, *unused_slot = NULL;
 
-  /* 1. Re-use existing streams if/when possible */
+  GST_DEBUG_OBJECT (dbin,
+      "DecodebinInput for %" GST_PTR_FORMAT " , unblock_other_inputs:%d",
+      input->parsebin, unblock_other_inputs);
+
+  /* Re-use existing streams if/when possible */
   GST_FIXME_OBJECT (dbin, "Re-use existing input streams if/when possible");
 
-  /* 2. Remove unused streams (push EOS) */
-  GST_DEBUG_OBJECT (dbin, "Removing unused streams");
+  /* Unblock all input streams and link to a slot if needed */
   SELECTION_LOCK (dbin);
   tmp = dbin->input_streams;
   while (tmp != NULL) {
     DecodebinInputStream *input_stream = (DecodebinInputStream *) tmp->data;
     GList *next = tmp->next;
+    MultiQueueSlot *slot;
 
     if (input_stream->input != input) {
       tmp = next;
@@ -456,58 +462,33 @@ unblock_pending_input (DecodebinInput * input)
     }
 
     GST_DEBUG_OBJECT (dbin, "Checking input stream %p", input_stream);
-    if (input_stream->input_buffer_probe_id) {
+
+    if (!input_stream->active_stream)
+      input_stream->active_stream = gst_pad_get_stream (input_stream->srcpad);
+
+    /* Ensure the stream has an associated slot */
+    slot = get_slot_for_input (dbin, input_stream);
+    if (slot->input != input_stream)
+      link_input_to_slot (input_stream, slot);
+
+    if (input_stream->buffer_probe_id) {
       GST_DEBUG_OBJECT (dbin,
           "Removing pad block on input %p pad %" GST_PTR_FORMAT, input_stream,
           input_stream->srcpad);
       gst_pad_remove_probe (input_stream->srcpad,
-          input_stream->input_buffer_probe_id);
+          input_stream->buffer_probe_id);
+      input_stream->buffer_probe_id = 0;
     }
-    input_stream->input_buffer_probe_id = 0;
 
     if (input_stream->saw_eos) {
+      GST_DEBUG_OBJECT (dbin, "Removing EOS'd stream");
       remove_input_stream (dbin, input_stream);
       tmp = dbin->input_streams;
     } else
       tmp = next;
   }
-  SELECTION_UNLOCK (dbin);
-
-  GST_DEBUG_OBJECT (dbin, "Creating new streams (if needed)");
-  /* 3. Create new streams */
-  for (tmp = input->pending_pads; tmp; tmp = tmp->next) {
-    GstStream *stream;
-    PendingPad *ppad = (PendingPad *) tmp->data;
-
-    stream = gst_pad_get_stream (ppad->pad);
-    if (stream == NULL) {
-      GST_ERROR_OBJECT (dbin, "No stream for pad ????");
-    } else {
-      MultiQueueSlot *slot;
-      DecodebinInputStream *input_stream;
-      /* The remaining pads in pending_pads are the ones that require a new
-       * input stream */
-      input_stream = create_input_stream (dbin, stream, ppad->pad, ppad->input);
-      /* See if we can link it straight away */
-      input_stream->active_stream = stream;
-
-      SELECTION_LOCK (dbin);
-      slot = get_slot_for_input (dbin, input_stream);
-      link_input_to_slot (input_stream, slot);
-      SELECTION_UNLOCK (dbin);
-
-      /* Remove the buffer and event probe */
-      gst_pad_remove_probe (ppad->pad, ppad->buffer_probe);
-      gst_pad_remove_probe (ppad->pad, ppad->event_probe);
-      g_free (ppad);
-    }
-  }
-
-  g_list_free (input->pending_pads);
-  input->pending_pads = NULL;
 
   /* Weed out unused multiqueue slots */
-  SELECTION_LOCK (dbin);
   for (tmp = dbin->slots; tmp; tmp = tmp->next) {
     MultiQueueSlot *slot = (MultiQueueSlot *) tmp->data;
     GST_LOG_OBJECT (dbin, "Slot %d input:%p", slot->id, slot->input);
@@ -518,105 +499,58 @@ unblock_pending_input (DecodebinInput * input)
   }
   SELECTION_UNLOCK (dbin);
 
-  for (tmp = unused_slot; tmp; tmp = tmp->next) {
-    GstPad *sink_pad = (GstPad *) tmp->data;
-    GST_DEBUG_OBJECT (sink_pad, "Sending EOS to unused slot");
-    gst_pad_send_event (sink_pad, gst_event_new_eos ());
-  }
-
-  if (unused_slot)
+  if (unused_slot) {
+    for (tmp = unused_slot; tmp; tmp = tmp->next) {
+      GstPad *sink_pad = (GstPad *) tmp->data;
+      GST_DEBUG_OBJECT (sink_pad, "Sending EOS to unused slot");
+      gst_pad_send_event (sink_pad, gst_event_new_eos ());
+    }
     g_list_free_full (unused_slot, (GDestroyNotify) gst_object_unref);
+  }
 
-}
-
-/* FIXME : HACK, REMOVE, USE INPUT CHAINS */
-static GstPadProbeReturn
-parsebin_buffer_probe (GstPad * pad, GstPadProbeInfo * info,
-    DecodebinInput * input)
-{
-  /* Any data out the demuxer means it's not creating pads
-   * any more right now */
-  GST_DEBUG_OBJECT (pad, "Got a buffer ! UNBLOCK !");
-  unblock_pending_input (input);
-
-  return GST_PAD_PROBE_OK;
-}
-
-static GstPadProbeReturn
-parsebin_pending_event_probe (GstPad * pad, GstPadProbeInfo * info,
-    PendingPad * ppad)
-{
-  GstDecodebin3 *dbin = ppad->dbin;
-  /* We drop all events by default */
-  GstPadProbeReturn ret = GST_PAD_PROBE_DROP;
-  GstEvent *ev = GST_PAD_PROBE_INFO_EVENT (info);
-
-  GST_DEBUG_OBJECT (pad, "Got event %p %s", ev, GST_EVENT_TYPE_NAME (ev));
-  switch (GST_EVENT_TYPE (ev)) {
-    case GST_EVENT_EOS:
-    {
-      GST_DEBUG_OBJECT (pad, "Pending pad marked as EOS, removing");
-      ppad->input->pending_pads =
-          g_list_remove (ppad->input->pending_pads, ppad);
-      gst_pad_remove_probe (ppad->pad, ppad->buffer_probe);
-      gst_pad_remove_probe (ppad->pad, ppad->event_probe);
-      g_free (ppad);
-
-      SELECTION_LOCK (dbin);
-      check_all_streams_for_eos (dbin, ev);
-      SELECTION_UNLOCK (dbin);
+  if (unblock_other_inputs) {
+    GList *tmp;
+    /* If requrested, unblock inputs which are targetting the same collection */
+    if (dbin->main_input != input) {
+      if (dbin->main_input->collection == input->collection) {
+        GST_DEBUG_OBJECT (dbin, "Unblock main input");
+        unblock_pending_input (dbin->main_input, FALSE);
+      }
+    }
+    for (tmp = dbin->other_inputs; tmp; tmp = tmp->next) {
+      DecodebinInput *other = tmp->data;
+      if (other->collection == input->collection) {
+        GST_DEBUG_OBJECT (dbin, "Unblock other input");
+        unblock_pending_input (other, FALSE);
+      }
     }
-      break;
-    case GST_EVENT_GAP:
-      GST_DEBUG_OBJECT (pad, "Got a gap event! UNBLOCK !");
-      unblock_pending_input (ppad->input);
-      ret = GST_PAD_PROBE_OK;
-      break;
-    default:
-      break;
   }
-
-  return ret;
 }
 
 static void
 parsebin_pad_added_cb (GstElement * demux, GstPad * pad, DecodebinInput * input)
 {
   GstDecodebin3 *dbin = input->dbin;
-  PendingPad *ppad;
-  GList *tmp;
 
   GST_DEBUG_OBJECT (dbin, "New pad %s:%s (input:%p)", GST_DEBUG_PAD_NAME (pad),
       input);
 
-  ppad = g_new0 (PendingPad, 1);
-  ppad->dbin = dbin;
-  ppad->input = input;
-  ppad->pad = pad;
-
-  ppad->event_probe =
-      gst_pad_add_probe (pad, GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM,
-      (GstPadProbeCallback) parsebin_pending_event_probe, ppad, NULL);
-  ppad->buffer_probe =
-      gst_pad_add_probe (pad,
-      GST_PAD_PROBE_TYPE_BLOCK | GST_PAD_PROBE_TYPE_BUFFER,
-      (GstPadProbeCallback) parsebin_buffer_probe, input, NULL);
+  SELECTION_LOCK (dbin);
+  create_input_stream (dbin, pad, input);
+  SELECTION_UNLOCK (dbin);
+}
 
-  input->pending_pads = g_list_append (input->pending_pads, ppad);
+static DecodebinInputStream *
+find_input_stream_for_pad (GstDecodebin3 * dbin, GstPad * pad)
+{
+  GList *tmp;
 
-  /* Check if all existing input streams have a buffer probe set */
   for (tmp = dbin->input_streams; tmp; tmp = tmp->next) {
-    DecodebinInputStream *input_stream = (DecodebinInputStream *) tmp->data;
-    if (input_stream->input == input &&
-        input_stream->input_buffer_probe_id == 0) {
-      GST_DEBUG_OBJECT (input_stream->srcpad, "Adding blocking buffer probe");
-      input_stream->input_buffer_probe_id =
-          gst_pad_add_probe (input_stream->srcpad,
-          GST_PAD_PROBE_TYPE_BLOCK | GST_PAD_PROBE_TYPE_BUFFER,
-          (GstPadProbeCallback) parsebin_buffer_probe, input_stream->input,
-          NULL);
-    }
+    DecodebinInputStream *cand = (DecodebinInputStream *) tmp->data;
+    if (cand->srcpad == pad)
+      return cand;
   }
+  return NULL;
 }
 
 static void
@@ -624,50 +558,39 @@ parsebin_pad_removed_cb (GstElement * demux, GstPad * pad, DecodebinInput * inp)
 {
   GstDecodebin3 *dbin = inp->dbin;
   DecodebinInputStream *input = NULL;
-  GList *tmp;
+  MultiQueueSlot *slot;
+
+  if (!GST_PAD_IS_SRC (pad))
+    return;
+
   GST_DEBUG_OBJECT (pad, "removed");
+  input = find_input_stream_for_pad (dbin, pad);
+  g_assert (input);
 
-  for (tmp = dbin->input_streams; tmp; tmp = tmp->next) {
-    DecodebinInputStream *cand = (DecodebinInputStream *) tmp->data;
-    if (cand->srcpad == pad)
-      input = cand;
-  }
   /* If there are no pending pads, this means we will definitely not need this
    * stream anymore */
-  if (input) {
-    GST_DEBUG_OBJECT (pad, "stream %p", input);
-    if (inp->pending_pads == NULL) {
-      MultiQueueSlot *slot;
-
-      GST_DEBUG_OBJECT (pad, "Remove input stream %p", input);
-
-      SELECTION_LOCK (dbin);
-      slot = get_slot_for_input (dbin, input);
-
-      remove_input_stream (dbin, input);
-      if (slot && g_list_find (dbin->slots, slot) && slot->is_drained) {
-        /* if slot is still there and already drained, remove it in here */
-        if (slot->output) {
-          DecodebinOutputStream *output = slot->output;
-          GST_DEBUG_OBJECT (pad,
-              "Multiqueue was drained, Remove output stream");
-
-          dbin->output_streams = g_list_remove (dbin->output_streams, output);
-          free_output_stream (dbin, output);
-        }
-        GST_DEBUG_OBJECT (pad, "No pending pad, Remove multiqueue slot");
-        if (slot->probe_id)
-          gst_pad_remove_probe (slot->src_pad, slot->probe_id);
-        slot->probe_id = 0;
-        dbin->slots = g_list_remove (dbin->slots, slot);
-        free_multiqueue_slot_async (dbin, slot);
-      }
-      SELECTION_UNLOCK (dbin);
-    } else {
-      input->srcpad = NULL;
-      if (input->input_buffer_probe_id)
-        gst_pad_remove_probe (pad, input->input_buffer_probe_id);
-      input->input_buffer_probe_id = 0;
+
+  GST_DEBUG_OBJECT (pad, "Remove input stream %p", input);
+
+  SELECTION_LOCK (dbin);
+  slot = get_slot_for_input (dbin, input);
+  remove_input_stream (dbin, input);
+
+  if (slot && g_list_find (dbin->slots, slot) && slot->is_drained) {
+    /* if slot is still there and already drained, remove it in here */
+    if (slot->output) {
+      DecodebinOutputStream *output = slot->output;
+      GST_DEBUG_OBJECT (pad, "Multiqueue was drained, Remove output stream");
+
+      dbin->output_streams = g_list_remove (dbin->output_streams, output);
+      free_output_stream (dbin, output);
     }
+    GST_DEBUG_OBJECT (pad, "No pending pad, Remove multiqueue slot");
+    if (slot->probe_id)
+      gst_pad_remove_probe (slot->src_pad, slot->probe_id);
+    slot->probe_id = 0;
+    dbin->slots = g_list_remove (dbin->slots, slot);
+    free_multiqueue_slot_async (dbin, slot);
   }
+  SELECTION_UNLOCK (dbin);
 }
diff --git a/subprojects/gst-plugins-base/gst/playback/gstdecodebin3.c b/subprojects/gst-plugins-base/gst/playback/gstdecodebin3.c
index 9b387ac1ae..c5543b8724 100644
--- a/subprojects/gst-plugins-base/gst/playback/gstdecodebin3.c
+++ b/subprojects/gst-plugins-base/gst/playback/gstdecodebin3.c
@@ -67,7 +67,11 @@
 /*
  * Global design
  *
- * 1) From sink pad to elementary streams (GstParseBin)
+ * 1) From sink pad to elementary streams (GstParseBin or identity)
+ *
+ * Note : If the incoming streams are push-based-only and are compatible with
+ * either the output caps or a potential decoder, the usage of parsebin is
+ * replaced by a simple passthrough identity element.
  *
  * The input sink pads are fed to GstParseBin. GstParseBin will feed them
  * through typefind. When the caps are detected (or changed) we recursively
@@ -157,7 +161,7 @@
  * MAIN CONCEPTS
  *  1) Activating a stream (i.e. linking a slot to an output) is only done within
  *    the streaming thread in the multiqueue_src_probe() and only if the
-      stream is in the REQUESTED selection.
+ *    stream is in the REQUESTED selection.
  *  2) Deactivating a stream (i.e. unlinking a slot from an output) is also done
  *    within the stream thread, but only in a purposefully called IDLE probe
  *    that calls reassign_slot().
@@ -216,7 +220,6 @@ struct _GstDecodebin3
   /* counter for input */
   guint32 input_counter;
   /* Current stream group_id (default : GST_GROUP_ID_INVALID) */
-  /* FIXME : Needs to be reset appropriately (when upstream changes ?) */
   guint32 current_group_id;
   /* End of variables protected by input_lock */
 
@@ -249,10 +252,6 @@ struct _GstDecodebin3
   /* End of variables protected by selection_lock */
   gboolean upstream_selected;
 
-  /* List of pending collections.
-   * FIXME : Is this really needed ? */
-  GList *pending_collection;
-
   /* Factories */
   GMutex factories_lock;
   guint32 factories_cookie;
@@ -293,20 +292,16 @@ struct _DecodebinInput
 
   guint group_id;
 
+  /* Either parsebin or identity is used */
   GstElement *parsebin;
+  GstElement *identity;
 
   gulong pad_added_sigid;
   gulong pad_removed_sigid;
   gulong drained_sigid;
 
-  /* TRUE if the input got drained
-   * FIXME : When do we reset it if re-used ?
-   */
+  /* TRUE if the input got drained */
   gboolean drained;
-
-  /* HACK : Remove these fields */
-  /* List of PendingPad structures */
-  GList *pending_pads;
 };
 
 /* Multiqueue Slots */
@@ -331,6 +326,7 @@ typedef struct _MultiQueueSlot
   /* id of the MQ src_pad event probe */
   gulong probe_id;
 
+  /* TRUE if EOS was pushed out by multiqueue */
   gboolean is_drained;
 
   DecodebinOutputStream *output;
@@ -362,18 +358,6 @@ struct _DecodebinOutputStream
   gulong drop_probe_id;
 };
 
-/* Pending pads from parsebin */
-typedef struct _PendingPad
-{
-  GstDecodebin3 *dbin;
-  DecodebinInput *input;
-  GstPad *pad;
-
-  gulong buffer_probe;
-  gulong event_probe;
-  gboolean saw_eos;
-} PendingPad;
-
 /* properties */
 enum
 {
@@ -491,6 +475,9 @@ gst_decodebin3_select_stream (GstDecodebin3 * dbin,
 
 static GstPad *gst_decodebin3_request_new_pad (GstElement * element,
     GstPadTemplate * temp, const gchar * name, const GstCaps * caps);
+static void gst_decodebin3_release_pad (GstElement * element, GstPad * pad);
+static void handle_stream_collection (GstDecodebin3 * dbin,
+    GstStreamCollection * collection, DecodebinInput * input);
 static void gst_decodebin3_handle_message (GstBin * bin, GstMessage * message);
 static GstStateChangeReturn gst_decodebin3_change_state (GstElement * element,
     GstStateChange transition);
@@ -504,7 +491,6 @@ static gboolean have_factory (GstDecodebin3 * dbin, GstCaps * caps,
 #endif
 
 static void free_input (GstDecodebin3 * dbin, DecodebinInput * input);
-static void free_input_async (GstDecodebin3 * dbin, DecodebinInput * input);
 static DecodebinInput *create_new_input (GstDecodebin3 * dbin, gboolean main);
 static gboolean set_input_group_id (DecodebinInput * input, guint32 * group_id);
 
@@ -558,13 +544,11 @@ gst_decodebin3_class_init (GstDecodebin3Class * klass)
   gobject_klass->set_property = gst_decodebin3_set_property;
   gobject_klass->get_property = gst_decodebin3_get_property;
 
-  /* FIXME : ADD PROPERTIES ! */
   g_object_class_install_property (gobject_klass, PROP_CAPS,
       g_param_spec_boxed ("caps", "Caps",
           "The caps on which to stop decoding. (NULL = default)",
           GST_TYPE_CAPS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
-  /* FIXME : ADD SIGNALS ! */
   /**
    * GstDecodebin3::select-stream
    * @decodebin: a #GstDecodebin3
@@ -602,6 +586,7 @@ gst_decodebin3_class_init (GstDecodebin3Class * klass)
       GST_DEBUG_FUNCPTR (gst_decodebin3_request_new_pad);
   element_class->change_state = GST_DEBUG_FUNCPTR (gst_decodebin3_change_state);
   element_class->send_event = GST_DEBUG_FUNCPTR (gst_decodebin3_send_event);
+  element_class->release_pad = GST_DEBUG_FUNCPTR (gst_decodebin3_release_pad);
 
   gst_element_class_add_pad_template (element_class,
       gst_static_pad_template_get (&sink_template));
@@ -716,7 +701,6 @@ gst_decodebin3_set_property (GObject * object, guint prop_id,
 {
   GstDecodebin3 *dbin = (GstDecodebin3 *) object;
 
-  /* FIXME : IMPLEMENT */
   switch (prop_id) {
     case PROP_CAPS:
       GST_OBJECT_LOCK (dbin);
@@ -737,7 +721,6 @@ gst_decodebin3_get_property (GObject * object, guint prop_id, GValue * value,
 {
   GstDecodebin3 *dbin = (GstDecodebin3 *) object;
 
-  /* FIXME : IMPLEMENT */
   switch (prop_id) {
     case PROP_CAPS:
       GST_OBJECT_LOCK (dbin);
@@ -780,9 +763,11 @@ set_input_group_id (DecodebinInput * input, guint32 * group_id)
   }
 
   if (*group_id != dbin->current_group_id) {
+    /* The input is being re-used with a different incoming stream, we do want
+     * to change/unify to this new group-id */
     if (dbin->current_group_id == GST_GROUP_ID_INVALID) {
-      GST_DEBUG_OBJECT (dbin, "Setting current group id to %" G_GUINT32_FORMAT,
-          *group_id);
+      GST_DEBUG_OBJECT (dbin,
+          "Setting current group id to %" G_GUINT32_FORMAT, *group_id);
       dbin->current_group_id = *group_id;
     }
     *group_id = dbin->current_group_id;
@@ -874,17 +859,49 @@ static GstPadLinkReturn
 gst_decodebin3_input_pad_link (GstPad * pad, GstObject * parent, GstPad * peer)
 {
   GstDecodebin3 *dbin = (GstDecodebin3 *) parent;
+  GstQuery *query;
+  gboolean pull_mode = FALSE;
   GstPadLinkReturn res = GST_PAD_LINK_OK;
   DecodebinInput *input = g_object_get_data (G_OBJECT (pad), "decodebin.input");
 
   g_return_val_if_fail (input, GST_PAD_LINK_REFUSED);
 
-  GST_LOG_OBJECT (parent, "Got link on input pad %" GST_PTR_FORMAT
-      ". Creating parsebin if needed", pad);
+  GST_LOG_OBJECT (parent, "Got link on input pad %" GST_PTR_FORMAT, pad);
+
+  query = gst_query_new_scheduling ();
+  if (gst_pad_query (peer, query)
+      && gst_query_has_scheduling_mode_with_flags (query, GST_PAD_MODE_PULL,
+          GST_SCHEDULING_FLAG_SEEKABLE))
+    pull_mode = TRUE;
+  gst_query_unref (query);
 
+  GST_DEBUG_OBJECT (dbin, "Upstream can do pull-based : %d", pull_mode);
+
+  /* If upstream *can* do pull-based, we always use a parsebin. If not, we will
+   * delay that decision to a later stage (caps/stream/collection event
+   * processing) to figure out if one is really needed or whether an identity
+   * element will be enough */
   INPUT_LOCK (dbin);
-  if (!ensure_input_parsebin (dbin, input))
-    res = GST_PAD_LINK_REFUSED;
+  if (pull_mode) {
+    if (!ensure_input_parsebin (dbin, input))
+      res = GST_PAD_LINK_REFUSED;
+    else if (input->identity) {
+      GST_ERROR_OBJECT (dbin,
+          "Can't reconfigure input from push-based to pull-based");
+      res = GST_PAD_LINK_REFUSED;
+    }
+  }
+
+  /* Clear stream-collection corresponding to current INPUT.  We do not
+   * recalculate the global one yet, it will be done when at least one
+   * collection is received/computed for this input.
+   */
+  if (input->collection) {
+    GST_DEBUG_OBJECT (pad, "Clearing input collection");
+    gst_object_unref (input->collection);
+    input->collection = NULL;
+  }
+
   INPUT_UNLOCK (dbin);
 
   return res;
@@ -909,15 +926,60 @@ query_duration_drop_probe (GstPad * pad, GstPadProbeInfo * info,
 }
 
 static void
-gst_decodebin3_input_pad_unlink (GstPad * pad, GstObject * parent)
+recalculate_group_id (GstDecodebin3 * dbin)
 {
-  GstDecodebin3 *dbin = (GstDecodebin3 *) parent;
-  DecodebinInput *input = g_object_get_data (G_OBJECT (pad), "decodebin.input");
+  guint32 common_group_id;
+  GList *iter;
+
+  common_group_id = dbin->main_input->group_id;
+
+  for (iter = dbin->other_inputs; iter; iter = iter->next) {
+    DecodebinInput *input = iter->data;
+
+    if (input->group_id != common_group_id)
+      return;
+  }
+
+  GST_DEBUG_OBJECT (dbin, "Updating global group_id to %" G_GUINT32_FORMAT,
+      common_group_id);
+  dbin->current_group_id = common_group_id;
+}
+
+/* CALL with INPUT LOCK */
+static void
+reset_input_parsebin (GstDecodebin3 * dbin, DecodebinInput * input)
+{
+  GList *iter;
+
+  if (input->parsebin == NULL)
+    return;
+
+  GST_DEBUG_OBJECT (dbin, "Resetting %" GST_PTR_FORMAT, input->parsebin);
+
+  GST_STATE_LOCK (dbin);
+  gst_element_set_state (input->parsebin, GST_STATE_NULL);
+  input->drained = FALSE;
+  input->group_id = GST_GROUP_ID_INVALID;
+  recalculate_group_id (dbin);
+  for (iter = dbin->input_streams; iter; iter = iter->next) {
+    DecodebinInputStream *istream = iter->data;
+    if (istream->input == input)
+      istream->saw_eos = TRUE;
+  }
+  gst_element_sync_state_with_parent (input->parsebin);
+  GST_STATE_UNLOCK (dbin);
+}
+
+
+static void
+gst_decodebin3_input_pad_unlink (GstPad * pad, GstPad * peer,
+    DecodebinInput * input)
+{
+  GstDecodebin3 *dbin = input->dbin;
 
   g_return_if_fail (input);
 
-  GST_LOG_OBJECT (parent, "Got unlink on input pad %" GST_PTR_FORMAT
-      ". Removing parsebin.", pad);
+  GST_LOG_OBJECT (dbin, "Got unlink on input pad %" GST_PTR_FORMAT, pad);
 
   INPUT_LOCK (dbin);
   if (input->parsebin == NULL) {
@@ -925,43 +987,69 @@ gst_decodebin3_input_pad_unlink (GstPad * pad, GstObject * parent)
     return;
   }
 
-  if (GST_OBJECT_PARENT (GST_OBJECT (input->parsebin)) == GST_OBJECT (dbin)) {
-    GstStreamCollection *collection = NULL;
-    gulong probe_id = gst_pad_add_probe (input->parsebin_sink,
-        GST_PAD_PROBE_TYPE_QUERY_UPSTREAM,
-        (GstPadProbeCallback) query_duration_drop_probe, input, NULL);
+  if (GST_PAD_MODE (pad) == GST_PAD_MODE_PULL) {
+    GST_DEBUG_OBJECT (dbin, "Resetting parsebin since it's pull-based");
+    reset_input_parsebin (dbin, input);
+  }
 
-    /* Clear stream-collection corresponding to current INPUT and post new
-     * stream-collection message, if needed */
-    if (input->collection) {
-      gst_object_unref (input->collection);
-      input->collection = NULL;
-    }
+  INPUT_UNLOCK (dbin);
+}
 
-    SELECTION_LOCK (dbin);
-    collection = get_merged_collection (dbin);
-    if (collection && collection != dbin->collection) {
-      GstMessage *msg;
-      GST_DEBUG_OBJECT (dbin, "Update Stream Collection");
+static void
+gst_decodebin3_release_pad (GstElement * element, GstPad * pad)
+{
+  GstDecodebin3 *dbin = (GstDecodebin3 *) element;
+  DecodebinInput *input = g_object_get_data (G_OBJECT (pad), "decodebin.input");
+  GstStreamCollection *collection = NULL;
+  gulong probe_id = 0;
+  GstMessage *msg;
 
-      if (dbin->collection)
-        gst_object_unref (dbin->collection);
-      dbin->collection = collection;
-      dbin->select_streams_seqnum = GST_SEQNUM_INVALID;
+  g_return_if_fail (input);
+  GST_LOG_OBJECT (dbin, "Releasing pad %" GST_PTR_FORMAT, pad);
 
-      msg =
-          gst_message_new_stream_collection ((GstObject *) dbin,
-          dbin->collection);
+  INPUT_LOCK (dbin);
 
-      SELECTION_UNLOCK (dbin);
-      gst_element_post_message (GST_ELEMENT_CAST (dbin), msg);
-      update_requested_selection (dbin);
-    } else {
-      if (collection)
-        gst_object_unref (collection);
-      SELECTION_UNLOCK (dbin);
-    }
+  /* Clear stream-collection corresponding to current INPUT and post new
+   * stream-collection message, if needed */
+  if (input->collection) {
+    gst_object_unref (input->collection);
+    input->collection = NULL;
+  }
+
+  SELECTION_LOCK (dbin);
+  collection = get_merged_collection (dbin);
+  if (!collection) {
+    SELECTION_UNLOCK (dbin);
+    goto beach;
+  }
+  if (collection == dbin->collection) {
+    SELECTION_UNLOCK (dbin);
+    gst_object_unref (collection);
+    goto beach;
+  }
+
+  GST_DEBUG_OBJECT (dbin, "Update Stream Collection");
 
+  if (dbin->collection)
+    gst_object_unref (dbin->collection);
+  dbin->collection = collection;
+  dbin->select_streams_seqnum = GST_SEQNUM_INVALID;
+
+  msg =
+      gst_message_new_stream_collection ((GstObject *) dbin, dbin->collection);
+
+  if (input->parsebin)
+    /* Drop duration queries that the application might be doing while this message is posted */
+    probe_id = gst_pad_add_probe (input->parsebin_sink,
+        GST_PAD_PROBE_TYPE_QUERY_UPSTREAM,
+        (GstPadProbeCallback) query_duration_drop_probe, input, NULL);
+
+  SELECTION_UNLOCK (dbin);
+  gst_element_post_message (GST_ELEMENT_CAST (dbin), msg);
+  update_requested_selection (dbin);
+
+  gst_ghost_pad_set_target (GST_GHOST_PAD (input->ghost_sink), NULL);
+  if (input->parsebin) {
     gst_bin_remove (GST_BIN (dbin), input->parsebin);
     gst_element_set_state (input->parsebin, GST_STATE_NULL);
     g_signal_handler_disconnect (input->parsebin, input->pad_removed_sigid);
@@ -973,20 +1061,34 @@ gst_decodebin3_input_pad_unlink (GstPad * pad, GstObject * parent)
 
     input->parsebin = NULL;
     input->parsebin_sink = NULL;
+  }
+  if (input->identity) {
+    GstPad *idpad = gst_element_get_static_pad (input->identity, "src");
+    DecodebinInputStream *stream = find_input_stream_for_pad (dbin, idpad);
+    gst_object_unref (idpad);
+    remove_input_stream (dbin, stream);
+    gst_element_set_state (input->identity, GST_STATE_NULL);
+    gst_bin_remove (GST_BIN (dbin), input->identity);
+    gst_object_unref (input->identity);
+    input->identity = NULL;
+  }
 
-    if (!input->is_main) {
-      dbin->other_inputs = g_list_remove (dbin->other_inputs, input);
-      free_input_async (dbin, input);
-    }
+  if (!input->is_main) {
+    dbin->other_inputs = g_list_remove (dbin->other_inputs, input);
+    free_input (dbin, input);
   }
+
+beach:
   INPUT_UNLOCK (dbin);
   return;
 }
 
+/* Call with INPUT LOCK */
 static void
 free_input (GstDecodebin3 * dbin, DecodebinInput * input)
 {
   GST_DEBUG ("Freeing input %p", input);
+
   gst_ghost_pad_set_target (GST_GHOST_PAD (input->ghost_sink), NULL);
   gst_element_remove_pad (GST_ELEMENT (dbin), input->ghost_sink);
   if (input->parsebin) {
@@ -997,19 +1099,19 @@ free_input (GstDecodebin3 * dbin, DecodebinInput * input)
     gst_object_unref (input->parsebin);
     gst_object_unref (input->parsebin_sink);
   }
+  if (input->identity) {
+    GstPad *idpad = gst_element_get_static_pad (input->identity, "src");
+    DecodebinInputStream *stream = find_input_stream_for_pad (dbin, idpad);
+    gst_object_unref (idpad);
+    remove_input_stream (dbin, stream);
+    gst_element_set_state (input->identity, GST_STATE_NULL);
+    gst_object_unref (input->identity);
+  }
   if (input->collection)
     gst_object_unref (input->collection);
   g_free (input);
 }
 
-static void
-free_input_async (GstDecodebin3 * dbin, DecodebinInput * input)
-{
-  GST_LOG_OBJECT (dbin, "pushing input %p on thread pool to free", input);
-  gst_element_call_async (GST_ELEMENT_CAST (dbin),
-      (GstElementCallAsyncFunc) free_input, input, NULL);
-}
-
 static gboolean
 sink_query_function (GstPad * sinkpad, GstDecodebin3 * dbin, GstQuery * query)
 {
@@ -1030,6 +1132,80 @@ sink_query_function (GstPad * sinkpad, GstDecodebin3 * dbin, GstQuery * query)
   return gst_pad_query_default (sinkpad, GST_OBJECT (dbin), query);
 }
 
+static gboolean
+is_parsebin_required_for_input (GstDecodebin3 * dbin, DecodebinInput * input,
+    GstCaps * newcaps, GstPad * sinkpad)
+{
+  gboolean parsebin_needed = TRUE;
+  GstStream *stream;
+
+  stream = gst_pad_get_stream (sinkpad);
+
+  if (stream == NULL) {
+    /* If upstream didn't provide a `GstStream` we will need to create a
+     * parsebin to handle that stream */
+    GST_DEBUG_OBJECT (sinkpad,
+        "Need to create parsebin since upstream doesn't provide GstStream");
+  } else if (gst_caps_can_intersect (newcaps, dbin->caps)) {
+    /* If the incoming caps match decodebin3 output, no processing is needed */
+    GST_FIXME_OBJECT (sinkpad, "parsebin not needed (matches output caps) !");
+    parsebin_needed = FALSE;
+  } else {
+    GList *decoder_list;
+    /* If the incoming caps are compatible with a decoder, we don't need to
+     * process it before */
+    g_mutex_lock (&dbin->factories_lock);
+    gst_decode_bin_update_factories_list (dbin);
+    decoder_list =
+        gst_element_factory_list_filter (dbin->decoder_factories, newcaps,
+        GST_PAD_SINK, TRUE);
+    g_mutex_unlock (&dbin->factories_lock);
+    if (decoder_list) {
+      GST_FIXME_OBJECT (sinkpad, "parsebin not needed (available decoders) !");
+      gst_plugin_feature_list_free (decoder_list);
+      parsebin_needed = FALSE;
+    }
+  }
+  if (stream)
+    gst_object_unref (stream);
+
+  return parsebin_needed;
+}
+
+static void
+setup_identify_for_input (GstDecodebin3 * dbin, DecodebinInput * input,
+    GstPad * sinkpad)
+{
+  GstPad *idsrc, *idsink;
+  DecodebinInputStream *inputstream;
+
+  GST_DEBUG_OBJECT (sinkpad, "Adding identity for new input stream");
+
+  input->identity = gst_element_factory_make ("identity", NULL);
+  /* We drop allocation queries due to our usage of multiqueue just
+   * afterwards. It is just too dangerous.
+   *
+   * If application users want to have optimal raw source <=> sink allocations
+   * they should not use decodebin3
+   */
+  g_object_set (input->identity, "drop-allocation", TRUE, NULL);
+  input->identity = gst_object_ref (input->identity);
+  idsink = gst_element_get_static_pad (input->identity, "sink");
+  idsrc = gst_element_get_static_pad (input->identity, "src");
+  gst_bin_add (GST_BIN (dbin), input->identity);
+
+  SELECTION_LOCK (dbin);
+  inputstream = create_input_stream (dbin, idsrc, input);
+  /* Forward any existing GstStream directly on the input stream */
+  inputstream->active_stream = gst_pad_get_stream (sinkpad);
+  SELECTION_UNLOCK (dbin);
+
+  gst_object_unref (idsrc);
+  gst_object_unref (idsink);
+  gst_ghost_pad_set_target (GST_GHOST_PAD (input->ghost_sink), idsink);
+  gst_element_sync_state_with_parent (input->identity);
+}
+
 static gboolean
 sink_event_function (GstPad * sinkpad, GstDecodebin3 * dbin, GstEvent * event)
 {
@@ -1060,30 +1236,86 @@ sink_event_function (GstPad * sinkpad, GstDecodebin3 * dbin, GstEvent * event)
          inputs is. This means things might break if there's a mix */
       if (input->upstream_selected)
         dbin->upstream_selected = TRUE;
+
+      /* Make sure group ids will be recalculated */
+      input->group_id = GST_GROUP_ID_INVALID;
+      recalculate_group_id (dbin);
+      break;
+    }
+    case GST_EVENT_STREAM_COLLECTION:
+    {
+      GstStreamCollection *collection = NULL;
+
+      gst_event_parse_stream_collection (event, &collection);
+      if (collection) {
+        INPUT_LOCK (dbin);
+        handle_stream_collection (dbin, collection, input);
+        gst_object_unref (collection);
+        INPUT_UNLOCK (dbin);
+        SELECTION_LOCK (dbin);
+        /* Post the (potentially) updated collection */
+        if (dbin->collection) {
+          GstMessage *msg;
+          msg =
+              gst_message_new_stream_collection ((GstObject *) dbin,
+              dbin->collection);
+          SELECTION_UNLOCK (dbin);
+          gst_element_post_message (GST_ELEMENT_CAST (dbin), msg);
+          update_requested_selection (dbin);
+        } else
+          SELECTION_UNLOCK (dbin);
+      }
+
+      /* If we are waiting to create an identity passthrough, do it now */
+      if (!input->parsebin && !input->identity)
+        setup_identify_for_input (dbin, input, sinkpad);
       break;
     }
     case GST_EVENT_CAPS:
     {
+      GstCaps *newcaps = NULL;
+
+      gst_event_parse_caps (event, &newcaps);
+      if (!newcaps)
+        break;
+      GST_DEBUG_OBJECT (sinkpad, "new caps %" GST_PTR_FORMAT, newcaps);
+
+      /* No parsebin or identity present, check if we can avoid creating one */
+      if (!input->parsebin && !input->identity) {
+        if (is_parsebin_required_for_input (dbin, input, newcaps, sinkpad)) {
+          GST_DEBUG_OBJECT (sinkpad, "parsebin is required for input");
+          ensure_input_parsebin (dbin, input);
+          break;
+        }
+        GST_DEBUG_OBJECT (sinkpad,
+            "parsebin not required. Will create identity passthrough element once we get the collection");
+        break;
+      }
+
+      if (input->identity) {
+        if (is_parsebin_required_for_input (dbin, input, newcaps, sinkpad)) {
+          GST_ERROR_OBJECT (sinkpad,
+              "Switching from passthrough to parsebin on inputs is not supported !");
+          gst_event_unref (event);
+          return FALSE;
+        }
+        /* Nothing else to do here */
+        break;
+      }
+
+      /* Check if the parsebin present can handle the new caps */
+      g_assert (input->parsebin);
       GST_DEBUG_OBJECT (sinkpad,
           "New caps, checking if they are compatible with existing parsebin");
-      if (input->parsebin_sink) {
-        GstCaps *newcaps = NULL;
-
-        gst_event_parse_caps (event, &newcaps);
-        GST_DEBUG_OBJECT (sinkpad, "new caps %" GST_PTR_FORMAT, newcaps);
-
-        if (newcaps
-            && !gst_pad_query_accept_caps (input->parsebin_sink, newcaps)) {
-          GST_DEBUG_OBJECT (sinkpad,
-              "Parsebin doesn't accept the new caps %" GST_PTR_FORMAT, newcaps);
-          GST_STATE_LOCK (dbin);
-          /* Reset parsebin so that it reconfigures itself for the new stream format */
-          gst_element_set_state (input->parsebin, GST_STATE_NULL);
-          gst_element_sync_state_with_parent (input->parsebin);
-          GST_STATE_UNLOCK (dbin);
-        } else {
-          GST_DEBUG_OBJECT (sinkpad, "Parsebin accepts new caps");
-        }
+      if (!gst_pad_query_accept_caps (input->parsebin_sink, newcaps)) {
+        GST_DEBUG_OBJECT (sinkpad,
+            "Parsebin doesn't accept the new caps %" GST_PTR_FORMAT, newcaps);
+        /* Reset parsebin so that it reconfigures itself for the new stream format */
+        INPUT_LOCK (dbin);
+        reset_input_parsebin (dbin, input);
+        INPUT_UNLOCK (dbin);
+      } else {
+        GST_DEBUG_OBJECT (sinkpad, "Parsebin accepts new caps");
       }
       break;
     }
@@ -1119,8 +1351,8 @@ create_new_input (GstDecodebin3 * dbin, gboolean main)
   gst_pad_set_query_function (input->ghost_sink,
       (GstPadQueryFunction) sink_query_function);
   gst_pad_set_link_function (input->ghost_sink, gst_decodebin3_input_pad_link);
-  gst_pad_set_unlink_function (input->ghost_sink,
-      gst_decodebin3_input_pad_unlink);
+  g_signal_connect (input->ghost_sink, "unlinked",
+      (GCallback) gst_decodebin3_input_pad_unlink, input);
 
   gst_pad_set_active (input->ghost_sink, TRUE);
   gst_element_add_pad ((GstElement *) dbin, input->ghost_sink);
@@ -1403,7 +1635,9 @@ get_merged_collection (GstDecodebin3 * dbin)
 
   for (tmp = dbin->other_inputs; tmp; tmp = tmp->next) {
     DecodebinInput *input = (DecodebinInput *) tmp->data;
-    if (input->collection) {
+    GST_LOG_OBJECT (dbin, "Comparing res %p input->collection %p", res,
+        input->collection);
+    if (input->collection && input->collection != res) {
       if (res) {
         needs_merge = TRUE;
         break;
@@ -1583,8 +1817,6 @@ handle_stream_collection (GstDecodebin3 * dbin,
      * When all streams from active collection are drained in multiqueue output ? */
     gst_object_unref (dbin->collection);
     dbin->collection = collection;
-    /* dbin->pending_collection = */
-    /*     g_list_append (dbin->pending_collection, collection); */
   }
   dbin->select_streams_seqnum = GST_SEQNUM_INVALID;
   SELECTION_UNLOCK (dbin);
@@ -1909,21 +2141,9 @@ check_all_slot_for_eos (GstDecodebin3 * dbin, GstEvent * ev)
     break;
   }
 
-  if (all_drained) {
-    INPUT_LOCK (dbin);
-    if (!pending_pads_are_eos (dbin->main_input))
-      all_drained = FALSE;
-
-    if (all_drained) {
-      for (iter = dbin->other_inputs; iter; iter = iter->next) {
-        if (!pending_pads_are_eos ((DecodebinInput *) iter->data)) {
-          all_drained = FALSE;
-          break;
-        }
-      }
-    }
-    INPUT_UNLOCK (dbin);
-  }
+  /* Also check with the inputs, data might be pending */
+  if (all_drained)
+    all_drained = all_inputs_are_eos (dbin);
 
   if (all_drained) {
     GST_DEBUG_OBJECT (dbin,
@@ -2347,8 +2567,8 @@ keyframe_waiter_probe (GstPad * pad, GstPadProbeInfo * info,
     DecodebinOutputStream * output)
 {
   GstBuffer *buf = GST_PAD_PROBE_INFO_BUFFER (info);
+
   /* If we have a keyframe, remove the probe and let all data through */
-  /* FIXME : HANDLE HEADER BUFFER ?? */
   if (!GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT) ||
       GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_HEADER)) {
     GST_DEBUG_OBJECT (pad,
@@ -3048,7 +3268,6 @@ gst_decodebin3_send_event (GstElement * element, GstEvent * event)
     dbin->pending_select_streams = g_list_copy (streams);
     SELECTION_UNLOCK (dbin);
 
-    /* FIXME : We don't have an upstream ?? */
 #if 0
     /* Send event upstream */
     if ((peer = gst_pad_get_peer (pad))) {
diff --git a/subprojects/gst-plugins-base/gst/playback/gstparsebin.c b/subprojects/gst-plugins-base/gst/playback/gstparsebin.c
index d2f1b7fe5f..1d1d5c9a68 100644
--- a/subprojects/gst-plugins-base/gst/playback/gstparsebin.c
+++ b/subprojects/gst-plugins-base/gst/playback/gstparsebin.c
@@ -3634,8 +3634,10 @@ retry:
     GstParsePad *parsepad = (GstParsePad *) tmp->data;
     gchar *padname;
 
-    //if (!parsepad->blocked)
-    //continue;
+    if (parsepad->exposed) {
+      GST_DEBUG_OBJECT (parsepad, "Pad is already exposed, not doing anything");
+      continue;
+    }
 
     /* 1. rewrite name */
     padname = g_strdup_printf ("src_%u", parsebin->nbpads);
@@ -3649,20 +3651,12 @@ retry:
         parsepad);
 
     /* 2. activate and add */
-    if (!parsepad->exposed) {
-      parsepad->exposed = TRUE;
-      if (!gst_element_add_pad (GST_ELEMENT (parsebin),
-              GST_PAD_CAST (parsepad))) {
-        /* not really fatal, we can try to add the other pads */
-        g_warning ("error adding pad to ParseBin");
-        parsepad->exposed = FALSE;
-        continue;
-      }
-#if 0
-      /* HACK: Send an empty gap event to push sticky events */
-      gst_pad_push_event (GST_PAD (parsepad),
-          gst_event_new_gap (0, GST_CLOCK_TIME_NONE));
-#endif
+    parsepad->exposed = TRUE;
+    if (!gst_element_add_pad (GST_ELEMENT (parsebin), GST_PAD_CAST (parsepad))) {
+      /* not really fatal, we can try to add the other pads */
+      g_warning ("error adding pad to ParseBin");
+      parsepad->exposed = FALSE;
+      continue;
     }
 
     GST_INFO_OBJECT (parsepad, "added new parsed pad");
diff --git a/subprojects/gst-plugins-base/gst/playback/gstplaybin3.c b/subprojects/gst-plugins-base/gst/playback/gstplaybin3.c
index ba8a4ecd4f..14b160e318 100644
--- a/subprojects/gst-plugins-base/gst/playback/gstplaybin3.c
+++ b/subprojects/gst-plugins-base/gst/playback/gstplaybin3.c
@@ -249,7 +249,6 @@ GST_DEBUG_CATEGORY_STATIC (gst_play_bin3_debug);
 
 typedef struct _GstPlayBin3 GstPlayBin3;
 typedef struct _GstPlayBin3Class GstPlayBin3Class;
-typedef struct _GstSourceGroup GstSourceGroup;
 typedef struct _GstSourceCombine GstSourceCombine;
 typedef struct _SourcePad SourcePad;
 
@@ -272,14 +271,8 @@ struct _GstSourceCombine
   GPtrArray *streams;           /* Sorted array of GstStream for the given type */
 
   gboolean has_active_pad;      /* stream combiner has the "active-pad" property */
-
-  gboolean is_concat;           /* The stream combiner is the 'concat' element */
 };
 
-#define GST_SOURCE_GROUP_GET_LOCK(group) (&((GstSourceGroup*)(group))->lock)
-#define GST_SOURCE_GROUP_LOCK(group) (g_mutex_lock (GST_SOURCE_GROUP_GET_LOCK(group)))
-#define GST_SOURCE_GROUP_UNLOCK(group) (g_mutex_unlock (GST_SOURCE_GROUP_GET_LOCK(group)))
-
 enum
 {
   PLAYBIN_STREAM_AUDIO = 0,
@@ -300,22 +293,6 @@ static const gchar *stream_type_names[] = {
     (s) & GST_STREAM_TYPE_TEXT ? "text " : ""
 
 
-#if 0                           /* AUTOPLUG DISABLED */
-static void avelements_free (gpointer data);
-static GSequence *avelements_create (GstPlayBin3 * playbin,
-    gboolean isaudioelement);
-#endif
-
-/* The GstAudioVideoElement structure holding the audio/video decoder
- * and the audio/video sink factories together with field indicating
- * the number of common caps features */
-typedef struct
-{
-  GstElementFactory *dec;       /* audio:video decoder */
-  GstElementFactory *sink;      /* audio:video sink */
-  guint n_comm_cf;              /* number of common caps features */
-} GstAVElement;
-
 /* a structure to hold information about a uridecodebin pad */
 struct _SourcePad
 {
@@ -325,101 +302,10 @@ struct _SourcePad
   gulong event_probe_id;
 };
 
-/* a structure to hold the objects for decoding a uri and the subtitle uri
- */
-struct _GstSourceGroup
-{
-  GstPlayBin3 *playbin;
-
-  GMutex lock;
-
-  gboolean valid;               /* the group has valid info to start playback */
-  gboolean active;              /* the group is active */
-
-  gboolean playing;             /* the group is currently playing
-                                 * (outputted on the sinks) */
-
-  /* properties */
-  gchar *uri;
-  gchar *suburi;
-
-  /* The currently outputted group_id */
-  guint group_id;
-
-  /* Bit-wise set of stream types we have requested from uridecodebin3 */
-  GstStreamType selected_stream_types;
-
-  /* Bit-wise set of stream types for which pads are present */
-  GstStreamType present_stream_types;
-
-  /* TRUE if a 'about-to-finish' needs to be posted once we have
-   * got source pads for all requested stream types
-   *
-   * FIXME : Move this logic to uridecodebin3 later */
-  gboolean pending_about_to_finish;
-
-  /* uridecodebin to handle uri and suburi */
-  GstElement *uridecodebin;
-
-  /* Active sinks for each media type. These are initialized with
-   * the configured or currently used sink, otherwise
-   * left as NULL and playbin tries to automatically
-   * select a good sink */
-  GstElement *audio_sink;
-  GstElement *video_sink;
-  GstElement *text_sink;
-
-  /* List of source pads */
-  GList *source_pads;
-
-  /* uridecodebin signals */
-  gulong pad_added_id;
-  gulong pad_removed_id;
-  gulong select_stream_id;
-  gulong source_setup_id;
-  gulong about_to_finish_id;
-
-#if 0                           /* AUTOPLUG DISABLED */
-  gulong autoplug_factories_id;
-  gulong autoplug_select_id;
-  gulong autoplug_continue_id;
-  gulong autoplug_query_id;
-#endif
-
-  gboolean stream_changed_pending;
-
-  /* Active stream collection */
-  GstStreamCollection *collection;
-
-
-  /* buffering message stored for after switching */
-  GstMessage *pending_buffering_msg;
-};
-
 #define GST_PLAY_BIN3_GET_LOCK(bin) (&((GstPlayBin3*)(bin))->lock)
 #define GST_PLAY_BIN3_LOCK(bin) (g_rec_mutex_lock (GST_PLAY_BIN3_GET_LOCK(bin)))
 #define GST_PLAY_BIN3_UNLOCK(bin) (g_rec_mutex_unlock (GST_PLAY_BIN3_GET_LOCK(bin)))
 
-/* lock to protect dynamic callbacks, like no-more-pads */
-#define GST_PLAY_BIN3_DYN_LOCK(bin)    g_mutex_lock (&(bin)->dyn_lock)
-#define GST_PLAY_BIN3_DYN_UNLOCK(bin)  g_mutex_unlock (&(bin)->dyn_lock)
-
-/* lock for shutdown */
-#define GST_PLAY_BIN3_SHUTDOWN_LOCK(bin,label)			\
-  G_STMT_START {						\
-    if (G_UNLIKELY (g_atomic_int_get (&bin->shutdown)))		\
-      goto label;						\
-    GST_PLAY_BIN3_DYN_LOCK (bin);				\
-    if (G_UNLIKELY (g_atomic_int_get (&bin->shutdown))) {	\
-      GST_PLAY_BIN3_DYN_UNLOCK (bin);				\
-      goto label;						\
-    }								\
-  } G_STMT_END
-
-/* unlock for shutdown */
-#define GST_PLAY_BIN3_SHUTDOWN_UNLOCK(bin)	\
-  GST_PLAY_BIN3_DYN_UNLOCK (bin);		\
-
 /**
  * GstPlayBin3:
  *
@@ -429,19 +315,21 @@ struct _GstPlayBin3
 {
   GstPipeline parent;
 
-  GRecMutex lock;               /* to protect group switching */
+  GRecMutex lock;               /* to protect various properties */
+
+  /* uridecodebin to handle uri and suburi */
+  GstElement *uridecodebin;
+
+  /* List of SourcePad structures */
+  GList *source_pads;
 
-  /* the input groups, we use a double buffer to switch between current and next */
-  GstSourceGroup groups[2];     /* array with group info */
-  GstSourceGroup *curr_group;   /* pointer to the currently playing group */
-  GstSourceGroup *next_group;   /* pointer to the next group */
+  /* Active stream collection */
+  GstStreamCollection *collection;
 
   /* combiners for different streams */
   GstSourceCombine combiner[PLAYBIN_STREAM_LAST];
 
-  /* Bit-wise set of stream types we have requested from uridecodebin3.
-   * Calculated as the combination of the 'selected_stream_types' of
-   * each sourcegroup */
+  /* Bit-wise set of stream types we have requested from uridecodebin3. */
   GstStreamType selected_stream_types;
 
   /* Bit-wise set of configured output stream types (i.e. active
@@ -449,7 +337,6 @@ struct _GstPlayBin3
   GstStreamType active_stream_types;
 
   /* properties */
-  guint64 connection_speed;     /* connection speed in bits/sec (0 = unknown) */
   gint current_video;           /* the currently selected stream */
   gint current_audio;           /* the currently selected stream */
   gint current_text;            /* the currently selected stream */
@@ -457,8 +344,7 @@ struct _GstPlayBin3
   gboolean do_stream_selections;        /* Set to TRUE when any of current-{video|audio|text} are set to
                                            say playbin should do backwards-compatibility behaviours */
 
-  guint64 buffer_duration;      /* When buffering, the max buffer duration (ns) */
-  guint buffer_size;            /* When buffering, the max buffer size (bytes) */
+  GstObject *collection_source; /* The element that provided the latest stream collection */
   gboolean force_aspect_ratio;
 
   /* Multiview/stereoscopic overrides */
@@ -468,20 +354,8 @@ struct _GstPlayBin3
   /* our play sink */
   GstPlaySink *playsink;
 
-  /* Task for (de)activating groups, protected by the activation lock */
-  GstTask *activation_task;
-  GRecMutex activation_lock;
-
-  /* lock protecting dynamic adding/removing */
-  GMutex dyn_lock;
-  /* if we are shutting down or not */
-  gint shutdown;
   gboolean async_pending;       /* async-start has been emitted */
 
-  GMutex elements_lock;
-  guint32 elements_cookie;
-  GList *elements;              /* factories we can use for selecting elements */
-
   gboolean have_selector;       /* set to FALSE when we fail to create an
                                  * input-selector, so that we only post a
                                  * warning once */
@@ -504,14 +378,7 @@ struct _GstPlayBin3
   GstElement *video_stream_combiner;    /* configured video stream combiner, or NULL */
   GstElement *text_stream_combiner;     /* configured text stream combiner, or NULL */
 
-  GSequence *aelements;         /* a list of GstAVElements for audio stream */
-  GSequence *velements;         /* a list of GstAVElements for video stream */
-
-  guint64 ring_buffer_max_size; /* 0 means disabled */
-
-  gboolean is_live;             /* Whether our current group is live */
-
-  GMutex buffering_post_lock;   /* Protect serialisation of buffering messages. Must not acquire this while holding any SOURCE_GROUP lock */
+  gboolean is_live;             /* Whether we are live */
 };
 
 struct _GstPlayBin3Class
@@ -579,7 +446,8 @@ enum
   PROP_AUDIO_FILTER,
   PROP_VIDEO_FILTER,
   PROP_MULTIVIEW_MODE,
-  PROP_MULTIVIEW_FLAGS
+  PROP_MULTIVIEW_FLAGS,
+  PROP_INSTANT_URI
 };
 
 /* signals */
@@ -592,11 +460,6 @@ enum
   LAST_SIGNAL
 };
 
-#if 0                           /* AUTOPLUG DISABLED */
-static GstStaticCaps raw_audio_caps = GST_STATIC_CAPS ("audio/x-raw(ANY)");
-static GstStaticCaps raw_video_caps = GST_STATIC_CAPS ("video/x-raw(ANY)");
-#endif
-
 static void gst_play_bin3_finalize (GObject * object);
 
 static void gst_play_bin3_set_property (GObject * object, guint prop_id,
@@ -616,19 +479,22 @@ static gboolean gst_play_bin3_send_event (GstElement * element,
 static GstSample *gst_play_bin3_convert_sample (GstPlayBin3 * playbin,
     GstCaps * caps);
 
-static GstStateChangeReturn setup_next_source (GstPlayBin3 * playbin);
-
-static void gst_play_bin3_check_group_status (GstPlayBin3 * playbin);
-static void emit_about_to_finish (GstPlayBin3 * playbin);
 static void reconfigure_output (GstPlayBin3 * playbin);
-static void pad_removed_cb (GstElement * decodebin, GstPad * pad,
-    GstSourceGroup * group);
 
+/* uridecodebin3 signal callbacks */
+static void pad_added_cb (GstElement * uridecodebin, GstPad * pad,
+    GstPlayBin3 * playbin);
+static void pad_removed_cb (GstElement * decodebin, GstPad * pad,
+    GstPlayBin3 * playbin);
 static gint select_stream_cb (GstElement * decodebin,
     GstStreamCollection * collection, GstStream * stream,
-    GstSourceGroup * group);
+    GstPlayBin3 * playbin);
+static void source_setup_cb (GstElement * element, GstElement * source,
+    GstPlayBin3 * playbin);
+static void about_to_finish_cb (GstElement * uridecodebin,
+    GstPlayBin3 * playbin);
 
-static void do_stream_selection (GstPlayBin3 * playbin, GstSourceGroup * group);
+static void do_stream_selection (GstPlayBin3 * playbin);
 
 static GstElementClass *parent_class;
 
@@ -874,6 +740,7 @@ gst_play_bin3_class_init (GstPlayBin3Class * klass)
           "Buffer size when buffering network streams",
           -1, G_MAXINT, DEFAULT_BUFFER_SIZE,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   g_object_class_install_property (gobject_klass, PROP_BUFFER_DURATION,
       g_param_spec_int64 ("buffer-duration", "Buffer duration (ns)",
           "Buffer duration when buffering network streams",
@@ -962,6 +829,19 @@ gst_play_bin3_class_init (GstPlayBin3Class * klass)
           GST_TYPE_VIDEO_MULTIVIEW_FLAGS, GST_VIDEO_MULTIVIEW_FLAGS_NONE,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+  /**
+   * GstPlayBin3:instant-uri:
+   *
+   * Changes to uri are applied immediately, instead of on EOS or when the
+   * element is set back to PLAYING.
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_klass, PROP_INSTANT_URI,
+      g_param_spec_boolean ("instant-uri", "Instantaneous URI change",
+          "When enabled, URI changes are applied immediately", FALSE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   /**
    * GstPlayBin3::about-to-finish
    * @playbin: a #GstPlayBin3
@@ -1061,6 +941,8 @@ do_async_start (GstPlayBin3 * playbin)
 
   playbin->async_pending = TRUE;
 
+  GST_DEBUG_OBJECT (playbin, "posting ASYNC_START");
+
   message = gst_message_new_async_start (GST_OBJECT_CAST (playbin));
   GST_BIN_CLASS (parent_class)->handle_message (GST_BIN_CAST (playbin),
       message);
@@ -1107,10 +989,7 @@ init_combiners (GstPlayBin3 * playbin)
       g_ptr_array_new_with_free_func ((GDestroyNotify) gst_object_unref);
 }
 
-/* Update the combiner information to be in sync with the current collection
- *
- * FIXME : "current" collection doesn't mean anything until we have a "combined"
- *  collection of all groups */
+/* Update the combiner information to be in sync with the current collection */
 static void
 update_combiner_info (GstPlayBin3 * playbin, GstStreamCollection * collection)
 {
@@ -1157,57 +1036,6 @@ update_combiner_info (GstPlayBin3 * playbin, GstStreamCollection * collection)
       playbin->combiner[PLAYBIN_STREAM_TEXT].streams->len);
 }
 
-#ifndef GST_DISABLE_GST_DEBUG
-#define debug_groups(playbin) G_STMT_START {	\
-    guint i;					\
-    						\
-    for (i = 0; i < 2; i++) {				\
-      GstSourceGroup *group = &playbin->groups[i];	\
-      							\
-      GST_DEBUG ("GstSourceGroup #%d (%s) : %s", i, (group == playbin->curr_group) ? "current" : (group == playbin->next_group) ? "next" : "unused", \
-		 group->uridecodebin ? GST_ELEMENT_NAME (group->uridecodebin) : "NULL" ); \
-      GST_DEBUG ("  valid:%d , active:%d , playing:%d", group->valid, group->active, group->playing); \
-      GST_DEBUG ("  uri:%s", group->uri);				\
-      GST_DEBUG ("  suburi:%s", group->suburi);				\
-      GST_DEBUG ("  group_id:%d", group->group_id);			\
-      GST_DEBUG ("  pending_about_to_finish:%d", group->pending_about_to_finish); \
-    }									\
-  } G_STMT_END
-#else
-#define debug_groups(p) {}
-#endif
-
-static void
-init_group (GstPlayBin3 * playbin, GstSourceGroup * group)
-{
-  g_mutex_init (&group->lock);
-
-  group->stream_changed_pending = FALSE;
-  group->group_id = GST_GROUP_ID_INVALID;
-
-  group->playbin = playbin;
-}
-
-static void
-free_group (GstPlayBin3 * playbin, GstSourceGroup * group)
-{
-  g_free (group->uri);
-  g_free (group->suburi);
-
-  g_mutex_clear (&group->lock);
-  group->stream_changed_pending = FALSE;
-
-  if (group->pending_buffering_msg)
-    gst_message_unref (group->pending_buffering_msg);
-  group->pending_buffering_msg = NULL;
-
-  gst_object_replace ((GstObject **) & group->collection, NULL);
-
-  gst_object_replace ((GstObject **) & group->audio_sink, NULL);
-  gst_object_replace ((GstObject **) & group->video_sink, NULL);
-  gst_object_replace ((GstObject **) & group->text_sink, NULL);
-}
-
 static void
 notify_volume_cb (GObject * combiner, GParamSpec * pspec, GstPlayBin3 * playbin)
 {
@@ -1227,106 +1055,34 @@ colorbalance_value_changed_cb (GstColorBalance * balance,
   gst_color_balance_value_changed (GST_COLOR_BALANCE (playbin), channel, value);
 }
 
-#if 0                           /* AUTOPLUG DISABLED */
-static gint
-compare_factories_func (gconstpointer p1, gconstpointer p2)
-{
-  GstPluginFeature *f1, *f2;
-  gboolean is_sink1, is_sink2;
-  gboolean is_parser1, is_parser2;
-
-  f1 = (GstPluginFeature *) p1;
-  f2 = (GstPluginFeature *) p2;
-
-  is_sink1 = gst_element_factory_list_is_type (GST_ELEMENT_FACTORY_CAST (f1),
-      GST_ELEMENT_FACTORY_TYPE_SINK);
-  is_sink2 = gst_element_factory_list_is_type (GST_ELEMENT_FACTORY_CAST (f2),
-      GST_ELEMENT_FACTORY_TYPE_SINK);
-  is_parser1 = gst_element_factory_list_is_type (GST_ELEMENT_FACTORY_CAST (f1),
-      GST_ELEMENT_FACTORY_TYPE_PARSER);
-  is_parser2 = gst_element_factory_list_is_type (GST_ELEMENT_FACTORY_CAST (f2),
-      GST_ELEMENT_FACTORY_TYPE_PARSER);
-
-  /* First we want all sinks as we prefer a sink if it directly
-   * supports the current caps */
-  if (is_sink1 && !is_sink2)
-    return -1;
-  else if (!is_sink1 && is_sink2)
-    return 1;
-
-  /* Then we want all parsers as we always want to plug parsers
-   * before decoders */
-  if (is_parser1 && !is_parser2)
-    return -1;
-  else if (!is_parser1 && is_parser2)
-    return 1;
-
-  /* And if it's a both a parser or sink we first sort by rank
-   * and then by factory name */
-  return gst_plugin_feature_rank_compare_func (p1, p2);
-}
-
-/* Must be called with elements lock! */
-static void
-gst_play_bin3_update_elements_list (GstPlayBin3 * playbin)
-{
-  GList *res, *tmp;
-  guint cookie;
-
-  cookie = gst_registry_get_feature_list_cookie (gst_registry_get ());
-
-  if (!playbin->elements || playbin->elements_cookie != cookie) {
-    if (playbin->elements)
-      gst_plugin_feature_list_free (playbin->elements);
-    res =
-        gst_element_factory_list_get_elements
-        (GST_ELEMENT_FACTORY_TYPE_DECODABLE, GST_RANK_MARGINAL);
-    tmp =
-        gst_element_factory_list_get_elements
-        (GST_ELEMENT_FACTORY_TYPE_AUDIOVIDEO_SINKS, GST_RANK_MARGINAL);
-    playbin->elements = g_list_concat (res, tmp);
-    playbin->elements = g_list_sort (playbin->elements, compare_factories_func);
-  }
-
-  if (!playbin->aelements || playbin->elements_cookie != cookie) {
-    if (playbin->aelements)
-      g_sequence_free (playbin->aelements);
-    playbin->aelements = avelements_create (playbin, TRUE);
-  }
-
-  if (!playbin->velements || playbin->elements_cookie != cookie) {
-    if (playbin->velements)
-      g_sequence_free (playbin->velements);
-    playbin->velements = avelements_create (playbin, FALSE);
-  }
-
-  playbin->elements_cookie = cookie;
-}
-#endif
-
 static void
 gst_play_bin3_init (GstPlayBin3 * playbin)
 {
   g_rec_mutex_init (&playbin->lock);
-  g_mutex_init (&playbin->dyn_lock);
-
-  g_mutex_init (&playbin->buffering_post_lock);
 
   /* assume we can create an input-selector */
   playbin->have_selector = TRUE;
 
   init_combiners (playbin);
 
-  /* init groups */
-  playbin->curr_group = &playbin->groups[0];
-  playbin->next_group = &playbin->groups[1];
-  init_group (playbin, &playbin->groups[0]);
-  init_group (playbin, &playbin->groups[1]);
-
-  /* first filter out the interesting element factories */
-  g_mutex_init (&playbin->elements_lock);
-
-  g_rec_mutex_init (&playbin->activation_lock);
+  /* Create uridecodebin3 */
+  playbin->uridecodebin =
+      gst_element_factory_make ("uridecodebin3", "uridecodebin3");
+  /* Set default property (based on default flags value) */
+  g_object_set (playbin->uridecodebin, "use-buffering", TRUE, NULL);
+  gst_bin_add (GST_BIN_CAST (playbin),
+      GST_ELEMENT_CAST (playbin->uridecodebin));
+
+  g_signal_connect (playbin->uridecodebin, "pad-added",
+      G_CALLBACK (pad_added_cb), playbin);
+  g_signal_connect (playbin->uridecodebin, "pad-removed",
+      G_CALLBACK (pad_removed_cb), playbin);
+  g_signal_connect (playbin->uridecodebin, "select-stream",
+      G_CALLBACK (select_stream_cb), playbin);
+  g_signal_connect (playbin->uridecodebin, "source-setup",
+      G_CALLBACK (source_setup_cb), playbin);
+  g_signal_connect (playbin->uridecodebin, "about-to-finish",
+      G_CALLBACK (about_to_finish_cb), playbin);
 
   /* add sink */
   playbin->playsink =
@@ -1346,10 +1102,6 @@ gst_play_bin3_init (GstPlayBin3 * playbin)
   playbin->current_audio = DEFAULT_CURRENT_AUDIO;
   playbin->current_text = DEFAULT_CURRENT_TEXT;
 
-  playbin->buffer_duration = DEFAULT_BUFFER_DURATION;
-  playbin->buffer_size = DEFAULT_BUFFER_SIZE;
-  playbin->ring_buffer_max_size = DEFAULT_RING_BUFFER_MAX_SIZE;
-
   playbin->force_aspect_ratio = TRUE;
 
   playbin->multiview_mode = GST_VIDEO_MULTIVIEW_FRAME_PACKING_NONE;
@@ -1365,9 +1117,6 @@ gst_play_bin3_finalize (GObject * object)
 
   playbin = GST_PLAY_BIN3 (object);
 
-  free_group (playbin, &playbin->groups[0]);
-  free_group (playbin, &playbin->groups[1]);
-
   /* Setting states to NULL is safe here because playsink
    * will already be gone and none of these sinks will be
    * a child of playsink
@@ -1405,22 +1154,8 @@ gst_play_bin3_finalize (GObject * object)
   g_ptr_array_free (playbin->combiner[PLAYBIN_STREAM_TEXT].streams, TRUE);
   g_ptr_array_free (playbin->combiner[PLAYBIN_STREAM_TEXT].inputpads, TRUE);
 
-  if (playbin->elements)
-    gst_plugin_feature_list_free (playbin->elements);
-
-  if (playbin->aelements)
-    g_sequence_free (playbin->aelements);
-
-  if (playbin->velements)
-    g_sequence_free (playbin->velements);
-
-  g_rec_mutex_clear (&playbin->activation_lock);
   g_rec_mutex_clear (&playbin->lock);
 
-  g_mutex_clear (&playbin->buffering_post_lock);
-  g_mutex_clear (&playbin->dyn_lock);
-  g_mutex_clear (&playbin->elements_lock);
-
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
@@ -1455,9 +1190,12 @@ invalid:
 static void
 gst_play_bin3_set_uri (GstPlayBin3 * playbin, const gchar * uri)
 {
-  GstSourceGroup *group;
+  if (uri == NULL) {
+    g_warning ("cannot set NULL uri");
+    return;
+  }
 
-  if (uri && !gst_playbin_uri_is_valid (playbin, uri)) {
+  if (!gst_playbin_uri_is_valid (playbin, uri)) {
     if (g_str_has_prefix (uri, "file:")) {
       GST_WARNING_OBJECT (playbin, "not entirely correct file URI '%s' - make "
           "sure to escape spaces and non-ASCII characters properly and specify "
@@ -1468,41 +1206,17 @@ gst_play_bin3_set_uri (GstPlayBin3 * playbin, const gchar * uri)
     }
   }
 
-  GST_PLAY_BIN3_LOCK (playbin);
-  group = playbin->next_group;
-
-  GST_SOURCE_GROUP_LOCK (group);
-  /* store the uri in the next group we will play */
-  g_free (group->uri);
-  if (uri) {
-    group->uri = g_strdup (uri);
-    group->valid = TRUE;
-  } else {
-    group->uri = NULL;
-    group->valid = FALSE;
-  }
-  GST_SOURCE_GROUP_UNLOCK (group);
+  g_object_set (playbin->uridecodebin, "uri", uri, NULL);
 
   GST_DEBUG ("set new uri to %s", GST_STR_NULL (uri));
-  GST_PLAY_BIN3_UNLOCK (playbin);
 }
 
 static void
 gst_play_bin3_set_suburi (GstPlayBin3 * playbin, const gchar * suburi)
 {
-  GstSourceGroup *group;
-
-  GST_PLAY_BIN3_LOCK (playbin);
-  group = playbin->next_group;
-
-  GST_SOURCE_GROUP_LOCK (group);
-  g_free (group->suburi);
-  group->suburi = g_strdup (suburi);
-  GST_SOURCE_GROUP_UNLOCK (group);
+  g_object_set (playbin->uridecodebin, "suburi", suburi, NULL);
 
   GST_DEBUG ("setting new .sub uri to %s", suburi);
-
-  GST_PLAY_BIN3_UNLOCK (playbin);
 }
 
 static void
@@ -1515,32 +1229,12 @@ gst_play_bin3_set_flags (GstPlayBin3 * playbin, GstPlayFlags flags)
     gst_play_sink_set_flags (playbin->playsink, flags);
     gst_play_sink_reconfigure (playbin->playsink);
   }
+  g_object_set (playbin->uridecodebin, "download",
+      ((flags & GST_PLAY_FLAG_DOWNLOAD) != 0),
+      /* configure buffering of demuxed/parsed data */
+      "use-buffering", ((flags & GST_PLAY_FLAG_BUFFERING) != 0), NULL);
 }
 
-static GstPlayFlags
-gst_play_bin3_get_flags (GstPlayBin3 * playbin)
-{
-  GstPlayFlags flags;
-
-  flags = gst_play_sink_get_flags (playbin->playsink);
-
-  return flags;
-}
-
-/* get the currently playing group or if nothing is playing, the next
- * group. Must be called with the PLAY_BIN_LOCK. */
-static GstSourceGroup *
-get_group (GstPlayBin3 * playbin)
-{
-  GstSourceGroup *result;
-
-  if (!(result = playbin->curr_group))
-    result = playbin->next_group;
-
-  return result;
-}
-
-
 static GstSample *
 gst_play_bin3_convert_sample (GstPlayBin3 * playbin, GstCaps * caps)
 {
@@ -1588,10 +1282,10 @@ gst_play_bin3_set_current_stream (GstPlayBin3 * playbin,
   GST_DEBUG_OBJECT (playbin, "Changing current %s stream %d -> %d",
       stream_type_names[stream_type], *current_value, stream);
 
-  if (combine->combiner == NULL || combine->is_concat) {
+  if (combine->combiner == NULL) {
     /* FIXME: Check that the current_value is within range */
     *current_value = stream;
-    do_stream_selection (playbin, playbin->curr_group);
+    do_stream_selection (playbin);
     GST_PLAY_BIN3_UNLOCK (playbin);
     return TRUE;
   }
@@ -1743,14 +1437,6 @@ gst_play_bin3_set_property (GObject * object, guint prop_id,
       break;
     case PROP_FLAGS:
       gst_play_bin3_set_flags (playbin, g_value_get_flags (value));
-      if (playbin->curr_group) {
-        GST_SOURCE_GROUP_LOCK (playbin->curr_group);
-        if (playbin->curr_group->uridecodebin) {
-          g_object_set (playbin->curr_group->uridecodebin, "download",
-              (g_value_get_flags (value) & GST_PLAY_FLAG_DOWNLOAD) != 0, NULL);
-        }
-        GST_SOURCE_GROUP_UNLOCK (playbin->curr_group);
-      }
       break;
     case PROP_SUBTITLE_ENCODING:
       gst_play_bin3_set_encoding (playbin, g_value_get_string (value));
@@ -1803,14 +1489,17 @@ gst_play_bin3_set_property (GObject * object, guint prop_id,
       break;
     case PROP_CONNECTION_SPEED:
       GST_PLAY_BIN3_LOCK (playbin);
-      playbin->connection_speed = g_value_get_uint64 (value) * 1000;
+      g_object_set_property ((GObject *) playbin->uridecodebin,
+          "connection-speed", value);
       GST_PLAY_BIN3_UNLOCK (playbin);
       break;
     case PROP_BUFFER_SIZE:
-      playbin->buffer_size = g_value_get_int (value);
+      g_object_set_property ((GObject *) playbin->uridecodebin, "buffer-size",
+          value);
       break;
     case PROP_BUFFER_DURATION:
-      playbin->buffer_duration = g_value_get_int64 (value);
+      g_object_set_property ((GObject *) playbin->uridecodebin,
+          "buffer-duration", value);
       break;
     case PROP_AV_OFFSET:
       gst_play_sink_set_av_offset (playbin->playsink,
@@ -1821,15 +1510,8 @@ gst_play_bin3_set_property (GObject * object, guint prop_id,
           g_value_get_int64 (value));
       break;
     case PROP_RING_BUFFER_MAX_SIZE:
-      playbin->ring_buffer_max_size = g_value_get_uint64 (value);
-      if (playbin->curr_group) {
-        GST_SOURCE_GROUP_LOCK (playbin->curr_group);
-        if (playbin->curr_group->uridecodebin) {
-          g_object_set (playbin->curr_group->uridecodebin,
-              "ring-buffer-max-size", playbin->ring_buffer_max_size, NULL);
-        }
-        GST_SOURCE_GROUP_UNLOCK (playbin->curr_group);
-      }
+      g_object_set_property ((GObject *) playbin->uridecodebin,
+          "ring-buffer-max-size", value);
       break;
     case PROP_FORCE_ASPECT_RATIO:
       g_object_set (playbin->playsink, "force-aspect-ratio",
@@ -1845,6 +1527,10 @@ gst_play_bin3_set_property (GObject * object, guint prop_id,
       playbin->multiview_flags = g_value_get_flags (value);
       GST_PLAY_BIN3_UNLOCK (playbin);
       break;
+    case PROP_INSTANT_URI:
+      g_object_set_property ((GObject *) playbin->uridecodebin,
+          "instant-uri", value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1871,25 +1557,6 @@ gst_play_bin3_get_current_sink (GstPlayBin3 * playbin, GstElement ** elem,
   return sink;
 }
 
-static GstElement *
-gst_play_bin3_get_current_stream_combiner (GstPlayBin3 * playbin,
-    GstElement ** elem, const gchar * dbg, int stream_type)
-{
-  GstElement *combiner;
-
-  GST_PLAY_BIN3_LOCK (playbin);
-  /* The special concat element should never be returned */
-  if (playbin->combiner[stream_type].is_concat)
-    combiner = NULL;
-  else if ((combiner = playbin->combiner[stream_type].combiner))
-    gst_object_ref (combiner);
-  else if ((combiner = *elem))
-    gst_object_ref (combiner);
-  GST_PLAY_BIN3_UNLOCK (playbin);
-
-  return combiner;
-}
-
 static void
 gst_play_bin3_get_property (GObject * object, guint prop_id, GValue * value,
     GParamSpec * pspec)
@@ -1899,46 +1566,37 @@ gst_play_bin3_get_property (GObject * object, guint prop_id, GValue * value,
   switch (prop_id) {
     case PROP_URI:
     {
-      GstSourceGroup *group;
-
       GST_PLAY_BIN3_LOCK (playbin);
-      group = playbin->next_group;
-      g_value_set_string (value, group->uri);
+      g_object_get_property ((GObject *) playbin->uridecodebin, "uri", value);
       GST_PLAY_BIN3_UNLOCK (playbin);
       break;
     }
     case PROP_CURRENT_URI:
     {
-      GstSourceGroup *group;
-
       GST_PLAY_BIN3_LOCK (playbin);
-      group = get_group (playbin);
-      g_value_set_string (value, group->uri);
+      g_object_get_property ((GObject *) playbin->uridecodebin, "current-uri",
+          value);
       GST_PLAY_BIN3_UNLOCK (playbin);
       break;
     }
     case PROP_SUBURI:
     {
-      GstSourceGroup *group;
-
       GST_PLAY_BIN3_LOCK (playbin);
-      group = playbin->next_group;
-      g_value_set_string (value, group->suburi);
+      g_object_get_property ((GObject *) playbin->uridecodebin, "suburi",
+          value);
       GST_PLAY_BIN3_UNLOCK (playbin);
       break;
     }
     case PROP_CURRENT_SUBURI:
     {
-      GstSourceGroup *group;
-
       GST_PLAY_BIN3_LOCK (playbin);
-      group = get_group (playbin);
-      g_value_set_string (value, group->suburi);
+      g_object_get_property ((GObject *) playbin->uridecodebin,
+          "current-suburi", value);
       GST_PLAY_BIN3_UNLOCK (playbin);
       break;
     }
     case PROP_FLAGS:
-      g_value_set_flags (value, gst_play_bin3_get_flags (playbin));
+      g_value_set_flags (value, gst_play_sink_get_flags (playbin->playsink));
       break;
     case PROP_SUBTITLE_ENCODING:
       GST_PLAY_BIN3_LOCK (playbin);
@@ -1976,19 +1634,13 @@ gst_play_bin3_get_property (GObject * object, guint prop_id, GValue * value,
               "text", GST_PLAY_SINK_TYPE_TEXT));
       break;
     case PROP_VIDEO_STREAM_COMBINER:
-      g_value_take_object (value,
-          gst_play_bin3_get_current_stream_combiner (playbin,
-              &playbin->video_stream_combiner, "video", PLAYBIN_STREAM_VIDEO));
+      g_value_set_object (value, playbin->video_stream_combiner);
       break;
     case PROP_AUDIO_STREAM_COMBINER:
-      g_value_take_object (value,
-          gst_play_bin3_get_current_stream_combiner (playbin,
-              &playbin->audio_stream_combiner, "audio", PLAYBIN_STREAM_AUDIO));
+      g_value_set_object (value, playbin->audio_stream_combiner);
       break;
     case PROP_TEXT_STREAM_COMBINER:
-      g_value_take_object (value,
-          gst_play_bin3_get_current_stream_combiner (playbin,
-              &playbin->text_stream_combiner, "text", PLAYBIN_STREAM_TEXT));
+      g_value_set_object (value, playbin->text_stream_combiner);
       break;
     case PROP_VOLUME:
       g_value_set_double (value, gst_play_sink_get_volume (playbin->playsink));
@@ -2006,17 +1658,20 @@ gst_play_bin3_get_property (GObject * object, guint prop_id, GValue * value,
       break;
     case PROP_CONNECTION_SPEED:
       GST_PLAY_BIN3_LOCK (playbin);
-      g_value_set_uint64 (value, playbin->connection_speed / 1000);
+      g_object_get_property ((GObject *) playbin->uridecodebin,
+          "connection-speed", value);
       GST_PLAY_BIN3_UNLOCK (playbin);
       break;
     case PROP_BUFFER_SIZE:
       GST_OBJECT_LOCK (playbin);
-      g_value_set_int (value, playbin->buffer_size);
+      g_object_get_property ((GObject *) playbin->uridecodebin, "buffer-size",
+          value);
       GST_OBJECT_UNLOCK (playbin);
       break;
     case PROP_BUFFER_DURATION:
       GST_OBJECT_LOCK (playbin);
-      g_value_set_int64 (value, playbin->buffer_duration);
+      g_object_get_property ((GObject *) playbin->uridecodebin,
+          "buffer-duration", value);
       GST_OBJECT_UNLOCK (playbin);
       break;
     case PROP_AV_OFFSET:
@@ -2028,7 +1683,8 @@ gst_play_bin3_get_property (GObject * object, guint prop_id, GValue * value,
           gst_play_sink_get_text_offset (playbin->playsink));
       break;
     case PROP_RING_BUFFER_MAX_SIZE:
-      g_value_set_uint64 (value, playbin->ring_buffer_max_size);
+      g_object_get_property ((GObject *) playbin->uridecodebin,
+          "ring-buffer-max-size", value);
       break;
     case PROP_FORCE_ASPECT_RATIO:{
       gboolean v;
@@ -2047,6 +1703,10 @@ gst_play_bin3_get_property (GObject * object, guint prop_id, GValue * value,
       g_value_set_flags (value, playbin->multiview_flags);
       GST_OBJECT_UNLOCK (playbin);
       break;
+    case PROP_INSTANT_URI:
+      g_object_get_property ((GObject *) playbin->uridecodebin,
+          "instant-uri", value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -2108,8 +1768,7 @@ extend_list_of_streams (GstPlayBin3 * playbin, GstStreamType stype,
 }
 
 static GstEvent *
-update_select_streams_event (GstPlayBin3 * playbin, GstEvent * event,
-    GstSourceGroup * group)
+update_select_streams_event (GstPlayBin3 * playbin, GstEvent * event)
 {
   GList *streams = NULL;
   GList *to_use;
@@ -2123,9 +1782,9 @@ update_select_streams_event (GstPlayBin3 * playbin, GstEvent * event,
     return event;
   }
 
-  if (!group->collection) {
+  if (!playbin->collection) {
     GST_DEBUG_OBJECT (playbin,
-        "No stream collection for group, no need to modify SELECT_STREAMS event");
+        "No stream collection, no need to modify SELECT_STREAMS event");
     return event;
   }
 
@@ -2137,7 +1796,7 @@ update_select_streams_event (GstPlayBin3 * playbin, GstEvent * event,
   if (playbin->audio_stream_combiner) {
     to_use =
         extend_list_of_streams (playbin, GST_STREAM_TYPE_AUDIO, to_use,
-        group->collection);
+        playbin->collection);
     combine_id =
         get_combiner_stream_id (playbin,
         &playbin->combiner[PLAYBIN_STREAM_AUDIO], streams);
@@ -2147,7 +1806,7 @@ update_select_streams_event (GstPlayBin3 * playbin, GstEvent * event,
   if (playbin->video_stream_combiner) {
     to_use =
         extend_list_of_streams (playbin, GST_STREAM_TYPE_VIDEO, to_use,
-        group->collection);
+        playbin->collection);
     combine_id =
         get_combiner_stream_id (playbin,
         &playbin->combiner[PLAYBIN_STREAM_VIDEO], streams);
@@ -2157,7 +1816,7 @@ update_select_streams_event (GstPlayBin3 * playbin, GstEvent * event,
   if (playbin->text_stream_combiner) {
     to_use =
         extend_list_of_streams (playbin, GST_STREAM_TYPE_TEXT, to_use,
-        group->collection);
+        playbin->collection);
     combine_id =
         get_combiner_stream_id (playbin,
         &playbin->combiner[PLAYBIN_STREAM_TEXT], streams);
@@ -2176,57 +1835,6 @@ update_select_streams_event (GstPlayBin3 * playbin, GstEvent * event,
   return event;
 }
 
-/* Returns TRUE if the given list of streams belongs to the stream collection */
-static gboolean
-gst_streams_belong_to_collection (GList * streams,
-    GstStreamCollection * collection)
-{
-  GList *tmp;
-  guint i, nb;
-
-  if (streams == NULL || collection == NULL)
-    return FALSE;
-  nb = gst_stream_collection_get_size (collection);
-  if (nb == 0)
-    return FALSE;
-
-  for (tmp = streams; tmp; tmp = tmp->next) {
-    const gchar *cand = (const gchar *) tmp->data;
-    gboolean found = FALSE;
-
-    for (i = 0; i < nb; i++) {
-      GstStream *stream = gst_stream_collection_get_stream (collection, i);
-      if (!g_strcmp0 (cand, gst_stream_get_stream_id (stream))) {
-        found = TRUE;
-        break;
-      }
-    }
-    if (!found)
-      return FALSE;
-  }
-  return TRUE;
-}
-
-static GstSourceGroup *
-get_source_group_for_streams (GstPlayBin3 * playbin, GstEvent * event)
-{
-  GList *streams;
-  GstSourceGroup *res = NULL;
-
-  gst_event_parse_select_streams (event, &streams);
-  if (playbin->curr_group->collection &&
-      gst_streams_belong_to_collection (streams,
-          playbin->curr_group->collection))
-    res = playbin->curr_group;
-  else if (playbin->next_group->collection &&
-      gst_streams_belong_to_collection (streams,
-          playbin->next_group->collection))
-    res = playbin->next_group;
-  g_list_free_full (streams, g_free);
-
-  return res;
-}
-
 static gboolean
 gst_play_bin3_send_event (GstElement * element, GstEvent * event)
 {
@@ -2234,7 +1842,6 @@ gst_play_bin3_send_event (GstElement * element, GstEvent * event)
 
   if (GST_EVENT_TYPE (event) == GST_EVENT_SELECT_STREAMS) {
     gboolean res;
-    GstSourceGroup *group;
 
     GST_PLAY_BIN3_LOCK (playbin);
     GST_LOG_OBJECT (playbin,
@@ -2242,25 +1849,17 @@ gst_play_bin3_send_event (GstElement * element, GstEvent * event)
     /* This is probably already false, but it doesn't hurt to be sure */
     playbin->do_stream_selections = FALSE;
 
-    group = get_source_group_for_streams (playbin, event);
-    if (group == NULL) {
-      GST_WARNING_OBJECT (playbin,
-          "Can't figure out to which uridecodebin the select-streams event should be sent to");
-      GST_PLAY_BIN3_UNLOCK (playbin);
-      return FALSE;
-    }
-
     /* If we have custom combiners, we need to extend the selection with
      * the list of all streams for that given type since we will be handling
      * the selection with that combiner */
-    event = update_select_streams_event (playbin, event, group);
+    event = update_select_streams_event (playbin, event);
 
     /* Don't reconfigure playsink just yet, until the streams-selected
      * message(s) tell us as streams become active / available */
 
     /* Send this event directly to uridecodebin, so it works even
      * if uridecodebin didn't add any pads yet */
-    res = gst_element_send_event (group->uridecodebin, event);
+    res = gst_element_send_event (playbin->uridecodebin, event);
     GST_PLAY_BIN3_UNLOCK (playbin);
 
     return res;
@@ -2284,7 +1883,7 @@ gst_play_bin3_send_event (GstElement * element, GstEvent * event)
 
 /* Called with playbin lock held */
 static void
-do_stream_selection (GstPlayBin3 * playbin, GstSourceGroup * group)
+do_stream_selection (GstPlayBin3 * playbin)
 {
   GstStreamCollection *collection;
   guint i, nb_streams;
@@ -2292,10 +1891,7 @@ do_stream_selection (GstPlayBin3 * playbin, GstSourceGroup * group)
   gint nb_video = 0, nb_audio = 0, nb_text = 0;
   GstStreamType chosen_stream_types = 0;
 
-  if (group == NULL)
-    return;
-
-  collection = group->collection;
+  collection = playbin->collection;
   if (collection == NULL) {
     GST_LOG_OBJECT (playbin, "No stream collection. Not doing stream-select");
     return;
@@ -2361,168 +1957,43 @@ do_stream_selection (GstPlayBin3 * playbin, GstSourceGroup * group)
   }
 
   if (streams) {
-    if (group->uridecodebin) {
-      GstEvent *ev = gst_event_new_select_streams (streams);
-      gst_element_send_event (group->uridecodebin, ev);
-    }
+    GstEvent *ev = gst_event_new_select_streams (streams);
+    gst_element_send_event ((GstElement *) playbin->collection_source, ev);
     g_list_free (streams);
   }
 
-  group->selected_stream_types = chosen_stream_types;
-  /* Update global selected_stream_types */
-  playbin->selected_stream_types =
-      playbin->groups[0].selected_stream_types | playbin->groups[1].
-      selected_stream_types;
+  playbin->selected_stream_types = chosen_stream_types;
   if (playbin->active_stream_types != playbin->selected_stream_types)
     reconfigure_output (playbin);
 }
 
-/* Return the GstSourceGroup to which this element belongs
- * Can be NULL (if it belongs to playsink for example) */
-static GstSourceGroup *
-find_source_group_owner (GstPlayBin3 * playbin, GstObject * element)
-{
-  if (playbin->curr_group->uridecodebin
-      && gst_object_has_as_ancestor (element,
-          GST_OBJECT_CAST (playbin->curr_group->uridecodebin)))
-    return playbin->curr_group;
-  if (playbin->next_group->uridecodebin
-      && gst_object_has_as_ancestor (element,
-          GST_OBJECT_CAST (playbin->next_group->uridecodebin)))
-    return playbin->next_group;
-  return NULL;
-}
-
 static void
 gst_play_bin3_handle_message (GstBin * bin, GstMessage * msg)
 {
   GstPlayBin3 *playbin = GST_PLAY_BIN3 (bin);
   gboolean do_reset_time = FALSE;
 
-  if (GST_MESSAGE_TYPE (msg) == GST_MESSAGE_STREAM_START) {
-    GstSourceGroup *group = NULL, *other_group = NULL;
-    gboolean changed = FALSE;
-    guint group_id;
-    GstMessage *buffering_msg;
-
-    if (!gst_message_parse_group_id (msg, &group_id)) {
-      GST_ERROR_OBJECT (bin,
-          "Could not get group_id from STREAM_START message !");
-      goto beach;
-    }
-    GST_DEBUG_OBJECT (bin, "STREAM_START group_id:%u", group_id);
-
-    /* Figure out to which group this group_id corresponds */
-    GST_PLAY_BIN3_LOCK (playbin);
-    if (playbin->groups[0].group_id == group_id) {
-      group = &playbin->groups[0];
-      other_group = &playbin->groups[1];
-    } else if (playbin->groups[1].group_id == group_id) {
-      group = &playbin->groups[1];
-      other_group = &playbin->groups[0];
-    }
-    if (group == NULL) {
-      GST_ERROR_OBJECT (bin, "group_id %u is not provided by any group !",
-          group_id);
-      GST_PLAY_BIN3_UNLOCK (playbin);
-      goto beach;
-    }
-
-    debug_groups (playbin);
-
-    /* Do the switch now ! */
-    playbin->curr_group = group;
-    playbin->next_group = other_group;
-
-    /* we may need to serialise a buffering
-     * message, and need to take that lock
-     * before any source group lock, so
-     * do that now */
-    g_mutex_lock (&playbin->buffering_post_lock);
-
-    GST_SOURCE_GROUP_LOCK (group);
-    if (group->playing == FALSE)
-      changed = TRUE;
-    group->playing = TRUE;
-
-    buffering_msg = group->pending_buffering_msg;
-    group->pending_buffering_msg = NULL;
-
-    GST_SOURCE_GROUP_UNLOCK (group);
-
-    GST_SOURCE_GROUP_LOCK (other_group);
-    other_group->playing = FALSE;
-    GST_SOURCE_GROUP_UNLOCK (other_group);
-
-    debug_groups (playbin);
-    GST_PLAY_BIN3_UNLOCK (playbin);
-    if (changed)
-      gst_play_bin3_check_group_status (playbin);
-    else
-      GST_DEBUG_OBJECT (bin, "Groups didn't changed");
-
-    /* If there was a pending buffering message to send, do it now */
-    if (buffering_msg)
-      GST_BIN_CLASS (parent_class)->handle_message (bin, buffering_msg);
-
-    g_mutex_unlock (&playbin->buffering_post_lock);
-
-  } else if (GST_MESSAGE_TYPE (msg) == GST_MESSAGE_BUFFERING) {
-    GstSourceGroup *group;
-
-    /* Only post buffering messages for group which is currently playing */
-    GST_PLAY_BIN3_LOCK (playbin);
-    group = find_source_group_owner (playbin, msg->src);
-    if (group->active) {
-      g_mutex_lock (&playbin->buffering_post_lock);
-
-      GST_SOURCE_GROUP_LOCK (group);
-      GST_PLAY_BIN3_UNLOCK (playbin);
-
-      if (!group->playing) {
-        GST_DEBUG_OBJECT (playbin,
-            "Storing buffering message from pending group " "%p %"
-            GST_PTR_FORMAT, group, msg);
-        gst_message_replace (&group->pending_buffering_msg, msg);
-        gst_message_unref (msg);
-        msg = NULL;
-      } else {
-        /* Ensure there's no cached buffering message for this group */
-        gst_message_replace (&group->pending_buffering_msg, NULL);
-      }
-      GST_SOURCE_GROUP_UNLOCK (group);
-
-      if (msg != NULL) {
-        GST_BIN_CLASS (parent_class)->handle_message (bin, msg);
-        msg = NULL;
-      }
-      g_mutex_unlock (&playbin->buffering_post_lock);
-    } else {
-      GST_PLAY_BIN3_UNLOCK (playbin);
-    }
-  } else if (GST_MESSAGE_TYPE (msg) == GST_MESSAGE_STREAM_COLLECTION) {
+  if (GST_MESSAGE_TYPE (msg) == GST_MESSAGE_STREAM_COLLECTION) {
     GstStreamCollection *collection = NULL;
 
     gst_message_parse_stream_collection (msg, &collection);
 
     if (collection) {
       gboolean pstate = playbin->do_stream_selections;
-      GstSourceGroup *target_group = NULL;
 
       GST_PLAY_BIN3_LOCK (playbin);
       GST_DEBUG_OBJECT (playbin,
           "STREAM_COLLECTION: Got a collection from %" GST_PTR_FORMAT,
           msg->src);
-      target_group = find_source_group_owner (playbin, msg->src);
-      if (target_group)
-        gst_object_replace ((GstObject **) & target_group->collection,
-            (GstObject *) collection);
-      /* FIXME: Only do the following if it's the current group? */
-      if (target_group == playbin->curr_group)
-        update_combiner_info (playbin, target_group->collection);
+      gst_object_replace ((GstObject **) & playbin->collection,
+          (GstObject *) collection);
+      gst_object_replace ((GstObject **) & playbin->collection_source,
+          (GstObject *) GST_MESSAGE_SRC (msg));
+
+      update_combiner_info (playbin, playbin->collection);
       if (pstate)
         playbin->do_stream_selections = FALSE;
-      do_stream_selection (playbin, target_group);
+      do_stream_selection (playbin);
       if (pstate)
         playbin->do_stream_selections = TRUE;
       GST_PLAY_BIN3_UNLOCK (playbin);
@@ -2534,34 +2005,26 @@ gst_play_bin3_handle_message (GstBin * bin, GstMessage * msg)
       do_reset_time = TRUE;
     }
   } else if (GST_MESSAGE_TYPE (msg) == GST_MESSAGE_STREAMS_SELECTED) {
-    GstSourceGroup *target_group;
+    GstStreamType selected_types = 0;
+    guint i, nb;
 
     GST_PLAY_BIN3_LOCK (playbin);
 
-    target_group = find_source_group_owner (playbin, msg->src);
-    if (target_group) {
-      GstStreamType selected_types = 0;
-      guint i, nb;
-      nb = gst_message_streams_selected_get_size (msg);
-      for (i = 0; i < nb; i++) {
-        GstStream *stream = gst_message_streams_selected_get_stream (msg, i);
-        selected_types |= gst_stream_get_stream_type (stream);
-        gst_object_unref (stream);
-      }
-      target_group->selected_stream_types = selected_types;
-      playbin->selected_stream_types =
-          playbin->groups[0].selected_stream_types | playbin->groups[1].
-          selected_stream_types;
-      if (playbin->active_stream_types != playbin->selected_stream_types) {
-        GST_DEBUG_OBJECT (playbin,
-            "selected stream types changed, reconfiguring output");
-        reconfigure_output (playbin);
-      }
+    nb = gst_message_streams_selected_get_size (msg);
+    for (i = 0; i < nb; i++) {
+      GstStream *stream = gst_message_streams_selected_get_stream (msg, i);
+      selected_types |= gst_stream_get_stream_type (stream);
+      gst_object_unref (stream);
+    }
+    playbin->selected_stream_types = selected_types;
+    if (playbin->active_stream_types != playbin->selected_stream_types) {
+      GST_DEBUG_OBJECT (playbin,
+          "selected stream types changed, reconfiguring output");
+      reconfigure_output (playbin);
     }
     GST_PLAY_BIN3_UNLOCK (playbin);
   }
 
-beach:
   if (msg)
     GST_BIN_CLASS (parent_class)->handle_message (bin, msg);
 
@@ -2725,28 +2188,12 @@ update_video_multiview_caps (GstPlayBin3 * playbin, GstCaps * caps)
   return out_caps;
 }
 
-static void
-emit_about_to_finish (GstPlayBin3 * playbin)
-{
-  GST_DEBUG_OBJECT (playbin, "Emitting about-to-finish");
-
-  /* after this call, we should have a next group to activate or we EOS */
-  g_signal_emit (G_OBJECT (playbin),
-      gst_play_bin3_signals[SIGNAL_ABOUT_TO_FINISH], 0, NULL);
-
-  debug_groups (playbin);
-
-  /* now activate the next group. If the app did not set a uri, this will
-   * fail and we can do EOS */
-  setup_next_source (playbin);
-}
-
 static SourcePad *
-find_source_pad (GstSourceGroup * group, GstPad * target)
+find_source_pad (GstPlayBin3 * playbin, GstPad * target)
 {
   GList *tmp;
 
-  for (tmp = group->source_pads; tmp; tmp = tmp->next) {
+  for (tmp = playbin->source_pads; tmp; tmp = tmp->next) {
     SourcePad *res = (SourcePad *) tmp->data;
     if (res->pad == target)
       return res;
@@ -2755,11 +2202,10 @@ find_source_pad (GstSourceGroup * group, GstPad * target)
 }
 
 static GstPadProbeReturn
-_decodebin_event_probe (GstPad * pad, GstPadProbeInfo * info, gpointer udata)
+_decodebin_event_probe (GstPad * pad, GstPadProbeInfo * info,
+    GstPlayBin3 * playbin)
 {
   GstPadProbeReturn ret = GST_PAD_PROBE_OK;
-  GstSourceGroup *group = (GstSourceGroup *) udata;
-  GstPlayBin3 *playbin = group->playbin;
   GstEvent *event = GST_PAD_PROBE_INFO_DATA (info);
 
   switch (GST_EVENT_TYPE (event)) {
@@ -2783,21 +2229,6 @@ _decodebin_event_probe (GstPad * pad, GstPadProbeInfo * info, gpointer udata)
       }
       break;
     }
-    case GST_EVENT_STREAM_START:
-    {
-      guint group_id;
-      if (gst_event_parse_group_id (event, &group_id)) {
-        GST_LOG_OBJECT (pad, "STREAM_START group_id:%u", group_id);
-        if (group->group_id == GST_GROUP_ID_INVALID)
-          group->group_id = group_id;
-        else if (group->group_id != group_id) {
-          GST_DEBUG_OBJECT (pad, "group_id changing from %u to %u",
-              group->group_id, group_id);
-          group->group_id = group_id;
-        }
-      }
-      break;
-    }
     default:
       break;
   }
@@ -2806,7 +2237,7 @@ _decodebin_event_probe (GstPad * pad, GstPadProbeInfo * info, gpointer udata)
 }
 
 static void
-control_source_pad (GstSourceGroup * group, GstPad * pad,
+control_source_pad (GstPlayBin3 * playbin, GstPad * pad,
     GstPad * combine_pad, GstStreamType stream_type)
 {
   SourcePad *sourcepad = g_slice_new0 (SourcePad);
@@ -2814,10 +2245,10 @@ control_source_pad (GstSourceGroup * group, GstPad * pad,
   sourcepad->pad = pad;
   sourcepad->event_probe_id =
       gst_pad_add_probe (pad, GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM,
-      _decodebin_event_probe, group, NULL);
+      (GstPadProbeCallback) _decodebin_event_probe, playbin, NULL);
   sourcepad->stream_type = stream_type;
   sourcepad->combine_sinkpad = combine_pad;
-  group->source_pads = g_list_append (group->source_pads, sourcepad);
+  playbin->source_pads = g_list_append (playbin->source_pads, sourcepad);
 }
 
 static void
@@ -2865,32 +2296,21 @@ create_combiner (GstPlayBin3 * playbin, GstSourceCombine * combine)
   combine->combiner = custom_combiner;
 
   if (!combine->combiner) {
-    gchar *concat_name;
-    GST_DEBUG_OBJECT (playbin,
-        "No custom combiner requested, using 'concat' element");
-    concat_name =
-        g_strdup_printf ("%s-concat",
-        gst_stream_type_get_name (combine->stream_type));
-    combine->combiner = gst_element_factory_make ("concat", concat_name);
-    g_object_set (combine->combiner, "adjust-base", FALSE, NULL);
-    g_free (concat_name);
-    combine->is_concat = TRUE;
+    GST_DEBUG_OBJECT (playbin, "No custom combiner requested");
+    return;
   }
 
   combine->srcpad = gst_element_get_static_pad (combine->combiner, "src");
 
   /* We only want to use 'active-pad' if it's a regular combiner that
-   * will consume all streams, and not concat (which is just used for
-   * gapless) */
-  if (!combine->is_concat) {
-    combine->has_active_pad =
-        g_object_class_find_property (G_OBJECT_GET_CLASS (combine->combiner),
-        "active-pad") != NULL;
-
-    if (combine->has_active_pad)
-      g_signal_connect (combine->combiner, "notify::active-pad",
-          G_CALLBACK (combiner_active_pad_changed), playbin);
-  }
+   * will consume all streams */
+  combine->has_active_pad =
+      g_object_class_find_property (G_OBJECT_GET_CLASS (combine->combiner),
+      "active-pad") != NULL;
+
+  if (combine->has_active_pad)
+    g_signal_connect (combine->combiner, "notify::active-pad",
+        G_CALLBACK (combiner_active_pad_changed), playbin);
 
   GST_DEBUG_OBJECT (playbin, "adding new stream combiner %" GST_PTR_FORMAT,
       combine->combiner);
@@ -2973,17 +2393,13 @@ failed_combiner_link:
   return NULL;
 }
 
-
-/* Call after pad was unlinked from (potential) combiner */
 static void
-release_source_pad (GstPlayBin3 * playbin, GstSourceGroup * group,
+release_source_pad (GstPlayBin3 * playbin,
     GstSourceCombine * combine, GstPad * pad)
 {
   SourcePad *sourcepad;
-  GList *tmp;
-  GstStreamType alltype = 0;
 
-  sourcepad = find_source_pad (group, pad);
+  sourcepad = find_source_pad (playbin, pad);
   if (!sourcepad) {
     GST_DEBUG_OBJECT (playbin, "Not a pad controlled by us ?");
     return;
@@ -3001,32 +2417,22 @@ release_source_pad (GstPlayBin3 * playbin, GstSourceGroup * group,
   }
 
   /* Remove from list of controlled pads and check again for EOS status */
-  group->source_pads = g_list_remove (group->source_pads, sourcepad);
+  playbin->source_pads = g_list_remove (playbin->source_pads, sourcepad);
   g_slice_free (SourcePad, sourcepad);
-
-  /* Update present stream types */
-  for (tmp = group->source_pads; tmp; tmp = tmp->next) {
-    SourcePad *cand = (SourcePad *) tmp->data;
-    alltype |= cand->stream_type;
-  }
-  group->present_stream_types = alltype;
 }
 
 /* this function is called when a new pad is added to decodebin. We check the
  * type of the pad and add it to the combiner element
  */
 static void
-pad_added_cb (GstElement * uridecodebin, GstPad * pad, GstSourceGroup * group)
+pad_added_cb (GstElement * uridecodebin, GstPad * pad, GstPlayBin3 * playbin)
 {
   GstSourceCombine *combine = NULL;
   gint pb_stream_type = -1;
   gchar *pad_name;
-  GstPlayBin3 *playbin = group->playbin;
   GstPad *combine_pad;
   GstStreamType selected, active, cur;
 
-  GST_PLAY_BIN3_SHUTDOWN_LOCK (playbin, shutdown);
-
   pad_name = gst_object_get_name (GST_OBJECT (pad));
 
   GST_DEBUG_OBJECT (playbin, "decoded pad %s:%s added",
@@ -3050,7 +2456,6 @@ pad_added_cb (GstElement * uridecodebin, GstPad * pad, GstSourceGroup * group)
   /* no stream type found for the media type, don't bother linking it to a
    * combiner. This will leave the pad unlinked and thus ignored. */
   if (pb_stream_type < 0) {
-    GST_PLAY_BIN3_SHUTDOWN_UNLOCK (playbin);
     goto unknown_type;
   }
 
@@ -3071,54 +2476,27 @@ pad_added_cb (GstElement * uridecodebin, GstPad * pad, GstSourceGroup * group)
         GST_DEBUG_PAD_NAME (pad));
     playbin->selected_stream_types = selected;
     reconfigure_output (playbin);
-
-    /* shutdown state can be changed meantime then combiner will not be
-     * configured */
-    if (g_atomic_int_get (&playbin->shutdown)) {
-      GST_PLAY_BIN3_UNLOCK (playbin);
-      GST_PLAY_BIN3_SHUTDOWN_UNLOCK (playbin);
-      return;
-    }
   }
 
   combine_pad = combiner_control_pad (playbin, combine, pad);
+  control_source_pad (playbin, pad, combine_pad, combine->stream_type);
 
-  control_source_pad (group, pad, combine_pad, combine->stream_type);
-
-  /* Update present stream_types and check whether we should post a pending about-to-finish */
-  group->present_stream_types |= combine->stream_type;
-
-  if (group->playing && group->pending_about_to_finish
-      && group->present_stream_types == group->selected_stream_types) {
-    group->pending_about_to_finish = FALSE;
-    emit_about_to_finish (playbin);
-  }
   GST_PLAY_BIN3_UNLOCK (playbin);
 
-  GST_PLAY_BIN3_SHUTDOWN_UNLOCK (playbin);
-
   return;
 
   /* ERRORS */
 unknown_type:
   GST_DEBUG_OBJECT (playbin, "Ignoring pad with unknown type");
   return;
-
-shutdown:
-  {
-    GST_DEBUG ("ignoring, we are shutting down. Pad will be left unlinked");
-    /* not going to done as we didn't request the caps */
-    return;
-  }
 }
 
 /* called when a pad is removed from the decodebin. We unlink the pad from
  * the combiner. */
 static void
-pad_removed_cb (GstElement * decodebin, GstPad * pad, GstSourceGroup * group)
+pad_removed_cb (GstElement * decodebin, GstPad * pad, GstPlayBin3 * playbin)
 {
   GstSourceCombine *combine;
-  GstPlayBin3 *playbin = group->playbin;
 
   GST_DEBUG_OBJECT (playbin,
       "decoded pad %s:%s removed", GST_DEBUG_PAD_NAME (pad));
@@ -3135,7 +2513,7 @@ pad_removed_cb (GstElement * decodebin, GstPad * pad, GstSourceGroup * group)
   else
     goto done;
 
-  release_source_pad (playbin, group, combine, pad);
+  release_source_pad (playbin, combine, pad);
 
 done:
   GST_PLAY_BIN3_UNLOCK (playbin);
@@ -3144,11 +2522,10 @@ done:
 
 static gint
 select_stream_cb (GstElement * decodebin, GstStreamCollection * collection,
-    GstStream * stream, GstSourceGroup * group)
+    GstStream * stream, GstPlayBin3 * playbin)
 {
   GstStreamType stype = gst_stream_get_stream_type (stream);
   GstElement *combiner = NULL;
-  GstPlayBin3 *playbin = group->playbin;
 
   if (stype & GST_STREAM_TYPE_AUDIO)
     combiner = playbin->audio_stream_combiner;
@@ -3226,16 +2603,11 @@ reconfigure_output (GstPlayBin3 * playbin)
       }
 
       /* Release combiner */
-      GST_FIXME_OBJECT (playbin, "Release combiner");
       remove_combiner (playbin, combine);
     } else if (!is_active && is_selected) {
       GST_DEBUG_OBJECT (playbin, "Stream type '%s' is now requested",
           gst_stream_type_get_name (combine->stream_type));
 
-      /* If we are shutting down, do *not* add more combiners */
-      if (g_atomic_int_get (&playbin->shutdown))
-        continue;
-
       g_assert (combine->sinkpad == NULL);
 
       /* Request playsink sink pad */
@@ -3276,1817 +2648,117 @@ reconfigure_output (GstPlayBin3 * playbin)
 }
 
 static void
-about_to_finish_cb (GstElement * uridecodebin, GstSourceGroup * group)
+about_to_finish_cb (GstElement * uridecodebin, GstPlayBin3 * playbin)
 {
-  GstPlayBin3 *playbin = group->playbin;
-  GST_DEBUG_OBJECT (playbin, "about to finish in group %p", group);
+  GST_DEBUG_OBJECT (playbin, "about to finish");
 
   GST_LOG_OBJECT (playbin, "selected_stream_types:%" STREAM_TYPES_FORMAT,
-      STREAM_TYPES_ARGS (group->selected_stream_types));
-  GST_LOG_OBJECT (playbin, "present_stream_types:%" STREAM_TYPES_FORMAT,
-      STREAM_TYPES_ARGS (group->present_stream_types));
-
-  if (group->selected_stream_types == 0
-      || (group->selected_stream_types != group->present_stream_types)) {
-    GST_LOG_OBJECT (playbin,
-        "Delaying emission of signal until this group is ready");
-    group->pending_about_to_finish = TRUE;
-  } else
-    emit_about_to_finish (playbin);
-}
-
-#if 0                           /* AUTOPLUG DISABLED */
-/* Like gst_element_factory_can_sink_any_caps() but doesn't
- * allow ANY caps on the sinkpad template */
-static gboolean
-_factory_can_sink_caps (GstElementFactory * factory, GstCaps * caps)
-{
-  const GList *templs;
-
-  templs = gst_element_factory_get_static_pad_templates (factory);
-
-  while (templs) {
-    GstStaticPadTemplate *templ = (GstStaticPadTemplate *) templs->data;
-
-    if (templ->direction == GST_PAD_SINK) {
-      GstCaps *templcaps = gst_static_caps_get (&templ->static_caps);
+      STREAM_TYPES_ARGS (playbin->selected_stream_types));
 
-      if (!gst_caps_is_any (templcaps)
-          && gst_caps_is_subset (caps, templcaps)) {
-        gst_caps_unref (templcaps);
-        return TRUE;
-      }
-      gst_caps_unref (templcaps);
-    }
-    templs = g_list_next (templs);
-  }
+  GST_DEBUG_OBJECT (playbin, "Emitting about-to-finish");
 
-  return FALSE;
+  /* after this call, we should have a next group to activate or we EOS */
+  g_signal_emit (G_OBJECT (playbin),
+      gst_play_bin3_signals[SIGNAL_ABOUT_TO_FINISH], 0, NULL);
 }
 
 static void
-avelements_free (gpointer avelement)
-{
-  GstAVElement *elm = (GstAVElement *) avelement;
-
-  if (elm->dec)
-    gst_object_unref (elm->dec);
-  if (elm->sink)
-    gst_object_unref (elm->sink);
-  g_slice_free (GstAVElement, elm);
-}
-
-static gint
-avelement_compare_decoder (gconstpointer p1, gconstpointer p2,
-    gpointer user_data)
-{
-  GstAVElement *v1, *v2;
-
-  v1 = (GstAVElement *) p1;
-  v2 = (GstAVElement *) p2;
-
-  return strcmp (GST_OBJECT_NAME (v1->dec), GST_OBJECT_NAME (v2->dec));
-}
-
-static gint
-avelement_lookup_decoder (gconstpointer p1, gconstpointer p2,
-    gpointer user_data)
-{
-  GstAVElement *v1;
-  GstElementFactory *f2;
-
-  v1 = (GstAVElement *) p1;
-  f2 = (GstElementFactory *) p2;
-
-  return strcmp (GST_OBJECT_NAME (v1->dec), GST_OBJECT_NAME (f2));
-}
-
-static gint
-avelement_compare (gconstpointer p1, gconstpointer p2)
-{
-  GstAVElement *v1, *v2;
-  GstPluginFeature *fd1, *fd2, *fs1, *fs2;
-  gint64 diff, v1_rank, v2_rank;
-
-  v1 = (GstAVElement *) p1;
-  v2 = (GstAVElement *) p2;
-
-  fd1 = (GstPluginFeature *) v1->dec;
-  fd2 = (GstPluginFeature *) v2->dec;
-
-  /* If both have a sink, we also compare their ranks */
-  if (v1->sink && v2->sink) {
-    fs1 = (GstPluginFeature *) v1->sink;
-    fs2 = (GstPluginFeature *) v2->sink;
-    v1_rank = (gint64) gst_plugin_feature_get_rank (fd1) *
-        gst_plugin_feature_get_rank (fs1);
-    v2_rank = (gint64) gst_plugin_feature_get_rank (fd2) *
-        gst_plugin_feature_get_rank (fs2);
-  } else {
-    v1_rank = gst_plugin_feature_get_rank (fd1);
-    v2_rank = gst_plugin_feature_get_rank (fd2);
-    fs1 = fs2 = NULL;
-  }
-
-  /* comparison based on the rank */
-  diff = v2_rank - v1_rank;
-  if (diff < 0)
-    return -1;
-  else if (diff > 0)
-    return 1;
-
-  /* comparison based on number of common caps features */
-  diff = v2->n_comm_cf - v1->n_comm_cf;
-  if (diff != 0)
-    return diff;
-
-  if (fs1 && fs2) {
-    /* comparison based on the name of sink elements */
-    diff = strcmp (GST_OBJECT_NAME (fs1), GST_OBJECT_NAME (fs2));
-    if (diff != 0)
-      return diff;
-  }
-
-  /* comparison based on the name of decoder elements */
-  return strcmp (GST_OBJECT_NAME (fd1), GST_OBJECT_NAME (fd2));
-}
-
-static GSequence *
-avelements_create (GstPlayBin3 * playbin, gboolean isaudioelement)
-{
-  GstElementFactory *d_factory, *s_factory;
-  GList *dec_list, *sink_list, *dl, *sl;
-  GSequence *ave_seq = NULL;
-  GstAVElement *ave;
-  guint n_common_cf = 0;
-
-  if (isaudioelement) {
-    sink_list = gst_element_factory_list_get_elements
-        (GST_ELEMENT_FACTORY_TYPE_SINK |
-        GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO, GST_RANK_MARGINAL);
-    dec_list =
-        gst_element_factory_list_get_elements (GST_ELEMENT_FACTORY_TYPE_DECODER
-        | GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO, GST_RANK_MARGINAL);
-  } else {
-    sink_list = gst_element_factory_list_get_elements
-        (GST_ELEMENT_FACTORY_TYPE_SINK |
-        GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO |
-        GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE, GST_RANK_MARGINAL);
-
-    dec_list =
-        gst_element_factory_list_get_elements (GST_ELEMENT_FACTORY_TYPE_DECODER
-        | GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO |
-        GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE, GST_RANK_MARGINAL);
-  }
-
-  /* create a list of audio/video elements. Each element in the list
-   * is holding an audio/video decoder and an audio/video sink in which
-   * the decoders srcpad template caps and sink element's sinkpad template
-   * caps are compatible */
-  dl = dec_list;
-  sl = sink_list;
-
-  ave_seq = g_sequence_new ((GDestroyNotify) avelements_free);
-
-  for (; dl; dl = dl->next) {
-    d_factory = (GstElementFactory *) dl->data;
-    for (; sl; sl = sl->next) {
-      s_factory = (GstElementFactory *) sl->data;
-
-      n_common_cf =
-          gst_playback_utils_get_n_common_capsfeatures (d_factory, s_factory,
-          gst_play_bin3_get_flags (playbin), isaudioelement);
-      if (n_common_cf < 1)
-        continue;
-
-      ave = g_slice_new (GstAVElement);
-      ave->dec = gst_object_ref (d_factory);
-      ave->sink = gst_object_ref (s_factory);
-      ave->n_comm_cf = n_common_cf;
-      g_sequence_append (ave_seq, ave);
-    }
-    sl = sink_list;
-  }
-  g_sequence_sort (ave_seq, (GCompareDataFunc) avelement_compare_decoder, NULL);
-
-  gst_plugin_feature_list_free (dec_list);
-  gst_plugin_feature_list_free (sink_list);
-
-  return ave_seq;
-}
-
-static gboolean
-avelement_iter_is_equal (GSequenceIter * iter, GstElementFactory * factory)
-{
-  GstAVElement *ave;
-
-  if (!iter)
-    return FALSE;
-
-  ave = g_sequence_get (iter);
-  if (!ave)
-    return FALSE;
-
-  return strcmp (GST_OBJECT_NAME (ave->dec), GST_OBJECT_NAME (factory)) == 0;
-}
-
-static GList *
-create_decoders_list (GList * factory_list, GSequence * avelements)
-{
-  GList *dec_list = NULL, *tmp;
-  GList *ave_list = NULL;
-  GList *ave_free_list = NULL;
-  GstAVElement *ave, *best_ave;
-
-  g_return_val_if_fail (factory_list != NULL, NULL);
-  g_return_val_if_fail (avelements != NULL, NULL);
-
-  for (tmp = factory_list; tmp; tmp = tmp->next) {
-    GstElementFactory *factory = (GstElementFactory *) tmp->data;
-
-    /* if there are parsers or sink elements, add them first */
-    if (gst_element_factory_list_is_type (factory,
-            GST_ELEMENT_FACTORY_TYPE_PARSER) ||
-        gst_element_factory_list_is_type (factory,
-            GST_ELEMENT_FACTORY_TYPE_SINK)) {
-      dec_list = g_list_prepend (dec_list, gst_object_ref (factory));
-    } else {
-      GSequenceIter *seq_iter;
-
-      seq_iter =
-          g_sequence_lookup (avelements, factory,
-          (GCompareDataFunc) avelement_lookup_decoder, NULL);
-      if (!seq_iter) {
-        GstAVElement *ave = g_slice_new0 (GstAVElement);
-
-        ave->dec = factory;
-        ave->sink = NULL;
-        /* There's at least raw */
-        ave->n_comm_cf = 1;
-
-        ave_list = g_list_prepend (ave_list, ave);
-
-        /* We need to free these later */
-        ave_free_list = g_list_prepend (ave_free_list, ave);
-        continue;
-      }
-
-      /* Go to first iter with that decoder */
-      do {
-        GSequenceIter *tmp_seq_iter;
-
-        tmp_seq_iter = g_sequence_iter_prev (seq_iter);
-        if (!avelement_iter_is_equal (tmp_seq_iter, factory))
-          break;
-        seq_iter = tmp_seq_iter;
-      } while (!g_sequence_iter_is_begin (seq_iter));
-
-      /* Get the best ranked GstAVElement for that factory */
-      best_ave = NULL;
-      while (!g_sequence_iter_is_end (seq_iter)
-          && avelement_iter_is_equal (seq_iter, factory)) {
-        ave = g_sequence_get (seq_iter);
-
-        if (!best_ave || avelement_compare (ave, best_ave) < 0)
-          best_ave = ave;
-
-        seq_iter = g_sequence_iter_next (seq_iter);
-      }
-      ave_list = g_list_prepend (ave_list, best_ave);
-    }
-  }
-
-  /* Sort all GstAVElements by their relative ranks and insert
-   * into the decoders list */
-  ave_list = g_list_sort (ave_list, (GCompareFunc) avelement_compare);
-  for (tmp = ave_list; tmp; tmp = tmp->next) {
-    ave = (GstAVElement *) tmp->data;
-    dec_list = g_list_prepend (dec_list, gst_object_ref (ave->dec));
-  }
-  g_list_free (ave_list);
-  gst_plugin_feature_list_free (factory_list);
-
-  for (tmp = ave_free_list; tmp; tmp = tmp->next)
-    g_slice_free (GstAVElement, tmp->data);
-  g_list_free (ave_free_list);
-
-  dec_list = g_list_reverse (dec_list);
-
-  return dec_list;
-}
-
-/* Called when we must provide a list of factories to plug to @pad with @caps.
- * We first check if we have a sink that can handle the format and if we do, we
- * return NULL, to expose the pad. If we have no sink (or the sink does not
- * work), we return the list of elements that can connect. */
-static GValueArray *
-autoplug_factories_cb (GstElement * decodebin, GstPad * pad,
-    GstCaps * caps, GstSourceGroup * group)
-{
-  GstPlayBin3 *playbin;
-  GList *factory_list, *tmp;
-  GValueArray *result;
-  gboolean unref_caps = FALSE;
-  gboolean isaudiodeclist = FALSE;
-  gboolean isvideodeclist = FALSE;
-
-  if (!caps) {
-    caps = gst_caps_new_any ();
-    unref_caps = TRUE;
-  }
-
-  playbin = group->playbin;
-
-  GST_DEBUG_OBJECT (playbin, "factories group %p for %s:%s, %" GST_PTR_FORMAT,
-      group, GST_DEBUG_PAD_NAME (pad), caps);
-
-  /* filter out the elements based on the caps. */
-  g_mutex_lock (&playbin->elements_lock);
-  gst_play_bin3_update_elements_list (playbin);
-  factory_list =
-      gst_element_factory_list_filter (playbin->elements, caps, GST_PAD_SINK,
-      gst_caps_is_fixed (caps));
-  g_mutex_unlock (&playbin->elements_lock);
-
-  GST_DEBUG_OBJECT (playbin, "found factories %p", factory_list);
-  GST_PLUGIN_FEATURE_LIST_DEBUG (factory_list);
-
-  /* check whether the caps are asking for a list of audio/video decoders */
-  tmp = factory_list;
-  if (!gst_caps_is_any (caps)) {
-    for (; tmp; tmp = tmp->next) {
-      GstElementFactory *factory = (GstElementFactory *) tmp->data;
-
-      isvideodeclist = gst_element_factory_list_is_type (factory,
-          GST_ELEMENT_FACTORY_TYPE_DECODER |
-          GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO |
-          GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE);
-      isaudiodeclist = gst_element_factory_list_is_type (factory,
-          GST_ELEMENT_FACTORY_TYPE_DECODER |
-          GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO);
-
-      if (isaudiodeclist || isvideodeclist)
-        break;
-    }
-  }
-
-  if (isaudiodeclist || isvideodeclist) {
-    GSequence **ave_list;
-    if (isaudiodeclist)
-      ave_list = &playbin->aelements;
-    else
-      ave_list = &playbin->velements;
-
-    g_mutex_lock (&playbin->elements_lock);
-    /* sort factory_list based on the GstAVElement list priority */
-    factory_list = create_decoders_list (factory_list, *ave_list);
-    g_mutex_unlock (&playbin->elements_lock);
-  }
-
-  /* 2 additional elements for the already set audio/video sinks */
-  result = g_value_array_new (g_list_length (factory_list) + 2);
-
-  /* Check if we already have an audio/video sink and if this is the case
-   * put it as the first element of the array */
-  if (group->audio_sink) {
-    GstElementFactory *factory = gst_element_get_factory (group->audio_sink);
-
-    if (factory && _factory_can_sink_caps (factory, caps)) {
-      GValue val = { 0, };
-
-      g_value_init (&val, G_TYPE_OBJECT);
-      g_value_set_object (&val, factory);
-      result = g_value_array_append (result, &val);
-      g_value_unset (&val);
-    }
-  }
-
-  if (group->video_sink) {
-    GstElementFactory *factory = gst_element_get_factory (group->video_sink);
-
-    if (factory && _factory_can_sink_caps (factory, caps)) {
-      GValue val = { 0, };
-
-      g_value_init (&val, G_TYPE_OBJECT);
-      g_value_set_object (&val, factory);
-      result = g_value_array_append (result, &val);
-      g_value_unset (&val);
-    }
-  }
-
-  for (tmp = factory_list; tmp; tmp = tmp->next) {
-    GstElementFactory *factory = GST_ELEMENT_FACTORY_CAST (tmp->data);
-    GValue val = { 0, };
-
-    if (group->audio_sink && gst_element_factory_list_is_type (factory,
-            GST_ELEMENT_FACTORY_TYPE_SINK |
-            GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO)) {
-      continue;
-    }
-    if (group->video_sink && gst_element_factory_list_is_type (factory,
-            GST_ELEMENT_FACTORY_TYPE_SINK | GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO
-            | GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE)) {
-      continue;
-    }
-
-    g_value_init (&val, G_TYPE_OBJECT);
-    g_value_set_object (&val, factory);
-    g_value_array_append (result, &val);
-    g_value_unset (&val);
-  }
-  gst_plugin_feature_list_free (factory_list);
-
-  if (unref_caps)
-    gst_caps_unref (caps);
-
-  return result;
-}
-#endif
-
-static GstBusSyncReply
-activate_sink_bus_handler (GstBus * bus, GstMessage * msg,
+source_setup_cb (GstElement * element, GstElement * source,
     GstPlayBin3 * playbin)
 {
-  if (GST_MESSAGE_TYPE (msg) == GST_MESSAGE_ERROR) {
-    /* Only proxy errors from a fixed sink. If that fails we can just error out
-     * early as stuff will fail later anyway */
-    if (playbin->audio_sink
-        && gst_object_has_as_ancestor (GST_MESSAGE_SRC (msg),
-            GST_OBJECT_CAST (playbin->audio_sink)))
-      gst_element_post_message (GST_ELEMENT_CAST (playbin), msg);
-    else if (playbin->video_sink
-        && gst_object_has_as_ancestor (GST_MESSAGE_SRC (msg),
-            GST_OBJECT_CAST (playbin->video_sink)))
-      gst_element_post_message (GST_ELEMENT_CAST (playbin), msg);
-    else if (playbin->text_sink
-        && gst_object_has_as_ancestor (GST_MESSAGE_SRC (msg),
-            GST_OBJECT_CAST (playbin->text_sink)))
-      gst_element_post_message (GST_ELEMENT_CAST (playbin), msg);
-    else
-      gst_message_unref (msg);
-  } else if (GST_MESSAGE_TYPE (msg) == GST_MESSAGE_HAVE_CONTEXT) {
-    GstContext *context;
-
-    gst_message_parse_have_context (msg, &context);
-    gst_element_set_context (GST_ELEMENT_CAST (playbin), context);
-    gst_context_unref (context);
-    gst_element_post_message (GST_ELEMENT_CAST (playbin), msg);
-  } else {
-    gst_element_post_message (GST_ELEMENT_CAST (playbin), msg);
-  }
-
-  /* Doesn't really matter, nothing is using this bus */
-  return GST_BUS_DROP;
-}
-
-static gboolean
-activate_sink (GstPlayBin3 * playbin, GstElement * sink, gboolean * activated)
-{
-  GstState state;
-  GstBus *bus = NULL;
-  GstStateChangeReturn sret;
-  gboolean ret = FALSE;
-
-  if (activated)
-    *activated = FALSE;
-
-  GST_OBJECT_LOCK (sink);
-  state = GST_STATE (sink);
-  GST_OBJECT_UNLOCK (sink);
-  if (state >= GST_STATE_READY) {
-    ret = TRUE;
-    goto done;
-  }
-
-  if (!GST_OBJECT_PARENT (sink)) {
-    bus = gst_bus_new ();
-    gst_bus_set_sync_handler (bus,
-        (GstBusSyncHandler) activate_sink_bus_handler, playbin, NULL);
-    gst_element_set_bus (sink, bus);
-  }
-
-  sret = gst_element_set_state (sink, GST_STATE_READY);
-  if (sret == GST_STATE_CHANGE_FAILURE)
-    goto done;
-
-  if (activated)
-    *activated = TRUE;
-  ret = TRUE;
-
-done:
-  if (bus) {
-    gst_element_set_bus (sink, NULL);
-    gst_object_unref (bus);
-  }
-
-  return ret;
-}
-
-#if 0                           /* AUTOPLUG DISABLED */
-/* autoplug-continue decides, if a pad has raw caps that can be exposed
- * directly or if further decoding is necessary. We use this to expose
- * supported subtitles directly */
-
-/* FIXME 0.11: Remove the checks for ANY caps, a sink should specify
- * explicitly the caps it supports and if it claims to support ANY
- * caps it really should support everything */
-static gboolean
-autoplug_continue_cb (GstElement * element, GstPad * pad, GstCaps * caps,
-    GstSourceGroup * group)
-{
-  gboolean ret = TRUE;
-  GstPad *sinkpad = NULL;
-  gboolean activated_sink;
-
-  GST_SOURCE_GROUP_LOCK (group);
-
-  if (group->text_sink &&
-      activate_sink (group->playbin, group->text_sink, &activated_sink)) {
-    sinkpad = gst_element_get_static_pad (group->text_sink, "sink");
-    if (sinkpad) {
-      GstCaps *sinkcaps;
-
-      sinkcaps = gst_pad_query_caps (sinkpad, NULL);
-      if (!gst_caps_is_any (sinkcaps))
-        ret = !gst_pad_query_accept_caps (sinkpad, caps);
-      gst_caps_unref (sinkcaps);
-      gst_object_unref (sinkpad);
-    }
-    if (activated_sink)
-      gst_element_set_state (group->text_sink, GST_STATE_NULL);
-  } else {
-    GstCaps *subcaps = gst_subtitle_overlay_create_factory_caps ();
-    ret = !gst_caps_is_subset (caps, subcaps);
-    gst_caps_unref (subcaps);
-  }
-  /* If autoplugging can stop don't do additional checks */
-  if (!ret)
-    goto done;
-
-  if (group->audio_sink &&
-      activate_sink (group->playbin, group->audio_sink, &activated_sink)) {
-
-    sinkpad = gst_element_get_static_pad (group->audio_sink, "sink");
-    if (sinkpad) {
-      GstCaps *sinkcaps;
-
-      sinkcaps = gst_pad_query_caps (sinkpad, NULL);
-      if (!gst_caps_is_any (sinkcaps))
-        ret = !gst_pad_query_accept_caps (sinkpad, caps);
-      gst_caps_unref (sinkcaps);
-      gst_object_unref (sinkpad);
-    }
-    if (activated_sink)
-      gst_element_set_state (group->audio_sink, GST_STATE_NULL);
-  }
-  if (!ret)
-    goto done;
-
-  if (group->video_sink
-      && activate_sink (group->playbin, group->video_sink, &activated_sink)) {
-    sinkpad = gst_element_get_static_pad (group->video_sink, "sink");
-    if (sinkpad) {
-      GstCaps *sinkcaps;
-
-      sinkcaps = gst_pad_query_caps (sinkpad, NULL);
-      if (!gst_caps_is_any (sinkcaps))
-        ret = !gst_pad_query_accept_caps (sinkpad, caps);
-      gst_caps_unref (sinkcaps);
-      gst_object_unref (sinkpad);
-    }
-    if (activated_sink)
-      gst_element_set_state (group->video_sink, GST_STATE_NULL);
-  }
-
-done:
-  GST_SOURCE_GROUP_UNLOCK (group);
-
-  GST_DEBUG_OBJECT (group->playbin,
-      "continue autoplugging group %p for %s:%s, %" GST_PTR_FORMAT ": %d",
-      group, GST_DEBUG_PAD_NAME (pad), caps, ret);
-
-  return ret;
+  g_signal_emit (playbin, gst_play_bin3_signals[SIGNAL_SOURCE_SETUP], 0,
+      source);
 }
 
 static gboolean
-sink_accepts_caps (GstPlayBin3 * playbin, GstElement * sink, GstCaps * caps)
+gst_play_bin3_start (GstPlayBin3 * playbin)
 {
-  GstPad *sinkpad;
+  GST_DEBUG_OBJECT (playbin, "starting");
 
-  if ((sinkpad = gst_element_get_static_pad (sink, "sink"))) {
-    /* Got the sink pad, now let's see if the element actually does accept the
-     * caps that we have */
-    if (!gst_pad_query_accept_caps (sinkpad, caps)) {
-      gst_object_unref (sinkpad);
-      return FALSE;
-    }
-    gst_object_unref (sinkpad);
-  }
+  GST_PLAY_BIN3_LOCK (playbin);
+  playbin->active_stream_types = 0;
+  playbin->selected_stream_types = 0;
+  do_async_start (playbin);
+  GST_PLAY_BIN3_UNLOCK (playbin);
 
   return TRUE;
 }
 
-/* We are asked to select an element. See if the next element to check
- * is a sink. If this is the case, we see if the sink works by setting it to
- * READY. If the sink works, we return SELECT_EXPOSE to make decodebin
- * expose the raw pad so that we can setup the mixers. */
-static GstAutoplugSelectResult
-autoplug_select_cb (GstElement * decodebin, GstPad * pad,
-    GstCaps * caps, GstElementFactory * factory, GstSourceGroup * group)
+static GstStateChangeReturn
+gst_play_bin3_change_state (GstElement * element, GstStateChange transition)
 {
+  GstStateChangeReturn ret;
   GstPlayBin3 *playbin;
-  GstElement *element;
-  const gchar *klass;
-  GstPlaySinkType type;
-  GstElement **sinkp;
-  GList *ave_list = NULL, *l;
-  GstAVElement *ave = NULL;
-  GSequence *ave_seq = NULL;
-  GSequenceIter *seq_iter;
-
-  playbin = group->playbin;
-
-  GST_DEBUG_OBJECT (playbin, "select group %p for %s:%s, %" GST_PTR_FORMAT,
-      group, GST_DEBUG_PAD_NAME (pad), caps);
-
-  GST_DEBUG_OBJECT (playbin, "checking factory %s", GST_OBJECT_NAME (factory));
-
-  /* if it's not a sink, we make sure the element is compatible with
-   * the fixed sink */
-  if (!gst_element_factory_list_is_type (factory,
-          GST_ELEMENT_FACTORY_TYPE_SINK)) {
-    gboolean isvideodec = gst_element_factory_list_is_type (factory,
-        GST_ELEMENT_FACTORY_TYPE_DECODER |
-        GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO |
-        GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE);
-    gboolean isaudiodec = gst_element_factory_list_is_type (factory,
-        GST_ELEMENT_FACTORY_TYPE_DECODER |
-        GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO);
-
-    if (!isvideodec && !isaudiodec)
-      return GST_AUTOPLUG_SELECT_TRY;
-
-    GST_SOURCE_GROUP_LOCK (group);
-    g_mutex_lock (&playbin->elements_lock);
-
-    if (isaudiodec) {
-      ave_seq = playbin->aelements;
-      sinkp = &group->audio_sink;
-    } else {
-      ave_seq = playbin->velements;
-      sinkp = &group->video_sink;
-    }
 
-    seq_iter =
-        g_sequence_lookup (ave_seq, factory,
-        (GCompareDataFunc) avelement_lookup_decoder, NULL);
-    if (seq_iter) {
-      /* Go to first iter with that decoder */
-      do {
-        GSequenceIter *tmp_seq_iter;
+  playbin = GST_PLAY_BIN3 (element);
 
-        tmp_seq_iter = g_sequence_iter_prev (seq_iter);
-        if (!avelement_iter_is_equal (tmp_seq_iter, factory))
-          break;
-        seq_iter = tmp_seq_iter;
-      } while (!g_sequence_iter_is_begin (seq_iter));
-
-      while (!g_sequence_iter_is_end (seq_iter)
-          && avelement_iter_is_equal (seq_iter, factory)) {
-        ave = g_sequence_get (seq_iter);
-        ave_list = g_list_prepend (ave_list, ave);
-        seq_iter = g_sequence_iter_next (seq_iter);
-      }
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      if (!gst_play_bin3_start (playbin))
+        return GST_STATE_CHANGE_FAILURE;
+      break;
+    default:
+      break;
+  }
 
-      /* Sort all GstAVElements by their relative ranks and insert
-       * into the decoders list */
-      ave_list = g_list_sort (ave_list, (GCompareFunc) avelement_compare);
-    } else {
-      ave_list = g_list_prepend (ave_list, NULL);
-    }
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+  if (ret == GST_STATE_CHANGE_FAILURE)
+    goto failure;
 
-    /* if it is a decoder and we don't have a fixed sink, then find out
-     * the matching audio/video sink from GstAVElements list */
-    for (l = ave_list; l; l = l->next) {
-      gboolean created_sink = FALSE;
-
-      ave = (GstAVElement *) l->data;
-
-      if (((isaudiodec && !group->audio_sink) ||
-              (isvideodec && !group->video_sink))) {
-        if (ave && ave->sink) {
-          GST_DEBUG_OBJECT (playbin,
-              "Trying to create sink '%s' for decoder '%s'",
-              gst_plugin_feature_get_name (GST_PLUGIN_FEATURE (ave->sink)),
-              gst_plugin_feature_get_name (GST_PLUGIN_FEATURE (factory)));
-          if ((*sinkp = gst_element_factory_create (ave->sink, NULL)) == NULL) {
-            GST_WARNING_OBJECT (playbin,
-                "Could not create an element from %s",
-                gst_plugin_feature_get_name (GST_PLUGIN_FEATURE (ave->sink)));
-            continue;
-          } else {
-            if (!activate_sink (playbin, *sinkp, NULL)) {
-              gst_object_unref (*sinkp);
-              *sinkp = NULL;
-              GST_WARNING_OBJECT (playbin,
-                  "Could not activate sink %s",
-                  gst_plugin_feature_get_name (GST_PLUGIN_FEATURE (ave->sink)));
-              continue;
-            }
-            gst_object_ref_sink (*sinkp);
-            created_sink = TRUE;
-          }
-        }
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      if (ret == GST_STATE_CHANGE_SUCCESS)
+        ret = GST_STATE_CHANGE_ASYNC;
+      break;
+    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+      do_async_done (playbin);
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      playbin->is_live = FALSE;
+      /* Make sure we reset our state  */
+      if (playbin->selected_stream_types) {
+        playbin->selected_stream_types = 0;
+        reconfigure_output (playbin);
       }
+      break;
+    case GST_STATE_CHANGE_READY_TO_NULL:
+    {
+      /* Set our sinks back to NULL, they might not be child of playbin */
+      if (playbin->audio_sink)
+        gst_element_set_state (playbin->audio_sink, GST_STATE_NULL);
+      if (playbin->video_sink)
+        gst_element_set_state (playbin->video_sink, GST_STATE_NULL);
+      if (playbin->text_sink)
+        gst_element_set_state (playbin->text_sink, GST_STATE_NULL);
 
-      /* If it is a decoder and we have a fixed sink for the media
-       * type it outputs, check that the decoder is compatible with this sink */
-      if ((isaudiodec && group->audio_sink) || (isvideodec
-              && group->video_sink)) {
-        gboolean compatible = FALSE;
-        GstPad *sinkpad;
-        GstCaps *caps;
-        GstElement *sink;
-
-        sink = *sinkp;
-
-        if ((sinkpad = gst_element_get_static_pad (sink, "sink"))) {
-          GstPlayFlags flags = gst_play_bin3_get_flags (playbin);
-          GstCaps *raw_caps =
-              (isaudiodec) ? gst_static_caps_get (&raw_audio_caps) :
-              gst_static_caps_get (&raw_video_caps);
-
-          caps = gst_pad_query_caps (sinkpad, NULL);
-
-          /* If the sink supports raw audio/video, we first check
-           * if the decoder could output any raw audio/video format
-           * and assume it is compatible with the sink then. We don't
-           * do a complete compatibility check here if converters
-           * are plugged between the decoder and the sink because
-           * the converters will convert between raw formats and
-           * even if the decoder format is not supported by the decoder
-           * a converter will convert it.
-           *
-           * We assume here that the converters can convert between
-           * any raw format.
-           */
-          if ((isaudiodec && !(flags & GST_PLAY_FLAG_NATIVE_AUDIO)
-                  && gst_caps_can_intersect (caps, raw_caps)) || (!isaudiodec
-                  && !(flags & GST_PLAY_FLAG_NATIVE_VIDEO)
-                  && gst_caps_can_intersect (caps, raw_caps))) {
-            compatible =
-                gst_element_factory_can_src_any_caps (factory, raw_caps)
-                || gst_element_factory_can_src_any_caps (factory, caps);
-          } else {
-            compatible = gst_element_factory_can_src_any_caps (factory, caps);
-          }
-
-          gst_object_unref (sinkpad);
-          gst_caps_unref (caps);
-        }
+      if (playbin->video_stream_combiner)
+        gst_element_set_state (playbin->video_stream_combiner, GST_STATE_NULL);
+      if (playbin->audio_stream_combiner)
+        gst_element_set_state (playbin->audio_stream_combiner, GST_STATE_NULL);
+      if (playbin->text_stream_combiner)
+        gst_element_set_state (playbin->text_stream_combiner, GST_STATE_NULL);
 
-        if (compatible)
-          break;
+      gst_object_replace ((GstObject **) & playbin->collection, NULL);
+      gst_object_replace ((GstObject **) & playbin->collection_source, NULL);
 
-        GST_DEBUG_OBJECT (playbin, "%s not compatible with the fixed sink",
-            GST_OBJECT_NAME (factory));
-
-        /* If it is not compatible, either continue with the next possible
-         * sink or if we have a fixed sink, skip the decoder */
-        if (created_sink) {
-          gst_element_set_state (*sinkp, GST_STATE_NULL);
-          gst_object_unref (*sinkp);
-          *sinkp = NULL;
-        } else {
-          g_mutex_unlock (&playbin->elements_lock);
-          GST_SOURCE_GROUP_UNLOCK (group);
-          return GST_AUTOPLUG_SELECT_SKIP;
-        }
-      }
+      break;
     }
-    g_list_free (ave_list);
-    g_mutex_unlock (&playbin->elements_lock);
-    GST_SOURCE_GROUP_UNLOCK (group);
-    return GST_AUTOPLUG_SELECT_TRY;
+    default:
+      break;
   }
 
-  /* it's a sink, see if an instance of it actually works */
-  GST_DEBUG_OBJECT (playbin, "we found a sink '%s'", GST_OBJECT_NAME (factory));
-
-  klass =
-      gst_element_factory_get_metadata (factory, GST_ELEMENT_METADATA_KLASS);
-
-  /* figure out the klass */
-  if (strstr (klass, "Audio")) {
-    GST_DEBUG_OBJECT (playbin, "we found an audio sink");
-    type = GST_PLAY_SINK_TYPE_AUDIO;
-    sinkp = &group->audio_sink;
-  } else if (strstr (klass, "Video")) {
-    GST_DEBUG_OBJECT (playbin, "we found a video sink");
-    type = GST_PLAY_SINK_TYPE_VIDEO;
-    sinkp = &group->video_sink;
-  } else {
-    /* unknown klass, skip this element */
-    GST_WARNING_OBJECT (playbin, "unknown sink klass %s found", klass);
-    return GST_AUTOPLUG_SELECT_SKIP;
-  }
+  if (GST_STATE_TRANSITION_NEXT (transition) == GST_STATE_PAUSED)
+    playbin->is_live = ret == GST_STATE_CHANGE_NO_PREROLL;
 
-  /* if we are asked to do visualisations and it's an audio sink, skip the
-   * element. We can only do visualisations with raw sinks */
-  if (gst_play_sink_get_flags (playbin->playsink) & GST_PLAY_FLAG_VIS) {
-    if (type == GST_PLAY_SINK_TYPE_AUDIO) {
-      GST_DEBUG_OBJECT (playbin, "skip audio sink because of vis");
-      return GST_AUTOPLUG_SELECT_SKIP;
-    }
-  }
+  if (ret == GST_STATE_CHANGE_NO_PREROLL)
+    do_async_done (playbin);
 
-  /* now see if we already have a sink element */
-  GST_SOURCE_GROUP_LOCK (group);
-  if (*sinkp && GST_STATE (*sinkp) >= GST_STATE_READY) {
-    GstElement *sink = gst_object_ref (*sinkp);
-
-    if (sink_accepts_caps (playbin, sink, caps)) {
-      GST_DEBUG_OBJECT (playbin,
-          "Existing sink '%s' accepts caps: %" GST_PTR_FORMAT,
-          GST_ELEMENT_NAME (sink), caps);
-      gst_object_unref (sink);
-      GST_SOURCE_GROUP_UNLOCK (group);
-      return GST_AUTOPLUG_SELECT_EXPOSE;
-    } else {
-      GST_DEBUG_OBJECT (playbin,
-          "Existing sink '%s' does not accept caps: %" GST_PTR_FORMAT,
-          GST_ELEMENT_NAME (sink), caps);
-      gst_object_unref (sink);
-      GST_SOURCE_GROUP_UNLOCK (group);
-      return GST_AUTOPLUG_SELECT_SKIP;
-    }
-  }
-  GST_DEBUG_OBJECT (playbin, "we have no pending sink, try to create '%s'",
-      gst_plugin_feature_get_name (GST_PLUGIN_FEATURE (factory)));
-
-  if ((*sinkp = gst_element_factory_create (factory, NULL)) == NULL) {
-    GST_WARNING_OBJECT (playbin, "Could not create an element from %s",
-        gst_plugin_feature_get_name (GST_PLUGIN_FEATURE (factory)));
-    GST_SOURCE_GROUP_UNLOCK (group);
-    return GST_AUTOPLUG_SELECT_SKIP;
-  }
-
-  element = *sinkp;
-
-  if (!activate_sink (playbin, element, NULL)) {
-    GST_WARNING_OBJECT (playbin, "Could not activate sink %s",
-        gst_plugin_feature_get_name (GST_PLUGIN_FEATURE (factory)));
-    *sinkp = NULL;
-    gst_object_unref (element);
-    GST_SOURCE_GROUP_UNLOCK (group);
-    return GST_AUTOPLUG_SELECT_SKIP;
-  }
-
-  /* Check if the selected sink actually supports the
-   * caps and can be set to READY*/
-  if (!sink_accepts_caps (playbin, element, caps)) {
-    *sinkp = NULL;
-    gst_element_set_state (element, GST_STATE_NULL);
-    gst_object_unref (element);
-    GST_SOURCE_GROUP_UNLOCK (group);
-    return GST_AUTOPLUG_SELECT_SKIP;
-  }
-
-  /* remember the sink in the group now, the element is floating, we take
-   * ownership now
-   *
-   * store the sink in the group, we will configure it later when we
-   * reconfigure the sink */
-  GST_DEBUG_OBJECT (playbin, "remember sink");
-  gst_object_ref_sink (element);
-  GST_SOURCE_GROUP_UNLOCK (group);
-
-  /* tell decodebin to expose the pad because we are going to use this
-   * sink */
-  GST_DEBUG_OBJECT (playbin, "we found a working sink, expose pad");
-
-  return GST_AUTOPLUG_SELECT_EXPOSE;
-}
-
-#define GST_PLAY_BIN3_FILTER_CAPS(filter,caps) G_STMT_START {                  \
-  if ((filter)) {                                                             \
-    GstCaps *intersection =                                                   \
-        gst_caps_intersect_full ((filter), (caps), GST_CAPS_INTERSECT_FIRST); \
-    gst_caps_unref ((caps));                                                  \
-    (caps) = intersection;                                                    \
-  }                                                                           \
-} G_STMT_END
-
-static gboolean
-autoplug_query_caps (GstElement * uridecodebin, GstPad * pad,
-    GstElement * element, GstQuery * query, GstSourceGroup * group)
-{
-  GstCaps *filter, *result = NULL;
-  GstElement *sink;
-  GstPad *sinkpad = NULL;
-  GstElementFactory *factory;
-  GstElementFactoryListType factory_type;
-  gboolean have_sink = FALSE;
-
-  GST_SOURCE_GROUP_LOCK (group);
-  gst_query_parse_caps (query, &filter);
-
-  factory = gst_element_get_factory (element);
-  if (!factory)
-    goto done;
-
-  if (gst_element_factory_list_is_type (factory,
-          GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO |
-          GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE)) {
-    factory_type =
-        GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO |
-        GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE;
-
-    if ((sink = group->video_sink)) {
-      sinkpad = gst_element_get_static_pad (sink, "sink");
-      if (sinkpad) {
-        GstCaps *sinkcaps;
-
-        sinkcaps = gst_pad_query_caps (sinkpad, filter);
-        if (!gst_caps_is_any (sinkcaps)) {
-          if (!result)
-            result = sinkcaps;
-          else
-            result = gst_caps_merge (result, sinkcaps);
-        } else {
-          gst_caps_unref (sinkcaps);
-        }
-        gst_object_unref (sinkpad);
-      }
-      have_sink = TRUE;
-    }
-  } else if (gst_element_factory_list_is_type (factory,
-          GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO)) {
-    factory_type = GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO;
-
-    if ((sink = group->audio_sink)) {
-      sinkpad = gst_element_get_static_pad (sink, "sink");
-      if (sinkpad) {
-        GstCaps *sinkcaps;
-
-        sinkcaps = gst_pad_query_caps (sinkpad, filter);
-        if (!gst_caps_is_any (sinkcaps)) {
-          if (!result)
-            result = sinkcaps;
-          else
-            result = gst_caps_merge (result, sinkcaps);
-        } else {
-          gst_caps_unref (sinkcaps);
-        }
-        gst_object_unref (sinkpad);
-      }
-      have_sink = TRUE;
-    }
-  } else if (gst_element_factory_list_is_type (factory,
-          GST_ELEMENT_FACTORY_TYPE_MEDIA_SUBTITLE)) {
-    factory_type = GST_ELEMENT_FACTORY_TYPE_MEDIA_SUBTITLE;
-
-    if ((sink = group->playbin->text_sink)) {
-      sinkpad = gst_element_get_static_pad (sink, "sink");
-      if (sinkpad) {
-        GstCaps *sinkcaps;
-
-        sinkcaps = gst_pad_query_caps (sinkpad, filter);
-        if (!gst_caps_is_any (sinkcaps)) {
-          if (!result)
-            result = sinkcaps;
-          else
-            result = gst_caps_merge (result, sinkcaps);
-        } else {
-          gst_caps_unref (sinkcaps);
-        }
-        gst_object_unref (sinkpad);
-      }
-      have_sink = TRUE;
-    } else {
-      GstCaps *subcaps = gst_subtitle_overlay_create_factory_caps ();
-      GST_PLAY_BIN3_FILTER_CAPS (filter, subcaps);
-      if (!result)
-        result = subcaps;
-      else
-        result = gst_caps_merge (result, subcaps);
-    }
-  } else {
-    goto done;
-  }
-
-  if (!have_sink) {
-    GValueArray *factories;
-    gint i, n;
-
-    factories = autoplug_factories_cb (uridecodebin, pad, NULL, group);
-    n = factories->n_values;
-    for (i = 0; i < n; i++) {
-      GValue *v = g_value_array_get_nth (factories, i);
-      GstElementFactory *f = g_value_get_object (v);
-      const GList *templates;
-      const GList *l;
-      GstCaps *templ_caps;
-
-      if (!gst_element_factory_list_is_type (f, factory_type))
-        continue;
-
-      templates = gst_element_factory_get_static_pad_templates (f);
-
-      for (l = templates; l; l = l->next) {
-        templ_caps = gst_static_pad_template_get_caps (l->data);
-
-        if (!gst_caps_is_any (templ_caps)) {
-          GST_PLAY_BIN3_FILTER_CAPS (filter, templ_caps);
-          if (!result)
-            result = templ_caps;
-          else
-            result = gst_caps_merge (result, templ_caps);
-        } else {
-          gst_caps_unref (templ_caps);
-        }
-      }
-    }
-    g_value_array_free (factories);
-  }
-
-done:
-  GST_SOURCE_GROUP_UNLOCK (group);
-
-  if (!result)
-    return FALSE;
-
-  /* Add the actual decoder/parser/etc caps at the very end to
-   * make sure we don't cause empty caps to be returned, e.g.
-   * if a parser asks us but a decoder is required after it
-   * because no sink can handle the format directly.
-   */
-  {
-    GstPad *target = gst_ghost_pad_get_target (GST_GHOST_PAD (pad));
-
-    if (target) {
-      GstCaps *target_caps = gst_pad_get_pad_template_caps (target);
-      GST_PLAY_BIN3_FILTER_CAPS (filter, target_caps);
-      if (!gst_caps_is_any (target_caps))
-        result = gst_caps_merge (result, target_caps);
-      gst_object_unref (target);
-    }
-  }
-
-
-  gst_query_set_caps_result (query, result);
-  gst_caps_unref (result);
-
-  return TRUE;
-}
-
-static gboolean
-autoplug_query_context (GstElement * uridecodebin, GstPad * pad,
-    GstElement * element, GstQuery * query, GstSourceGroup * group)
-{
-  GstElement *sink;
-  GstPad *sinkpad = NULL;
-  GstElementFactory *factory;
-  gboolean res = FALSE;
-
-  GST_SOURCE_GROUP_LOCK (group);
-
-  factory = gst_element_get_factory (element);
-  if (!factory)
-    goto done;
-
-  if (gst_element_factory_list_is_type (factory,
-          GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO |
-          GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE)) {
-    if ((sink = group->video_sink)) {
-      sinkpad = gst_element_get_static_pad (sink, "sink");
-      if (sinkpad) {
-        res = gst_pad_query (sinkpad, query);
-        gst_object_unref (sinkpad);
-      }
-    }
-  } else if (gst_element_factory_list_is_type (factory,
-          GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO)) {
-    if ((sink = group->audio_sink)) {
-      sinkpad = gst_element_get_static_pad (sink, "sink");
-      if (sinkpad) {
-        res = gst_pad_query (sinkpad, query);
-        gst_object_unref (sinkpad);
-      }
-    }
-  } else if (gst_element_factory_list_is_type (factory,
-          GST_ELEMENT_FACTORY_TYPE_MEDIA_SUBTITLE)) {
-    if ((sink = group->playbin->text_sink)) {
-      sinkpad = gst_element_get_static_pad (sink, "sink");
-      if (sinkpad) {
-        res = gst_pad_query (sinkpad, query);
-        gst_object_unref (sinkpad);
-      }
-    }
-  } else {
-    goto done;
-  }
-
-done:
-  GST_SOURCE_GROUP_UNLOCK (group);
-
-  return res;
-}
-
-static gboolean
-autoplug_query_cb (GstElement * uridecodebin, GstPad * pad,
-    GstElement * element, GstQuery * query, GstSourceGroup * group)
-{
-
-  switch (GST_QUERY_TYPE (query)) {
-    case GST_QUERY_CAPS:
-      return autoplug_query_caps (uridecodebin, pad, element, query, group);
-    case GST_QUERY_CONTEXT:
-      return autoplug_query_context (uridecodebin, pad, element, query, group);
-    default:
-      return FALSE;
-  }
-}
-#endif
-
-/* must be called with the group lock */
-static gboolean
-group_set_locked_state_unlocked (GstPlayBin3 * playbin, GstSourceGroup * group,
-    gboolean locked)
-{
-  GST_DEBUG_OBJECT (playbin, "locked_state %d on group %p", locked, group);
-
-  if (group->uridecodebin)
-    gst_element_set_locked_state (group->uridecodebin, locked);
-
-  return TRUE;
-}
-
-static gboolean
-make_or_reuse_element (GstPlayBin3 * playbin, const gchar * name,
-    GstElement ** elem)
-{
-  if (*elem) {
-    GST_DEBUG_OBJECT (playbin, "reusing existing %s", name);
-    gst_element_set_state (*elem, GST_STATE_READY);
-    /* no need to take extra ref, we already have one
-     * and the bin will add one since it is no longer floating,
-     * as we added a non-floating ref when removing it from the
-     * bin earlier */
-  } else {
-    GstElement *new_elem;
-    GST_DEBUG_OBJECT (playbin, "making new %s", name);
-    new_elem = gst_element_factory_make (name, NULL);
-    if (!new_elem)
-      return FALSE;
-    *elem = gst_object_ref (new_elem);
-  }
-
-  if (GST_OBJECT_PARENT (*elem) != GST_OBJECT_CAST (playbin))
-    gst_bin_add (GST_BIN_CAST (playbin), *elem);
-  return TRUE;
-}
-
-
-static void
-source_setup_cb (GstElement * element, GstElement * source,
-    GstSourceGroup * group)
-{
-  g_signal_emit (group->playbin, gst_play_bin3_signals[SIGNAL_SOURCE_SETUP], 0,
-      source);
-}
-
-/* must be called with PLAY_BIN_LOCK */
-static GstStateChangeReturn
-activate_group (GstPlayBin3 * playbin, GstSourceGroup * group)
-{
-  GstElement *uridecodebin = NULL;
-  GstPlayFlags flags;
-  gboolean audio_sink_activated = FALSE;
-  gboolean video_sink_activated = FALSE;
-  gboolean text_sink_activated = FALSE;
-  GstStateChangeReturn state_ret;
-
-  g_return_val_if_fail (group->valid, GST_STATE_CHANGE_FAILURE);
-  g_return_val_if_fail (!group->active, GST_STATE_CHANGE_FAILURE);
-
-  GST_DEBUG_OBJECT (playbin, "activating group %p", group);
-
-  GST_SOURCE_GROUP_LOCK (group);
-
-  /* First set up the custom sinks */
-  if (playbin->audio_sink)
-    group->audio_sink = gst_object_ref (playbin->audio_sink);
-  else
-    group->audio_sink =
-        gst_play_sink_get_sink (playbin->playsink, GST_PLAY_SINK_TYPE_AUDIO);
-
-  if (group->audio_sink) {
-    if (!activate_sink (playbin, group->audio_sink, &audio_sink_activated)) {
-      if (group->audio_sink == playbin->audio_sink) {
-        goto sink_failure;
-      } else {
-        gst_object_unref (group->audio_sink);
-        group->audio_sink = NULL;
-      }
-    }
-  }
-
-  if (playbin->video_sink)
-    group->video_sink = gst_object_ref (playbin->video_sink);
-  else
-    group->video_sink =
-        gst_play_sink_get_sink (playbin->playsink, GST_PLAY_SINK_TYPE_VIDEO);
-
-  if (group->video_sink) {
-    if (!activate_sink (playbin, group->video_sink, &video_sink_activated)) {
-      if (group->video_sink == playbin->video_sink) {
-        goto sink_failure;
-      } else {
-        gst_object_unref (group->video_sink);
-        group->video_sink = NULL;
-      }
-    }
-  }
-
-  if (playbin->text_sink)
-    group->text_sink = gst_object_ref (playbin->text_sink);
-  else
-    group->text_sink =
-        gst_play_sink_get_sink (playbin->playsink, GST_PLAY_SINK_TYPE_TEXT);
-
-  if (group->text_sink) {
-    if (!activate_sink (playbin, group->text_sink, &text_sink_activated)) {
-      if (group->text_sink == playbin->text_sink) {
-        goto sink_failure;
-      } else {
-        gst_object_unref (group->text_sink);
-        group->text_sink = NULL;
-      }
-    }
-  }
-
-
-  if (!make_or_reuse_element (playbin, "uridecodebin3", &group->uridecodebin))
-    goto no_uridecodebin;
-  uridecodebin = group->uridecodebin;
-
-  flags = gst_play_sink_get_flags (playbin->playsink);
-
-  g_object_set (uridecodebin,
-      /* configure connection speed */
-      "connection-speed", playbin->connection_speed / 1000,
-      /* configure uri */
-      "uri", group->uri,
-      /* configure download buffering */
-      "download", ((flags & GST_PLAY_FLAG_DOWNLOAD) != 0),
-      /* configure buffering of demuxed/parsed data */
-      "use-buffering", ((flags & GST_PLAY_FLAG_BUFFERING) != 0),
-      /* configure buffering parameters */
-      "buffer-duration", playbin->buffer_duration,
-      "buffer-size", playbin->buffer_size,
-      "ring-buffer-max-size", playbin->ring_buffer_max_size, NULL);
-
-  group->pad_added_id = g_signal_connect (uridecodebin, "pad-added",
-      G_CALLBACK (pad_added_cb), group);
-  group->pad_removed_id = g_signal_connect (uridecodebin,
-      "pad-removed", G_CALLBACK (pad_removed_cb), group);
-  group->select_stream_id = g_signal_connect (uridecodebin, "select-stream",
-      G_CALLBACK (select_stream_cb), group);
-  group->source_setup_id = g_signal_connect (uridecodebin, "source-setup",
-      G_CALLBACK (source_setup_cb), group);
-  group->about_to_finish_id =
-      g_signal_connect (uridecodebin, "about-to-finish",
-      G_CALLBACK (about_to_finish_cb), group);
-
-  if (group->suburi)
-    g_object_set (group->uridecodebin, "suburi", group->suburi, NULL);
-
-  /* release the group lock before setting the state of the source bins, they
-   * might fire signals in this thread that we need to handle with the
-   * group_lock taken. */
-  GST_SOURCE_GROUP_UNLOCK (group);
-
-  if ((state_ret =
-          gst_element_set_state (uridecodebin,
-              GST_STATE_PAUSED)) == GST_STATE_CHANGE_FAILURE)
-    goto uridecodebin_failure;
-
-  GST_SOURCE_GROUP_LOCK (group);
-  /* allow state changes of the playbin affect the group elements now */
-  group_set_locked_state_unlocked (playbin, group, FALSE);
-  group->active = TRUE;
-  GST_SOURCE_GROUP_UNLOCK (group);
-
-  return state_ret;
-
-  /* ERRORS */
-no_uridecodebin:
-  {
-    GstMessage *msg;
-
-    GST_SOURCE_GROUP_UNLOCK (group);
-    msg =
-        gst_missing_element_message_new (GST_ELEMENT_CAST (playbin),
-        "uridecodebin3");
-    gst_element_post_message (GST_ELEMENT_CAST (playbin), msg);
-
-    GST_ELEMENT_ERROR (playbin, CORE, MISSING_PLUGIN,
-        (_("Could not create \"uridecodebin3\" element.")), (NULL));
-
-    GST_SOURCE_GROUP_LOCK (group);
-
-    goto error_cleanup;
-  }
-uridecodebin_failure:
-  {
-    GST_DEBUG_OBJECT (playbin, "failed state change of uridecodebin");
-    GST_SOURCE_GROUP_LOCK (group);
-    goto error_cleanup;
-  }
-sink_failure:
-  {
-    GST_ERROR_OBJECT (playbin, "failed to activate sinks");
-    goto error_cleanup;
-  }
-
-error_cleanup:
-  {
-    group->selected_stream_types = 0;
-
-    /* delete any custom sinks we might have */
-    if (group->audio_sink) {
-      /* If this is a automatically created sink set it to NULL */
-      if (audio_sink_activated)
-        gst_element_set_state (group->audio_sink, GST_STATE_NULL);
-      gst_object_unref (group->audio_sink);
-    }
-    group->audio_sink = NULL;
-
-    if (group->video_sink) {
-      /* If this is a automatically created sink set it to NULL */
-      if (video_sink_activated)
-        gst_element_set_state (group->video_sink, GST_STATE_NULL);
-      gst_object_unref (group->video_sink);
-    }
-    group->video_sink = NULL;
-
-    if (group->text_sink) {
-      /* If this is a automatically created sink set it to NULL */
-      if (text_sink_activated)
-        gst_element_set_state (group->text_sink, GST_STATE_NULL);
-      gst_object_unref (group->text_sink);
-    }
-    group->text_sink = NULL;
-
-    if (uridecodebin) {
-      REMOVE_SIGNAL (group->uridecodebin, group->pad_added_id);
-      REMOVE_SIGNAL (group->uridecodebin, group->pad_removed_id);
-      REMOVE_SIGNAL (group->uridecodebin, group->select_stream_id);
-      REMOVE_SIGNAL (group->uridecodebin, group->source_setup_id);
-      REMOVE_SIGNAL (group->uridecodebin, group->about_to_finish_id);
-#if 0
-      REMOVE_SIGNAL (group->urisourcebin, group->autoplug_factories_id);
-      REMOVE_SIGNAL (group->urisourcebin, group->autoplug_select_id);
-      REMOVE_SIGNAL (group->urisourcebin, group->autoplug_continue_id);
-      REMOVE_SIGNAL (group->urisourcebin, group->autoplug_query_id);
-#endif
-
-      gst_element_set_state (uridecodebin, GST_STATE_NULL);
-      gst_bin_remove (GST_BIN_CAST (playbin), uridecodebin);
-    }
-
-    GST_SOURCE_GROUP_UNLOCK (group);
-
-    return GST_STATE_CHANGE_FAILURE;
-  }
-}
-
-/* must be called with PLAY_BIN_LOCK, which is dropped temporarily
- * if changing states */
-static gboolean
-deactivate_group (GstPlayBin3 * playbin, GstSourceGroup * group)
-{
-  g_return_val_if_fail (group->active, FALSE);
-  g_return_val_if_fail (group->valid, FALSE);
-
-  GST_DEBUG_OBJECT (playbin, "unlinking group %p", group);
-
-  GST_SOURCE_GROUP_LOCK (group);
-  group->active = FALSE;
-  group->playing = FALSE;
-  group->group_id = GST_GROUP_ID_INVALID;
-
-  group->selected_stream_types = 0;
-  /* Update global selected_stream_types */
-  playbin->selected_stream_types =
-      playbin->groups[0].selected_stream_types | playbin->groups[1].
-      selected_stream_types;
-  if (playbin->active_stream_types != playbin->selected_stream_types)
-    reconfigure_output (playbin);
-
-#if 0
-  /* delete any custom sinks we might have.
-   * conditionally set them to null if they aren't inside playsink yet */
-  if (group->audio_sink) {
-    if (!gst_object_has_as_ancestor (GST_OBJECT_CAST (group->audio_sink),
-            GST_OBJECT_CAST (playbin->playsink))) {
-      gst_element_set_state (group->audio_sink, GST_STATE_NULL);
-    }
-    gst_object_unref (group->audio_sink);
-  }
-  group->audio_sink = NULL;
-  if (group->video_sink) {
-    if (!gst_object_has_as_ancestor (GST_OBJECT_CAST (group->video_sink),
-            GST_OBJECT_CAST (playbin->playsink))) {
-      gst_element_set_state (group->video_sink, GST_STATE_NULL);
-    }
-    gst_object_unref (group->video_sink);
-  }
-  group->video_sink = NULL;
-  if (group->text_sink) {
-    if (!gst_object_has_as_ancestor (GST_OBJECT_CAST (group->text_sink),
-            GST_OBJECT_CAST (playbin->playsink))) {
-      gst_element_set_state (group->text_sink, GST_STATE_NULL);
-    }
-    gst_object_unref (group->text_sink);
-  }
-  group->text_sink = NULL;
-#endif
-
-  if (group->uridecodebin) {
-    REMOVE_SIGNAL (group->uridecodebin, group->select_stream_id);
-    REMOVE_SIGNAL (group->uridecodebin, group->source_setup_id);
-    REMOVE_SIGNAL (group->uridecodebin, group->about_to_finish_id);
-
-    GST_PLAY_BIN3_UNLOCK (playbin);
-    gst_element_set_state (group->uridecodebin, GST_STATE_NULL);
-    gst_bin_remove (GST_BIN_CAST (playbin), group->uridecodebin);
-    GST_PLAY_BIN3_LOCK (playbin);
-
-    REMOVE_SIGNAL (group->uridecodebin, group->pad_added_id);
-    REMOVE_SIGNAL (group->uridecodebin, group->pad_removed_id);
-#if 0
-    REMOVE_SIGNAL (group->urisourcebin, group->autoplug_factories_id);
-    REMOVE_SIGNAL (group->urisourcebin, group->autoplug_select_id);
-    REMOVE_SIGNAL (group->urisourcebin, group->autoplug_continue_id);
-    REMOVE_SIGNAL (group->urisourcebin, group->autoplug_query_id);
-#endif
-  }
-
-  GST_SOURCE_GROUP_UNLOCK (group);
-
-  GST_DEBUG_OBJECT (playbin, "Done");
-
-  return TRUE;
-}
-
-/* setup the next group to play, this assumes the next_group is valid and
- * configured. It swaps out the current_group and activates the valid
- * next_group. */
-static GstStateChangeReturn
-setup_next_source (GstPlayBin3 * playbin)
-{
-  GstSourceGroup *new_group;
-  GstStateChangeReturn state_ret;
-
-  GST_DEBUG_OBJECT (playbin, "setup next source");
-
-  debug_groups (playbin);
-
-  /* see if there is a next group */
-  GST_PLAY_BIN3_LOCK (playbin);
-  new_group = playbin->next_group;
-  if (!new_group || !new_group->valid || new_group->active)
-    goto no_next_group;
-
-  /* activate the new group */
-  state_ret = activate_group (playbin, new_group);
-  if (state_ret == GST_STATE_CHANGE_FAILURE)
-    goto activate_failed;
-
-  GST_PLAY_BIN3_UNLOCK (playbin);
-
-  debug_groups (playbin);
-
-  return state_ret;
-
-  /* ERRORS */
-no_next_group:
-  {
-    GST_DEBUG_OBJECT (playbin, "no next group");
-    GST_PLAY_BIN3_UNLOCK (playbin);
-    return GST_STATE_CHANGE_FAILURE;
-  }
-activate_failed:
-  {
-    new_group->stream_changed_pending = FALSE;
-    GST_DEBUG_OBJECT (playbin, "activate failed");
-    new_group->valid = FALSE;
-    GST_PLAY_BIN3_UNLOCK (playbin);
-    return GST_STATE_CHANGE_FAILURE;
-  }
-}
-
-/* The group that is currently playing is copied again to the
- * next_group so that it will start playing the next time.
- */
-static gboolean
-save_current_group (GstPlayBin3 * playbin)
-{
-  GstSourceGroup *curr_group;
-  gboolean swapped = FALSE;
-
-  GST_DEBUG_OBJECT (playbin, "save current group");
-
-  /* see if there is a current group */
-  GST_PLAY_BIN3_LOCK (playbin);
-  curr_group = playbin->curr_group;
-  if (curr_group && curr_group->valid && curr_group->active) {
-    swapped = TRUE;
-  }
-  /* swap old and new */
-  playbin->curr_group = playbin->next_group;
-  playbin->next_group = curr_group;
-
-  if (swapped) {
-    /* unlink our pads with the sink */
-    deactivate_group (playbin, curr_group);
-  }
-  GST_PLAY_BIN3_UNLOCK (playbin);
-
-  return TRUE;
-}
-
-/* clear the locked state from all groups. This function is called before a
- * state change to NULL is performed on them. */
-static gboolean
-groups_set_locked_state (GstPlayBin3 * playbin, gboolean locked)
-{
-  GST_DEBUG_OBJECT (playbin, "setting locked state to %d on all groups",
-      locked);
-
-  GST_PLAY_BIN3_LOCK (playbin);
-  GST_SOURCE_GROUP_LOCK (playbin->curr_group);
-  group_set_locked_state_unlocked (playbin, playbin->curr_group, locked);
-  GST_SOURCE_GROUP_UNLOCK (playbin->curr_group);
-  GST_SOURCE_GROUP_LOCK (playbin->next_group);
-  group_set_locked_state_unlocked (playbin, playbin->next_group, locked);
-  GST_SOURCE_GROUP_UNLOCK (playbin->next_group);
-  GST_PLAY_BIN3_UNLOCK (playbin);
-
-  return TRUE;
-}
-
-static void
-gst_play_bin3_check_group_status (GstPlayBin3 * playbin)
-{
-  if (playbin->activation_task)
-    gst_task_start (playbin->activation_task);
-}
-
-static void
-gst_play_bin3_activation_thread (GstPlayBin3 * playbin)
-{
-  GST_DEBUG_OBJECT (playbin, "starting");
-
-  debug_groups (playbin);
-
-  /* Check if next_group needs to be deactivated */
-  GST_PLAY_BIN3_LOCK (playbin);
-  if (playbin->next_group->active) {
-    deactivate_group (playbin, playbin->next_group);
-    playbin->next_group->valid = FALSE;
-  }
-
-  /* Is there a pending about-to-finish to be emitted ? */
-  GST_SOURCE_GROUP_LOCK (playbin->curr_group);
-  if (playbin->curr_group->pending_about_to_finish) {
-    GST_LOG_OBJECT (playbin, "Propagating about-to-finish");
-    playbin->curr_group->pending_about_to_finish = FALSE;
-    GST_SOURCE_GROUP_UNLOCK (playbin->curr_group);
-    /* This will activate the next source afterwards */
-    emit_about_to_finish (playbin);
-  } else
-    GST_SOURCE_GROUP_UNLOCK (playbin->curr_group);
-
-  GST_LOG_OBJECT (playbin, "Pausing task");
-  if (playbin->activation_task)
-    gst_task_pause (playbin->activation_task);
-  GST_PLAY_BIN3_UNLOCK (playbin);
-
-  GST_DEBUG_OBJECT (playbin, "done");
-  return;
-}
-
-static gboolean
-gst_play_bin3_start (GstPlayBin3 * playbin)
-{
-  GST_DEBUG_OBJECT (playbin, "starting");
-
-  GST_PLAY_BIN3_LOCK (playbin);
-
-  if (playbin->activation_task == NULL) {
-    playbin->activation_task =
-        gst_task_new ((GstTaskFunction) gst_play_bin3_activation_thread,
-        playbin, NULL);
-    if (playbin->activation_task == NULL)
-      goto task_error;
-    gst_task_set_lock (playbin->activation_task, &playbin->activation_lock);
-  }
-  GST_LOG_OBJECT (playbin, "clearing shutdown flag");
-  g_atomic_int_set (&playbin->shutdown, 0);
-  do_async_start (playbin);
-
-  GST_PLAY_BIN3_UNLOCK (playbin);
-
-  return TRUE;
-
-task_error:
-  {
-    GST_PLAY_BIN3_UNLOCK (playbin);
-    GST_ERROR_OBJECT (playbin, "Failed to create task");
-    return FALSE;
-  }
-}
-
-static void
-gst_play_bin3_stop (GstPlayBin3 * playbin)
-{
-  GstTask *task;
-
-  GST_DEBUG_OBJECT (playbin, "stopping");
-
-  /* FIXME unlock our waiting groups */
-  GST_LOG_OBJECT (playbin, "setting shutdown flag");
-  g_atomic_int_set (&playbin->shutdown, 1);
-
-  /* wait for all callbacks to end by taking the lock.
-   * No dynamic (critical) new callbacks will
-   * be able to happen as we set the shutdown flag. */
-  GST_PLAY_BIN3_DYN_LOCK (playbin);
-  GST_LOG_OBJECT (playbin, "dynamic lock taken, we can continue shutdown");
-  GST_PLAY_BIN3_DYN_UNLOCK (playbin);
-
-  /* Stop the activation task */
-  GST_PLAY_BIN3_LOCK (playbin);
-  if ((task = playbin->activation_task)) {
-    playbin->activation_task = NULL;
-    GST_PLAY_BIN3_UNLOCK (playbin);
-
-    gst_task_stop (task);
-
-    /* Make sure task is not running */
-    g_rec_mutex_lock (&playbin->activation_lock);
-    g_rec_mutex_unlock (&playbin->activation_lock);
-
-    /* Wait for task to finish and unref it */
-    gst_task_join (task);
-    gst_object_unref (task);
-
-    GST_PLAY_BIN3_LOCK (playbin);
-  }
-  GST_PLAY_BIN3_UNLOCK (playbin);
-}
-
-static GstStateChangeReturn
-gst_play_bin3_change_state (GstElement * element, GstStateChange transition)
-{
-  GstStateChangeReturn ret;
-  GstPlayBin3 *playbin;
-  gboolean do_save = FALSE;
-
-  playbin = GST_PLAY_BIN3 (element);
-
-  switch (transition) {
-    case GST_STATE_CHANGE_READY_TO_PAUSED:
-      if (!gst_play_bin3_start (playbin))
-        return GST_STATE_CHANGE_FAILURE;
-      break;
-    case GST_STATE_CHANGE_PAUSED_TO_READY:
-    async_down:
-      gst_play_bin3_stop (playbin);
-      if (!do_save)
-        break;
-    case GST_STATE_CHANGE_READY_TO_NULL:
-      /* we go async to PAUSED, so if that fails, we never make it to PAUSED
-       * and we will never be called with the GST_STATE_CHANGE_PAUSED_TO_READY.
-       * Make sure we do go through the same steps (see above) for
-       * proper cleanup */
-      if (!g_atomic_int_get (&playbin->shutdown)) {
-        do_save = TRUE;
-        goto async_down;
-      }
-
-      /* unlock so that all groups go to NULL */
-      groups_set_locked_state (playbin, FALSE);
-      break;
-    default:
-      break;
-  }
-
-  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
-  if (ret == GST_STATE_CHANGE_FAILURE)
-    goto failure;
-
-  switch (transition) {
-    case GST_STATE_CHANGE_READY_TO_PAUSED:
-      if ((ret = setup_next_source (playbin)) == GST_STATE_CHANGE_FAILURE)
-        goto failure;
-      if (ret == GST_STATE_CHANGE_SUCCESS)
-        ret = GST_STATE_CHANGE_ASYNC;
-
-      break;
-    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
-      do_async_done (playbin);
-      /* FIXME Release audio device when we implement that */
-      break;
-    case GST_STATE_CHANGE_PAUSED_TO_READY:
-      playbin->is_live = FALSE;
-      save_current_group (playbin);
-      break;
-    case GST_STATE_CHANGE_READY_TO_NULL:
-    {
-      guint i;
-
-      /* also do missed state change down to READY */
-      if (do_save)
-        save_current_group (playbin);
-      /* Deactivate the groups, set uridecodebin to NULL and unref it */
-      GST_PLAY_BIN3_LOCK (playbin);
-      for (i = 0; i < 2; i++) {
-        if (playbin->groups[i].active && playbin->groups[i].valid) {
-          deactivate_group (playbin, &playbin->groups[i]);
-          playbin->groups[i].valid = FALSE;
-        }
-
-        if (playbin->groups[i].uridecodebin) {
-          gst_element_set_state (playbin->groups[i].uridecodebin,
-              GST_STATE_NULL);
-          gst_object_unref (playbin->groups[i].uridecodebin);
-          playbin->groups[i].uridecodebin = NULL;
-        }
-
-      }
-      GST_PLAY_BIN3_UNLOCK (playbin);
-
-      /* Set our sinks back to NULL, they might not be child of playbin */
-      if (playbin->audio_sink)
-        gst_element_set_state (playbin->audio_sink, GST_STATE_NULL);
-      if (playbin->video_sink)
-        gst_element_set_state (playbin->video_sink, GST_STATE_NULL);
-      if (playbin->text_sink)
-        gst_element_set_state (playbin->text_sink, GST_STATE_NULL);
-
-      if (playbin->video_stream_combiner)
-        gst_element_set_state (playbin->video_stream_combiner, GST_STATE_NULL);
-      if (playbin->audio_stream_combiner)
-        gst_element_set_state (playbin->audio_stream_combiner, GST_STATE_NULL);
-      if (playbin->text_stream_combiner)
-        gst_element_set_state (playbin->text_stream_combiner, GST_STATE_NULL);
-
-      /* make sure the groups don't perform a state change anymore until we
-       * enable them again */
-      groups_set_locked_state (playbin, TRUE);
-      break;
-    }
-    default:
-      break;
-  }
-
-  if (GST_STATE_TRANSITION_NEXT (transition) == GST_STATE_PAUSED)
-    playbin->is_live = ret == GST_STATE_CHANGE_NO_PREROLL;
-
-  if (ret == GST_STATE_CHANGE_NO_PREROLL)
-    do_async_done (playbin);
-
-  return ret;
+  return ret;
 
   /* ERRORS */
 failure:
   {
     do_async_done (playbin);
-
-    if (transition == GST_STATE_CHANGE_READY_TO_PAUSED) {
-      GstSourceGroup *curr_group;
-
-      GST_PLAY_BIN3_LOCK (playbin);
-
-      curr_group = playbin->curr_group;
-      if (curr_group) {
-        if (curr_group->active && curr_group->valid) {
-          /* unlink our pads with the sink */
-          deactivate_group (playbin, curr_group);
-        }
-        curr_group->valid = FALSE;
-      }
-
-      /* Swap current and next group back */
-      playbin->curr_group = playbin->next_group;
-      playbin->next_group = curr_group;
-
-      GST_PLAY_BIN3_UNLOCK (playbin);
-    }
     return ret;
   }
 }
diff --git a/subprojects/gst-plugins-base/gst/playback/gststreamsynchronizer.c b/subprojects/gst-plugins-base/gst/playback/gststreamsynchronizer.c
index ec50263072..6a0f26cf43 100644
--- a/subprojects/gst-plugins-base/gst/playback/gststreamsynchronizer.c
+++ b/subprojects/gst-plugins-base/gst/playback/gststreamsynchronizer.c
@@ -419,13 +419,14 @@ gst_stream_synchronizer_sink_event (GstPad * pad, GstObject * parent,
                 "Stream %d belongs to running stream %d, no waiting",
                 stream->stream_number, ostream->stream_number);
             stream->wait = FALSE;
-
+            gst_syncstream_unref (stream);
             GST_STREAM_SYNCHRONIZER_UNLOCK (self);
             break;
           }
         } else if (group_id == self->group_id) {
           GST_DEBUG_OBJECT (pad, "Stream %d belongs to running group %d, "
               "no waiting", stream->stream_number, group_id);
+          gst_syncstream_unref (stream);
           GST_STREAM_SYNCHRONIZER_UNLOCK (self);
           break;
         }
diff --git a/subprojects/gst-plugins-base/gst/playback/gsturidecodebin3.c b/subprojects/gst-plugins-base/gst/playback/gsturidecodebin3.c
index 85af4a6e76..3750a01a85 100644
--- a/subprojects/gst-plugins-base/gst/playback/gsturidecodebin3.c
+++ b/subprojects/gst-plugins-base/gst/playback/gsturidecodebin3.c
@@ -27,12 +27,6 @@
  *    post the (last) buffering messages.
  *    If no group_id is being outputted (still prerolling), then output
  *    the messages directly
- *
- * * ASYNC HANDLING
- * ** URIDECODEBIN3 is not async-aware.
- *
- * * GAPLESS HANDLING
- * ** Correlate group_id and URI to know when/which stream is being outputted/started
  */
 
 /**
@@ -74,16 +68,19 @@ typedef struct _GstSourceGroup GstSourceGroup;
 typedef struct _GstURIDecodeBin3 GstURIDecodeBin3;
 typedef struct _GstURIDecodeBin3Class GstURIDecodeBin3Class;
 
-#define GST_URI_DECODE_BIN3_LOCK(dec) (g_mutex_lock(&((GstURIDecodeBin3*)(dec))->lock))
-#define GST_URI_DECODE_BIN3_UNLOCK(dec) (g_mutex_unlock(&((GstURIDecodeBin3*)(dec))->lock))
-
 typedef struct _GstPlayItem GstPlayItem;
 typedef struct _GstSourceItem GstSourceItem;
 typedef struct _GstSourceHandler GstSourceHandler;
+typedef struct _GstSourcePad GstSourcePad;
 typedef struct _OutputPad OutputPad;
 
 /* A structure describing a play item, which travels through the elements
- * over time. */
+ * over time.
+ *
+ * All source items in this play item will be played together. Corresponds to an
+ * end-user "play item" (ex: one item from a playlist, even though it might be
+ * using a main content and subtitle content).
+ */
 struct _GstPlayItem
 {
   GstURIDecodeBin3 *uridecodebin;
@@ -101,11 +98,25 @@ struct _GstPlayItem
    * The urisourcebin-specific group_id is located in GstSourceItem */
   guint group_id;
 
-  /* Is this play item the one being currently outputted by decodebin3
-   * and on our source ghostpads */
-  gboolean currently_outputted;
+  /* The two following variables are required for gapless, since there could be
+   * a play item which is started which is different from the one currently
+   * being outputted */
+
+  /* active: TRUE if the backing urisourcebin were created */
+  gboolean active;
+
+  /* Whether about-to-finish was already posted for this play item */
+  gboolean posted_about_to_finish;
+
+  /* Whether about-to-finish should be posted once this play item becomes the
+   * current input item */
+  gboolean pending_about_to_finish;
 };
 
+/* The actual "source" component of a "play item"
+ *
+ * This is defined by having a URI, is backed by a `GstSourceHandler`.
+ */
 struct _GstSourceItem
 {
   /* The GstPlayItem to which this GstSourceItem belongs to */
@@ -116,17 +127,13 @@ struct _GstSourceItem
   /* The urisourcebin controlling this uri
    * Can be NULL */
   GstSourceHandler *handler;
-
-  /* The groupid created by urisourcebin for this uri */
-  guint internal_groupid;
-
-  /* FIXME : Add tag lists and other uri-specific items here ? */
 };
 
 /* Structure wrapping everything related to a urisourcebin */
 struct _GstSourceHandler
 {
   GstURIDecodeBin3 *uridecodebin;
+  GstPlayItem *play_item;
 
   GstElement *urisourcebin;
 
@@ -139,19 +146,46 @@ struct _GstSourceHandler
   /* TRUE if the controlled urisourcebin was added to uridecodebin */
   gboolean active;
 
-  /* whether urisourcebin is drained or not.
-   * Reset if/when setting a new URI */
-  gboolean drained;
-
-  /* Whether urisourcebin posted EOS on all pads and
-   * there is no pending entry */
-  gboolean is_eos;
-
   /* TRUE if the urisourcebin handles main item */
   gboolean is_main_source;
 
   /* buffering message stored for after switching */
   GstMessage *pending_buffering_msg;
+
+  /* Number of expected sourcepads. Default 1, else it's the number of streams
+   * specified by GST_MESSAGE_SELECTED_STREAMS from the source */
+  guint expected_pads;
+
+  /* List of GstSourcePad */
+  GList *sourcepads;
+};
+
+/* Structure wrapping everything related to a urisourcebin pad */
+struct _GstSourcePad
+{
+  GstSourceHandler *handler;
+
+  GstPad *src_pad;
+
+  /* GstStream (if present) */
+  GstStream *stream;
+
+  /* Decodebin3 pad to which src_pad is linked to */
+  GstPad *db3_sink_pad;
+
+  /* TRUE if db3_sink_pad is a request pad */
+  gboolean db3_pad_is_request;
+
+  /* TRUE if EOS went through the source pad. Marked as TRUE if decodebin3
+   * notified `about-to-finish` for pull mode */
+  gboolean saw_eos;
+
+  /* Downstream blocking probe id. Only set/valid if we need to block this
+   * pad */
+  gulong block_probe_id;
+
+  /* Downstream event probe id */
+  gulong event_probe_id;
 };
 
 /* Controls an output source pad */
@@ -165,14 +199,23 @@ struct _OutputPad
   /* Downstream event probe id */
   gulong probe_id;
 
-  /* TRUE if the pad saw EOS. Reset to FALSE on STREAM_START */
-  gboolean is_eos;
-
   /* The last seen (i.e. current) group_id
    * Can be (guint)-1 if no group_id was seen yet */
   guint current_group_id;
 };
 
+#define PLAY_ITEMS_GET_LOCK(d) (&(GST_URI_DECODE_BIN3_CAST(d)->play_items_lock))
+#define PLAY_ITEMS_LOCK(d) G_STMT_START { \
+    GST_TRACE("Locking play_items from thread %p", g_thread_self()); \
+    g_mutex_lock (PLAY_ITEMS_GET_LOCK (d)); \
+    GST_TRACE("Locked play_items from thread %p", g_thread_self()); \
+ } G_STMT_END
+
+#define PLAY_ITEMS_UNLOCK(d) G_STMT_START { \
+    GST_TRACE("Unlocking play_items from thread %p", g_thread_self()); \
+    g_mutex_unlock (PLAY_ITEMS_GET_LOCK (d)); \
+ } G_STMT_END
+
 /**
  * GstURIDecodeBin3
  *
@@ -182,8 +225,6 @@ struct _GstURIDecodeBin3
 {
   GstBin parent_instance;
 
-  GMutex lock;                  /* lock for constructing */
-
   /* Properties */
   GstElement *source;
   guint64 connection_speed;     /* In bits/sec (0 = unknown) */
@@ -193,26 +234,23 @@ struct _GstURIDecodeBin3
   gboolean download;
   gboolean use_buffering;
   guint64 ring_buffer_max_size;
+  gboolean instant_uri;         /* Whether URI changes should be applied immediately or not */
 
-  GList *play_items;            /* List of GstPlayItem ordered by time of
-                                 * creation. Head of list is therefore the
-                                 * current (or pending if initial) one being
-                                 * outputted */
-  GstPlayItem *current;         /* Currently active GstPlayItem. Can be NULL
-                                 * if no entry is active yet (i.e. no source
-                                 * pads) */
-
-  /* sources.
-   * FIXME : Replace by a more modular system later on */
-  GstSourceHandler *main_handler;
-  GstSourceHandler *sub_handler;
-
-  /* URI handling
-   * FIXME : Switch to a playlist-based API */
-  gchar *uri;
-  gboolean uri_changed;         /* TRUE if uri changed */
-  gchar *suburi;
-  gboolean suburi_changed;      /* TRUE if suburi changed */
+  /* Mutex to protect play_items/input_item/output_item */
+  GMutex play_items_lock;
+
+  /* Notify that the input_item sources have all drained */
+  GCond input_source_drained;
+
+  /* List of GstPlayItem ordered by time of creation (first is oldest, new ones
+   * are appended) */
+  GList *play_items;
+
+  /* Play item currently feeding decodebin3. */
+  GstPlayItem *input_item;
+
+  /* Play item currently outputted by decodebin3 */
+  GstPlayItem *output_item;
 
   /* A global decodebin3 that's used to actually do decoding */
   GstElement *decodebin;
@@ -223,15 +261,14 @@ struct _GstURIDecodeBin3
   gulong db_select_stream_id;
   gulong db_about_to_finish_id;
 
-  GList *output_pads;           /* List of OutputPad */
-
-  GList *source_handlers;       /* List of SourceHandler */
+  /* 1 if shutting down */
+  gint shutdown;
 
-  /* Whether we already signalled about-to-finish or not
-   * FIXME: Track this by group-id ! */
-  gboolean posted_about_to_finish;
+  GList *output_pads;           /* List of OutputPad */
 };
 
+static GstStateChangeReturn activate_play_item (GstPlayItem * item);
+
 static gint
 gst_uridecodebin3_select_stream (GstURIDecodeBin3 * dbin,
     GstStreamCollection * collection, GstStream * stream)
@@ -261,11 +298,6 @@ enum
   LAST_SIGNAL
 };
 
-#if 0
-static GstStaticCaps raw_audio_caps = GST_STATIC_CAPS ("audio/x-raw(ANY)");
-static GstStaticCaps raw_video_caps = GST_STATIC_CAPS ("video/x-raw(ANY)");
-#endif
-
 /* properties */
 #define DEFAULT_PROP_URI            NULL
 #define DEFAULT_PROP_SUBURI            NULL
@@ -276,6 +308,7 @@ static GstStaticCaps raw_video_caps = GST_STATIC_CAPS ("video/x-raw(ANY)");
 #define DEFAULT_DOWNLOAD            FALSE
 #define DEFAULT_USE_BUFFERING       FALSE
 #define DEFAULT_RING_BUFFER_MAX_SIZE 0
+#define DEFAULT_INSTANT_URI         FALSE
 
 enum
 {
@@ -291,7 +324,8 @@ enum
   PROP_DOWNLOAD,
   PROP_USE_BUFFERING,
   PROP_RING_BUFFER_MAX_SIZE,
-  PROP_CAPS
+  PROP_CAPS,
+  PROP_INSTANT_URI
 };
 
 static guint gst_uri_decode_bin3_signals[LAST_SIGNAL] = { 0 };
@@ -341,14 +375,28 @@ static void gst_uri_decode_bin3_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec);
 static void gst_uri_decode_bin3_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec);
-static void gst_uri_decode_bin3_finalize (GObject * obj);
+static void gst_uri_decode_bin3_dispose (GObject * obj);
 static GstSourceHandler *new_source_handler (GstURIDecodeBin3 * uridecodebin,
-    gboolean is_main);
+    GstPlayItem * item, gboolean is_main);
+static void free_source_item (GstURIDecodeBin3 * uridecodebin,
+    GstSourceItem * item);
+
+static GstPlayItem *new_play_item (GstURIDecodeBin3 * dec);
+static void free_play_item (GstURIDecodeBin3 * dec, GstPlayItem * item);
+static gboolean play_item_is_eos (GstPlayItem * item);
+static void play_item_set_eos (GstPlayItem * item);
+static gboolean play_item_has_all_pads (GstPlayItem * item);
+
+static void gst_uri_decode_bin3_set_uri (GstURIDecodeBin3 * dec,
+    const gchar * uri);
+static void gst_uri_decode_bin3_set_suburi (GstURIDecodeBin3 * dec,
+    const gchar * uri);
 
 static GstStateChangeReturn gst_uri_decode_bin3_change_state (GstElement *
     element, GstStateChange transition);
 static gboolean gst_uri_decodebin3_send_event (GstElement * element,
     GstEvent * event);
+static void gst_uri_decode_bin3_handle_message (GstBin * bin, GstMessage * msg);
 
 static gboolean
 _gst_int_accumulator (GSignalInvocationHint * ihint,
@@ -370,13 +418,15 @@ gst_uri_decode_bin3_class_init (GstURIDecodeBin3Class * klass)
 {
   GObjectClass *gobject_class;
   GstElementClass *gstelement_class;
+  GstBinClass *gstbin_class;
 
   gobject_class = G_OBJECT_CLASS (klass);
   gstelement_class = GST_ELEMENT_CLASS (klass);
+  gstbin_class = GST_BIN_CLASS (klass);
 
   gobject_class->set_property = gst_uri_decode_bin3_set_property;
   gobject_class->get_property = gst_uri_decode_bin3_get_property;
-  gobject_class->finalize = gst_uri_decode_bin3_finalize;
+  gobject_class->dispose = gst_uri_decode_bin3_dispose;
 
   g_object_class_install_property (gobject_class, PROP_URI,
       g_param_spec_string ("uri", "URI", "URI to decode",
@@ -459,6 +509,19 @@ gst_uri_decode_bin3_class_init (GstURIDecodeBin3Class * klass)
           "The caps on which to stop decoding. (NULL = default)",
           GST_TYPE_CAPS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+  /**
+   * GstURIDecodeBin3:instant-uri:
+   *
+   * Changes to uri are applied immediately (instead of on EOS or when the
+   * element is set back to PLAYING.
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class, PROP_INSTANT_URI,
+      g_param_spec_boolean ("instant-uri", "Instantaneous URI change",
+          "When enabled, URI changes are applied immediately",
+          DEFAULT_INSTANT_URI, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   /**
    * GstURIDecodebin3::select-stream
    * @decodebin: a #GstURIDecodebin3
@@ -521,18 +584,93 @@ gst_uri_decode_bin3_class_init (GstURIDecodeBin3Class * klass)
   gstelement_class->send_event =
       GST_DEBUG_FUNCPTR (gst_uri_decodebin3_send_event);
 
+  gstbin_class->handle_message = gst_uri_decode_bin3_handle_message;
+
   klass->select_stream = gst_uridecodebin3_select_stream;
 }
 
+static void
+check_output_group_id (GstURIDecodeBin3 * dec)
+{
+  GList *iter;
+  guint common_group_id = GST_GROUP_ID_INVALID;
+
+  PLAY_ITEMS_LOCK (dec);
+
+  for (iter = dec->output_pads; iter; iter = iter->next) {
+    OutputPad *pad = iter->data;
+
+    if (common_group_id == GST_GROUP_ID_INVALID)
+      common_group_id = pad->current_group_id;
+    else if (common_group_id != pad->current_group_id) {
+      GST_DEBUG_OBJECT (dec, "transitioning output play item");
+      PLAY_ITEMS_UNLOCK (dec);
+      return;
+    }
+  }
+
+  if (dec->output_item->group_id == common_group_id) {
+    GST_DEBUG_OBJECT (dec, "Output play item %d fully active", common_group_id);
+  } else if (dec->output_item->group_id == GST_GROUP_ID_INVALID) {
+    /* This can happen for pull-based situations */
+    GST_DEBUG_OBJECT (dec, "Assigning group id %u to current output play item",
+        common_group_id);
+    dec->output_item->group_id = common_group_id;
+  } else if (common_group_id != GST_GROUP_ID_INVALID &&
+      dec->output_item->group_id != common_group_id) {
+    GstPlayItem *previous_item = dec->output_item;
+    GST_DEBUG_OBJECT (dec, "Output play item %d fully active", common_group_id);
+    if (g_list_length (dec->play_items) > 1) {
+      dec->play_items = g_list_remove (dec->play_items, previous_item);
+      dec->output_item = dec->play_items->data;
+      dec->output_item->group_id = common_group_id;
+      free_play_item (dec, previous_item);
+    }
+  }
+
+  PLAY_ITEMS_UNLOCK (dec);
+}
+
 static GstPadProbeReturn
 db_src_probe (GstPad * pad, GstPadProbeInfo * info, OutputPad * output)
 {
-  /* FIXME : IMPLEMENT */
+  GstEvent *event = GST_PAD_PROBE_INFO_EVENT (info);
+  GstURIDecodeBin3 *uridecodebin = output->uridecodebin;
+
+  GST_DEBUG_OBJECT (pad, "event %" GST_PTR_FORMAT, event);
 
   /* EOS : Mark pad as EOS */
 
-  /* STREAM_START : Store group_id and check if currently active
-   *  PlayEntry changed */
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_EOS:
+    {
+      /* If there is a next input, drop the EOS event */
+      if (uridecodebin->input_item != uridecodebin->output_item ||
+          uridecodebin->input_item !=
+          g_list_last (uridecodebin->play_items)->data) {
+        GST_DEBUG_OBJECT (uridecodebin,
+            "Dropping EOS event because in gapless mode");
+        return GST_PAD_PROBE_DROP;
+      }
+      break;
+    }
+    case GST_EVENT_STREAM_START:
+    {
+      /* STREAM_START : Store group_id and check if currently active
+       *  PlayEntry changed */
+      if (gst_event_parse_group_id (event, &output->current_group_id)) {
+        GST_DEBUG_OBJECT (pad, "current group id %" G_GUINT32_FORMAT,
+            output->current_group_id);
+        /* Check if we switched over to a new output */
+        check_output_group_id (uridecodebin);
+      }
+
+      break;
+    }
+    default:
+      break;
+  }
+
 
   return GST_PAD_PROBE_OK;
 }
@@ -617,12 +755,12 @@ db_pad_removed_cb (GstElement * element, GstPad * pad, GstURIDecodeBin3 * dec)
     gst_ghost_pad_set_target ((GstGhostPad *) output->ghost_pad, NULL);
     gst_element_remove_pad ((GstElement *) dec, output->ghost_pad);
 
-    /* FIXME : Update global/current PlayEntry group_id (did we switch ?) */
-
     /* Remove event probe */
     gst_pad_remove_probe (output->target_pad, output->probe_id);
 
     g_slice_free (OutputPad, output);
+
+    check_output_group_id (dec);
   }
 }
 
@@ -639,23 +777,88 @@ db_select_stream_cb (GstElement * decodebin,
   return response;
 }
 
+static gboolean
+check_pad_mode (GstElement * src, GstPad * pad, gpointer udata)
+{
+  GstPadMode curmode = GST_PAD_MODE (pad);
+  GstPadMode *retmode = (GstPadMode *) udata;
+
+  /* We don't care if pads aren't activated */
+  if (curmode == GST_PAD_MODE_NONE)
+    return TRUE;
+
+  if (*retmode == GST_PAD_MODE_NONE) {
+    *retmode = curmode;
+  } else if (*retmode != curmode) {
+    GST_ERROR_OBJECT (src, "source has different scheduling mode ?");
+  }
+
+  return TRUE;
+}
+
+static gboolean
+play_item_is_pull_based (GstPlayItem * item)
+{
+  GstElement *src;
+  GstPadMode mode = GST_PAD_MODE_NONE;
+
+  g_assert (item->main_item && item->main_item->handler
+      && item->main_item->handler->urisourcebin);
+
+  src = item->main_item->handler->urisourcebin;
+  gst_element_foreach_src_pad (src, check_pad_mode, &mode);
+
+  return (mode == GST_PAD_MODE_PULL);
+}
+
 static void
-db_about_to_finish_cb (GstElement * decodebin, GstURIDecodeBin3 * uridecodebin)
+emit_and_handle_about_to_finish (GstURIDecodeBin3 * uridecodebin,
+    GstPlayItem * item)
 {
-  if (!uridecodebin->posted_about_to_finish) {
-    uridecodebin->posted_about_to_finish = TRUE;
-    g_signal_emit (uridecodebin,
-        gst_uri_decode_bin3_signals[SIGNAL_ABOUT_TO_FINISH], 0, NULL);
+  GST_DEBUG_OBJECT (uridecodebin, "output %d , posted_about_to_finish:%d",
+      item->group_id, item->posted_about_to_finish);
+
+  if (item->posted_about_to_finish) {
+    GST_DEBUG_OBJECT (uridecodebin,
+        "already handling about-to-finish for this play item");
+    return;
+  }
+
+  if (item != uridecodebin->input_item) {
+    GST_DEBUG_OBJECT (uridecodebin, "Postponing about-to-finish propagation");
+    item->pending_about_to_finish = TRUE;
+    return;
   }
+
+  /* If the input entry is pull-based, mark all the source pads as EOS */
+  if (play_item_is_pull_based (item)) {
+    GST_DEBUG_OBJECT (uridecodebin, "Marking play item as EOS");
+    play_item_set_eos (item);
+  }
+
+  item->posted_about_to_finish = TRUE;
+  GST_DEBUG_OBJECT (uridecodebin, "Posting about-to-finish");
+  g_signal_emit (uridecodebin,
+      gst_uri_decode_bin3_signals[SIGNAL_ABOUT_TO_FINISH], 0, NULL);
+
+  /* Note : Activation of the (potential) next entry is handled in
+   * gst_uri_decode_bin3_set_uri */
+}
+
+static void
+db_about_to_finish_cb (GstElement * decodebin, GstURIDecodeBin3 * uridecodebin)
+{
+  GST_LOG_OBJECT (uridecodebin, "about to finish from %s",
+      GST_OBJECT_NAME (decodebin));
+
+  emit_and_handle_about_to_finish (uridecodebin, uridecodebin->output_item);
 }
 
 static void
 gst_uri_decode_bin3_init (GstURIDecodeBin3 * dec)
 {
-  g_mutex_init (&dec->lock);
+  GstPlayItem *item;
 
-  dec->uri = DEFAULT_PROP_URI;
-  dec->suburi = DEFAULT_PROP_SUBURI;
   dec->connection_speed = DEFAULT_CONNECTION_SPEED;
   dec->caps = DEFAULT_CAPS;
   dec->buffer_duration = DEFAULT_BUFFER_DURATION;
@@ -664,6 +867,9 @@ gst_uri_decode_bin3_init (GstURIDecodeBin3 * dec)
   dec->use_buffering = DEFAULT_USE_BUFFERING;
   dec->ring_buffer_max_size = DEFAULT_RING_BUFFER_MAX_SIZE;
 
+  g_mutex_init (&dec->play_items_lock);
+  g_cond_init (&dec->input_source_drained);
+
   dec->decodebin = gst_element_factory_make ("decodebin3", NULL);
   gst_bin_add (GST_BIN_CAST (dec), dec->decodebin);
   dec->db_pad_added_id =
@@ -682,18 +888,32 @@ gst_uri_decode_bin3_init (GstURIDecodeBin3 * dec)
   GST_OBJECT_FLAG_SET (dec, GST_ELEMENT_FLAG_SOURCE);
   gst_bin_set_suppressed_flags (GST_BIN (dec),
       GST_ELEMENT_FLAG_SOURCE | GST_ELEMENT_FLAG_SINK);
+
+  item = new_play_item (dec);
+  dec->play_items = g_list_append (dec->play_items, item);
+  /* The initial play item is automatically the input and output one */
+  dec->input_item = dec->output_item = item;
 }
 
 static void
-gst_uri_decode_bin3_finalize (GObject * obj)
+gst_uri_decode_bin3_dispose (GObject * obj)
 {
   GstURIDecodeBin3 *dec = GST_URI_DECODE_BIN3 (obj);
+  GList *iter;
 
-  g_mutex_clear (&dec->lock);
-  g_free (dec->uri);
-  g_free (dec->suburi);
+  GST_DEBUG_OBJECT (obj, "Disposing");
 
-  G_OBJECT_CLASS (parent_class)->finalize (obj);
+  /* Free all play items */
+  for (iter = dec->play_items; iter; iter = iter->next) {
+    GstPlayItem *item = iter->data;
+    free_play_item (dec, item);
+  }
+  g_list_free (dec->play_items);
+  dec->play_items = NULL;
+
+  g_mutex_clear (&dec->play_items_lock);
+
+  G_OBJECT_CLASS (parent_class)->dispose (obj);
 }
 
 static GstStateChangeReturn
@@ -709,31 +929,19 @@ activate_source_item (GstSourceItem * item)
   g_object_set (handler->urisourcebin, "uri", item->uri, NULL);
   if (!handler->active) {
     gst_bin_add ((GstBin *) handler->uridecodebin, handler->urisourcebin);
-    /* if (!gst_element_sync_state_with_parent (handler->urisourcebin)) */
-    /*   return GST_STATE_CHANGE_FAILURE; */
     handler->active = TRUE;
   }
 
+  gst_element_sync_state_with_parent (handler->urisourcebin);
+
   return GST_STATE_CHANGE_SUCCESS;
 }
 
 static void
-src_pad_added_cb (GstElement * element, GstPad * pad,
-    GstSourceHandler * handler)
+link_src_pad_to_db3 (GstURIDecodeBin3 * uridecodebin, GstSourcePad * spad)
 {
-  GstURIDecodeBin3 *uridecodebin;
+  GstSourceHandler *handler = spad->handler;
   GstPad *sinkpad = NULL;
-  GstPadLinkReturn res;
-  GstPlayItem *current_play_item;
-  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
-
-  uridecodebin = handler->uridecodebin;
-  current_play_item = uridecodebin->current;
-
-  GST_DEBUG_OBJECT (uridecodebin,
-      "New pad %" GST_PTR_FORMAT " from source %" GST_PTR_FORMAT, pad, element);
-
-  /* FIXME: Add probe to unify group_id and detect EOS */
 
   /* Try to link to main sink pad only if it's from a main handler */
   if (handler->is_main_source) {
@@ -744,44 +952,374 @@ src_pad_added_cb (GstElement * element, GstPad * pad,
     }
   }
 
-  if (sinkpad == NULL)
+  if (sinkpad == NULL) {
     sinkpad =
         gst_element_request_pad_simple (uridecodebin->decodebin, "sink_%u");
+    spad->db3_pad_is_request = TRUE;
+  }
 
   if (sinkpad) {
+    GstPadLinkReturn res;
     GST_DEBUG_OBJECT (uridecodebin,
-        "Linking %" GST_PTR_FORMAT " to %" GST_PTR_FORMAT, pad, sinkpad);
-    res = gst_pad_link (pad, sinkpad);
+        "Linking %" GST_PTR_FORMAT " to %" GST_PTR_FORMAT, spad->src_pad,
+        sinkpad);
+    res = gst_pad_link (spad->src_pad, sinkpad);
     gst_object_unref (sinkpad);
-    if (GST_PAD_LINK_FAILED (res))
-      goto link_failed;
+    if (GST_PAD_LINK_FAILED (res)) {
+      GST_ERROR_OBJECT (uridecodebin,
+          "failed to link pad %s:%s to decodebin, reason %s (%d)",
+          GST_DEBUG_PAD_NAME (spad->src_pad), gst_pad_link_get_name (res), res);
+      return;
+    }
+  } else {
+    GST_ERROR_OBJECT (uridecodebin, "Could not get a sinkpad from decodebin3");
+    return;
   }
 
+  spad->db3_sink_pad = sinkpad;
+
   /* Activate sub_item after the main source activation was finished */
-  if (handler->is_main_source && current_play_item->sub_item
-      && !current_play_item->sub_item->handler) {
-    current_play_item->sub_item->handler =
-        new_source_handler (uridecodebin, FALSE);
-    ret = activate_source_item (current_play_item->sub_item);
+  if (handler->is_main_source && handler->play_item->sub_item
+      && !handler->play_item->sub_item->handler) {
+    GstStateChangeReturn ret;
+    handler->play_item->sub_item->handler =
+        new_source_handler (uridecodebin, handler->play_item, FALSE);
+    ret = activate_source_item (handler->play_item->sub_item);
     if (ret == GST_STATE_CHANGE_FAILURE)
       goto sub_item_activation_failed;
   }
 
   return;
 
-link_failed:
+sub_item_activation_failed:
   {
     GST_ERROR_OBJECT (uridecodebin,
-        "failed to link pad %s:%s to decodebin, reason %s (%d)",
-        GST_DEBUG_PAD_NAME (pad), gst_pad_link_get_name (res), res);
+        "failed to activate subtitle playback item");
     return;
   }
-sub_item_activation_failed:
+}
+
+static GList *
+get_all_play_item_source_pads (GstPlayItem * item)
+{
+  GList *ret = NULL;
+
+  if (item->main_item && item->main_item->handler) {
+    ret = g_list_copy (item->main_item->handler->sourcepads);
+  }
+
+  if (item->sub_item && item->sub_item->handler) {
+    ret =
+        g_list_concat (ret, g_list_copy (item->sub_item->handler->sourcepads));
+  }
+
+  return ret;
+}
+
+static GstSourcePad *
+find_matching_source_pad (GList * candidates, GstSourcePad * target)
+{
+  GList *iter;
+  GstStream *stream = target->stream;
+
+  GST_DEBUG_OBJECT (target->src_pad, "Find match for stream %" GST_PTR_FORMAT,
+      stream);
+
+  for (iter = candidates; iter; iter = iter->next) {
+    GstSourcePad *cand = iter->data;
+
+    if (!cand->db3_sink_pad)
+      continue;
+
+    /* Target doesn't have a specific GstStream, return the first result */
+    if (!stream)
+      return cand;
+
+    if (gst_stream_get_stream_type (cand->stream) ==
+        gst_stream_get_stream_type (stream))
+      return cand;
+  }
+
+  return NULL;
+}
+
+/* PLAY_ITEMS_LOCK held
+ *
+ * Switch the input play item to the next one
+ */
+static void
+switch_and_activate_input_locked (GstURIDecodeBin3 * uridecodebin,
+    GstPlayItem * new_item)
+{
+  GList *new_pads = get_all_play_item_source_pads (new_item);
+  GList *old_pads = get_all_play_item_source_pads (uridecodebin->input_item);
+  GList *to_activate = NULL;
+  GList *iternew, *iterold;
+
+  /* Deactivate old urisourcebins first ? Problem is they might remove the pads */
+
+  /* Go over new item source pads and figure out a candidate replacement in  */
+  /* Figure out source pad matches */
+  for (iternew = new_pads; iternew; iternew = iternew->next) {
+    GstSourcePad *new_spad = iternew->data;
+    GstSourcePad *old_spad = find_matching_source_pad (old_pads, new_spad);
+
+    if (old_spad) {
+      GST_DEBUG_OBJECT (uridecodebin, "Relinking %s:%s from %s:%s to %s:%s",
+          GST_DEBUG_PAD_NAME (old_spad->db3_sink_pad),
+          GST_DEBUG_PAD_NAME (old_spad->src_pad),
+          GST_DEBUG_PAD_NAME (new_spad->src_pad));
+      gst_pad_unlink (old_spad->src_pad, old_spad->db3_sink_pad);
+      new_spad->db3_sink_pad = old_spad->db3_sink_pad;
+      new_spad->db3_pad_is_request = old_spad->db3_pad_is_request;
+      old_spad->db3_sink_pad = NULL;
+
+      gst_pad_link (new_spad->src_pad, new_spad->db3_sink_pad);
+      old_pads = g_list_remove (old_pads, old_spad);
+    } else {
+      GST_DEBUG_OBJECT (new_spad->src_pad, "Needs a new pad");
+      to_activate = g_list_append (to_activate, new_spad);
+    }
+  }
+
+  /* Remove unmatched old source pads */
+  for (iterold = old_pads; iterold; iterold = iterold->next) {
+    GstSourcePad *old_spad = iterold->data;
+    if (old_spad->db3_sink_pad && old_spad->db3_pad_is_request) {
+      GST_DEBUG_OBJECT (uridecodebin, "Releasing no longer used db3 pad");
+      gst_element_release_request_pad (uridecodebin->decodebin,
+          old_spad->db3_sink_pad);
+      old_spad->db3_sink_pad = NULL;
+    }
+  }
+
+  /* Link new source pads */
+  for (iternew = to_activate; iternew; iternew = iternew->next) {
+    GstSourcePad *new_spad = iternew->data;
+    link_src_pad_to_db3 (uridecodebin, new_spad);
+  }
+
+  /* Unblock all new item source pads */
+  for (iternew = new_pads; iternew; iternew = iternew->next) {
+    GstSourcePad *new_spad = iternew->data;
+    if (new_spad->block_probe_id) {
+      gst_pad_remove_probe (new_spad->src_pad, new_spad->block_probe_id);
+      new_spad->block_probe_id = 0;
+    }
+  }
+  g_list_free (new_pads);
+  g_list_free (old_pads);
+
+  /* Deactivate old input item (by removing the source components). The final
+   * removal of this play item will be done once decodebin3 starts output the
+   * content of the new play item. */
+  if (uridecodebin->input_item->main_item) {
+    free_source_item (uridecodebin, uridecodebin->input_item->main_item);
+    uridecodebin->input_item->main_item = NULL;
+  }
+  if (uridecodebin->input_item->sub_item) {
+    free_source_item (uridecodebin, uridecodebin->input_item->sub_item);
+    uridecodebin->input_item->sub_item = NULL;
+  }
+
+  /* and set new one as input item */
+  uridecodebin->input_item = new_item;
+
+  if (new_item->main_item->handler->pending_buffering_msg) {
+    GstMessage *msg = new_item->main_item->handler->pending_buffering_msg;
+    new_item->main_item->handler->pending_buffering_msg = NULL;
+    PLAY_ITEMS_UNLOCK (uridecodebin);
+    GST_BIN_CLASS (parent_class)->handle_message ((GstBin *) uridecodebin, msg);
+    PLAY_ITEMS_LOCK (uridecodebin);
+  }
+}
+
+static GstPadProbeReturn
+uri_src_probe (GstPad * pad, GstPadProbeInfo * info, GstSourcePad * srcpad)
+{
+  GstEvent *event = GST_PAD_PROBE_INFO_EVENT (info);
+  GstSourceHandler *handler = srcpad->handler;
+  GstPadProbeReturn ret = GST_PAD_PROBE_OK;
+
+  GST_DEBUG_OBJECT (pad, "event %" GST_PTR_FORMAT, event);
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_EOS:
+    {
+      GstPad *peer;
+      /* Propagate the EOS *before* triggering any potential switch */
+      peer = gst_pad_get_peer (pad);
+      if (peer) {
+        gst_pad_send_event (peer, event);
+        gst_object_unref (peer);
+      } else {
+        /* No peer, just drop it (since we're returning HANDLED below) */
+        gst_event_unref (event);
+      }
+
+      PLAY_ITEMS_LOCK (handler->uridecodebin);
+      /* EOS : Mark pad as EOS */
+      srcpad->saw_eos = TRUE;
+      /* Check if the input play item is fully EOS. If yes and there is a
+       * pending play item, switch to it */
+      if (handler->play_item == handler->uridecodebin->input_item &&
+          play_item_is_eos (handler->play_item)) {
+        g_cond_signal (&handler->uridecodebin->input_source_drained);
+      }
+      PLAY_ITEMS_UNLOCK (handler->uridecodebin);
+      ret = GST_PAD_PROBE_HANDLED;
+      break;
+    }
+    case GST_EVENT_STREAM_START:
+    {
+      GstStream *stream = NULL;
+      srcpad->saw_eos = FALSE;
+      gst_event_parse_stream (event, &stream);
+      if (stream) {
+        GST_DEBUG_OBJECT (srcpad->src_pad, "Got GstStream %" GST_PTR_FORMAT,
+            stream);
+        if (srcpad->stream)
+          gst_object_unref (srcpad->stream);
+        srcpad->stream = stream;
+      }
+      break;
+    }
+    case GST_EVENT_SEGMENT:
+    {
+      srcpad->saw_eos = FALSE;
+      break;
+    }
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+static GstPadProbeReturn
+uri_src_block_probe (GstPad * pad, GstPadProbeInfo * info,
+    GstSourcePad * srcpad)
+{
+  GstPadProbeReturn ret = GST_PAD_PROBE_OK;
+  GstSourceHandler *handler = srcpad->handler;
+  GST_DEBUG_OBJECT (pad, "blocked");
+
+  /* We only block on buffers, buffer list and gap events. Everything else is
+   * dropped (sticky events will be propagated later) */
+  if (GST_IS_EVENT (GST_PAD_PROBE_INFO_DATA (info)) &&
+      GST_EVENT_TYPE (GST_PAD_PROBE_INFO_EVENT (info)) != GST_EVENT_GAP) {
+    GstEvent *event = GST_PAD_PROBE_INFO_EVENT (info);
+    if (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START) {
+      GstStream *stream = NULL;
+      gst_event_parse_stream (event, &stream);
+      if (stream) {
+        GST_DEBUG_OBJECT (srcpad->src_pad, "Got GstStream %" GST_PTR_FORMAT,
+            stream);
+        if (srcpad->stream)
+          gst_object_unref (srcpad->stream);
+        srcpad->stream = stream;
+      }
+    }
+    GST_LOG_OBJECT (pad, "Skiping %" GST_PTR_FORMAT, event);
+    return GST_PAD_PROBE_DROP;
+  }
+
+  PLAY_ITEMS_LOCK (handler->uridecodebin);
+  if (play_item_is_eos (handler->uridecodebin->input_item)) {
+    GST_DEBUG_OBJECT (handler->uridecodebin,
+        "We can switch over to the next input item");
+    switch_and_activate_input_locked (handler->uridecodebin,
+        handler->play_item);
+    ret = GST_PAD_PROBE_REMOVE;
+  } else if (play_item_has_all_pads (handler->play_item)) {
+    /* We have all expected pads for this play item but the current input
+     * play item isn't done yet, wait for it */
+    g_cond_wait (&handler->uridecodebin->input_source_drained,
+        &handler->uridecodebin->play_items_lock);
+    if (g_atomic_int_get (&handler->uridecodebin->shutdown))
+      goto shutdown;
+    if (play_item_is_eos (handler->uridecodebin->input_item)) {
+      GST_DEBUG_OBJECT (handler->uridecodebin,
+          "We can switch over to the next input item");
+      switch_and_activate_input_locked (handler->uridecodebin,
+          handler->play_item);
+      ret = GST_PAD_PROBE_REMOVE;
+    }
+  }
+
+  PLAY_ITEMS_UNLOCK (handler->uridecodebin);
+
+  return ret;
+
+  /* ERRORS */
+shutdown:
   {
-    GST_ERROR_OBJECT (uridecodebin,
-        "failed to activate subtitle playback item");
+    GST_LOG_OBJECT (pad, "Shutting down");
+    PLAY_ITEMS_UNLOCK (handler->uridecodebin);
+    return GST_PAD_PROBE_REMOVE;
+  }
+}
+
+static void
+src_pad_added_cb (GstElement * element, GstPad * pad,
+    GstSourceHandler * handler)
+{
+  GstSourcePad *spad = g_slice_new0 (GstSourcePad);
+  GstURIDecodeBin3 *uridecodebin;
+
+  uridecodebin = handler->uridecodebin;
+
+  PLAY_ITEMS_LOCK (uridecodebin);
+
+  GST_DEBUG_OBJECT (uridecodebin,
+      "New pad %" GST_PTR_FORMAT " from source %" GST_PTR_FORMAT, pad, element);
+
+  /* Register the new pad information with the source handler */
+  spad->handler = handler;
+  spad->src_pad = pad;
+  spad->event_probe_id =
+      gst_pad_add_probe (pad,
+      GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM, (GstPadProbeCallback) uri_src_probe,
+      spad, NULL);
+
+  handler->sourcepads = g_list_append (handler->sourcepads, spad);
+
+  /* Can the pad be linked straight away to db3 ?
+   * This can happen if:
+   * * It is the initial play item
+   * * It is part of the current input item
+   */
+  if (handler->play_item == uridecodebin->input_item) {
+    GST_DEBUG_OBJECT (uridecodebin,
+        "Pad is part of current input item, linking");
+
+    link_src_pad_to_db3 (uridecodebin, spad);
+    PLAY_ITEMS_UNLOCK (uridecodebin);
     return;
   }
+
+  /* This pad is not from the current input item. We add a blocking probe to
+   * wait until we block on the new urisourcebin streaming thread and can
+   * switch */
+  GST_DEBUG_OBJECT (uridecodebin, "Blocking input pad");
+  spad->block_probe_id =
+      gst_pad_add_probe (pad, GST_PAD_PROBE_TYPE_BLOCK_DOWNSTREAM,
+      (GstPadProbeCallback) uri_src_block_probe, spad, NULL);
+  PLAY_ITEMS_UNLOCK (uridecodebin);
+}
+
+static GstSourcePad *
+handler_get_source_pad (GstSourceHandler * handler, GstPad * srcpad)
+{
+  GList *iter;
+
+  for (iter = handler->sourcepads; iter; iter = iter->next) {
+    GstSourcePad *spad = iter->data;
+    if (spad->src_pad == srcpad)
+      return spad;
+  }
+
+  return NULL;
 }
 
 static void
@@ -789,26 +1327,21 @@ src_pad_removed_cb (GstElement * element, GstPad * pad,
     GstSourceHandler * handler)
 {
   GstURIDecodeBin3 *uridecodebin = handler->uridecodebin;
-  GstPad *peer_pad = gst_pad_get_peer (pad);
+  GstSourcePad *spad = handler_get_source_pad (handler, pad);
 
-  if (peer_pad) {
-    GstPadTemplate *templ = gst_pad_get_pad_template (peer_pad);
+  if (!spad)
+    return;
 
-    GST_DEBUG_OBJECT (uridecodebin,
-        "Source %" GST_PTR_FORMAT " removed pad %" GST_PTR_FORMAT " peer %"
-        GST_PTR_FORMAT, element, pad, peer_pad);
+  GST_DEBUG_OBJECT (uridecodebin,
+      "Source %" GST_PTR_FORMAT " removed pad %" GST_PTR_FORMAT " peer %"
+      GST_PTR_FORMAT, element, pad, spad->db3_sink_pad);
 
-    if (templ) {
-      if (GST_PAD_TEMPLATE_PRESENCE (templ) == GST_PAD_REQUEST) {
-        GST_DEBUG_OBJECT (uridecodebin,
-            "Releasing decodebin pad %" GST_PTR_FORMAT, peer_pad);
-        gst_element_release_request_pad (uridecodebin->decodebin, peer_pad);
-      }
-      gst_object_unref (templ);
-    }
+  if (spad->db3_sink_pad && spad->db3_pad_is_request)
+    gst_element_release_request_pad (uridecodebin->decodebin,
+        spad->db3_sink_pad);
 
-    gst_object_unref (peer_pad);
-  }
+  handler->sourcepads = g_list_remove (handler->sourcepads, spad);
+  g_slice_free (GstSourcePad, spad);
 }
 
 static void
@@ -822,22 +1355,22 @@ src_source_setup_cb (GstElement * element, GstElement * source,
 static void
 src_about_to_finish_cb (GstElement * element, GstSourceHandler * handler)
 {
-  /* FIXME : check if all sources are done */
-  if (!handler->uridecodebin->posted_about_to_finish) {
-    handler->uridecodebin->posted_about_to_finish = TRUE;
-    g_signal_emit (handler->uridecodebin,
-        gst_uri_decode_bin3_signals[SIGNAL_ABOUT_TO_FINISH], 0, NULL);
-  }
+  GST_LOG_OBJECT (handler->uridecodebin, "about to finish from %s",
+      GST_OBJECT_NAME (element));
+
+  emit_and_handle_about_to_finish (handler->uridecodebin, handler->play_item);
 }
 
 static GstSourceHandler *
-new_source_handler (GstURIDecodeBin3 * uridecodebin, gboolean is_main)
+new_source_handler (GstURIDecodeBin3 * uridecodebin, GstPlayItem * item,
+    gboolean is_main)
 {
   GstSourceHandler *handler;
 
   handler = g_slice_new0 (GstSourceHandler);
 
   handler->uridecodebin = uridecodebin;
+  handler->play_item = item;
   handler->is_main_source = is_main;
   handler->urisourcebin = gst_element_factory_make ("urisourcebin", NULL);
   /* Set pending properties */
@@ -847,7 +1380,8 @@ new_source_handler (GstURIDecodeBin3 * uridecodebin, gboolean is_main)
       "use-buffering", uridecodebin->use_buffering,
       "buffer-duration", uridecodebin->buffer_duration,
       "buffer-size", uridecodebin->buffer_size,
-      "ring-buffer-max-size", uridecodebin->ring_buffer_max_size, NULL);
+      "ring-buffer-max-size", uridecodebin->ring_buffer_max_size,
+      "parse-streams", TRUE, NULL);
 
   handler->pad_added_id =
       g_signal_connect (handler->urisourcebin, "pad-added",
@@ -862,12 +1396,38 @@ new_source_handler (GstURIDecodeBin3 * uridecodebin, gboolean is_main)
       g_signal_connect (handler->urisourcebin, "about-to-finish",
       (GCallback) src_about_to_finish_cb, handler);
 
-  uridecodebin->source_handlers =
-      g_list_append (uridecodebin->source_handlers, handler);
+  handler->expected_pads = 1;
 
   return handler;
 }
 
+static gboolean
+source_handler_is_eos (GstSourceHandler * handler)
+{
+  GList *iter;
+
+  for (iter = handler->sourcepads; iter; iter = iter->next) {
+    GstSourcePad *spad = iter->data;
+
+    if (!spad->saw_eos)
+      return FALSE;
+  }
+
+  return TRUE;
+}
+
+static void
+source_handler_set_eos (GstSourceHandler * handler)
+{
+  GList *iter;
+
+  for (iter = handler->sourcepads; iter; iter = iter->next) {
+    GstSourcePad *spad = iter->data;
+
+    spad->saw_eos = TRUE;
+  }
+}
+
 static void
 gst_uri_decode_bin3_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec)
@@ -876,19 +1436,15 @@ gst_uri_decode_bin3_set_property (GObject * object, guint prop_id,
 
   switch (prop_id) {
     case PROP_URI:
-      if (dec->uri)
-        g_free (dec->uri);
-      dec->uri = g_value_dup_string (value);
+      gst_uri_decode_bin3_set_uri (dec, g_value_get_string (value));
       break;
     case PROP_SUBURI:
-      if (dec->suburi)
-        g_free (dec->suburi);
-      dec->suburi = g_value_dup_string (value);
+      gst_uri_decode_bin3_set_suburi (dec, g_value_get_string (value));
       break;
     case PROP_CONNECTION_SPEED:
-      GST_URI_DECODE_BIN3_LOCK (dec);
+      GST_OBJECT_LOCK (dec);
       dec->connection_speed = g_value_get_uint64 (value) * 1000;
-      GST_URI_DECODE_BIN3_UNLOCK (dec);
+      GST_OBJECT_UNLOCK (dec);
       break;
     case PROP_BUFFER_SIZE:
       dec->buffer_size = g_value_get_int (value);
@@ -912,6 +1468,11 @@ gst_uri_decode_bin3_set_property (GObject * object, guint prop_id,
       dec->caps = g_value_dup_boxed (value);
       GST_OBJECT_UNLOCK (dec);
       break;
+    case PROP_INSTANT_URI:
+      GST_OBJECT_LOCK (dec);
+      dec->instant_uri = g_value_get_boolean (value);
+      GST_OBJECT_UNLOCK (dec);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -927,13 +1488,18 @@ gst_uri_decode_bin3_get_property (GObject * object, guint prop_id,
   switch (prop_id) {
     case PROP_URI:
     {
-      g_value_set_string (value, dec->uri);
+      GstPlayItem *item = dec->play_items->data;
+      /* Return from the head */
+      if (item->main_item)
+        g_value_set_string (value, item->main_item->uri);
+      else
+        g_value_set_string (value, NULL);
       break;
     }
     case PROP_CURRENT_URI:
     {
-      if (dec->current && dec->current->main_item) {
-        g_value_set_string (value, dec->current->main_item->uri);
+      if (dec->output_item && dec->output_item->main_item) {
+        g_value_set_string (value, dec->output_item->main_item->uri);
       } else {
         g_value_set_string (value, NULL);
       }
@@ -941,13 +1507,18 @@ gst_uri_decode_bin3_get_property (GObject * object, guint prop_id,
     }
     case PROP_SUBURI:
     {
-      g_value_set_string (value, dec->suburi);
+      GstPlayItem *item = dec->play_items->data;
+      /* Return from the head */
+      if (item->sub_item)
+        g_value_set_string (value, item->sub_item->uri);
+      else
+        g_value_set_string (value, NULL);
       break;
     }
     case PROP_CURRENT_SUBURI:
     {
-      if (dec->current && dec->current->sub_item) {
-        g_value_set_string (value, dec->current->sub_item->uri);
+      if (dec->output_item && dec->output_item->sub_item) {
+        g_value_set_string (value, dec->output_item->sub_item->uri);
       } else {
         g_value_set_string (value, NULL);
       }
@@ -961,9 +1532,9 @@ gst_uri_decode_bin3_get_property (GObject * object, guint prop_id,
       break;
     }
     case PROP_CONNECTION_SPEED:
-      GST_URI_DECODE_BIN3_LOCK (dec);
+      GST_OBJECT_LOCK (dec);
       g_value_set_uint64 (value, dec->connection_speed / 1000);
-      GST_URI_DECODE_BIN3_UNLOCK (dec);
+      GST_OBJECT_UNLOCK (dec);
       break;
     case PROP_BUFFER_SIZE:
       GST_OBJECT_LOCK (dec);
@@ -989,6 +1560,11 @@ gst_uri_decode_bin3_get_property (GObject * object, guint prop_id,
       g_value_set_boxed (value, dec->caps);
       GST_OBJECT_UNLOCK (dec);
       break;
+    case PROP_INSTANT_URI:
+      GST_OBJECT_LOCK (dec);
+      g_value_set_boolean (value, dec->instant_uri);
+      GST_OBJECT_UNLOCK (dec);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1001,13 +1577,22 @@ free_source_handler (GstURIDecodeBin3 * uridecodebin,
 {
   GST_LOG_OBJECT (uridecodebin, "source handler %p", handler);
   if (handler->active) {
+    GList *iter;
+    GST_STATE_LOCK (uridecodebin);
     GST_LOG_OBJECT (uridecodebin, "Removing %" GST_PTR_FORMAT,
         handler->urisourcebin);
+    for (iter = handler->sourcepads; iter; iter = iter->next) {
+      GstSourcePad *spad = iter->data;
+      if (spad->block_probe_id)
+        gst_pad_remove_probe (spad->src_pad, spad->block_probe_id);
+    }
     gst_element_set_state (handler->urisourcebin, GST_STATE_NULL);
     gst_bin_remove ((GstBin *) uridecodebin, handler->urisourcebin);
+    GST_STATE_UNLOCK (uridecodebin);
+    g_list_free (handler->sourcepads);
   }
-  uridecodebin->source_handlers =
-      g_list_remove (uridecodebin->source_handlers, handler);
+  if (handler->pending_buffering_msg)
+    gst_message_unref (handler->pending_buffering_msg);
   g_slice_free (GstSourceHandler, handler);
 }
 
@@ -1028,18 +1613,28 @@ free_source_item (GstURIDecodeBin3 * uridecodebin, GstSourceItem * item)
   GST_LOG_OBJECT (uridecodebin, "source item %p", item);
   if (item->handler)
     free_source_handler (uridecodebin, item->handler);
+  g_free (item->uri);
   g_slice_free (GstSourceItem, item);
 }
 
+static void
+source_item_set_uri (GstSourceItem * item, const gchar * uri)
+{
+  if (item->uri)
+    g_free (item->uri);
+  item->uri = g_strdup (uri);
+  if (item->handler) {
+    g_object_set (item->handler->urisourcebin, "uri", uri, NULL);
+  }
+}
+
 static GstPlayItem *
-new_play_item (GstURIDecodeBin3 * dec, gchar * uri, gchar * suburi)
+new_play_item (GstURIDecodeBin3 * dec)
 {
   GstPlayItem *item = g_slice_new0 (GstPlayItem);
 
   item->uridecodebin = dec;
-  item->main_item = new_source_item (dec, item, uri);
-  if (suburi)
-    item->sub_item = new_source_item (dec, item, suburi);
+  item->group_id = GST_GROUP_ID_INVALID;
 
   return item;
 }
@@ -1056,6 +1651,170 @@ free_play_item (GstURIDecodeBin3 * dec, GstPlayItem * item)
   g_slice_free (GstPlayItem, item);
 }
 
+static void
+play_item_set_uri (GstPlayItem * item, const gchar * uri)
+{
+  if (!item->main_item) {
+    item->main_item =
+        new_source_item (item->uridecodebin, item, g_strdup (uri));
+  } else {
+    source_item_set_uri (item->main_item, uri);
+  }
+}
+
+static void
+play_item_set_suburi (GstPlayItem * item, const gchar * uri)
+{
+  if (!item->sub_item) {
+    item->sub_item = new_source_item (item->uridecodebin, item, g_strdup (uri));
+  } else {
+    source_item_set_uri (item->sub_item, uri);
+  }
+}
+
+static gboolean
+play_item_is_eos (GstPlayItem * item)
+{
+  if (item->main_item && item->main_item->handler) {
+    if (!source_handler_is_eos (item->main_item->handler))
+      return FALSE;
+  }
+  if (item->sub_item && item->sub_item->handler) {
+    if (!source_handler_is_eos (item->sub_item->handler))
+      return FALSE;
+  }
+
+  return TRUE;
+}
+
+/* Mark all sourcepads of a play item as EOS. Used in pull-mode */
+static void
+play_item_set_eos (GstPlayItem * item)
+{
+  if (item->main_item && item->main_item->handler)
+    source_handler_set_eos (item->main_item->handler);
+
+  if (item->sub_item && item->sub_item->handler)
+    source_handler_set_eos (item->sub_item->handler);
+}
+
+static gboolean
+play_item_has_all_pads (GstPlayItem * item)
+{
+  GstSourceHandler *handler;
+
+  if (item->main_item && item->main_item->handler) {
+    handler = item->main_item->handler;
+    if (handler->expected_pads != g_list_length (handler->sourcepads))
+      return FALSE;
+  }
+
+  if (item->sub_item && item->sub_item->handler) {
+    handler = item->sub_item->handler;
+    if (handler->expected_pads != g_list_length (handler->sourcepads))
+      return FALSE;
+  }
+
+  return TRUE;
+}
+
+/* Returns the next inactive play item. If none available, it will create one
+ * and add it to the list of play items */
+static GstPlayItem *
+next_inactive_play_item (GstURIDecodeBin3 * dec)
+{
+  GstPlayItem *res;
+  GList *iter;
+
+  for (iter = dec->play_items; iter; iter = iter->next) {
+    res = iter->data;
+    if (!res->active)
+      return res;
+  }
+
+  GST_DEBUG_OBJECT (dec, "No inactive play items, creating a new one");
+  res = new_play_item (dec);
+  dec->play_items = g_list_append (dec->play_items, res);
+
+  return res;
+}
+
+static GstPadProbeReturn
+uri_src_ignore_block_probe (GstPad * pad, GstPadProbeInfo * info,
+    GstSourcePad * srcpad)
+{
+  GST_DEBUG_OBJECT (pad, "blocked");
+  return GST_PAD_PROBE_OK;
+}
+
+static void
+gst_uri_decode_bin3_set_uri (GstURIDecodeBin3 * dec, const gchar * uri)
+{
+  GstPlayItem *item;
+  gboolean start_item = FALSE;
+
+  GST_DEBUG_OBJECT (dec, "uri: %s", uri);
+
+  item = next_inactive_play_item (dec);
+  play_item_set_uri (item, uri);
+  if (dec->instant_uri && item != dec->input_item) {
+    GList *old_pads = get_all_play_item_source_pads (dec->input_item);
+    GList *iter;
+
+    /* Switch immediately if not the current input item */
+    GST_DEBUG_OBJECT (dec, "Switching immediately");
+
+    /* FLUSH START all input pads */
+    for (iter = old_pads; iter; iter = iter->next) {
+      GstSourcePad *spad = iter->data;
+      if (spad->db3_sink_pad) {
+        /* Mark all input pads as EOS */
+        gst_pad_send_event (spad->db3_sink_pad, gst_event_new_flush_start ());
+      }
+      /* Block all input source pads */
+      spad->block_probe_id =
+          gst_pad_add_probe (spad->src_pad, GST_PAD_PROBE_TYPE_IDLE,
+          (GstPadProbeCallback) uri_src_ignore_block_probe, spad, NULL);
+      spad->saw_eos = TRUE;
+    }
+    for (iter = old_pads; iter; iter = iter->next) {
+      /* FLUSH_STOP all current input pads */
+      GstSourcePad *spad = iter->data;
+      if (spad->db3_sink_pad) {
+        gst_pad_send_event (spad->db3_sink_pad,
+            gst_event_new_flush_stop (TRUE));
+      }
+    }
+    start_item = TRUE;
+  } else if (dec->input_item->posted_about_to_finish) {
+    GList *iter = g_list_find (dec->play_items, dec->input_item);
+    /* If the current item is finishing and the new item is the one just after,
+     *  we need to activate it */
+    if (iter && iter->next && iter->next->data == item) {
+      GST_DEBUG_OBJECT (dec, "Starting new entry (gapless mode)");
+      start_item = TRUE;
+    }
+  }
+
+  if (start_item) {
+    /* Start new item */
+    activate_play_item (item);
+  }
+}
+
+static void
+gst_uri_decode_bin3_set_suburi (GstURIDecodeBin3 * dec, const gchar * uri)
+{
+  GstPlayItem *item;
+  GST_DEBUG_OBJECT (dec, "suburi: %s", uri);
+
+  /* FIXME : Handle instant-uri-change. Should we just apply it automatically to
+   * the current input item ? */
+
+  item = next_inactive_play_item (dec);
+  play_item_set_suburi (item, uri);
+}
+
 /* Sync source handlers for the given play item. Might require creating/removing some
  * and/or configure the handlers accordingly */
 static GstStateChangeReturn
@@ -1063,12 +1822,12 @@ assign_handlers_to_item (GstURIDecodeBin3 * dec, GstPlayItem * item)
 {
   GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
 
-  /* FIXME : Go over existing handlers to see if we can assign some to the
-   * given item */
+  if (item->main_item == NULL)
+    return GST_STATE_CHANGE_FAILURE;
 
   /* Create missing handlers */
   if (item->main_item->handler == NULL) {
-    item->main_item->handler = new_source_handler (dec, TRUE);
+    item->main_item->handler = new_source_handler (dec, item, TRUE);
     ret = activate_source_item (item->main_item);
     if (ret == GST_STATE_CHANGE_FAILURE)
       return ret;
@@ -1079,40 +1838,37 @@ assign_handlers_to_item (GstURIDecodeBin3 * dec, GstPlayItem * item)
 
 /* Called to activate the next play item */
 static GstStateChangeReturn
-activate_next_play_item (GstURIDecodeBin3 * dec)
+activate_play_item (GstPlayItem * item)
 {
-  GstPlayItem *item;
   GstStateChangeReturn ret;
 
-  /* If there is no current play entry, create one from the uri/suburi
-   * FIXME : Use a playlist API in the future */
-  item = new_play_item (dec, dec->uri, dec->suburi);
+  GST_DEBUG_OBJECT (item->uridecodebin, "Activating play item");
 
-  ret = assign_handlers_to_item (dec, item);
-  if (ret == GST_STATE_CHANGE_FAILURE) {
-    free_play_item (dec, item);
-    return ret;
+  ret = assign_handlers_to_item (item->uridecodebin, item);
+  if (ret != GST_STATE_CHANGE_FAILURE) {
+    item->active = TRUE;
   }
 
-  dec->play_items = g_list_append (dec->play_items, item);
-  dec->current = dec->play_items->data;
-
   return ret;
 }
 
+/* Remove all but the last play item */
 static void
-free_play_items (GstURIDecodeBin3 * dec)
+purge_play_items (GstURIDecodeBin3 * dec)
 {
-  GList *tmp;
+  GST_DEBUG_OBJECT (dec, "Purging play items");
 
-  for (tmp = dec->play_items; tmp; tmp = tmp->next) {
-    GstPlayItem *item = (GstPlayItem *) tmp->data;
+  PLAY_ITEMS_LOCK (dec);
+  g_cond_signal (&dec->input_source_drained);
+  while (dec->play_items && dec->play_items->next) {
+    GstPlayItem *item = dec->play_items->data;
+    dec->play_items = g_list_remove (dec->play_items, item);
     free_play_item (dec, item);
   }
 
-  g_list_free (dec->play_items);
-  dec->play_items = NULL;
-  dec->current = NULL;
+  dec->output_item = dec->input_item = dec->play_items->data;
+  dec->output_item->posted_about_to_finish = FALSE;
+  PLAY_ITEMS_UNLOCK (dec);
 }
 
 static GstStateChangeReturn
@@ -1127,9 +1883,17 @@ gst_uri_decode_bin3_change_state (GstElement * element,
       g_object_set (uridecodebin->decodebin, "caps", uridecodebin->caps, NULL);
       break;
     case GST_STATE_CHANGE_READY_TO_PAUSED:
-      ret = activate_next_play_item (uridecodebin);
+      g_atomic_int_set (&uridecodebin->shutdown, 0);
+      ret = activate_play_item (uridecodebin->input_item);
       if (ret == GST_STATE_CHANGE_FAILURE)
         goto failure;
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      PLAY_ITEMS_LOCK (uridecodebin);
+      g_atomic_int_set (&uridecodebin->shutdown, 1);
+      g_cond_signal (&uridecodebin->input_source_drained);
+      PLAY_ITEMS_UNLOCK (uridecodebin);
+      break;
     default:
       break;
   }
@@ -1140,10 +1904,9 @@ gst_uri_decode_bin3_change_state (GstElement * element,
 
   switch (transition) {
     case GST_STATE_CHANGE_PAUSED_TO_READY:
-      /* FIXME: Cleanup everything */
-      free_play_items (uridecodebin);
-      /* Free play item */
-      uridecodebin->posted_about_to_finish = FALSE;
+      /* Remove all play items *but* the last one, which becomes the current entry */
+      purge_play_items (uridecodebin);
+      uridecodebin->input_item->active = FALSE;
       break;
     default:
       break;
@@ -1155,11 +1918,93 @@ gst_uri_decode_bin3_change_state (GstElement * element,
 failure:
   {
     if (transition == GST_STATE_CHANGE_READY_TO_PAUSED)
-      free_play_items (uridecodebin);
+      purge_play_items (uridecodebin);
     return ret;
   }
 }
 
+static GstSourceHandler *
+find_source_handler_for_element (GstURIDecodeBin3 * uridecodebin,
+    GstObject * element)
+{
+  GList *iter;
+
+  for (iter = uridecodebin->play_items; iter; iter = iter->next) {
+    GstPlayItem *item = iter->data;
+
+    if (item->main_item && item->main_item->handler) {
+      GstSourceHandler *handler = item->main_item->handler;
+
+      if (gst_object_has_as_ancestor (element,
+              (GstObject *) handler->urisourcebin))
+        return handler;
+    }
+    if (item->sub_item && item->sub_item->handler) {
+      GstSourceHandler *handler = item->sub_item->handler;
+
+      if (gst_object_has_as_ancestor (element,
+              (GstObject *) handler->urisourcebin))
+        return handler;
+    }
+  }
+
+  return NULL;
+}
+
+static void
+gst_uri_decode_bin3_handle_message (GstBin * bin, GstMessage * msg)
+{
+  GstURIDecodeBin3 *uridecodebin = (GstURIDecodeBin3 *) bin;
+
+  switch (GST_MESSAGE_TYPE (msg)) {
+    case GST_MESSAGE_STREAMS_SELECTED:
+    {
+      GstSourceHandler *handler;
+      GST_DEBUG_OBJECT (uridecodebin, "Handle streams selected");
+      PLAY_ITEMS_LOCK (uridecodebin);
+      /* Find the matching handler (if any) */
+      if ((handler = find_source_handler_for_element (uridecodebin, msg->src))) {
+        handler->expected_pads = gst_message_streams_selected_get_size (msg);
+        GST_DEBUG_OBJECT (uridecodebin,
+            "Got streams-selected for %s with %d streams selected",
+            GST_ELEMENT_NAME (handler->urisourcebin), handler->expected_pads);
+      }
+      PLAY_ITEMS_UNLOCK (uridecodebin);
+      break;
+    }
+    case GST_MESSAGE_BUFFERING:
+    {
+      GstSourceHandler *handler;
+      GST_DEBUG_OBJECT (uridecodebin, "Handle buffering message");
+      PLAY_ITEMS_LOCK (uridecodebin);
+      /* Find the matching handler (if any) */
+      handler = find_source_handler_for_element (uridecodebin, msg->src);
+      if (!handler || !uridecodebin->input_item->main_item) {
+        gst_message_unref (msg);
+        msg = NULL;
+      } else if (handler != uridecodebin->input_item->main_item->handler) {
+        /* Store the message for a later time */
+        if (handler->pending_buffering_msg)
+          gst_message_unref (handler->pending_buffering_msg);
+        handler->pending_buffering_msg = msg;
+        msg = NULL;
+      } else {
+        /* This is the active main input item, we can forward directly */
+        GST_DEBUG_OBJECT (uridecodebin,
+            "Forwarding message for active input item");
+      }
+      PLAY_ITEMS_UNLOCK (uridecodebin);
+      break;
+
+    }
+    default:
+      break;
+  }
+
+  if (msg)
+    GST_BIN_CLASS (parent_class)->handle_message (bin, msg);
+}
+
 static gboolean
 gst_uri_decodebin3_send_event (GstElement * element, GstEvent * event)
 {
diff --git a/subprojects/gst-plugins-base/gst/playback/gsturisourcebin.c b/subprojects/gst-plugins-base/gst/playback/gsturisourcebin.c
index 9161a07a95..c2e7f3e6b8 100644
--- a/subprojects/gst-plugins-base/gst/playback/gsturisourcebin.c
+++ b/subprojects/gst-plugins-base/gst/playback/gsturisourcebin.c
@@ -34,10 +34,6 @@
  * > Its behaviour and exposed API is subject to change.
  */
 
-/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
- * with newer GLib versions (>= 2.31.0) */
-#define GLIB_DISABLE_DEPRECATION_WARNINGS
-
 #ifdef HAVE_CONFIG_H
 #  include "config.h"
 #endif
@@ -90,38 +86,63 @@ typedef struct _OutputSlotInfo OutputSlotInfo;
     g_mutex_unlock (&GST_URI_SOURCE_BIN_CAST(ubin)->buffering_lock);		\
 } G_STMT_END
 
-/* Track a source pad from a child that
- * is linked or needs linking to an output
- * slot, or source pads that are directly
- * exposed as ghost pads */
+/* Track a source pad from the source element and the chain of (optional)
+ * elements that are linked to it up to the output slots */
 struct _ChildSrcPadInfo
 {
-  guint blocking_probe_id;
-  guint event_probe_id;
+  GstURISourceBin *urisrc;
 
-  /* Source pad this info is attached to (not reffed, since
-   * the pad owns the ChildSrcPadInfo as qdata */
+  /* Source pad this info is attached to (reffed) */
   GstPad *src_pad;
-  GstCaps *cur_caps;            /* holds ref */
-  GstPad *ghost_pad;            /* ghostpad if any */
 
-  /* Configured output slot, if any */
-  OutputSlotInfo *output_slot;
+  /* An optional typefind */
+  GstElement *typefind;
 
-  /* If this info is for a directly exposed pad,
-   * rather than linked through a slot it's here: */
-  GstPad *output_pad;
+  /* Pre-parsebin buffering elements. Only present is parse-streams and
+   * downloading *or* ring-buffer-max-size */
+  GstElement *pre_parse_queue;
+
+  /* Post-parsebin multiqueue. Only present if parse-streams and buffering is
+   * required */
+  GstElement *multiqueue;
+
+  /* An optional demuxer or parsebin */
+  GstElement *demuxer;
+  gboolean demuxer_handles_buffering;
+
+  /* list of output slots */
+  GList *outputs;
+
+  /* The following fields specify how this output should be handled */
+
+  /* use_downloadbuffer : TRUE if the content from the source should be
+   * downloaded with a downloadbuffer element */
+  gboolean use_downloadbuffer;
+
+  /* use_queue2: TRUE if the contents should be buffered through a queue2
+   * element */
+  gboolean use_queue2;
 };
 
+/* Output Slot:
+ *
+ * Handles everything related to outputing, including optional buffering.
+ */
 struct _OutputSlotInfo
 {
-  ChildSrcPadInfo *linked_info; /* demux source pad info feeding this slot, if any */
-  GstElement *queue;            /* queue2 or downloadbuffer */
-  GstPad *sinkpad;              /* Sink pad of the queue eleemnt */
-  GstPad *srcpad;               /* Output ghost pad */
+  ChildSrcPadInfo *linked_info; /* source pad info feeding this slot */
+
+  GstPad *originating_pad;      /* Pad that created this OutputSlotInfo (ref held) */
+  GstPad *output_pad;           /* Output ghost pad */
+
   gboolean is_eos;              /* Did EOS get fed into the buffering element */
 
+  GstElement *queue;            /* queue2 or downloadbuffer */
+  GstPad *queue_sinkpad;        /* Sink pad of the queue eleemnt */
+
   gulong bitrate_changed_id;    /* queue bitrate changed notification */
+
+  guint demuxer_event_probe_id;
 };
 
 /**
@@ -135,30 +156,26 @@ struct _GstURISourceBin
 
   GMutex lock;                  /* lock for constructing */
 
-  GMutex factories_lock;
-  guint32 factories_cookie;
-  GList *factories;             /* factories we can use for selecting elements */
-
   gchar *uri;
   guint64 connection_speed;
 
+  gboolean activated;           /* TRUE if the switch to PAUSED has been completed */
+  gboolean flushing;            /* TRUE if switching from PAUSED to READY */
+  GCond activation_cond;        /* Uses the urisourcebin lock */
+
   gboolean is_stream;
   gboolean is_adaptive;
-  gboolean demuxer_handles_buffering;   /* If TRUE: Don't use buffering elements */
-  gboolean source_streams_aware;        /* if TRUE: Don't block output pads */
-  gboolean need_queue;
   guint64 buffer_duration;      /* When buffering, buffer duration (ns) */
   guint buffer_size;            /* When buffering, buffer size (bytes) */
   gboolean download;
   gboolean use_buffering;
   gdouble low_watermark;
   gdouble high_watermark;
+  gboolean parse_streams;
 
   GstElement *source;
-  GList *typefinds;             /* list of typefind element */
 
-  GstElement *demuxer;          /* Adaptive demuxer if any */
-  GSList *out_slots;
+  GList *src_infos;             /* List of ChildSrcPadInfo for the source */
 
   guint numpads;
 
@@ -167,9 +184,6 @@ struct _GstURISourceBin
 
   guint64 ring_buffer_max_size; /* 0 means disabled */
 
-  GList *pending_pads;          /* Pads we have blocked pending assignment
-                                   to an output source pad */
-
   GList *buffering_status;      /* element currently buffering messages */
   gint last_buffering_pct;      /* Avoid sending buffering over and over */
   GMutex buffering_lock;
@@ -217,7 +231,8 @@ enum
 #define DEFAULT_USE_BUFFERING       TRUE
 #define DEFAULT_RING_BUFFER_MAX_SIZE 0
 #define DEFAULT_LOW_WATERMARK       0.01
-#define DEFAULT_HIGH_WATERMARK      0.99
+#define DEFAULT_HIGH_WATERMARK      0.60
+#define DEFAULT_PARSE_STREAMS       FALSE
 
 #define ACTUAL_DEFAULT_BUFFER_SIZE  10 * 1024 * 1024    /* The value used for byte limits when buffer-size == -1 */
 #define ACTUAL_DEFAULT_BUFFER_DURATION  5 * GST_SECOND  /* The value used for time limits when buffer-duration == -1 */
@@ -240,6 +255,7 @@ enum
   PROP_LOW_WATERMARK,
   PROP_HIGH_WATERMARK,
   PROP_STATISTICS,
+  PROP_PARSE_STREAMS,
 };
 
 #define CUSTOM_EOS_QUARK _custom_eos_quark_get ()
@@ -285,14 +301,16 @@ static gboolean gst_uri_source_bin_query (GstElement * element,
 static GstStateChangeReturn gst_uri_source_bin_change_state (GstElement *
     element, GstStateChange transition);
 
-static void remove_demuxer (GstURISourceBin * bin);
+static void handle_new_pad (ChildSrcPadInfo * info, GstPad * srcpad,
+    GstCaps * caps);
+static gboolean setup_typefind (ChildSrcPadInfo * info);
 static void expose_output_pad (GstURISourceBin * urisrc, GstPad * pad);
-static OutputSlotInfo *get_output_slot (GstURISourceBin * urisrc,
-    gboolean do_download, gboolean is_adaptive, GstCaps * caps);
+static OutputSlotInfo *new_output_slot (ChildSrcPadInfo * info,
+    GstPad * originating_pad);
 static void free_output_slot (OutputSlotInfo * slot, GstURISourceBin * urisrc);
 static void free_output_slot_async (GstURISourceBin * urisrc,
     OutputSlotInfo * slot);
-static GstPad *create_output_pad (GstURISourceBin * urisrc, GstPad * pad);
+static GstPad *create_output_pad (OutputSlotInfo * slot, GstPad * pad);
 static void remove_buffering_msgs (GstURISourceBin * bin, GstObject * src);
 
 static void update_queue_values (GstURISourceBin * urisrc);
@@ -421,6 +439,20 @@ gst_uri_source_bin_class_init (GstURISourceBinClass * klass)
           "this element", GST_TYPE_STRUCTURE,
           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 
+  /**
+   * GstURISourceBin:parse-streams:
+   *
+   * A `parsebin` element will be used on all non-raw streams, and urisourcebin
+   * will output the elementary streams. Recommended when buffering is used
+   * since it will provide accurate buffering levels.
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class, PROP_PARSE_STREAMS,
+      g_param_spec_boolean ("parse-streams", "Parse Streams",
+          "Extract the elementary streams of non-raw sources",
+          DEFAULT_PARSE_STREAMS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   /**
    * GstURISourceBin::drained:
    *
@@ -477,14 +509,13 @@ gst_uri_source_bin_class_init (GstURISourceBinClass * klass)
 static void
 gst_uri_source_bin_init (GstURISourceBin * urisrc)
 {
-  /* first filter out the interesting element factories */
-  g_mutex_init (&urisrc->factories_lock);
-
   g_mutex_init (&urisrc->lock);
 
   g_mutex_init (&urisrc->buffering_lock);
   g_mutex_init (&urisrc->buffering_post_lock);
 
+  g_cond_init (&urisrc->activation_cond);
+
   urisrc->uri = g_strdup (DEFAULT_PROP_URI);
   urisrc->connection_speed = DEFAULT_CONNECTION_SPEED;
 
@@ -497,8 +528,6 @@ gst_uri_source_bin_init (GstURISourceBin * urisrc)
   urisrc->low_watermark = DEFAULT_LOW_WATERMARK;
   urisrc->high_watermark = DEFAULT_HIGH_WATERMARK;
 
-  urisrc->demuxer_handles_buffering = FALSE;
-
   GST_OBJECT_FLAG_SET (urisrc,
       GST_ELEMENT_FLAG_SOURCE | GST_BIN_FLAG_STREAMS_AWARE);
   gst_bin_set_suppressed_flags (GST_BIN (urisrc),
@@ -510,14 +539,10 @@ gst_uri_source_bin_finalize (GObject * obj)
 {
   GstURISourceBin *urisrc = GST_URI_SOURCE_BIN (obj);
 
-  remove_demuxer (urisrc);
   g_mutex_clear (&urisrc->lock);
-  g_mutex_clear (&urisrc->factories_lock);
   g_mutex_clear (&urisrc->buffering_lock);
   g_mutex_clear (&urisrc->buffering_post_lock);
   g_free (urisrc->uri);
-  if (urisrc->factories)
-    gst_plugin_feature_list_free (urisrc->factories);
 
   G_OBJECT_CLASS (parent_class)->finalize (obj);
 }
@@ -565,6 +590,9 @@ gst_uri_source_bin_set_property (GObject * object, guint prop_id,
       urisrc->high_watermark = g_value_get_double (value);
       update_queue_values (urisrc);
       break;
+    case PROP_PARSE_STREAMS:
+      urisrc->parse_streams = g_value_get_boolean (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -621,6 +649,9 @@ gst_uri_source_bin_get_property (GObject * object, guint prop_id,
     case PROP_STATISTICS:
       g_value_take_boxed (value, get_queue_statistics (urisrc));
       break;
+    case PROP_PARSE_STREAMS:
+      g_value_set_boolean (value, urisrc->parse_streams);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -639,244 +670,144 @@ copy_sticky_events (GstPad * pad, GstEvent ** event, gpointer user_data)
 }
 
 static GstPadProbeReturn
-pending_pad_blocked (GstPad * pad, GstPadProbeInfo * info, gpointer user_data);
-
-static GstPadProbeReturn
-demux_pad_events (GstPad * pad, GstPadProbeInfo * info, gpointer user_data);
+demux_pad_events (GstPad * pad, GstPadProbeInfo * info, OutputSlotInfo * slot);
 
+/* CALL WITH URISOURCEBIN LOCK */
 static void
-free_child_src_pad_info (ChildSrcPadInfo * info)
+free_child_src_pad_info (ChildSrcPadInfo * info, GstURISourceBin * urisrc)
 {
-  if (info->cur_caps)
-    gst_caps_unref (info->cur_caps);
-  if (info->output_pad)
-    gst_object_unref (info->output_pad);
-  g_free (info);
-}
+  g_assert (info->src_pad);
 
-/* Called by the signal handlers when a demuxer has produced a new stream */
-static void
-new_demuxer_pad_added_cb (GstElement * element, GstPad * pad,
-    GstURISourceBin * urisrc)
-{
-  ChildSrcPadInfo *info;
-
-  info = g_new0 (ChildSrcPadInfo, 1);
-  info->src_pad = pad;
-  info->cur_caps = gst_pad_get_current_caps (pad);
-  if (info->cur_caps == NULL)
-    info->cur_caps = gst_pad_query_caps (pad, NULL);
+  GST_DEBUG_OBJECT (urisrc,
+      "Freeing ChildSrcPadInfo for %" GST_PTR_FORMAT, info->src_pad);
+  if (info->typefind) {
+    gst_element_set_state (info->typefind, GST_STATE_NULL);
+    gst_bin_remove (GST_BIN_CAST (urisrc), info->typefind);
+  }
 
-  g_object_set_data_full (G_OBJECT (pad), "urisourcebin.srcpadinfo",
-      info, (GDestroyNotify) free_child_src_pad_info);
+  gst_object_unref (info->src_pad);
+  if (info->demuxer) {
+    GST_DEBUG_OBJECT (urisrc, "Removing demuxer");
+    gst_element_set_state (info->demuxer, GST_STATE_NULL);
+    gst_bin_remove (GST_BIN_CAST (urisrc), info->demuxer);
+  }
 
-  GST_URI_SOURCE_BIN_LOCK (urisrc);
-  /* If the demuxer handles buffering and is streams-aware, we can expose it
-     as-is directly. We still add an event probe to deal with EOS */
-  if (urisrc->demuxer_handles_buffering && urisrc->source_streams_aware) {
-    info->ghost_pad = create_output_pad (urisrc, pad);
-    GST_DEBUG_OBJECT (element,
-        "New streams-aware demuxer pad %s:%s , exposing directly",
-        GST_DEBUG_PAD_NAME (pad));
-    expose_output_pad (urisrc, info->ghost_pad);
-    GST_URI_SOURCE_BIN_UNLOCK (urisrc);
-  } else {
-    GST_DEBUG_OBJECT (element, "new demuxer pad, name: <%s>. "
-        "Added as pending pad with caps %" GST_PTR_FORMAT,
-        GST_PAD_NAME (pad), info->cur_caps);
+  g_list_foreach (info->outputs, (GFunc) free_output_slot, urisrc);
+  g_list_free (info->outputs);
 
-    urisrc->pending_pads = g_list_prepend (urisrc->pending_pads, pad);
-    GST_URI_SOURCE_BIN_UNLOCK (urisrc);
+  if (info->multiqueue) {
+    GST_DEBUG_OBJECT (urisrc, "Removing multiqueue");
+    gst_element_set_state (info->multiqueue, GST_STATE_NULL);
+    remove_buffering_msgs (urisrc, GST_OBJECT_CAST (info->multiqueue));
+    gst_bin_remove (GST_BIN_CAST (urisrc), info->multiqueue);
+  }
 
-    /* Block the pad. On the first data on that pad if it hasn't
-     * been linked to an output slot, we'll create one */
-    info->blocking_probe_id =
-        gst_pad_add_probe (pad, GST_PAD_PROBE_TYPE_BLOCK_DOWNSTREAM,
-        pending_pad_blocked, urisrc, NULL);
+  if (info->pre_parse_queue) {
+    gst_element_set_state (info->pre_parse_queue, GST_STATE_NULL);
+    remove_buffering_msgs (urisrc, GST_OBJECT_CAST (info->pre_parse_queue));
+    gst_bin_remove (GST_BIN_CAST (urisrc), info->pre_parse_queue);
   }
-  info->event_probe_id =
-      gst_pad_add_probe (pad, GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM |
-      GST_PAD_PROBE_TYPE_EVENT_FLUSH, demux_pad_events, urisrc, NULL);
+
+  g_free (info);
 }
 
-static GstPadProbeReturn
-pending_pad_blocked (GstPad * pad, GstPadProbeInfo * info, gpointer user_data)
+static ChildSrcPadInfo *
+get_cspi_for_pad (GstURISourceBin * urisrc, GstPad * pad)
 {
-  ChildSrcPadInfo *child_info;
-  OutputSlotInfo *slot;
-  GstURISourceBin *urisrc = GST_URI_SOURCE_BIN (user_data);
-  GstCaps *caps;
-  GstPad *output_pad;
-
-  if (!(child_info =
-          g_object_get_data (G_OBJECT (pad), "urisourcebin.srcpadinfo")))
-    goto done;
-
-  GST_LOG_OBJECT (urisrc, "Removing pad %" GST_PTR_FORMAT " from pending list",
-      pad);
-
-  GST_URI_SOURCE_BIN_LOCK (urisrc);
-
-  /* Once blocked, this pad is no longer pending, one way or another */
-  urisrc->pending_pads = g_list_remove (urisrc->pending_pads, pad);
+  GList *iter;
 
-  /* If already linked to a slot, nothing more to do */
-  if (child_info->output_slot) {
-    GST_LOG_OBJECT (urisrc, "Pad %" GST_PTR_FORMAT " is linked to queue %"
-        GST_PTR_FORMAT " on slot %p", pad, child_info->output_slot->queue,
-        child_info->output_slot);
-    GST_URI_SOURCE_BIN_UNLOCK (urisrc);
-    goto done;
+  for (iter = urisrc->src_infos; iter; iter = iter->next) {
+    ChildSrcPadInfo *info = iter->data;
+    if (info->src_pad == pad)
+      return info;
   }
+  return NULL;
+}
 
-  /* If the demuxer handles buffering, we can expose it as-is */
-  if (urisrc->demuxer_handles_buffering) {
-    GstPad *ghostpad = create_output_pad (urisrc, pad);
-    GST_DEBUG_OBJECT (pad, "Demuxer handles buffering, exposing as-is");
-    expose_output_pad (urisrc, ghostpad);
-    GST_URI_SOURCE_BIN_UNLOCK (urisrc);
-    goto done;
-  }
+static ChildSrcPadInfo *
+new_child_src_pad_info (GstURISourceBin * urisrc, GstPad * pad)
+{
+  ChildSrcPadInfo *info;
 
-  caps = gst_pad_get_current_caps (pad);
-  if (caps == NULL)
-    caps = gst_pad_query_caps (pad, NULL);
+  GST_LOG_OBJECT (urisrc, "New ChildSrcPadInfo for %" GST_PTR_FORMAT, pad);
 
-  slot = get_output_slot (urisrc, FALSE, TRUE, caps);
+  info = g_new0 (ChildSrcPadInfo, 1);
+  info->urisrc = urisrc;
+  info->src_pad = gst_object_ref (pad);
 
-  gst_caps_unref (caps);
+  urisrc->src_infos = g_list_append (urisrc->src_infos, info);
 
-  if (slot == NULL) {
-    GST_URI_SOURCE_BIN_UNLOCK (urisrc);
-    goto done;
-  }
+  return info;
+}
 
-  GST_LOG_OBJECT (urisrc, "Pad %" GST_PTR_FORMAT " linked to slot %p", pad,
-      slot);
+/* Called by the signal handlers when a demuxer has produced a new stream */
+static void
+new_demuxer_pad_added_cb (GstElement * element, GstPad * pad,
+    ChildSrcPadInfo * info)
+{
+  GstURISourceBin *urisrc = info->urisrc;
+  OutputSlotInfo *slot;
+  GstPad *output_pad;
 
-  child_info->output_slot = slot;
-  slot->linked_info = child_info;
-  gst_pad_link (pad, slot->sinkpad);
+  GST_DEBUG_OBJECT (element, "New pad %" GST_PTR_FORMAT, pad);
+
+  GST_URI_SOURCE_BIN_LOCK (urisrc);
+  /* If the demuxer handles buffering and is streams-aware, we can expose it
+     as-is directly. We still add an event probe to deal with EOS */
+  slot = new_output_slot (info, pad);
+  output_pad = gst_object_ref (slot->output_pad);
 
-  output_pad = gst_object_ref (slot->srcpad);
+  slot->demuxer_event_probe_id =
+      gst_pad_add_probe (pad, GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM |
+      GST_PAD_PROBE_TYPE_EVENT_FLUSH, (GstPadProbeCallback) demux_pad_events,
+      slot, NULL);
 
   GST_URI_SOURCE_BIN_UNLOCK (urisrc);
-
   expose_output_pad (urisrc, output_pad);
   gst_object_unref (output_pad);
-
-done:
-  return GST_PAD_PROBE_REMOVE;
 }
 
-/* Called with LOCK held */
-/* Looks for a suitable pending pad to connect onto this
- * finishing output slot that's about to EOS */
+/* Called with lock held */
 static gboolean
-link_pending_pad_to_output (GstURISourceBin * urisrc, OutputSlotInfo * slot)
+all_slots_are_eos (GstURISourceBin * urisrc)
 {
-  GList *cur;
-  ChildSrcPadInfo *in_info = slot->linked_info;
-  ChildSrcPadInfo *out_info = NULL;
-  gboolean res = FALSE;
-  GstCaps *cur_caps;
-
-  /* Look for a suitable pending pad */
-  cur_caps = gst_pad_get_current_caps (slot->sinkpad);
-
-  GST_DEBUG_OBJECT (urisrc,
-      "Looking for a pending pad with caps %" GST_PTR_FORMAT, cur_caps);
-
-  for (cur = urisrc->pending_pads; cur != NULL; cur = g_list_next (cur)) {
-    GstPad *pending = (GstPad *) (cur->data);
-    ChildSrcPadInfo *cur_info = NULL;
-    if ((cur_info =
-            g_object_get_data (G_OBJECT (pending),
-                "urisourcebin.srcpadinfo"))) {
-      /* Don't re-link to the same pad in case of EOS while still pending */
-      if (in_info == cur_info)
-        continue;
-      if (cur_caps == NULL || gst_caps_is_equal (cur_caps, cur_info->cur_caps)) {
-        GST_DEBUG_OBJECT (urisrc, "Found suitable pending pad %" GST_PTR_FORMAT
-            " with caps %" GST_PTR_FORMAT " to link to this output slot",
-            cur_info->src_pad, cur_info->cur_caps);
-        out_info = cur_info;
-        break;
-      }
-    }
-  }
-
-  if (cur_caps)
-    gst_caps_unref (cur_caps);
-
-  if (out_info) {
-    /* Block any upstream stuff while we switch out the pad */
-    guint block_id =
-        gst_pad_add_probe (slot->sinkpad, GST_PAD_PROBE_TYPE_BLOCK_UPSTREAM,
-        NULL, NULL, NULL);
-    GST_DEBUG_OBJECT (urisrc, "Linking pending pad %" GST_PTR_FORMAT
-        " to existing output slot %p", out_info->src_pad, slot);
+  GList *tmp;
 
-    if (in_info) {
-      gst_pad_unlink (in_info->src_pad, slot->sinkpad);
-      in_info->output_slot = NULL;
-      slot->linked_info = NULL;
+  for (tmp = urisrc->src_infos; tmp; tmp = tmp->next) {
+    ChildSrcPadInfo *cspi = tmp->data;
+    GList *iter2;
+    for (iter2 = cspi->outputs; iter2; iter2 = iter2->next) {
+      OutputSlotInfo *slot = (OutputSlotInfo *) iter2->data;
+      if (slot->is_eos == FALSE)
+        return FALSE;
     }
-
-    if (gst_pad_link (out_info->src_pad, slot->sinkpad) == GST_PAD_LINK_OK) {
-      out_info->output_slot = slot;
-      slot->linked_info = out_info;
-
-      BUFFERING_LOCK (urisrc);
-      /* A re-linked slot is no longer EOS */
-      slot->is_eos = FALSE;
-      BUFFERING_UNLOCK (urisrc);
-      res = TRUE;
-      slot->is_eos = FALSE;
-      urisrc->pending_pads =
-          g_list_remove (urisrc->pending_pads, out_info->src_pad);
-    } else {
-      GST_ERROR_OBJECT (urisrc,
-          "Failed to link new demuxer pad to the output slot we tried");
-    }
-    gst_pad_remove_probe (slot->sinkpad, block_id);
   }
-
-  return res;
+  return TRUE;
 }
 
-/* Called with lock held */
-static gboolean
-all_slots_are_eos (GstURISourceBin * urisrc)
+/* CALL WITH URISOURCEBIN LOCK */
+static OutputSlotInfo *
+output_slot_for_originating_pad (ChildSrcPadInfo * info,
+    GstPad * originating_pad)
 {
-  GSList *tmp;
-
-  for (tmp = urisrc->out_slots; tmp; tmp = tmp->next) {
-    OutputSlotInfo *slot = (OutputSlotInfo *) tmp->data;
-    if (slot->is_eos == FALSE)
-      return FALSE;
+  GList *iter;
+  for (iter = info->outputs; iter; iter = iter->next) {
+    OutputSlotInfo *slot = iter->data;
+    if (slot->originating_pad == originating_pad)
+      return slot;
   }
-  return TRUE;
+
+  return NULL;
 }
 
 static GstPadProbeReturn
-demux_pad_events (GstPad * pad, GstPadProbeInfo * info, gpointer user_data)
+demux_pad_events (GstPad * pad, GstPadProbeInfo * info, OutputSlotInfo * slot)
 {
-  GstURISourceBin *urisrc = GST_URI_SOURCE_BIN (user_data);
-  ChildSrcPadInfo *child_info;
+  GstURISourceBin *urisrc = slot->linked_info->urisrc;
   GstPadProbeReturn ret = GST_PAD_PROBE_OK;
   GstEvent *ev = GST_PAD_PROBE_INFO_EVENT (info);
 
-  if (!(child_info =
-          g_object_get_data (G_OBJECT (pad), "urisourcebin.srcpadinfo")))
-    goto done;
-
   GST_URI_SOURCE_BIN_LOCK (urisrc);
-  /* If not linked to a slot, nothing more to do */
-  if (child_info->output_slot == NULL) {
-    GST_URI_SOURCE_BIN_UNLOCK (urisrc);
-    goto done;
-  }
 
   switch (GST_EVENT_TYPE (ev)) {
     case GST_EVENT_EOS:
@@ -885,49 +816,27 @@ demux_pad_events (GstPad * pad, GstPadProbeInfo * info, gpointer user_data)
 
       GST_LOG_OBJECT (urisrc, "EOS on pad %" GST_PTR_FORMAT, pad);
 
-      if ((urisrc->pending_pads &&
-              link_pending_pad_to_output (urisrc, child_info->output_slot))) {
-        /* Found a new source pad to give this slot data - no need to send EOS */
-        GST_URI_SOURCE_BIN_UNLOCK (urisrc);
-        ret = GST_PAD_PROBE_DROP;
-        goto done;
-      }
-
       BUFFERING_LOCK (urisrc);
       /* Mark that we fed an EOS to this slot */
-      child_info->output_slot->is_eos = TRUE;
+      slot->is_eos = TRUE;
       all_streams_eos = all_slots_are_eos (urisrc);
       BUFFERING_UNLOCK (urisrc);
 
-      /* EOS means this element is no longer buffering */
-      remove_buffering_msgs (urisrc,
-          GST_OBJECT_CAST (child_info->output_slot->queue));
-
-      /* Mark this custom EOS, replacing the event in the probe data */
-      ev = gst_event_make_writable (ev);
-      GST_PAD_PROBE_INFO_DATA (info) = ev;
-
-      gst_mini_object_set_qdata (GST_MINI_OBJECT_CAST (ev), CUSTOM_EOS_QUARK,
-          (gchar *) CUSTOM_EOS_QUARK_DATA, NULL);
+      if (slot->queue)
+        /* EOS means this element is no longer buffering */
+        remove_buffering_msgs (urisrc, GST_OBJECT_CAST (slot->queue));
 
       if (all_streams_eos) {
-        GST_DEBUG_OBJECT (urisrc, "POSTING ABOUT TO FINISH");
+        GST_DEBUG_OBJECT (urisrc, "Posting about-to-finish");
         g_signal_emit (urisrc,
             gst_uri_source_bin_signals[SIGNAL_ABOUT_TO_FINISH], 0, NULL);
       }
     }
       break;
-    case GST_EVENT_CAPS:
-    {
-      GstCaps *caps;
-      gst_event_parse_caps (ev, &caps);
-      gst_caps_replace (&child_info->cur_caps, caps);
-    }
-      break;
     case GST_EVENT_STREAM_START:
     case GST_EVENT_FLUSH_STOP:
       BUFFERING_LOCK (urisrc);
-      child_info->output_slot->is_eos = FALSE;
+      slot->is_eos = FALSE;
       BUFFERING_UNLOCK (urisrc);
       break;
     default:
@@ -936,7 +845,6 @@ demux_pad_events (GstPad * pad, GstPadProbeInfo * info, gpointer user_data)
 
   GST_URI_SOURCE_BIN_UNLOCK (urisrc);
 
-done:
   return ret;
 }
 
@@ -970,31 +878,37 @@ get_queue_statistics (GstURISourceBin * urisrc)
   guint64 min_time_level = 0, max_time_level = 0;
   gdouble avg_byte_level = 0., avg_time_level = 0.;
   guint i = 0;
-  GSList *cur;
+  GList *iter, *cur;
 
   GST_URI_SOURCE_BIN_LOCK (urisrc);
 
-  for (cur = urisrc->out_slots; cur != NULL; cur = g_slist_next (cur)) {
-    OutputSlotInfo *slot = (OutputSlotInfo *) (cur->data);
-    guint byte_limit = 0;
-    guint64 time_limit = 0;
+  for (iter = urisrc->src_infos; iter; iter = iter->next) {
+    ChildSrcPadInfo *info = iter->data;
+    for (cur = info->outputs; cur; cur = cur->next) {
+      OutputSlotInfo *slot = (OutputSlotInfo *) (cur->data);
+      guint byte_limit = 0;
+      guint64 time_limit = 0;
 
-    g_object_get (slot->queue, "current-level-bytes", &byte_limit,
-        "current-level-time", &time_limit, NULL);
+      if (!slot->queue)
+        continue;
+
+      g_object_get (slot->queue, "current-level-bytes", &byte_limit,
+          "current-level-time", &time_limit, NULL);
 
-    if (byte_limit < min_byte_level)
-      min_byte_level = byte_limit;
-    if (byte_limit > max_byte_level)
-      max_byte_level = byte_limit;
-    avg_byte_level = (avg_byte_level * i + byte_limit) / (gdouble) (i + 1);
+      if (byte_limit < min_byte_level)
+        min_byte_level = byte_limit;
+      if (byte_limit > max_byte_level)
+        max_byte_level = byte_limit;
+      avg_byte_level = (avg_byte_level * i + byte_limit) / (gdouble) (i + 1);
 
-    if (time_limit < min_time_level)
-      min_time_level = time_limit;
-    if (time_limit > max_time_level)
-      max_time_level = time_limit;
-    avg_time_level = (avg_time_level * i + time_limit) / (gdouble) (i + 1);
+      if (time_limit < min_time_level)
+        min_time_level = time_limit;
+      if (time_limit > max_time_level)
+        max_time_level = time_limit;
+      avg_time_level = (avg_time_level * i + time_limit) / (gdouble) (i + 1);
 
-    i++;
+      i++;
+    }
   }
   GST_URI_SOURCE_BIN_UNLOCK (urisrc);
 
@@ -1016,7 +930,7 @@ update_queue_values (GstURISourceBin * urisrc)
   guint buffer_size;
   gdouble low_watermark, high_watermark;
   guint64 cumulative_bitrate = 0;
-  GSList *cur;
+  GList *iter, *cur;
 
   GST_URI_SOURCE_BIN_LOCK (urisrc);
   duration = GET_BUFFER_DURATION (urisrc);
@@ -1024,22 +938,29 @@ update_queue_values (GstURISourceBin * urisrc)
   low_watermark = urisrc->low_watermark;
   high_watermark = urisrc->high_watermark;
 
-  for (cur = urisrc->out_slots; cur != NULL; cur = g_slist_next (cur)) {
-    OutputSlotInfo *slot = (OutputSlotInfo *) (cur->data);
-    guint64 bitrate = 0;
+  for (iter = urisrc->src_infos; iter; iter = iter->next) {
+    ChildSrcPadInfo *info = iter->data;
+    for (cur = info->outputs; cur; cur = cur->next) {
+      OutputSlotInfo *slot = (OutputSlotInfo *) (cur->data);
+      guint64 bitrate = 0;
 
-    if (g_object_class_find_property (G_OBJECT_GET_CLASS (slot->queue),
-            "bitrate")) {
-      g_object_get (G_OBJECT (slot->queue), "bitrate", &bitrate, NULL);
-    }
+      if (!slot->queue)
+        continue;
 
-    if (bitrate > 0)
-      cumulative_bitrate += bitrate;
-    else {
-      GST_TRACE_OBJECT (urisrc, "Unknown bitrate detected from %" GST_PTR_FORMAT
-          ", resetting all bitrates", slot->queue);
-      cumulative_bitrate = 0;
-      break;
+      if (g_object_class_find_property (G_OBJECT_GET_CLASS (slot->queue),
+              "bitrate")) {
+        g_object_get (G_OBJECT (slot->queue), "bitrate", &bitrate, NULL);
+      }
+
+      if (bitrate > 0)
+        cumulative_bitrate += bitrate;
+      else {
+        GST_TRACE_OBJECT (urisrc,
+            "Unknown bitrate detected from %" GST_PTR_FORMAT
+            ", resetting all bitrates", slot->queue);
+        cumulative_bitrate = 0;
+        break;
+      }
     }
   }
 
@@ -1047,32 +968,38 @@ update_queue_values (GstURISourceBin * urisrc)
       "bitrate %" G_GUINT64_FORMAT ", buffer size %u, buffer duration %"
       G_GINT64_FORMAT, cumulative_bitrate, buffer_size, duration);
 
-  for (cur = urisrc->out_slots; cur != NULL; cur = g_slist_next (cur)) {
-    OutputSlotInfo *slot = (OutputSlotInfo *) (cur->data);
-    guint byte_limit;
-
-    if (cumulative_bitrate > 0
-        && g_object_class_find_property (G_OBJECT_GET_CLASS (slot->queue),
-            "bitrate")) {
-      guint64 bitrate;
-      g_object_get (G_OBJECT (slot->queue), "bitrate", &bitrate, NULL);
-      byte_limit =
-          gst_util_uint64_scale (buffer_size, bitrate, cumulative_bitrate);
-    } else {
-      /* if not all queue's have valid bitrates, use the buffer-size as the
-       * limit */
-      byte_limit = buffer_size;
-    }
+  for (iter = urisrc->src_infos; iter; iter = iter->next) {
+    ChildSrcPadInfo *info = iter->data;
+    for (cur = info->outputs; cur; cur = cur->next) {
+      OutputSlotInfo *slot = (OutputSlotInfo *) (cur->data);
+      guint byte_limit;
+
+      if (!slot->queue)
+        continue;
 
-    GST_DEBUG_OBJECT (urisrc,
-        "calculated new limits for queue-like element %" GST_PTR_FORMAT
-        ", bytes:%u, time:%" G_GUINT64_FORMAT
-        ", low-watermark:%f, high-watermark:%f",
-        slot->queue, byte_limit, (guint64) duration, low_watermark,
-        high_watermark);
-    g_object_set (G_OBJECT (slot->queue), "max-size-bytes", byte_limit,
-        "max-size-time", (guint64) duration, "low-watermark", low_watermark,
-        "high-watermark", high_watermark, NULL);
+      if (cumulative_bitrate > 0
+          && g_object_class_find_property (G_OBJECT_GET_CLASS (slot->queue),
+              "bitrate")) {
+        guint64 bitrate;
+        g_object_get (G_OBJECT (slot->queue), "bitrate", &bitrate, NULL);
+        byte_limit =
+            gst_util_uint64_scale (buffer_size, bitrate, cumulative_bitrate);
+      } else {
+        /* if not all queue's have valid bitrates, use the buffer-size as the
+         * limit */
+        byte_limit = buffer_size;
+      }
+
+      GST_DEBUG_OBJECT (urisrc,
+          "calculated new limits for queue-like element %" GST_PTR_FORMAT
+          ", bytes:%u, time:%" G_GUINT64_FORMAT
+          ", low-watermark:%f, high-watermark:%f",
+          slot->queue, byte_limit, (guint64) duration, low_watermark,
+          high_watermark);
+      g_object_set (G_OBJECT (slot->queue), "max-size-bytes", byte_limit,
+          "max-size-time", (guint64) duration, "low-watermark", low_watermark,
+          "high-watermark", high_watermark, NULL);
+    }
   }
   GST_URI_SOURCE_BIN_UNLOCK (urisrc);
 }
@@ -1087,135 +1014,183 @@ on_queue_bitrate_changed (GstElement * queue, GParamSpec * pspec,
       (GstElementCallAsyncFunc) update_queue_values, NULL, NULL);
 }
 
-/* Called with lock held */
-static OutputSlotInfo *
-get_output_slot (GstURISourceBin * urisrc, gboolean do_download,
-    gboolean is_adaptive, GstCaps * caps)
+static void
+setup_downloadbuffer (GstURISourceBin * urisrc, GstElement * downloadbuffer)
 {
-  OutputSlotInfo *slot;
-  GstPad *srcpad;
-  GstElement *queue;
-  const gchar *elem_name;
+  gchar *temp_template, *filename;
+  const gchar *tmp_dir, *prgname;
 
-  /* If we have caps, iterate the existing slots and look for an
-   * unlinked one that can be used */
-  if (caps && gst_caps_is_fixed (caps)) {
-    GSList *cur;
-    GstCaps *cur_caps;
-
-    for (cur = urisrc->out_slots; cur != NULL; cur = g_slist_next (cur)) {
-      slot = (OutputSlotInfo *) (cur->data);
-      if (slot->linked_info == NULL) {
-        cur_caps = gst_pad_get_current_caps (slot->sinkpad);
-        if (cur_caps == NULL || gst_caps_is_equal (caps, cur_caps)) {
-          GST_LOG_OBJECT (urisrc, "Found existing slot %p to link to", slot);
-          gst_caps_unref (cur_caps);
-          slot->is_eos = FALSE;
-          return slot;
-        }
-        gst_caps_unref (cur_caps);
-      }
-    }
-  }
+  tmp_dir = g_get_user_cache_dir ();
+  prgname = g_get_prgname ();
+  if (prgname == NULL)
+    prgname = "GStreamer";
 
-  /* Otherwise create the new slot */
-  if (do_download)
-    elem_name = "downloadbuffer";
-  else
-    elem_name = "queue2";
+  filename = g_strdup_printf ("%s-XXXXXX", prgname);
 
-  queue = gst_element_factory_make (elem_name, NULL);
-  if (!queue)
-    goto no_buffer_element;
+  /* build our filename */
+  temp_template = g_build_filename (tmp_dir, filename, NULL);
 
-  slot = g_new0 (OutputSlotInfo, 1);
-  slot->queue = queue;
+  GST_DEBUG_OBJECT (urisrc, "enable download buffering in %s (%s, %s, %s)",
+      temp_template, tmp_dir, prgname, filename);
 
-  /* Set the slot onto the queue (needed in buffering msg handling) */
-  g_object_set_data (G_OBJECT (queue), "urisourcebin.slotinfo", slot);
+  /* configure progressive download for selected media types */
+  g_object_set (downloadbuffer, "temp-template", temp_template, NULL);
 
-  slot->bitrate_changed_id =
-      g_signal_connect (G_OBJECT (queue), "notify::bitrate",
-      (GCallback) on_queue_bitrate_changed, urisrc);
+  g_free (filename);
+  g_free (temp_template);
+}
 
-  if (do_download) {
-    gchar *temp_template, *filename;
-    const gchar *tmp_dir, *prgname;
+static void
+setup_multiqueue (GstURISourceBin * urisrc, ChildSrcPadInfo * info,
+    GstElement * multiqueue)
+{
+  if (info->use_downloadbuffer || !urisrc->is_stream) {
+    /* If we have a downloadbuffer we will let that one deal with buffering,
+       and we only use multiqueue for dealing with interleave */
+    g_object_set (info->multiqueue, "use-buffering", FALSE, NULL);
+  } else {
+    /* Else we set the minimum interleave time of multiqueue to the required
+     * buffering duration and ask it to report buffering */
+    g_object_set (info->multiqueue, "use-buffering", TRUE,
+        "min-interleave-time", GET_BUFFER_DURATION (urisrc), NULL);
+  }
+  /* Common properties */
+  g_object_set (info->multiqueue,
+      "sync-by-running-time", TRUE,
+      "use-interleave", TRUE,
+      "max-size-bytes", 0,
+      "max-size-buffers", 0,
+      "low-watermark", urisrc->low_watermark,
+      "high-watermark", urisrc->high_watermark, NULL);
+  gst_bin_add (GST_BIN_CAST (urisrc), info->multiqueue);
+  gst_element_sync_state_with_parent (info->multiqueue);
+}
 
-    tmp_dir = g_get_user_cache_dir ();
-    prgname = g_get_prgname ();
-    if (prgname == NULL)
-      prgname = "GStreamer";
+/* Called with lock held */
+static OutputSlotInfo *
+new_output_slot (ChildSrcPadInfo * info, GstPad * originating_pad)
+{
+  GstURISourceBin *urisrc = info->urisrc;
+  OutputSlotInfo *slot;
+  GstPad *srcpad;
+  GstElement *queue = NULL;
+  const gchar *elem_name;
+  gboolean use_downloadbuffer;
 
-    filename = g_strdup_printf ("%s-XXXXXX", prgname);
+  GST_DEBUG_OBJECT (urisrc,
+      "use_queue2:%d use_downloadbuffer:%d, demuxer:%d, originating_pad:%"
+      GST_PTR_FORMAT, info->use_queue2, info->use_downloadbuffer,
+      info->demuxer != NULL, originating_pad);
 
-    /* build our filename */
-    temp_template = g_build_filename (tmp_dir, filename, NULL);
+  slot = g_new0 (OutputSlotInfo, 1);
+  slot->linked_info = info;
 
-    GST_DEBUG_OBJECT (urisrc, "enable download buffering in %s (%s, %s, %s)",
-        temp_template, tmp_dir, prgname, filename);
+  /* If a demuxer/parsebin is present, then the downloadbuffer will have been handled before that */
+  use_downloadbuffer = info->use_downloadbuffer && !info->demuxer;
 
-    /* configure progressive download for selected media types */
-    g_object_set (queue, "temp-template", temp_template, NULL);
+  /* If parsebin is used, we might have to go through a multiqueue */
+  if (urisrc->parse_streams && (info->use_queue2 || info->use_downloadbuffer
+          || !urisrc->is_stream)) {
+    GST_DEBUG_OBJECT (urisrc, "Using multiqueue");
+    if (!info->multiqueue) {
+      GST_DEBUG_OBJECT (urisrc,
+          "Creating multiqueue for handling elementary streams");
+      elem_name = "multiqueue";
+      info->multiqueue = gst_element_factory_make (elem_name, NULL);
+      if (!info->multiqueue)
+        goto no_buffer_element;
+      setup_multiqueue (urisrc, info, info->multiqueue);
+    }
 
-    g_free (filename);
-    g_free (temp_template);
-  } else {
-    if (is_adaptive) {
-      GST_LOG_OBJECT (urisrc, "Adding queue for adaptive streaming stream");
-      g_object_set (queue, "use-buffering", urisrc->use_buffering,
-          "use-tags-bitrate", TRUE, "use-rate-estimate", FALSE, NULL);
+    slot->queue_sinkpad =
+        gst_element_request_pad_simple (info->multiqueue, "sink_%u");
+    srcpad = gst_pad_get_single_internal_link (slot->queue_sinkpad);
+    slot->output_pad = create_output_pad (slot, srcpad);
+    gst_object_unref (srcpad);
+    gst_pad_link (originating_pad, slot->queue_sinkpad);
+  }
+  /* If buffering is required, create the element. If downloadbuffer is
+   * required, it will take precedence over queue2 */
+  else if (use_downloadbuffer || info->use_queue2) {
+    if (use_downloadbuffer)
+      elem_name = "downloadbuffer";
+    else
+      elem_name = "queue2";
+
+    queue = gst_element_factory_make (elem_name, NULL);
+    if (!queue)
+      goto no_buffer_element;
+
+    slot->queue = queue;
+
+    slot->bitrate_changed_id =
+        g_signal_connect (G_OBJECT (queue), "notify::bitrate",
+        (GCallback) on_queue_bitrate_changed, urisrc);
+
+    if (use_downloadbuffer) {
+      setup_downloadbuffer (urisrc, slot->queue);
     } else {
-      GST_LOG_OBJECT (urisrc, "Adding queue for buffering");
       g_object_set (queue, "use-buffering", urisrc->use_buffering, NULL);
-    }
+      if (info->demuxer) {
+        /* If a adaptive demuxer or parsebin is used, use more accurate information */
+        g_object_set (queue, "use-tags-bitrate", TRUE, "use-rate-estimate",
+            FALSE, NULL);
+      } else {
+        GST_DEBUG_OBJECT (queue,
+            "Setting ring-buffer-max-size %" G_GUINT64_FORMAT,
+            urisrc->ring_buffer_max_size);
+        /* Else allow ring-buffer-max-size setting to be used */
+        g_object_set (queue, "ring-buffer-max-size",
+            urisrc->ring_buffer_max_size, NULL);
+      }
 
-    g_object_set (queue, "ring-buffer-max-size",
-        urisrc->ring_buffer_max_size, NULL);
-    /* Disable max-size-buffers - queue based on data rate to the default time limit */
-    g_object_set (queue, "max-size-buffers", 0, NULL);
+      /* Disable max-size-buffers - queue based on data rate to the default time limit */
+      g_object_set (queue, "max-size-buffers", 0, NULL);
 
-    /* Don't start buffering until the queue is empty (< 1%).
-     * Start playback when the queue is 60% full, leaving a bit more room
-     * for upstream to push more without getting bursty */
-    g_object_set (queue, "low-percent", 1, "high-percent", 60, NULL);
+      /* Don't start buffering until the queue is empty (< 1%).
+       * Start playback when the queue is 60% full, leaving a bit more room
+       * for upstream to push more without getting bursty */
+      g_object_set (queue, "low-percent", 1, "high-percent", 60, NULL);
 
-    g_object_set (queue, "low-watermark", urisrc->low_watermark,
-        "high-watermark", urisrc->high_watermark, NULL);
-  }
+      g_object_set (queue, "low-watermark", urisrc->low_watermark,
+          "high-watermark", urisrc->high_watermark, NULL);
+    }
 
-  /* set the necessary limits on the queue-like elements */
-  g_object_set (queue, "max-size-bytes", GET_BUFFER_SIZE (urisrc),
-      "max-size-time", (guint64) GET_BUFFER_DURATION (urisrc), NULL);
-#if 0
-  /* Disabled because this makes initial startup slower for radio streams */
-  else {
-    /* Buffer 4 seconds by default - some extra headroom over the
-     * core default, because we trigger playback sooner */
-    //g_object_set (queue, "max-size-time", 4 * GST_SECOND, NULL);
-  }
-#endif
+    /* set the necessary limits on the queue-like elements */
+    g_object_set (queue, "max-size-bytes", GET_BUFFER_SIZE (urisrc),
+        "max-size-time", (guint64) GET_BUFFER_DURATION (urisrc), NULL);
+
+    gst_bin_add (GST_BIN_CAST (urisrc), queue);
+    gst_element_sync_state_with_parent (queue);
+
+    slot->queue_sinkpad = gst_element_get_static_pad (queue, "sink");
 
-  /* save queue pointer so we can remove it later */
-  urisrc->out_slots = g_slist_prepend (urisrc->out_slots, slot);
+    /* get the new raw srcpad */
+    srcpad = gst_element_get_static_pad (queue, "src");
 
-  gst_bin_add (GST_BIN_CAST (urisrc), queue);
-  gst_element_sync_state_with_parent (queue);
+    slot->output_pad = create_output_pad (slot, srcpad);
 
-  slot->sinkpad = gst_element_get_static_pad (queue, "sink");
+    gst_object_unref (srcpad);
 
-  /* get the new raw srcpad */
-  srcpad = gst_element_get_static_pad (queue, "src");
-  g_object_set_data (G_OBJECT (srcpad), "urisourcebin.slotinfo", slot);
+    gst_pad_link (originating_pad, slot->queue_sinkpad);
+  } else {
+    /* Expose pad directly */
+    slot->output_pad = create_output_pad (slot, originating_pad);
+  }
+  slot->originating_pad = gst_object_ref (originating_pad);
 
-  slot->srcpad = create_output_pad (urisrc, srcpad);
+  /* save output slot so we can remove it later */
+  info->outputs = g_list_append (info->outputs, slot);
 
-  gst_object_unref (srcpad);
+  GST_DEBUG_OBJECT (urisrc,
+      "New output_pad %" GST_PTR_FORMAT " for originating pad %" GST_PTR_FORMAT,
+      slot->output_pad, originating_pad);
 
   return slot;
 
 no_buffer_element:
   {
+    g_free (slot);
     post_missing_plugin_error (GST_ELEMENT_CAST (urisrc), elem_name);
     return NULL;
   }
@@ -1226,15 +1201,19 @@ source_pad_event_probe (GstPad * pad, GstPadProbeInfo * info,
     gpointer user_data)
 {
   GstEvent *event = GST_PAD_PROBE_INFO_EVENT (info);
-  GstURISourceBin *urisrc = user_data;
+  OutputSlotInfo *slot = user_data;
+  GstURISourceBin *urisrc = slot->linked_info->urisrc;
 
-  GST_LOG_OBJECT (pad, "%s, urisrc %p", GST_EVENT_TYPE_NAME (event), event);
+  GST_LOG_OBJECT (pad, "%" GST_PTR_FORMAT, event);
 
+  /* A custom EOS will be received if an adaptive demuxer source pad removed a
+   * pad and buffering was present on that slot */
   if (GST_EVENT_TYPE (event) == GST_EVENT_EOS &&
       gst_mini_object_get_qdata (GST_MINI_OBJECT_CAST (event),
           CUSTOM_EOS_QUARK)) {
-    OutputSlotInfo *slot;
-    GST_DEBUG_OBJECT (pad, "we received EOS");
+    GstPadProbeReturn probe_ret = GST_PAD_PROBE_DROP;
+
+    GST_DEBUG_OBJECT (pad, "we received custom EOS");
 
     /* remove custom-eos */
     gst_mini_object_set_qdata (GST_MINI_OBJECT_CAST (event), CUSTOM_EOS_QUARK,
@@ -1242,41 +1221,19 @@ source_pad_event_probe (GstPad * pad, GstPadProbeInfo * info,
 
     GST_URI_SOURCE_BIN_LOCK (urisrc);
 
-    slot = g_object_get_data (G_OBJECT (pad), "urisourcebin.slotinfo");
-
-    if (slot) {
-      GstEvent *eos;
-      guint32 seqnum;
-
-      if (slot->linked_info) {
-        if (slot->is_eos) {
-          /* linked_info is old input which is still linked without removal */
-          GST_DEBUG_OBJECT (pad, "push actual EOS");
-          seqnum = gst_event_get_seqnum (event);
-          eos = gst_event_new_eos ();
-          gst_event_set_seqnum (eos, seqnum);
-          gst_pad_push_event (slot->srcpad, eos);
-        } else {
-          /* Do not clear output slot yet. A new input was
-           * connected. We should just drop this EOS */
-        }
-        GST_URI_SOURCE_BIN_UNLOCK (urisrc);
-        return GST_PAD_PROBE_DROP;
-      }
-
-      seqnum = gst_event_get_seqnum (event);
-      eos = gst_event_new_eos ();
-      gst_event_set_seqnum (eos, seqnum);
-      gst_pad_push_event (slot->srcpad, eos);
-      free_output_slot_async (urisrc, slot);
+    if (slot->is_eos) {
+      /* linked_info is old input which is still linked without removal */
+      GST_DEBUG_OBJECT (pad, "push actual EOS");
+      gst_pad_push_event (slot->output_pad, event);
+      probe_ret = GST_PAD_PROBE_HANDLED;
     }
 
-    /* FIXME: Only emit drained if all output pads are done and there's no
-     * pending pads */
-    g_signal_emit (urisrc, gst_uri_source_bin_signals[SIGNAL_DRAINED], 0, NULL);
+    /* And finally remove the output. This is done asynchronously since we can't
+     * do it from the streaming thread */
+    free_output_slot_async (urisrc, slot);
 
     GST_URI_SOURCE_BIN_UNLOCK (urisrc);
-    return GST_PAD_PROBE_DROP;
+    return probe_ret;
   }
   /* never drop events */
   return GST_PAD_PROBE_OK;
@@ -1286,14 +1243,17 @@ source_pad_event_probe (GstPad * pad, GstPadProbeInfo * info,
  * padprobe to detect EOS before exposing the pad.
  * Called with LOCK held. */
 static GstPad *
-create_output_pad (GstURISourceBin * urisrc, GstPad * pad)
+create_output_pad (OutputSlotInfo * slot, GstPad * pad)
 {
+  GstURISourceBin *urisrc = slot->linked_info->urisrc;
   GstPad *newpad;
   GstPadTemplate *pad_tmpl;
   gchar *padname;
 
-  gst_pad_add_probe (pad, GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM,
-      source_pad_event_probe, urisrc, NULL);
+  /* If the output slot does buffering, add a probe to detect drainage */
+  if (slot->queue)
+    gst_pad_add_probe (pad, GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM,
+        source_pad_event_probe, slot, NULL);
 
   pad_tmpl = gst_static_pad_template_get (&srctemplate);
 
@@ -1310,6 +1270,32 @@ create_output_pad (GstURISourceBin * urisrc, GstPad * pad)
   return newpad;
 }
 
+static GstPadProbeReturn
+expose_block_probe (GstPad * pad, GstPadProbeInfo * info, gpointer user_data)
+{
+  GstURISourceBin *urisrc = (GstURISourceBin *) user_data;
+  gboolean expose = FALSE;
+
+  GST_DEBUG_OBJECT (pad, "blocking");
+
+  GST_URI_SOURCE_BIN_LOCK (urisrc);
+  while (!urisrc->activated && !urisrc->flushing) {
+    GST_DEBUG_OBJECT (urisrc, "activated:%d flushing:%d", urisrc->activated,
+        urisrc->flushing);
+    g_cond_wait (&urisrc->activation_cond, &urisrc->lock);
+  }
+  GST_DEBUG_OBJECT (urisrc, "activated:%d flushing:%d", urisrc->activated,
+      urisrc->flushing);
+
+  if (!urisrc->flushing)
+    expose = TRUE;
+  GST_URI_SOURCE_BIN_UNLOCK (urisrc);
+  if (expose)
+    gst_element_add_pad (GST_ELEMENT_CAST (urisrc), pad);
+  GST_DEBUG_OBJECT (pad, "Done blocking, removing probe");
+  return GST_PAD_PROBE_REMOVE;
+}
+
 static void
 expose_output_pad (GstURISourceBin * urisrc, GstPad * pad)
 {
@@ -1323,118 +1309,78 @@ expose_output_pad (GstURISourceBin * urisrc, GstPad * pad)
   gst_pad_sticky_events_foreach (target, copy_sticky_events, pad);
   gst_object_unref (target);
 
-  GST_DEBUG_OBJECT (urisrc, "Exposing pad %s:%s", GST_DEBUG_PAD_NAME (pad));
-
   gst_pad_set_active (pad, TRUE);
-  gst_element_add_pad (GST_ELEMENT_CAST (urisrc), pad);
-}
-
-static void
-expose_raw_output_pad (GstURISourceBin * urisrc, GstPad * srcpad,
-    GstPad * output_pad)
-{
-  ChildSrcPadInfo *info = g_new0 (ChildSrcPadInfo, 1);
-  info->src_pad = srcpad;
-  info->output_pad = gst_object_ref (output_pad);
-
-  g_assert (g_object_get_data (G_OBJECT (srcpad),
-          "urisourcebin.srcpadinfo") == NULL);
-
-  g_object_set_data_full (G_OBJECT (srcpad), "urisourcebin.srcpadinfo",
-      info, (GDestroyNotify) free_child_src_pad_info);
-
-  expose_output_pad (urisrc, output_pad);
-}
-
-static void
-remove_output_pad (GstURISourceBin * urisrc, GstPad * pad)
-{
-  if (!gst_object_has_as_parent (GST_OBJECT (pad), GST_OBJECT (urisrc)))
-    return;                     /* Pad is not exposed */
-
-  GST_DEBUG_OBJECT (urisrc, "Removing pad %s:%s", GST_DEBUG_PAD_NAME (pad));
+  GST_URI_SOURCE_BIN_LOCK (urisrc);
+  if (!urisrc->activated) {
+    GST_DEBUG_OBJECT (urisrc, "Not fully activated, adding pad once PAUSED !");
+    gst_pad_add_probe (pad, GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM,
+        expose_block_probe, urisrc, NULL);
+    pad = NULL;
+  }
+  GST_URI_SOURCE_BIN_UNLOCK (urisrc);
 
-  gst_pad_set_active (pad, FALSE);
-  gst_element_remove_pad (GST_ELEMENT_CAST (urisrc), pad);
+  if (pad) {
+    GST_DEBUG_OBJECT (urisrc, "Exposing pad %" GST_PTR_FORMAT, pad);
+    gst_element_add_pad (GST_ELEMENT_CAST (urisrc), pad);
+  }
 }
 
 static void
-pad_removed_cb (GstElement * element, GstPad * pad, GstURISourceBin * urisrc)
+demuxer_pad_removed_cb (GstElement * element, GstPad * pad,
+    ChildSrcPadInfo * info)
 {
-  ChildSrcPadInfo *info;
-
-  GST_DEBUG_OBJECT (element, "pad removed name: <%s:%s>",
-      GST_DEBUG_PAD_NAME (pad));
+  GstURISourceBin *urisrc;
+  OutputSlotInfo *slot;
 
   /* we only care about srcpads */
   if (!GST_PAD_IS_SRC (pad))
     return;
 
-  if (!(info = g_object_get_data (G_OBJECT (pad), "urisourcebin.srcpadinfo")))
-    goto no_info;
+  urisrc = info->urisrc;
+
+  GST_DEBUG_OBJECT (urisrc, "pad removed name: <%s:%s>",
+      GST_DEBUG_PAD_NAME (pad));
 
   GST_URI_SOURCE_BIN_LOCK (urisrc);
-  /* Make sure this isn't in the pending pads list */
-  urisrc->pending_pads = g_list_remove (urisrc->pending_pads, pad);
+  slot = output_slot_for_originating_pad (info, pad);
+  g_assert (slot);
 
-  /* Send EOS to the output slot if the demuxer didn't already */
-  if (info->output_slot) {
-    GstStructure *s;
-    GstEvent *event;
-    OutputSlotInfo *slot;
+  gst_pad_remove_probe (pad, slot->demuxer_event_probe_id);
+  slot->demuxer_event_probe_id = 0;
 
-    slot = info->output_slot;
+  if (slot->queue) {
+    gboolean was_eos;
 
-    if (!slot->is_eos && urisrc->pending_pads &&
-        link_pending_pad_to_output (urisrc, slot)) {
-      /* Found a new source pad to give this slot data - no need to send EOS */
-      GST_URI_SOURCE_BIN_UNLOCK (urisrc);
-      return;
-    }
+    /* Propagate custom EOS to buffering elements. The slot will be removed when
+     * it is received on the output of the buffering elements */
 
     BUFFERING_LOCK (urisrc);
     /* Unlink this pad from its output slot and send a fake EOS event
      * to drain the queue */
+    was_eos = slot->is_eos;
     slot->is_eos = TRUE;
     BUFFERING_UNLOCK (urisrc);
 
     remove_buffering_msgs (urisrc, GST_OBJECT_CAST (slot->queue));
-
-    slot->linked_info = NULL;
-
-    info->output_slot = NULL;
-
-    GST_LOG_OBJECT (element,
-        "Pad %" GST_PTR_FORMAT " was removed without EOS. Sending.", pad);
-
-    event = gst_event_new_eos ();
-    s = gst_event_writable_structure (event);
-    gst_structure_set (s, "urisourcebin-custom-eos", G_TYPE_BOOLEAN, TRUE,
-        NULL);
-    gst_pad_send_event (slot->sinkpad, event);
-  } else if (info->output_pad != NULL) {
-    GST_LOG_OBJECT (element,
-        "Pad %" GST_PTR_FORMAT " was removed. Unexposing %" GST_PTR_FORMAT,
-        pad, info->output_pad);
-    remove_output_pad (urisrc, info->output_pad);
-  } else {
-    GST_LOG_OBJECT (urisrc, "Removed pad has no output slot or pad");
-    if (urisrc->source_streams_aware) {
-      GST_DEBUG_OBJECT (info->ghost_pad,
-          "Streams-aware, removing pad immediately");
-      gst_element_remove_pad ((GstElement *) urisrc, info->ghost_pad);
+    if (!was_eos) {
+      GstStructure *s;
+      GstEvent *event;
+      event = gst_event_new_eos ();
+      s = gst_event_writable_structure (event);
+      gst_structure_set (s, "urisourcebin-custom-eos", G_TYPE_BOOLEAN, TRUE,
+          NULL);
+      gst_pad_send_event (slot->queue_sinkpad, event);
     }
+  } else {
+    GST_LOG_OBJECT (urisrc,
+        "No buffering involved, removing output slot immediately");
+    /* Remove output slot immediately */
+    info->outputs = g_list_remove (info->outputs, slot);
+    free_output_slot (slot, urisrc);
   }
   GST_URI_SOURCE_BIN_UNLOCK (urisrc);
 
   return;
-
-  /* ERRORS */
-no_info:
-  {
-    GST_WARNING_OBJECT (element, "no info found for pad");
-    return;
-  }
 }
 
 /* helper function to lookup stuff in lists */
@@ -1527,12 +1473,20 @@ gen_source_element (GstURISourceBin * urisrc)
   }
   gst_query_unref (query);
 
-  GST_LOG_OBJECT (urisrc, "source is stream: %d", urisrc->is_stream);
+  source_class = G_OBJECT_GET_CLASS (source);
 
-  urisrc->need_queue = IS_QUEUE_URI (urisrc->uri);
-  GST_LOG_OBJECT (urisrc, "source needs queue: %d", urisrc->need_queue);
+  if (urisrc->is_stream) {
+    /* Live sources are not streamable */
+    pspec = g_object_class_find_property (source_class, "is-live");
+    if (pspec && G_PARAM_SPEC_VALUE_TYPE (pspec) == G_TYPE_BOOLEAN) {
+      gboolean is_live;
+      g_object_get (G_OBJECT (source), "is-live", &is_live, NULL);
+      if (is_live)
+        urisrc->is_stream = FALSE;
+    }
+  }
 
-  source_class = G_OBJECT_GET_CLASS (source);
+  GST_LOG_OBJECT (urisrc, "source is stream: %d", urisrc->is_stream);
 
   pspec = g_object_class_find_property (source_class, "connection-speed");
   if (pspec != NULL) {
@@ -1649,32 +1603,6 @@ done:
   return res;
 }
 
-/**
- * has_all_raw_caps:
- * @pad: a #GstPad
- * @all_raw: pointer to hold the result
- *
- * check if the caps of the pad are all raw. The caps are all raw if
- * all of its structures contain audio/x-raw or video/x-raw.
- *
- * Returns: %FALSE @pad has no caps. Else TRUE and @all_raw set t the result.
- */
-static gboolean
-has_all_raw_caps (GstPad * pad, GstCaps * rawcaps, gboolean * all_raw)
-{
-  GstCaps *caps;
-  gboolean res = FALSE;
-
-  caps = gst_pad_query_caps (pad, NULL);
-
-  GST_DEBUG_OBJECT (pad, "have caps %" GST_PTR_FORMAT, caps);
-
-  res = is_all_raw_caps (caps, rawcaps, all_raw);
-
-  gst_caps_unref (caps);
-  return res;
-}
-
 static void
 post_missing_plugin_error (GstElement * urisrc, const gchar * element_name)
 {
@@ -1688,16 +1616,95 @@ post_missing_plugin_error (GstElement * urisrc, const gchar * element_name)
           element_name), (NULL));
 }
 
+typedef struct
+{
+  GstURISourceBin *urisrc;
+  gboolean have_out;
+  gboolean res;
+} AnalyseData;
+
+static void
+analyse_pad_foreach (const GValue * item, AnalyseData * data)
+{
+  GstURISourceBin *urisrc = data->urisrc;
+  GstPad *pad = g_value_dup_object (item);
+  ChildSrcPadInfo *info;
+  GstCaps *padcaps = NULL;
+  gboolean pad_is_raw;
+  gboolean res = TRUE;
+
+  GST_LOG_OBJECT (urisrc, "pad %" GST_PTR_FORMAT, pad);
+
+  data->have_out = TRUE;
+
+  /* The info might already exist if there was an iterator resync */
+  if (get_cspi_for_pad (urisrc, pad)) {
+    GST_LOG_OBJECT (urisrc, "Already analysed");
+    goto out;
+  }
+
+  info = new_child_src_pad_info (urisrc, pad);
+  padcaps = gst_pad_query_caps (pad, NULL);
+
+  if (!is_all_raw_caps (padcaps, DEFAULT_CAPS, &pad_is_raw) || !pad_is_raw) {
+    /* if FALSE, this pad has no caps, we setup typefinding on it */
+    if (!setup_typefind (info)) {
+      res = FALSE;
+      goto out;
+    }
+  } else if (pad_is_raw) {
+    /* caps on source pad are all raw, we can add the pad */
+    GstPad *output_pad;
+    OutputSlotInfo *slot;
+
+    GST_URI_SOURCE_BIN_LOCK (urisrc);
+    /* Only use buffering (via queue2) on raw pads in very specific
+     * conditions */
+    info->use_queue2 = urisrc->use_buffering && IS_QUEUE_URI (urisrc->uri);
+
+    GST_DEBUG_OBJECT (urisrc, "use_buffering:%d is_queue:%d",
+        urisrc->use_buffering, IS_QUEUE_URI (urisrc->uri));
+    slot = new_output_slot (info, pad);
+
+    if (!slot) {
+      res = FALSE;
+      GST_URI_SOURCE_BIN_UNLOCK (urisrc);
+      goto out;
+    }
+
+    /* get the new raw srcpad */
+    output_pad = gst_object_ref (slot->output_pad);
+
+    GST_URI_SOURCE_BIN_UNLOCK (urisrc);
+
+    expose_output_pad (urisrc, output_pad);
+    gst_object_unref (output_pad);
+  } else {
+    GST_DEBUG_OBJECT (urisrc, "Handling non-raw pad");
+    /* The caps are non-raw, we handle it directly */
+    handle_new_pad (info, pad, padcaps);
+  }
+
+out:
+  if (padcaps)
+    gst_caps_unref (padcaps);
+  gst_object_unref (pad);
+  data->res &= res;
+}
+
 /**
- * analyse_source:
+ * analyse_source_and_expose_raw_pads:
  * @urisrc: a #GstURISourceBin
- * @is_raw: are all pads raw data
+ * @all_pads_raw: are all pads raw data
  * @have_out: does the source have output
  * @is_dynamic: is this a dynamic source
- * @use_queue: put a queue before raw output pads
  *
  * Check the source of @urisrc and collect information about it.
  *
+ * All pads will be handled directly. Raw pads are exposed as-is. Pads without
+ * any caps will have a typefind appended to them, and other pads will be
+ * analysed further.
+ *
  * @is_raw will be set to TRUE if the source only produces raw pads. When this
  * function returns, all of the raw pad of the source will be added
  * to @urisrc
@@ -1710,95 +1717,36 @@ post_missing_plugin_error (GstElement * urisrc, const gchar * element_name)
  * Returns: FALSE if a fatal error occurred while scanning.
  */
 static gboolean
-analyse_source (GstURISourceBin * urisrc, gboolean * is_raw,
-    gboolean * have_out, gboolean * is_dynamic, gboolean use_queue)
+analyse_source_and_expose_raw_pads (GstURISourceBin * urisrc,
+    gboolean * have_out, gboolean * is_dynamic)
 {
   GstElementClass *elemclass;
+  AnalyseData data = { 0, };
+  GstIteratorResult iterres;
   GList *walk;
   GstIterator *pads_iter;
-  gboolean done = FALSE;
   gboolean res = TRUE;
-  GstPad *pad;
-  GValue item = { 0, };
-  guint nb_raw = 0;
-  guint nb_pads = 0;
-  GstCaps *rawcaps = DEFAULT_CAPS;
-
-  *have_out = FALSE;
-  *is_raw = FALSE;
-  *is_dynamic = FALSE;
 
   pads_iter = gst_element_iterate_src_pads (urisrc->source);
-  while (!done) {
-    switch (gst_iterator_next (pads_iter, &item)) {
-      case GST_ITERATOR_ERROR:
-        res = FALSE;
-        /* FALLTHROUGH */
-      case GST_ITERATOR_DONE:
-        done = TRUE;
-        break;
-      case GST_ITERATOR_RESYNC:
-        /* reset results and resync */
-        *have_out = FALSE;
-        *is_raw = FALSE;
-        *is_dynamic = FALSE;
-        nb_pads = nb_raw = 0;
-        gst_iterator_resync (pads_iter);
-        break;
-      case GST_ITERATOR_OK:
-        pad = g_value_dup_object (&item);
-        /* we now officially have an output pad */
-        *have_out = TRUE;
-
-        /* if FALSE, this pad has no caps and we continue with the next pad. */
-        if (!has_all_raw_caps (pad, rawcaps, is_raw)) {
-          gst_object_unref (pad);
-          g_value_reset (&item);
-          break;
-        }
-
-        nb_pads++;
-        /* caps on source pad are all raw, we can add the pad */
-        if (*is_raw) {
-          GstPad *output_pad;
-
-          nb_raw++;
-          GST_URI_SOURCE_BIN_LOCK (urisrc);
-          if (use_queue) {
-            OutputSlotInfo *slot = get_output_slot (urisrc, FALSE, FALSE, NULL);
-            if (!slot)
-              goto no_slot;
-
-            gst_pad_link (pad, slot->sinkpad);
-
-            /* get the new raw srcpad */
-            output_pad = gst_object_ref (slot->srcpad);
-
-            GST_URI_SOURCE_BIN_UNLOCK (urisrc);
-
-            expose_output_pad (urisrc, output_pad);
-            gst_object_unref (output_pad);
-          } else {
-            output_pad = create_output_pad (urisrc, pad);
-
-            GST_URI_SOURCE_BIN_UNLOCK (urisrc);
-
-            expose_raw_output_pad (urisrc, pad, output_pad);
-          }
-          gst_object_unref (pad);
-        } else {
-          gst_object_unref (pad);
-        }
-        g_value_reset (&item);
-        break;
-    }
-  }
-  g_value_unset (&item);
+
+restart:
+  data.res = TRUE;
+  data.have_out = FALSE;
+  data.urisrc = urisrc;
+  iterres =
+      gst_iterator_foreach (pads_iter,
+      (GstIteratorForeachFunction) analyse_pad_foreach, &data);
+  if (iterres == GST_ITERATOR_RESYNC)
+    goto restart;
+  if (iterres == GST_ITERATOR_ERROR)
+    res = FALSE;
+  else
+    res = data.res;
   gst_iterator_free (pads_iter);
-  gst_caps_unref (rawcaps);
 
   /* check for padtemplates that list SOMETIMES pads to
    * determine if the element is dynamic. */
+  *is_dynamic = FALSE;
   elemclass = GST_ELEMENT_GET_CLASS (urisrc->source);
   walk = gst_element_class_get_pad_template_list (elemclass);
   while (walk != NULL) {
@@ -1813,38 +1761,14 @@ analyse_source (GstURISourceBin * urisrc, gboolean * is_raw,
     walk = g_list_next (walk);
   }
 
-  if (nb_pads && nb_pads == nb_raw)
-    *is_raw = TRUE;
+  *have_out = data.have_out;
 
   return res;
-no_slot:
-  {
-    GST_URI_SOURCE_BIN_UNLOCK (urisrc);
-    gst_object_unref (pad);
-    g_value_unset (&item);
-    gst_iterator_free (pads_iter);
-    gst_caps_unref (rawcaps);
-
-    return FALSE;
-  }
-}
-
-/* Remove any adaptive demuxer element */
-static void
-remove_demuxer (GstURISourceBin * bin)
-{
-  if (bin->demuxer) {
-    GST_DEBUG_OBJECT (bin, "removing old demuxer element");
-    gst_element_set_state (bin->demuxer, GST_STATE_NULL);
-    gst_bin_remove (GST_BIN_CAST (bin), bin->demuxer);
-    bin->demuxer = NULL;
-    bin->demuxer_handles_buffering = FALSE;
-  }
 }
 
 /* make a demuxer and connect to all the signals */
 static GstElement *
-make_demuxer (GstURISourceBin * urisrc, GstCaps * caps)
+make_demuxer (GstURISourceBin * urisrc, ChildSrcPadInfo * info, GstCaps * caps)
 {
   GList *factories, *eligible, *cur;
   GstElement *demuxer = NULL;
@@ -1877,6 +1801,11 @@ make_demuxer (GstURISourceBin * urisrc, GstCaps * caps)
       continue;
 
     demuxer = gst_element_factory_create (factory, NULL);
+    if (!GST_OBJECT_FLAG_IS_SET (demuxer, GST_BIN_FLAG_STREAMS_AWARE)) {
+      GST_DEBUG_OBJECT (urisrc, "Ignoring non-streams-aware adaptive demuxer");
+      gst_object_unref (demuxer);
+      continue;
+    }
     break;
   }
   gst_plugin_feature_list_free (eligible);
@@ -1890,9 +1819,9 @@ make_demuxer (GstURISourceBin * urisrc, GstCaps * caps)
   /* set up callbacks to create the links between
    * demuxer streams and output */
   g_signal_connect (demuxer,
-      "pad-added", G_CALLBACK (new_demuxer_pad_added_cb), urisrc);
+      "pad-added", G_CALLBACK (new_demuxer_pad_added_cb), info);
   g_signal_connect (demuxer,
-      "pad-removed", G_CALLBACK (pad_removed_cb), urisrc);
+      "pad-removed", G_CALLBACK (demuxer_pad_removed_cb), info);
 
   /* Propagate connection-speed property */
   pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (demuxer),
@@ -1913,26 +1842,126 @@ no_demuxer:
   }
 }
 
+static gboolean
+setup_parsebin_for_slot (ChildSrcPadInfo * info, GstPad * originating_pad)
+{
+  GstURISourceBin *urisrc = info->urisrc;
+  GstPad *sinkpad;
+  GstPadLinkReturn link_res;
+
+  GST_DEBUG_OBJECT (urisrc, "Setting up parsebin for %" GST_PTR_FORMAT,
+      originating_pad);
+
+  GST_STATE_LOCK (urisrc);
+  GST_URI_SOURCE_BIN_LOCK (urisrc);
+
+  /* Set up optional pre-parsebin download/ringbuffer elements */
+  if (info->use_downloadbuffer || urisrc->ring_buffer_max_size) {
+    if (info->use_downloadbuffer) {
+      GST_DEBUG_OBJECT (urisrc, "Setting up pre-parsebin downloadbuffer");
+      info->pre_parse_queue = gst_element_factory_make ("downloadbuffer", NULL);
+      setup_downloadbuffer (urisrc, info->pre_parse_queue);
+      g_object_set (info->pre_parse_queue, "max-size-bytes",
+          GET_BUFFER_SIZE (urisrc), "max-size-time",
+          (guint64) GET_BUFFER_DURATION (urisrc), NULL);
+    } else if (urisrc->ring_buffer_max_size) {
+      /* If a ring-buffer-max-size is specified with parsebin, we set it up on
+       * the queue2 *before* parsebin. We will use its buffering levels instead
+       * of the ones from multiqueue */
+      GST_DEBUG_OBJECT (urisrc,
+          "Setting up pre-parsebin queue2 for ring-buffer-max-size %"
+          G_GUINT64_FORMAT, urisrc->ring_buffer_max_size);
+      info->pre_parse_queue = gst_element_factory_make ("queue2", NULL);
+      /* We do not use this queue2 for buffering levels, but the multiqueue */
+      g_object_set (info->pre_parse_queue, "use-buffering", FALSE,
+          "ring-buffer-max-size", urisrc->ring_buffer_max_size,
+          "max-size-buffers", 0, NULL);
+    }
+    gst_element_set_locked_state (info->pre_parse_queue, TRUE);
+    gst_bin_add (GST_BIN_CAST (urisrc), info->pre_parse_queue);
+    sinkpad = gst_element_get_static_pad (info->pre_parse_queue, "sink");
+    link_res = gst_pad_link (originating_pad, sinkpad);
+
+    gst_object_unref (sinkpad);
+    if (link_res != GST_PAD_LINK_OK)
+      goto could_not_link;
+  }
+
+  info->demuxer = gst_element_factory_make ("parsebin", NULL);
+  if (!info->demuxer) {
+    post_missing_plugin_error (GST_ELEMENT_CAST (urisrc), "parsebin");
+    return FALSE;
+  }
+  gst_element_set_locked_state (info->demuxer, TRUE);
+  gst_bin_add (GST_BIN_CAST (urisrc), info->demuxer);
+
+  if (info->pre_parse_queue) {
+    if (!gst_element_link_pads (info->pre_parse_queue, "src", info->demuxer,
+            "sink"))
+      goto could_not_link;
+  } else {
+    sinkpad = gst_element_get_static_pad (info->demuxer, "sink");
+
+    link_res = gst_pad_link (originating_pad, sinkpad);
+
+    gst_object_unref (sinkpad);
+    if (link_res != GST_PAD_LINK_OK)
+      goto could_not_link;
+  }
+
+  /* set up callbacks to create the links between parsebin and output */
+  g_signal_connect (info->demuxer,
+      "pad-added", G_CALLBACK (new_demuxer_pad_added_cb), info);
+  g_signal_connect (info->demuxer,
+      "pad-removed", G_CALLBACK (demuxer_pad_removed_cb), info);
+
+  if (info->pre_parse_queue) {
+    gst_element_set_locked_state (info->pre_parse_queue, FALSE);
+    gst_element_sync_state_with_parent (info->pre_parse_queue);
+  }
+  gst_element_set_locked_state (info->demuxer, FALSE);
+  gst_element_sync_state_with_parent (info->demuxer);
+  GST_URI_SOURCE_BIN_UNLOCK (urisrc);
+  GST_STATE_UNLOCK (urisrc);
+  return TRUE;
+
+could_not_link:
+  {
+    GST_URI_SOURCE_BIN_UNLOCK (urisrc);
+    GST_STATE_UNLOCK (urisrc);
+    GST_ELEMENT_ERROR (urisrc, CORE, NEGOTIATION,
+        (NULL), ("Can't link to (pre-)parsebin element"));
+    return FALSE;
+  }
+}
+
+/* Called when:
+ * * Source element adds a new pad
+ * * typefind has found a type
+ */
 static void
-handle_new_pad (GstURISourceBin * urisrc, GstPad * srcpad, GstCaps * caps)
+handle_new_pad (ChildSrcPadInfo * info, GstPad * srcpad, GstCaps * caps)
 {
+  GstURISourceBin *urisrc = info->urisrc;
   gboolean is_raw;
   GstStructure *s;
   const gchar *media_type;
-  gboolean do_download = FALSE;
 
   GST_URI_SOURCE_BIN_LOCK (urisrc);
 
   /* if this is a pad with all raw caps, we can expose it */
   if (is_all_raw_caps (caps, DEFAULT_CAPS, &is_raw) && is_raw) {
+    OutputSlotInfo *slot;
     GstPad *output_pad;
 
     GST_DEBUG_OBJECT (urisrc, "Found pad with raw caps %" GST_PTR_FORMAT
         ", exposing", caps);
-    output_pad = create_output_pad (urisrc, srcpad);
+    slot = new_output_slot (info, srcpad);
+    output_pad = gst_object_ref (slot->output_pad);
     GST_URI_SOURCE_BIN_UNLOCK (urisrc);
 
-    expose_raw_output_pad (urisrc, srcpad, output_pad);
+    expose_output_pad (urisrc, slot->output_pad);
+    gst_object_unref (output_pad);
     return;
   }
   GST_URI_SOURCE_BIN_UNLOCK (urisrc);
@@ -1947,20 +1976,20 @@ handle_new_pad (GstURISourceBin * urisrc, GstPad * srcpad, GstCaps * caps)
     GstPadLinkReturn link_res;
     GstQuery *query;
 
-    urisrc->demuxer = make_demuxer (urisrc, caps);
-    if (!urisrc->demuxer)
+    info->demuxer = make_demuxer (urisrc, info, caps);
+    if (!info->demuxer)
       goto no_demuxer;
-    gst_bin_add (GST_BIN_CAST (urisrc), urisrc->demuxer);
+    gst_bin_add (GST_BIN_CAST (urisrc), info->demuxer);
 
     /* Query the demuxer to see if it can handle buffering */
     query = gst_query_new_buffering (GST_FORMAT_TIME);
-    urisrc->demuxer_handles_buffering =
-        gst_element_query (urisrc->demuxer, query);
+    info->use_queue2 = urisrc->use_buffering
+        && !gst_element_query (info->demuxer, query);
     gst_query_unref (query);
     GST_DEBUG_OBJECT (urisrc, "Demuxer handles buffering : %d",
-        urisrc->demuxer_handles_buffering);
+        info->demuxer_handles_buffering);
 
-    sinkpad = gst_element_get_static_pad (urisrc->demuxer, "sink");
+    sinkpad = gst_element_get_static_pad (info->demuxer, "sink");
     if (sinkpad == NULL)
       goto no_demuxer_sink;
 
@@ -1970,46 +1999,57 @@ handle_new_pad (GstURISourceBin * urisrc, GstPad * srcpad, GstCaps * caps)
     if (link_res != GST_PAD_LINK_OK)
       goto could_not_link;
 
-    gst_element_sync_state_with_parent (urisrc->demuxer);
+    gst_element_sync_state_with_parent (info->demuxer);
   } else if (!urisrc->is_stream) {
-    GstPad *output_pad;
-    /* We don't need slot here, expose immediately */
-    GST_URI_SOURCE_BIN_LOCK (urisrc);
-    output_pad = create_output_pad (urisrc, srcpad);
-    expose_raw_output_pad (urisrc, srcpad, output_pad);
-    GST_URI_SOURCE_BIN_UNLOCK (urisrc);
-  } else {
-    OutputSlotInfo *slot;
-    GstPad *output_pad;
+    if (urisrc->parse_streams) {
+      /* GST_URI_SOURCE_BIN_LOCK (urisrc); */
+      setup_parsebin_for_slot (info, srcpad);
+      /* GST_URI_SOURCE_BIN_UNLOCK (urisrc); */
+    } else {
+      /* We don't need buffering here, expose immediately */
+      OutputSlotInfo *slot;
+      GstPad *output_pad;
 
+      GST_URI_SOURCE_BIN_LOCK (urisrc);
+      slot = new_output_slot (info, srcpad);
+      output_pad = gst_object_ref (slot->output_pad);
+      GST_URI_SOURCE_BIN_UNLOCK (urisrc);
+      expose_output_pad (urisrc, output_pad);
+      gst_object_unref (output_pad);
+    }
+  } else {
     /* only enable download buffering if the upstream duration is known */
     if (urisrc->download) {
       GstQuery *query = gst_query_new_duration (GST_FORMAT_BYTES);
       if (gst_pad_query (srcpad, query)) {
         gint64 dur;
         gst_query_parse_duration (query, NULL, &dur);
-        do_download = (dur != -1);
+        info->use_downloadbuffer = (dur != -1);
       }
       gst_query_unref (query);
     }
+    info->use_queue2 = urisrc->use_buffering;
 
-    GST_DEBUG_OBJECT (urisrc, "check media-type %s, do_download:%d", media_type,
-        do_download);
-
-    GST_URI_SOURCE_BIN_LOCK (urisrc);
-    slot = get_output_slot (urisrc, do_download, FALSE, NULL);
+    if (urisrc->parse_streams) {
+      /* GST_URI_SOURCE_BIN_LOCK (urisrc); */
+      setup_parsebin_for_slot (info, srcpad);
+      /* GST_URI_SOURCE_BIN_UNLOCK (urisrc); */
+    } else {
+      OutputSlotInfo *slot;
+      GstPad *output_pad;
 
-    if (slot == NULL || gst_pad_link (srcpad, slot->sinkpad) != GST_PAD_LINK_OK)
-      goto could_not_link;
+      GST_URI_SOURCE_BIN_LOCK (urisrc);
+      slot = new_output_slot (info, srcpad);
 
-    gst_pad_add_probe (srcpad, GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM,
-        pre_queue_event_probe, urisrc, NULL);
+      gst_pad_add_probe (srcpad, GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM,
+          pre_queue_event_probe, urisrc, NULL);
 
-    output_pad = gst_object_ref (slot->srcpad);
-    GST_URI_SOURCE_BIN_UNLOCK (urisrc);
+      output_pad = gst_object_ref (slot->output_pad);
+      GST_URI_SOURCE_BIN_UNLOCK (urisrc);
 
-    expose_output_pad (urisrc, output_pad);
-    gst_object_unref (output_pad);
+      expose_output_pad (urisrc, output_pad);
+      gst_object_unref (output_pad);
+    }
   }
 
   return;
@@ -2039,13 +2079,14 @@ could_not_link:
  * buffering or regular buffering */
 static void
 type_found (GstElement * typefind, guint probability,
-    GstCaps * caps, GstURISourceBin * urisrc)
+    GstCaps * caps, ChildSrcPadInfo * info)
 {
+  GstURISourceBin *urisrc = info->urisrc;
   GstPad *srcpad = gst_element_get_static_pad (typefind, "src");
 
   GST_DEBUG_OBJECT (urisrc, "typefind found caps %" GST_PTR_FORMAT
       " on pad %" GST_PTR_FORMAT, caps, srcpad);
-  handle_new_pad (urisrc, srcpad, caps);
+  handle_new_pad (info, srcpad, caps);
 
   gst_object_unref (GST_OBJECT (srcpad));
 }
@@ -2054,42 +2095,33 @@ type_found (GstElement * typefind, guint probability,
  * source. After we find the type, we decide to whether to plug an adaptive
  * demuxer, or just link through queue2 (if needed) and expose the data */
 static gboolean
-setup_typefind (GstURISourceBin * urisrc, GstPad * srcpad)
+setup_typefind (ChildSrcPadInfo * info)
 {
-  GstElement *typefind;
+  GstURISourceBin *urisrc = info->urisrc;
+  GstPad *sinkpad;
 
   /* now create the typefind element */
-  typefind = gst_element_factory_make ("typefind", NULL);
-  if (!typefind)
+  info->typefind = gst_element_factory_make ("typefind", NULL);
+  if (!info->typefind)
     goto no_typefind;
 
   /* Make sure the bin doesn't set the typefind running yet */
-  gst_element_set_locked_state (typefind, TRUE);
-
-  gst_bin_add (GST_BIN_CAST (urisrc), typefind);
+  gst_element_set_locked_state (info->typefind, TRUE);
 
-  if (!srcpad) {
-    if (!gst_element_link_pads (urisrc->source, NULL, typefind, "sink"))
-      goto could_not_link;
-  } else {
-    GstPad *sinkpad = gst_element_get_static_pad (typefind, "sink");
-    GstPadLinkReturn ret;
-
-    ret = gst_pad_link (srcpad, sinkpad);
-    gst_object_unref (sinkpad);
-    if (ret != GST_PAD_LINK_OK)
-      goto could_not_link;
-  }
+  gst_bin_add (GST_BIN_CAST (urisrc), info->typefind);
 
-  urisrc->typefinds = g_list_append (urisrc->typefinds, typefind);
+  sinkpad = gst_element_get_static_pad (info->typefind, "sink");
+  if (gst_pad_link (info->src_pad, sinkpad) != GST_PAD_LINK_OK)
+    goto could_not_link;
+  gst_object_unref (sinkpad);
 
   /* connect a signal to find out when the typefind element found
    * a type */
-  g_signal_connect (typefind, "have-type", G_CALLBACK (type_found), urisrc);
+  g_signal_connect (info->typefind, "have-type", G_CALLBACK (type_found), info);
 
   /* Now it can start */
-  gst_element_set_locked_state (typefind, FALSE);
-  gst_element_sync_state_with_parent (typefind);
+  gst_element_set_locked_state (info->typefind, FALSE);
+  gst_element_sync_state_with_parent (info->typefind);
 
   return TRUE;
 
@@ -2103,32 +2135,45 @@ no_typefind:
   }
 could_not_link:
   {
+    gst_object_unref (sinkpad);
     GST_ELEMENT_ERROR (urisrc, CORE, NEGOTIATION,
         (NULL), ("Can't link source to typefind element"));
-    gst_bin_remove (GST_BIN_CAST (urisrc), typefind);
     return FALSE;
   }
 }
 
+/* CALL WITH URISOURCEBIN LOCK */
 static void
 free_output_slot (OutputSlotInfo * slot, GstURISourceBin * urisrc)
 {
-  GST_DEBUG_OBJECT (urisrc, "removing old queue element and freeing slot %p",
-      slot);
-  if (slot->bitrate_changed_id > 0)
-    g_signal_handler_disconnect (slot->queue, slot->bitrate_changed_id);
-  slot->bitrate_changed_id = 0;
+  GST_DEBUG_OBJECT (urisrc,
+      "removing output slot %" GST_PTR_FORMAT " -> %" GST_PTR_FORMAT,
+      slot->originating_pad, slot->output_pad);
+
+  if (slot->queue) {
+    if (slot->bitrate_changed_id > 0)
+      g_signal_handler_disconnect (slot->queue, slot->bitrate_changed_id);
+    slot->bitrate_changed_id = 0;
 
-  gst_element_set_locked_state (slot->queue, TRUE);
-  gst_element_set_state (slot->queue, GST_STATE_NULL);
-  remove_buffering_msgs (urisrc, GST_OBJECT_CAST (slot->queue));
-  gst_bin_remove (GST_BIN_CAST (urisrc), slot->queue);
+    gst_element_set_locked_state (slot->queue, TRUE);
+    gst_element_set_state (slot->queue, GST_STATE_NULL);
+    remove_buffering_msgs (urisrc, GST_OBJECT_CAST (slot->queue));
+    gst_bin_remove (GST_BIN_CAST (urisrc), slot->queue);
+  }
+  if (slot->queue_sinkpad) {
+    if (slot->linked_info && slot->linked_info->multiqueue)
+      gst_element_release_request_pad (slot->linked_info->multiqueue,
+          slot->queue_sinkpad);
+    gst_object_replace ((GstObject **) & slot->queue_sinkpad, NULL);
+  }
 
-  gst_object_unref (slot->sinkpad);
+  if (slot->demuxer_event_probe_id)
+    gst_pad_remove_probe (slot->originating_pad, slot->demuxer_event_probe_id);
 
+  gst_object_unref (slot->originating_pad);
   /* deactivate and remove the srcpad */
-  gst_pad_set_active (slot->srcpad, FALSE);
-  gst_element_remove_pad (GST_ELEMENT_CAST (urisrc), slot->srcpad);
+  gst_pad_set_active (slot->output_pad, FALSE);
+  gst_element_remove_pad (GST_ELEMENT_CAST (urisrc), slot->output_pad);
 
   g_free (slot);
 }
@@ -2145,60 +2190,19 @@ static void
 free_output_slot_async (GstURISourceBin * urisrc, OutputSlotInfo * slot)
 {
   GST_LOG_OBJECT (urisrc, "pushing output slot on thread pool to free");
-  urisrc->out_slots = g_slist_remove (urisrc->out_slots, slot);
+  slot->linked_info->outputs = g_list_remove (slot->linked_info->outputs, slot);
   gst_element_call_async (GST_ELEMENT_CAST (urisrc),
       (GstElementCallAsyncFunc) call_free_output_slot, slot, NULL);
 }
 
-static void
-unexpose_src_pads (GstURISourceBin * urisrc, GstElement * element)
-{
-  GstIterator *pads_iter;
-  GValue item = { 0, };
-  gboolean done = FALSE;
-
-  pads_iter = gst_element_iterate_src_pads (element);
-  while (!done) {
-    switch (gst_iterator_next (pads_iter, &item)) {
-      case GST_ITERATOR_ERROR:
-        /* FALLTHROUGH */
-      case GST_ITERATOR_DONE:
-        done = TRUE;
-        break;
-      case GST_ITERATOR_RESYNC:
-        gst_iterator_resync (pads_iter);
-        break;
-      case GST_ITERATOR_OK:
-      {
-        ChildSrcPadInfo *info;
-        GstPad *pad = g_value_get_object (&item);
-
-        if (!(info =
-                g_object_get_data (G_OBJECT (pad), "urisourcebin.srcpadinfo")))
-          break;
-
-        if (info->output_pad != NULL)
-          remove_output_pad (urisrc, info->output_pad);
-
-        g_value_reset (&item);
-        break;
-      }
-    }
-  }
-  g_value_unset (&item);
-  gst_iterator_free (pads_iter);
-}
-
 /* remove source and all related elements */
 static void
 remove_source (GstURISourceBin * urisrc)
 {
-
   if (urisrc->source) {
     GstElement *source = urisrc->source;
 
     GST_DEBUG_OBJECT (urisrc, "removing old src element");
-    unexpose_src_pads (urisrc, source);
     gst_element_set_state (source, GST_STATE_NULL);
 
     if (urisrc->src_np_sig_id) {
@@ -2209,34 +2213,13 @@ remove_source (GstURISourceBin * urisrc)
     urisrc->source = NULL;
   }
 
-  if (urisrc->typefinds) {
-    GList *iter, *next;
-    GST_DEBUG_OBJECT (urisrc, "removing old typefind element");
-    for (iter = urisrc->typefinds; iter; iter = next) {
-      GstElement *typefind = iter->data;
-
-      next = g_list_next (iter);
-
-      unexpose_src_pads (urisrc, typefind);
-      gst_element_set_state (typefind, GST_STATE_NULL);
-      gst_bin_remove (GST_BIN_CAST (urisrc), typefind);
-    }
-    g_list_free (urisrc->typefinds);
-    urisrc->typefinds = NULL;
-  }
-
   GST_URI_SOURCE_BIN_LOCK (urisrc);
-  g_slist_foreach (urisrc->out_slots, (GFunc) free_output_slot, urisrc);
-  g_slist_free (urisrc->out_slots);
-  urisrc->out_slots = NULL;
-  GST_URI_SOURCE_BIN_UNLOCK (urisrc);
-
-  if (urisrc->demuxer) {
-    GST_DEBUG_OBJECT (urisrc, "removing old adaptive demux element");
-    gst_element_set_state (urisrc->demuxer, GST_STATE_NULL);
-    gst_bin_remove (GST_BIN_CAST (urisrc), urisrc->demuxer);
-    urisrc->demuxer = NULL;
+  if (urisrc->src_infos) {
+    g_list_foreach (urisrc->src_infos, (GFunc) free_child_src_pad_info, urisrc);
+    g_list_free (urisrc->src_infos);
+    urisrc->src_infos = NULL;
   }
+  GST_URI_SOURCE_BIN_UNLOCK (urisrc);
 }
 
 /* is called when a dynamic source element created a new pad. */
@@ -2244,48 +2227,31 @@ static void
 source_new_pad (GstElement * element, GstPad * pad, GstURISourceBin * urisrc)
 {
   GstCaps *caps;
+  ChildSrcPadInfo *info = new_child_src_pad_info (urisrc, pad);
 
   GST_DEBUG_OBJECT (urisrc, "Found new pad %s.%s in source element %s",
       GST_DEBUG_PAD_NAME (pad), GST_ELEMENT_NAME (element));
+
   caps = gst_pad_get_current_caps (pad);
+  GST_DEBUG_OBJECT (urisrc, "caps %" GST_PTR_FORMAT, caps);
   if (caps == NULL)
-    setup_typefind (urisrc, pad);
+    setup_typefind (info);
   else {
-    handle_new_pad (urisrc, pad, caps);
+    handle_new_pad (info, pad, caps);
     gst_caps_unref (caps);
   }
 }
 
-static gboolean
-is_live_source (GstElement * source)
-{
-  GObjectClass *source_class = NULL;
-  gboolean is_live = FALSE;
-  GParamSpec *pspec;
-
-  source_class = G_OBJECT_GET_CLASS (source);
-  pspec = g_object_class_find_property (source_class, "is-live");
-  if (!pspec || G_PARAM_SPEC_VALUE_TYPE (pspec) != G_TYPE_BOOLEAN)
-    return FALSE;
-
-  g_object_get (G_OBJECT (source), "is-live", &is_live, NULL);
-
-  return is_live;
-}
-
 /* construct and run the source and demuxer elements until we found
  * all the streams or until a preroll queue has been filled.
 */
 static gboolean
 setup_source (GstURISourceBin * urisrc)
 {
-  gboolean is_raw, have_out, is_dynamic;
+  gboolean have_out, is_dynamic;
 
   GST_DEBUG_OBJECT (urisrc, "setup source");
 
-  /* delete old src */
-  remove_source (urisrc);
-
   /* create and configure an element that can handle the uri */
   if (!(urisrc->source = gen_source_element (urisrc)))
     goto no_source;
@@ -2300,32 +2266,16 @@ setup_source (GstURISourceBin * urisrc)
   g_signal_emit (urisrc, gst_uri_source_bin_signals[SIGNAL_SOURCE_SETUP],
       0, urisrc->source);
 
-  if (is_live_source (urisrc->source))
-    urisrc->is_stream = FALSE;
-
-  /* remove the old demuxer now, if any */
-  remove_demuxer (urisrc);
-
   /* see if the source element emits raw audio/video all by itself,
    * if so, we can create streams for the pads and be done with it.
    * Also check that is has source pads, if not, we assume it will
    * do everything itself.  */
-  if (!analyse_source (urisrc, &is_raw, &have_out, &is_dynamic,
-          urisrc->need_queue && urisrc->use_buffering))
+  if (!analyse_source_and_expose_raw_pads (urisrc, &have_out, &is_dynamic))
     goto invalid_source;
 
   if (!is_dynamic) {
-    if (is_raw) {
-      GST_DEBUG_OBJECT (urisrc, "Source provides all raw data");
-      /* source provides raw data, we added the pads and we can now signal a
-       * no_more pads because we are done. */
-      gst_element_no_more_pads (GST_ELEMENT_CAST (urisrc));
-      return TRUE;
-    } else if (!have_out) {
-      GST_DEBUG_OBJECT (urisrc, "Source has no output pads");
-
-      return TRUE;
-    }
+    if (!have_out)
+      goto no_pads;
   } else {
     GST_DEBUG_OBJECT (urisrc, "Source has dynamic output pads");
     /* connect a handler for the new-pad signal */
@@ -2334,50 +2284,6 @@ setup_source (GstURISourceBin * urisrc)
         G_CALLBACK (source_new_pad), urisrc);
   }
 
-  if (is_raw) {
-    GST_DEBUG_OBJECT (urisrc,
-        "Got raw srcpads on a dynamic source, using them as is.");
-
-    return TRUE;
-  } else if (urisrc->is_stream) {
-    GST_DEBUG_OBJECT (urisrc, "Setting up streaming");
-    /* do the stream things here */
-    if (!setup_typefind (urisrc, NULL))
-      goto streaming_failed;
-  } else {
-    GstIterator *pads_iter;
-    gboolean done = FALSE;
-
-    /* Expose all non-raw srcpads */
-    pads_iter = gst_element_iterate_src_pads (urisrc->source);
-    while (!done) {
-      GValue item = { 0, };
-      GstPad *pad;
-
-      switch (gst_iterator_next (pads_iter, &item)) {
-        case GST_ITERATOR_ERROR:
-          GST_WARNING_OBJECT (urisrc, "Error iterating pads on source element");
-          /* FALLTHROUGH */
-        case GST_ITERATOR_DONE:
-          done = TRUE;
-          break;
-        case GST_ITERATOR_RESYNC:
-          /* reset results and resync */
-          gst_iterator_resync (pads_iter);
-          break;
-        case GST_ITERATOR_OK:
-          pad = g_value_get_object (&item);
-          if (!setup_typefind (urisrc, pad)) {
-            gst_iterator_free (pads_iter);
-            goto streaming_failed;
-          }
-          g_value_reset (&item);
-          break;
-      }
-    }
-    gst_iterator_free (pads_iter);
-  }
-
   return TRUE;
 
   /* ERRORS */
@@ -2392,9 +2298,10 @@ invalid_source:
         (_("Source element is invalid.")), (NULL));
     return FALSE;
   }
-streaming_failed:
+no_pads:
   {
-    /* message was posted */
+    GST_ELEMENT_ERROR (urisrc, CORE, FAILED,
+        (_("Source element has no pads.")), (NULL));
     return FALSE;
   }
 }
@@ -2488,6 +2395,24 @@ handle_redirect_message (GstURISourceBin * urisrc, GstMessage * msg)
   return new_msg;
 }
 
+/* CALL WITH URISOURCEBIN LOCK */
+static OutputSlotInfo *
+output_slot_for_buffering_element (GstURISourceBin * urisrc,
+    GstElement * element)
+{
+  GList *top, *iter;
+  for (top = urisrc->src_infos; top; top = top->next) {
+    ChildSrcPadInfo *info = top->data;
+    for (iter = info->outputs; iter; iter = iter->next) {
+      OutputSlotInfo *slot = iter->data;
+      if (slot->queue == element)
+        return slot;
+    }
+  }
+
+  return NULL;
+}
+
 static void
 handle_buffering_message (GstURISourceBin * urisrc, GstMessage * msg)
 {
@@ -2498,9 +2423,9 @@ handle_buffering_message (GstURISourceBin * urisrc, GstMessage * msg)
   GList *iter;
   OutputSlotInfo *slot;
 
-  /* buffering messages must be aggregated as there might be multiple
-   * multiqueue in the pipeline and their independent buffering messages
-   * will confuse the application
+  /* buffering messages must be aggregated as there might be multiple buffering
+   * elements in the pipeline and their independent buffering messages will
+   * confuse the application
    *
    * urisourcebin keeps a list of messages received from elements that are
    * buffering.
@@ -2516,10 +2441,10 @@ handle_buffering_message (GstURISourceBin * urisrc, GstMessage * msg)
   GST_LOG_OBJECT (urisrc, "Got buffering msg from %" GST_PTR_FORMAT
       " with %d%%", GST_MESSAGE_SRC (msg), msg_perc);
 
-  slot = g_object_get_data (G_OBJECT (GST_MESSAGE_SRC (msg)),
-      "urisourcebin.slotinfo");
-
   BUFFERING_LOCK (urisrc);
+  slot =
+      output_slot_for_buffering_element (urisrc,
+      (GstElement *) GST_MESSAGE_SRC (msg));
   if (slot && slot->is_eos) {
     /* Ignore buffering messages from queues we marked as EOS,
      * we already removed those from the list of buffering
@@ -2529,7 +2454,6 @@ handle_buffering_message (GstURISourceBin * urisrc, GstMessage * msg)
     return;
   }
 
-
   g_mutex_lock (&urisrc->buffering_post_lock);
 
   /*
@@ -2542,8 +2466,9 @@ handle_buffering_message (GstURISourceBin * urisrc, GstMessage * msg)
     GstMessage *bufstats = iter->data;
     gboolean is_eos = FALSE;
 
-    slot = g_object_get_data (G_OBJECT (GST_MESSAGE_SRC (bufstats)),
-        "urisourcebin.slotinfo");
+    slot =
+        output_slot_for_buffering_element (urisrc,
+        (GstElement *) GST_MESSAGE_SRC (msg));
     if (slot)
       is_eos = slot->is_eos;
 
@@ -2671,11 +2596,19 @@ handle_message (GstBin * bin, GstMessage * msg)
       break;
     }
     case GST_MESSAGE_STREAM_COLLECTION:
-    {
-      GST_DEBUG_OBJECT (urisrc, "Source is streams-aware");
-      urisrc->source_streams_aware = TRUE;
+      /* We only want to forward stream collection from the source element *OR*
+       * from adaptive demuxers. We do not want to forward them from the
+       * potential parsebins since there might be many and require aggregation
+       * to be useful/coherent. */
+      if (GST_MESSAGE_SRC (msg) != (GstObject *) urisrc->source
+          && !urisrc->is_adaptive) {
+        GST_DEBUG_OBJECT (bin,
+            "Dropping stream-collection from non-adaptive-demuxer %"
+            GST_PTR_FORMAT, GST_MESSAGE_SRC (msg));
+        gst_message_unref (msg);
+        msg = NULL;
+      }
       break;
-    }
     case GST_MESSAGE_BUFFERING:
       handle_buffering_message (urisrc, msg);
       msg = NULL;
@@ -2978,10 +2911,19 @@ gst_uri_source_bin_change_state (GstElement * element,
 
   switch (transition) {
     case GST_STATE_CHANGE_READY_TO_PAUSED:
+      GST_URI_SOURCE_BIN_LOCK (element);
+      urisrc->flushing = FALSE;
+      urisrc->activated = FALSE;
+      GST_URI_SOURCE_BIN_UNLOCK (element);
       GST_DEBUG ("ready to paused");
       if (!setup_source (urisrc))
         goto source_failed;
       break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      GST_URI_SOURCE_BIN_LOCK (element);
+      urisrc->flushing = TRUE;
+      g_cond_broadcast (&urisrc->activation_cond);
+      GST_URI_SOURCE_BIN_UNLOCK (element);
     default:
       break;
   }
@@ -2992,21 +2934,21 @@ gst_uri_source_bin_change_state (GstElement * element,
 
   switch (transition) {
     case GST_STATE_CHANGE_READY_TO_PAUSED:
+    {
+      GST_URI_SOURCE_BIN_LOCK (element);
+      GST_DEBUG_OBJECT (urisrc, "Potentially exposing pads");
+      urisrc->activated = TRUE;
+      g_cond_broadcast (&urisrc->activation_cond);
+      GST_URI_SOURCE_BIN_UNLOCK (element);
+    }
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
       GST_DEBUG ("paused to ready");
-      remove_demuxer (urisrc);
       remove_source (urisrc);
       g_list_free_full (urisrc->buffering_status,
           (GDestroyNotify) gst_message_unref);
       urisrc->buffering_status = NULL;
       urisrc->last_buffering_pct = -1;
-      urisrc->source_streams_aware = FALSE;
-      break;
-    case GST_STATE_CHANGE_READY_TO_NULL:
-      GST_DEBUG ("ready to null");
-      remove_demuxer (urisrc);
-      remove_source (urisrc);
       break;
     default:
       break;
diff --git a/subprojects/gst-plugins-base/gst/rawparse/gstrawvideoparse.c b/subprojects/gst-plugins-base/gst/rawparse/gstrawvideoparse.c
index ab0fa651d5..d630040c65 100644
--- a/subprojects/gst-plugins-base/gst/rawparse/gstrawvideoparse.c
+++ b/subprojects/gst-plugins-base/gst/rawparse/gstrawvideoparse.c
@@ -1161,9 +1161,9 @@ gst_raw_video_parse_update_info (GstRawVideoParseConfig * config)
     gint stride = GST_VIDEO_INFO_PLANE_STRIDE (info, last_plane);
     gint x_tiles = GST_VIDEO_TILE_X_TILES (stride);
     gint y_tiles = GST_VIDEO_TILE_Y_TILES (stride);
-    gint tile_width = 1 << GST_VIDEO_FORMAT_INFO_TILE_WS (info->finfo);
-    gint tile_height = 1 << GST_VIDEO_FORMAT_INFO_TILE_HS (info->finfo);
-    last_plane_size = x_tiles * y_tiles * tile_width * tile_height;
+    guint tile_size = GST_VIDEO_FORMAT_INFO_TILE_SIZE (info->finfo, last_plane);
+
+    last_plane_size = x_tiles * y_tiles * tile_size;
   } else {
     gint comp[GST_VIDEO_MAX_COMPONENTS];
     gst_video_format_info_component (info->finfo, last_plane, comp);
diff --git a/subprojects/gst-plugins-base/gst/videoconvertscale/gstvideoconvert.c b/subprojects/gst-plugins-base/gst/videoconvertscale/gstvideoconvert.c
index 88f3de0bc1..e87fb15790 100644
--- a/subprojects/gst-plugins-base/gst/videoconvertscale/gstvideoconvert.c
+++ b/subprojects/gst-plugins-base/gst/videoconvertscale/gstvideoconvert.c
@@ -56,7 +56,7 @@ gst_video_convert_class_init (GstVideoConvertClass * klass)
   gst_element_class_set_static_metadata (element_class,
       "Video colorspace converter",
       "Filter/Converter/Video/Colorspace",
-      "Resizes video and allow color conversion",
+      "Converts video from one colorspace to another",
       "Wim Taymans <wim.taymans@gmail.com>");
 
   convertscale_class->any_memory = TRUE;
diff --git a/subprojects/gst-plugins-base/gst/videoconvertscale/gstvideoconvertscale.c b/subprojects/gst-plugins-base/gst/videoconvertscale/gstvideoconvertscale.c
index b885271a22..b6c4f44e22 100644
--- a/subprojects/gst-plugins-base/gst/videoconvertscale/gstvideoconvertscale.c
+++ b/subprojects/gst-plugins-base/gst/videoconvertscale/gstvideoconvertscale.c
@@ -378,7 +378,7 @@ gst_video_convert_scale_class_init (GstVideoConvertScaleClass * klass)
   gst_element_class_set_static_metadata (element_class,
       "Video colorspace converter and scaler",
       "Filter/Converter/Video/Scaler/Colorspace",
-      "Converts video from one colorspace to another",
+      "Resizes video and converts from one colorspace to another",
       "Wim Taymans <wim.taymans@gmail.com>");
 
   gst_element_class_add_pad_template (element_class,
diff --git a/subprojects/gst-plugins-base/meson.build b/subprojects/gst-plugins-base/meson.build
index 4e2dde8c55..83a341c337 100644
--- a/subprojects/gst-plugins-base/meson.build
+++ b/subprojects/gst-plugins-base/meson.build
@@ -1,5 +1,5 @@
 project('gst-plugins-base', 'c',
-  version : '1.21.2',
+  version : '1.21.2.1',
   meson_version : '>= 0.62',
   default_options : [ 'warning_level=1',
                       'buildtype=debugoptimized' ])
diff --git a/subprojects/gst-plugins-base/tools/gst-play.c b/subprojects/gst-plugins-base/tools/gst-play.c
index c66c77adee..11378bada5 100644
--- a/subprojects/gst-plugins-base/tools/gst-play.c
+++ b/subprojects/gst-plugins-base/tools/gst-play.c
@@ -104,6 +104,7 @@ typedef struct
 
   gboolean buffering;
   gboolean is_live;
+  gboolean initial_file;
 
   GstState desired_state;       /* as per user interaction, PAUSED or PLAYING */
 
@@ -111,6 +112,7 @@ typedef struct
 
   /* configuration */
   gboolean gapless;
+  gboolean instant_uri;
 
   GstPlayTrickMode trick_mode;
   gdouble rate;
@@ -166,8 +168,9 @@ gst_play_printf (const gchar * format, ...)
 
 static GstPlay *
 play_new (gchar ** uris, const gchar * audio_sink, const gchar * video_sink,
-    gboolean gapless, gdouble initial_volume, gboolean verbose,
-    const gchar * flags_string, gboolean use_playbin3, gdouble start_position)
+    gboolean gapless, gboolean instant_uri, gdouble initial_volume,
+    gboolean verbose, const gchar * flags_string, gboolean use_playbin3,
+    gdouble start_position)
 {
   GstElement *sink, *playbin;
   GstPlay *play;
@@ -262,6 +265,11 @@ play_new (gchar ** uris, const gchar * audio_sink, const gchar * video_sink,
         G_CALLBACK (play_about_to_finish), play);
   }
 
+  play->initial_file = TRUE;
+  if (use_playbin3) {
+    play->instant_uri = instant_uri;
+    g_object_set (G_OBJECT (play->playbin), "instant-uri", instant_uri, NULL);
+  }
   if (initial_volume != -1)
     play_set_relative_volume (play, initial_volume - 1.0);
 
@@ -745,7 +753,8 @@ play_uri (GstPlay * play, const gchar * next_uri)
 {
   gchar *loc;
 
-  gst_element_set_state (play->playbin, GST_STATE_READY);
+  if (!play->instant_uri || play->initial_file)
+    gst_element_set_state (play->playbin, GST_STATE_READY);
   play_reset (play);
 
   loc = play_uri_get_display_name (play, next_uri);
@@ -754,23 +763,26 @@ play_uri (GstPlay * play, const gchar * next_uri)
 
   g_object_set (play->playbin, "uri", next_uri, NULL);
 
-  switch (gst_element_set_state (play->playbin, GST_STATE_PAUSED)) {
-    case GST_STATE_CHANGE_FAILURE:
-      /* ignore, we should get an error message posted on the bus */
-      break;
-    case GST_STATE_CHANGE_NO_PREROLL:
-      gst_print ("Pipeline is live.\n");
-      play->is_live = TRUE;
-      break;
-    case GST_STATE_CHANGE_ASYNC:
-      gst_print ("Prerolling...\r");
-      break;
-    default:
-      break;
-  }
+  if (!play->instant_uri || play->initial_file) {
+    switch (gst_element_set_state (play->playbin, GST_STATE_PAUSED)) {
+      case GST_STATE_CHANGE_FAILURE:
+        /* ignore, we should get an error message posted on the bus */
+        break;
+      case GST_STATE_CHANGE_NO_PREROLL:
+        gst_print ("Pipeline is live.\n");
+        play->is_live = TRUE;
+        break;
+      case GST_STATE_CHANGE_ASYNC:
+        gst_print ("Prerolling...\r");
+        break;
+      default:
+        break;
+    }
 
-  if (play->desired_state != GST_STATE_PAUSED)
-    gst_element_set_state (play->playbin, play->desired_state);
+    if (play->desired_state != GST_STATE_PAUSED)
+      gst_element_set_state (play->playbin, play->desired_state);
+  }
+  play->initial_file = FALSE;
 }
 
 /* returns FALSE if we have reached the end of the playlist */
@@ -1589,6 +1601,7 @@ main (int argc, char **argv)
   gboolean print_version = FALSE;
   gboolean interactive = TRUE;
   gboolean gapless = FALSE;
+  gboolean instant_uri = FALSE;
   gboolean shuffle = FALSE;
   gdouble volume = -1;
   gdouble start_position = 0;
@@ -1619,6 +1632,8 @@ main (int argc, char **argv)
         N_("Audio sink to use (default is autoaudiosink)"), NULL},
     {"gapless", 0, 0, G_OPTION_ARG_NONE, &gapless,
         N_("Enable gapless playback"), NULL},
+    {"instant-uri", 0, 0, G_OPTION_ARG_NONE, &instant_uri,
+        N_("Enable instantaneous uri changes (only with playbin3)"), NULL},
     {"shuffle", 0, 0, G_OPTION_ARG_NONE, &shuffle,
         N_("Shuffle playlist"), NULL},
     {"no-interactive", 0, G_OPTION_FLAG_REVERSE, G_OPTION_ARG_NONE,
@@ -1754,8 +1769,9 @@ main (int argc, char **argv)
     shuffle_uris (uris, num);
 
   /* prepare */
-  play = play_new (uris, audio_sink, video_sink, gapless, volume, verbose,
-      flags, use_playbin3, start_position);
+  play =
+      play_new (uris, audio_sink, video_sink, gapless, instant_uri, volume,
+      verbose, flags, use_playbin3, start_position);
 
   if (play == NULL) {
     gst_printerr
