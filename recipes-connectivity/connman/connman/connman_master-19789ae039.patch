diff --git a/AUTHORS b/AUTHORS
index 3ed09850..2ba7b20e 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -176,3 +176,7 @@ Lukáš Karas <lukas.karas@centrum.cz>
 Michael Nazzareno Trimarchi <michael@amarulasolutions.com>
 Christian Taedcke <christian.taedcke@lemonbeat.com>
 Matthias Gerstner <mgerstner@suse.de>
+Sebastian Pipping <sebastian@pipping.org>
+Daniel Linjama <daniel@dev.linjama.com>
+Nathan Crandall <ncrandall@tesla.com>
+Ben Kohler <bkohler@gentoo.org>
diff --git a/Makefile.am b/Makefile.am
index e5718b19..c108b8f3 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -243,6 +243,7 @@ AM_CFLAGS = @DBUS_CFLAGS@ @GLIB_CFLAGS@ \
 				-DSCRIPTDIR=\""$(build_scriptdir)"\" \
 				-DSTORAGEDIR=\""$(storagedir)\"" \
 				-DVPN_STORAGEDIR=\""$(vpn_storagedir)\"" \
+				-DRUNSTATEDIR=\""$(runstatedir)"\" \
 				-DCONFIGDIR=\""$(configdir)\""
 
 if VPN
@@ -275,6 +276,7 @@ vpn_connman_vpnd_CFLAGS = @DBUS_CFLAGS@ @GLIB_CFLAGS@ \
 				-DSCRIPTDIR=\""$(build_scriptdir)"\" \
 				-DSTORAGEDIR=\""$(storagedir)\"" \
 				-DVPN_STORAGEDIR=\""$(vpn_storagedir)\"" \
+				-DRUNSTATEDIR=\""$(runstatedir)"\" \
 				-DCONFIGDIR=\""$(configdir)\"" \
 				-I$(builddir)/vpn
 
@@ -434,6 +436,21 @@ test_scripts += test/vpn-connect test/vpn-disconnect test/vpn-get \
 if TEST
 testdir = $(pkglibdir)/test
 test_SCRIPTS = $(test_scripts)
+
+if INTERNAL_DNS_BACKEND
+tools_dnsproxy_standalone_CFLAGS = $(src_connmand_CFLAGS) -I$(srcdir)/src
+tools_dnsproxy_standalone_SOURCES = tools/dnsproxy-standalone.c $(src_connmand_SOURCES)
+# for EXTRA_PROGRAMS the BUILT_SOURCES aren't automatically added as
+# dependency, so let's do it explicitly
+tools/dnsproxy-standalone.c: $(BUILT_SOURCES)
+tools_dnsproxy_standalone_LDADD = $(src_connmand_LDADD)
+# pass -zmuldefs to let the linker tolerate the duplicate definition of
+# main(), the first definition from dnsproxy-standalone should be used
+tools_dnsproxy_standalone_LDFLAGS = $(src_connmand_LDFLAGS) -Wl,-zmuldefs
+
+noinst_PROGRAMS += tools/dnsproxy-standalone
+endif
+
 endif
 
 EXTRA_DIST += $(test_scripts)
diff --git a/Makefile.plugins b/Makefile.plugins
index 8e323617..bd5049ec 100644
--- a/Makefile.plugins
+++ b/Makefile.plugins
@@ -138,6 +138,7 @@ vpn_plugin_objects += $(plugins_vpnc_la_OBJECTS)
 vpn_plugins_vpnc_la_SOURCES = vpn/plugins/vpnc.c
 vpn_plugins_vpnc_la_CFLAGS = $(plugin_cflags) -DVPNC=\"@VPNC@\" \
 					-DVPN_STATEDIR=\""$(vpn_statedir)"\" \
+					-DRUNSTATEDIR=\""$(runstatedir)"\" \
 					-DSCRIPTDIR=\""$(build_scriptdir)"\"
 vpn_plugins_vpnc_la_LDFLAGS = $(plugin_ldflags)
 endif
diff --git a/doc/connman.conf.5.in b/doc/connman.conf.5.in
index 82cceb72..1f9b2908 100644
--- a/doc/connman.conf.5.in
+++ b/doc/connman.conf.5.in
@@ -129,7 +129,8 @@ are in 'online' or 'ready' states, the newly connected service is
 the only one that will be kept connected. A service connected by the
 user will be used until going out of network coverage. With this
 setting enabled applications will notice more network breaks than
-normal. Default value is false.
+normal. Note this options can't be used with VPNs.
+Default value is false.
 .TP
 .BI TetheringTechnologies= technology\fR[,...]
 List of technologies that are allowed to enable tethering separated by ",".
@@ -205,6 +206,23 @@ address will be chosen instead (according to RFC3927). If an address conflict
 occurs for an address offered via DHCP, ConnMan send a DHCP DECLINE once and
 for the second conflict resort to finding an IPv4LL address.
 Default value is false.
+.TP
+.BI Localtime= string
+Path to localtime file. Defaults to /etc/localtime.
+.TP
+.BI RegdomFollowsTimezone= true\ \fR|\fB\ false
+Enable regdomain to be changed along timezone changes. With this option set to
+true each time the timezone changes the first present ISO3166 country code is
+being read from /usr/share/zoneinfo/zone1970.tab and set as regdom value.
+Default value is false.
+.TP
+.BI ResolvConf= string
+Path to resolv.conf file. If the file does not exist, but intermediate
+directories exist, it will be created.
+If this option is not set, it tries to write into
+@runstatedir@/connman/resolv.conf and fallbacks to @sysconfdir@/resolv.conf if
+it fails (@runstatedir@/connman does not exist or is not writeable).
+If you do not want to update resolv.conf, you can set /dev/null.
 .SH "EXAMPLE"
 The following example configuration disables hostname updates and enables
 ethernet tethering.
diff --git a/gdhcp/client.c b/gdhcp/client.c
index 3016dfc2..7efa7e45 100644
--- a/gdhcp/client.c
+++ b/gdhcp/client.c
@@ -3036,7 +3036,7 @@ char *g_dhcp_client_get_server_address(GDHCPClient *dhcp_client)
 	if (!dhcp_client)
 		return NULL;
 
-	return get_ip(dhcp_client->server_ip);
+	return get_ip(htonl(dhcp_client->server_ip));
 }
 
 char *g_dhcp_client_get_address(GDHCPClient *dhcp_client)
diff --git a/gsupplicant/supplicant.c b/gsupplicant/supplicant.c
index 470d99eb..1b92ec44 100644
--- a/gsupplicant/supplicant.c
+++ b/gsupplicant/supplicant.c
@@ -810,6 +810,33 @@ static void remove_peer(gpointer data)
 	g_free(peer);
 }
 
+static void remove_ssid(gpointer data)
+{
+	GSupplicantSSID *ssid = data;
+
+	if (!ssid)
+		return;
+
+	g_free((void *) ssid->ssid);
+	g_free((char *) ssid->eap);
+	g_free((char *) ssid->passphrase);
+	g_free((char *) ssid->identity);
+	g_free((char *) ssid->anonymous_identity);
+	g_free((char *) ssid->ca_cert_path);
+	g_free((char *) ssid->subject_match);
+	g_free((char *) ssid->altsubject_match);
+	g_free((char *) ssid->domain_suffix_match);
+	g_free((char *) ssid->domain_match);
+	g_free((char *) ssid->client_cert_path);
+	g_free((char *) ssid->private_key_path);
+	g_free((char *) ssid->private_key_passphrase);
+	g_free((char *) ssid->phase2_auth);
+	g_free((char *) ssid->pin_wps);
+	g_free((char *) ssid->bgscan);
+
+	g_free(ssid);
+}
+
 static void debug_strvalmap(const char *label, struct strvalmap *map,
 							unsigned int val)
 {
@@ -4151,6 +4178,7 @@ done:
 	if (data->callback)
 		data->callback(err, NULL, data->user_data);
 
+	remove_ssid(data->ssid);
 	dbus_free(data);
 }
 
@@ -4469,7 +4497,7 @@ static void interface_select_network_result(const char *error,
 	if (data->callback)
 		data->callback(err, data->interface, data->user_data);
 
-	g_free(data->ssid);
+	remove_ssid(data->ssid);
 	dbus_free(data);
 }
 
@@ -4525,7 +4553,7 @@ error:
 	}
 
 	g_free(data->path);
-	g_free(data->ssid);
+	remove_ssid(data->ssid);
 	g_free(data);
 }
 
@@ -5030,7 +5058,7 @@ static void interface_wps_start_result(const char *error,
 		data->callback(err, data->interface, data->user_data);
 
 	g_free(data->path);
-	g_free(data->ssid);
+	remove_ssid(data->ssid);
 	dbus_free(data);
 }
 
@@ -5070,7 +5098,7 @@ static void wps_start(const char *error, DBusMessageIter *iter, void *user_data)
 	if (error) {
 		SUPPLICANT_DBG("error: %s", error);
 		g_free(data->path);
-		g_free(data->ssid);
+		remove_ssid(data->ssid);
 		dbus_free(data);
 		return;
 	}
@@ -5159,6 +5187,7 @@ int g_supplicant_interface_connect(GSupplicantInterface *interface,
 			 * type is 802.11x).
 			 */
 			if (compare_network_parameters(interface, ssid)) {
+				remove_ssid(ssid);
 				return -EALREADY;
 			}
 
@@ -5184,6 +5213,7 @@ int g_supplicant_interface_connect(GSupplicantInterface *interface,
 
 	if (ret < 0) {
 		g_free(data->path);
+		remove_ssid(data->ssid);
 		dbus_free(data);
 		return ret;
 	}
@@ -5234,6 +5264,7 @@ static void network_remove_result(const char *error,
 	} else {
 		if (data->callback)
 			data->callback(result, data->interface, data->user_data);
+		remove_ssid(data->ssid);
 	}
 	g_free(data->path);
 	dbus_free(data);
@@ -5287,6 +5318,7 @@ static void interface_disconnect_result(const char *error,
 							data->user_data);
 
 		g_free(data->path);
+		remove_ssid(data->ssid);
 		dbus_free(data);
 		return;
 	}
@@ -5299,10 +5331,12 @@ static void interface_disconnect_result(const char *error,
 	if (result != -ECONNABORTED) {
 		if (network_remove(data) < 0) {
 			g_free(data->path);
+			remove_ssid(data->ssid);
 			dbus_free(data);
 		}
 	} else {
 		g_free(data->path);
+		remove_ssid(data->ssid);
 		dbus_free(data);
 	}
 }
diff --git a/gweb/gresolv.c b/gweb/gresolv.c
index 954e7cfe..8101d718 100644
--- a/gweb/gresolv.c
+++ b/gweb/gresolv.c
@@ -36,6 +36,7 @@
 #include <arpa/inet.h>
 #include <arpa/nameser.h>
 #include <net/if.h>
+#include <ctype.h>
 
 #include "gresolv.h"
 
diff --git a/gweb/gweb.c b/gweb/gweb.c
index 12fcb1d8..13c6c5f2 100644
--- a/gweb/gweb.c
+++ b/gweb/gweb.c
@@ -918,7 +918,7 @@ static gboolean received_data(GIOChannel *channel, GIOCondition cond,
 		}
 
 		*pos = '\0';
-		count = strlen((char *) ptr);
+		count = pos - ptr;
 		if (count > 0 && ptr[count - 1] == '\r') {
 			ptr[--count] = '\0';
 			bytes_read--;
diff --git a/include/agent.h b/include/agent.h
index 6961f7a1..27020203 100644
--- a/include/agent.h
+++ b/include/agent.h
@@ -71,6 +71,7 @@ int connman_agent_queue_message(void *user_context,
 				DBusMessage *msg, int timeout,
 				agent_queue_cb callback, void *user_data,
 				void *agent_data);
+bool connman_agent_queue_search(void *user_context, void *agent_data);
 
 void *connman_agent_get_info(const char *dbus_sender, const char **sender,
 							const char **path);
diff --git a/include/network.h b/include/network.h
index 8f9dd94a..5bca62ad 100644
--- a/include/network.h
+++ b/include/network.h
@@ -163,6 +163,7 @@ struct connman_network_driver {
 	void (*remove) (struct connman_network *network);
 	int (*connect) (struct connman_network *network);
 	int (*disconnect) (struct connman_network *network);
+	int (*forget) (struct connman_network *network);
 	int (*set_autoconnect) (struct connman_network *network,
 				bool autoconnect);
 };
diff --git a/include/timeserver.h b/include/timeserver.h
index 48ea1945..3177d4e5 100644
--- a/include/timeserver.h
+++ b/include/timeserver.h
@@ -26,6 +26,13 @@
 extern "C" {
 #endif
 
+enum connman_timeserver_sync_reason {
+	CONNMAN_TIMESERVER_SYNC_REASON_START		= 0,
+	CONNMAN_TIMESERVER_SYNC_REASON_ADDRESS_UPDATE	= 1,
+	CONNMAN_TIMESERVER_SYNC_REASON_STATE_UPDATE	= 2,
+	CONNMAN_TIMESERVER_SYNC_REASON_TS_CHANGE	= 3,
+};
+
 int __connman_timeserver_system_set(char **server);
 
 #ifdef __cplusplus
diff --git a/plugins/iwd.c b/plugins/iwd.c
index ac3d1e17..485e0661 100644
--- a/plugins/iwd.c
+++ b/plugins/iwd.c
@@ -241,7 +241,9 @@ static void cm_network_connect_cb(DBusMessage *message, void *user_data)
 			return;
 
 		DBG("%s connect failed: %s", path, dbus_error);
-		if (!strcmp(dbus_error, "net.connman.iwd.Failed"))
+		if (!strcmp(dbus_error, "net.connman.iwd.Failed") ||
+				!strcmp(dbus_error,
+					"net.connman.iwd.InvalidFormat"))
 			connman_network_set_error(iwdn->network,
 					CONNMAN_NETWORK_ERROR_INVALID_KEY);
 		else if (!iwdn->autoconnect)
@@ -270,6 +272,46 @@ static int cm_network_connect(struct connman_network *network)
 	return -EINPROGRESS;
 }
 
+static void cm_network_forget_cb(DBusMessage *message, void *user_data)
+{
+	struct iwd_known_network *iwdkn;
+	const char *path = user_data;
+
+	iwdkn = g_hash_table_lookup(known_networks, path);
+	if (!iwdkn)
+		return;
+
+	if (dbus_message_get_type(message) == DBUS_MESSAGE_TYPE_ERROR) {
+		const char *dbus_error = dbus_message_get_error_name(message);
+
+		DBG("%s failed: %s", path, dbus_error);
+	}
+}
+
+static int cm_network_forget(struct connman_network *network)
+{
+	struct iwd_network *iwdn = connman_network_get_data(network);
+	struct iwd_known_network *iwdkn;
+
+	if (!iwdn)
+		return -EINVAL;
+
+	if (!iwdn->known_network)
+		return 0;
+
+	iwdkn = g_hash_table_lookup(known_networks,
+				iwdn->known_network);
+	if (!iwdkn)
+		return 0;
+
+	if (!g_dbus_proxy_method_call(iwdkn->proxy, "Forget",
+			NULL, cm_network_forget_cb,
+			g_strdup(iwdkn->path), g_free))
+		return -EIO;
+
+	return 0;
+}
+
 static void cm_network_disconnect_cb(DBusMessage *message, void *user_data)
 {
 	const char *path = user_data;
@@ -470,6 +512,7 @@ static struct connman_network_driver network_driver = {
 	.probe			= cm_network_probe,
 	.connect		= cm_network_connect,
 	.disconnect		= cm_network_disconnect,
+	.forget		= cm_network_forget,
 	.set_autoconnect	= cm_network_set_autoconnect,
 };
 
@@ -693,7 +736,7 @@ static void tech_enable_tethering_cb(const DBusError *error, void *user_data)
 	}
 
 	if (dbus_error_is_set(error)) {
-		connman_warn("iwd device %s could not enable AcessPoint mode: %s",
+		connman_warn("iwd device %s could not enable AccessPoint mode: %s",
 			cbd->path, error->message);
 		goto out;
 	}
@@ -745,6 +788,7 @@ static void tech_disable_tethering_cb(const DBusError *error, void *user_data)
 		goto out;
 	}
 
+	connman_technology_tethering_notify(cbd->tech, false);
 	iwdap = g_hash_table_lookup(access_points, iwdd->path);
 	if (!iwdap) {
 		DBG("%s no ap object found", iwdd->path);
@@ -756,11 +800,6 @@ static void tech_disable_tethering_cb(const DBusError *error, void *user_data)
 	iwdap->bridge = NULL;
 	iwdap->tech = NULL;
 
-	if (!connman_inet_remove_from_bridge(cbd->index, cbd->bridge))
-		goto out;
-
-	connman_technology_tethering_notify(cbd->tech, false);
-
 	if (!g_dbus_proxy_method_call(iwdap->proxy, "Stop",
 					NULL, tech_ap_stop_cb, cbd, NULL)) {
 		connman_warn("iwd ap %s could not stop AccessPoint mode: %s",
@@ -787,6 +826,9 @@ static int cm_change_tethering(struct iwd_device *iwdd,
 	if (index < 0)
 		return -ENODEV;
 
+	if (!enabled && connman_inet_remove_from_bridge(index, bridge))
+		return -EIO;
+
 	cbd = g_new(struct tech_cb_data, 1);
 	cbd->iwdd = iwdd;
 	cbd->path = g_strdup(iwdd->path);
@@ -1128,7 +1170,9 @@ static unsigned char calculate_strength(int strength)
 	 * ConnMan expects it in the range from 100 (strongest) to 0
 	 * (weakest).
 	 */
-	res = (unsigned char)((strength + 10000) / 100);
+	res = (unsigned char)(120 + strength / 100);
+	if (res > 100)
+		res = 100;
 
 	return res;
 }
diff --git a/plugins/ofono.c b/plugins/ofono.c
index f0bd3c5d..8bb53949 100644
--- a/plugins/ofono.c
+++ b/plugins/ofono.c
@@ -40,6 +40,7 @@
 #include <connman/dbus.h>
 #include <connman/log.h>
 #include <connman/technology.h>
+#include <connman/setting.h>
 
 #include "mcc.h"
 
@@ -1710,6 +1711,10 @@ static void netreg_update_regdom(struct modem_data *modem,
 	char *alpha2;
 	int mcc;
 
+	/* Do not change regdom here if it is set to follow timezone. */
+	if (connman_setting_get_bool("RegdomFollowsTimezone"))
+		return;
+
 	dbus_message_iter_get_basic(value, &mobile_country_code);
 
 	DBG("%s MobileContryCode %s", modem->path, mobile_country_code);
diff --git a/plugins/wifi.c b/plugins/wifi.c
index e947b169..ed7437f5 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -2163,21 +2163,29 @@ static GSupplicantSecurity network_security(const char *security)
 static void ssid_init(GSupplicantSSID *ssid, struct connman_network *network)
 {
 	struct wifi_network *network_data = connman_network_get_data(network);
+	const char *ssid_blob;
 	const char *security;
 
 	memset(ssid, 0, sizeof(*ssid));
 	ssid->mode = G_SUPPLICANT_MODE_INFRA;
-	ssid->ssid = connman_network_get_blob(network, "WiFi.SSID",
-						&ssid->ssid_len);
+	ssid->ssid_len = 0;
+	ssid_blob =
+		connman_network_get_blob(network, "WiFi.SSID", &ssid->ssid_len);
+	ssid->ssid = g_try_malloc(ssid->ssid_len);
+	if (ssid->ssid)
+		memcpy((void *)ssid->ssid, ssid_blob, ssid->ssid_len);
+	else
+		ssid->ssid_len = 0;
+
 	ssid->scan_ssid = 1;
 	security = connman_network_get_string(network, "WiFi.Security");
 	ssid->security = network_security(security);
 	ssid->keymgmt = network_data->keymgmt;
 	ssid->ieee80211w = G_SUPPLICANT_MFP_OPTIONAL;
-	ssid->passphrase = connman_network_get_string(network,
-						"WiFi.Passphrase");
+	ssid->passphrase = g_strdup(
+		connman_network_get_string(network, "WiFi.Passphrase"));
 
-	ssid->eap = connman_network_get_string(network, "WiFi.EAP");
+	ssid->eap = g_strdup(connman_network_get_string(network, "WiFi.EAP"));
 
 	/*
 	 * If our private key password is unset,
@@ -2186,42 +2194,44 @@ static void ssid_init(GSupplicantSSID *ssid, struct connman_network *network)
 	 * cert may have to be provided.
 	 */
 	if (!connman_network_get_string(network, "WiFi.PrivateKeyPassphrase"))
-		connman_network_set_string(network,
-						"WiFi.PrivateKeyPassphrase",
-						ssid->passphrase);
+		connman_network_set_string(network, "WiFi.PrivateKeyPassphrase",
+					   ssid->passphrase);
 	/* We must have an identity for both PEAP and TLS */
-	ssid->identity = connman_network_get_string(network, "WiFi.Identity");
+	ssid->identity =
+		g_strdup(connman_network_get_string(network, "WiFi.Identity"));
 
 	/* Use agent provided identity as a fallback */
 	if (!ssid->identity || strlen(ssid->identity) == 0)
-		ssid->identity = connman_network_get_string(network,
-							"WiFi.AgentIdentity");
-
-	ssid->anonymous_identity = connman_network_get_string(network,
-						"WiFi.AnonymousIdentity");
-	ssid->ca_cert_path = connman_network_get_string(network,
-							"WiFi.CACertFile");
-	ssid->subject_match = connman_network_get_string(network,
-							"WiFi.SubjectMatch");
-	ssid->altsubject_match = connman_network_get_string(network,
-							"WiFi.AltSubjectMatch");
-	ssid->domain_suffix_match = connman_network_get_string(network,
-							"WiFi.DomainSuffixMatch");
-	ssid->domain_match = connman_network_get_string(network,
-							"WiFi.DomainMatch");
-	ssid->client_cert_path = connman_network_get_string(network,
-							"WiFi.ClientCertFile");
-	ssid->private_key_path = connman_network_get_string(network,
-							"WiFi.PrivateKeyFile");
-	ssid->private_key_passphrase = connman_network_get_string(network,
-						"WiFi.PrivateKeyPassphrase");
-	ssid->phase2_auth = connman_network_get_string(network, "WiFi.Phase2");
+		ssid->identity = g_strdup(connman_network_get_string(
+			network, "WiFi.AgentIdentity"));
+
+	ssid->anonymous_identity = g_strdup(
+		connman_network_get_string(network, "WiFi.AnonymousIdentity"));
+	ssid->ca_cert_path = g_strdup(
+		connman_network_get_string(network, "WiFi.CACertFile"));
+	ssid->subject_match = g_strdup(
+		connman_network_get_string(network, "WiFi.SubjectMatch"));
+	ssid->altsubject_match = g_strdup(
+		connman_network_get_string(network, "WiFi.AltSubjectMatch"));
+	ssid->domain_suffix_match = g_strdup(
+		connman_network_get_string(network, "WiFi.DomainSuffixMatch"));
+	ssid->domain_match = g_strdup(
+		connman_network_get_string(network, "WiFi.DomainMatch"));
+	ssid->client_cert_path = g_strdup(
+		connman_network_get_string(network, "WiFi.ClientCertFile"));
+	ssid->private_key_path = g_strdup(
+		connman_network_get_string(network, "WiFi.PrivateKeyFile"));
+	ssid->private_key_passphrase = g_strdup(connman_network_get_string(
+		network, "WiFi.PrivateKeyPassphrase"));
+	ssid->phase2_auth =
+		g_strdup(connman_network_get_string(network, "WiFi.Phase2"));
 
 	ssid->use_wps = connman_network_get_bool(network, "WiFi.UseWPS");
-	ssid->pin_wps = connman_network_get_string(network, "WiFi.PinWPS");
+	ssid->pin_wps =
+		g_strdup(connman_network_get_string(network, "WiFi.PinWPS"));
 
 	if (connman_setting_get_bool("BackgroundScanning"))
-		ssid->bgscan = BGSCAN_DEFAULT;
+		ssid->bgscan = g_strdup(BGSCAN_DEFAULT);
 }
 
 static int network_connect(struct connman_network *network)
@@ -2246,12 +2256,12 @@ static int network_connect(struct connman_network *network)
 
 	interface = wifi->interface;
 
-	ssid_init(ssid, network);
-
 	if (wifi->disconnecting) {
 		wifi->pending_network = network;
 		g_free(ssid);
 	} else {
+		ssid_init(ssid, network);
+
 		wifi->network = connman_network_ref(network);
 		wifi->retries = 0;
 
@@ -2518,6 +2528,25 @@ static bool handle_4way_handshake_failure(GSupplicantInterface *interface,
 	return false;
 }
 
+static bool handle_sae_authentication_failure(struct connman_network *network,
+					      struct wifi_data *wifi)
+{
+	struct wifi_network *network_data = connman_network_get_data(network);
+
+	if (!(network_data->keymgmt & G_SUPPLICANT_KEYMGMT_SAE))
+		return false;
+
+	if (wifi->state != G_SUPPLICANT_STATE_AUTHENTICATING)
+		return false;
+
+	if (wifi->connected)
+		return false;
+
+	connman_network_set_error(network, CONNMAN_NETWORK_ERROR_INVALID_KEY);
+
+	return true;
+}
+
 static void interface_state(GSupplicantInterface *interface)
 {
 	struct connman_network *network;
@@ -2615,6 +2644,13 @@ static void interface_state(GSupplicantInterface *interface)
 						network, wifi))
 			break;
 
+		/*
+		 * On WPA3-SAE authentication, wpa_supplicant goes directly from
+		 * authenticating to disconnected state if the key was invalid.
+		 */
+		if (handle_sae_authentication_failure(network, wifi))
+			break;
+
 		/* See table 8-36 Reason codes in IEEE Std 802.11 */
 		switch (wifi->disconnect_code) {
 		case 6: /* Class 2 frame received from nonauthenticated STA */
diff --git a/src/agent-connman.c b/src/agent-connman.c
index fca7cc1f..2bd33e04 100644
--- a/src/agent-connman.c
+++ b/src/agent-connman.c
@@ -865,3 +865,17 @@ int __connman_agent_request_peer_authorization(struct connman_peer *peer,
 
 	return -EINPROGRESS;
 }
+
+bool __connman_agent_is_request_pending(struct connman_service *service,
+						const char *dbus_sender)
+{
+	void *agent;
+
+	/* Default agent will be returned if no dbus_sender */
+	agent = connman_agent_get_info(dbus_sender, NULL, NULL);
+
+	if (!service || !agent)
+		return false;
+
+	return connman_agent_queue_search(service, agent);
+}
diff --git a/src/agent.c b/src/agent.c
index d4f9add4..23517d9b 100644
--- a/src/agent.c
+++ b/src/agent.c
@@ -257,6 +257,28 @@ int connman_agent_queue_message(void *user_context,
 	return err;
 }
 
+bool connman_agent_queue_search(void *user_context, void *agent_data)
+{
+	struct connman_agent *agent = agent_data;
+	struct connman_agent_request *queue_data;
+	GList *iter;
+
+	if (!agent || !user_context)
+		return false;
+
+	if (agent->pending && agent->pending->user_context == user_context)
+		return true;
+
+	for (iter = agent->queue; iter; iter = iter->next) {
+		queue_data = iter->data;
+
+		if (queue_data && queue_data->user_context == user_context)
+			return true;
+	}
+
+	return false;
+}
+
 static void set_default_agent(void)
 {
 	struct connman_agent *agent = NULL;
diff --git a/src/clock.c b/src/clock.c
index 906538ac..54ac274a 100644
--- a/src/clock.c
+++ b/src/clock.c
@@ -270,6 +270,7 @@ static DBusMessage *set_property(DBusConnection *conn,
 	} else if (g_str_equal(name, "TimeUpdates")) {
 		const char *strval;
 		enum time_updates newval;
+		struct connman_service *service;
 
 		if (type != DBUS_TYPE_STRING)
 			return __connman_error_invalid_arguments(msg);
@@ -290,12 +291,8 @@ static DBusMessage *set_property(DBusConnection *conn,
 				CONNMAN_CLOCK_INTERFACE, "TimeUpdates",
 				DBUS_TYPE_STRING, &strval);
 
-		if (newval == TIME_UPDATES_AUTO) {
-			struct connman_service *service;
-
-			service = connman_service_get_default();
-			__connman_timeserver_conf_update(service);
-		}
+		service = connman_service_get_default();
+		__connman_timeserver_conf_update(service);
 	} else if (g_str_equal(name, "Timezone")) {
 		const char *strval;
 
diff --git a/src/connman.h b/src/connman.h
index 68176086..b955d98b 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -126,6 +126,8 @@ int __connman_agent_request_peer_authorization(struct connman_peer *peer,
 						bool wps_requested,
 						const char *dbus_sender,
 						void *user_data);
+bool __connman_agent_is_request_pending(struct connman_service *service,
+						const char *dbus_sender);
 
 #include <connman/log.h>
 
@@ -449,7 +451,8 @@ char **__connman_timeserver_system_get();
 GSList *__connman_timeserver_add_list(GSList *server_list,
 		const char *timeserver);
 GSList *__connman_timeserver_get_all(struct connman_service *service);
-void __connman_timeserver_sync(struct connman_service *service);
+void __connman_timeserver_sync(struct connman_service *service,
+				enum connman_timeserver_sync_reason reason);
 void __connman_timeserver_conf_update(struct connman_service *service);
 
 bool __connman_timeserver_is_synced(void);
@@ -605,6 +608,7 @@ void __connman_network_set_device(struct connman_network *network,
 
 int __connman_network_connect(struct connman_network *network);
 int __connman_network_disconnect(struct connman_network *network);
+int __connman_network_forget(struct connman_network *network);
 int __connman_network_clear_ipconfig(struct connman_network *network,
 					struct connman_ipconfig *ipconfig);
 int __connman_network_enable_ipconfig(struct connman_network *network,
@@ -983,6 +987,7 @@ void __connman_dnsproxy_remove_listener(int index);
 int __connman_dnsproxy_append(int index, const char *domain, const char *server);
 int __connman_dnsproxy_remove(int index, const char *domain, const char *server);
 int __connman_dnsproxy_set_mdns(int index, bool enabled);
+void __connman_dnsproxy_set_listen_port(unsigned int port);
 
 int __connman_6to4_probe(struct connman_service *service);
 void __connman_6to4_remove(struct connman_ipconfig *ipconfig);
diff --git a/src/dhcp.c b/src/dhcp.c
index 2d96c439..18dbab27 100644
--- a/src/dhcp.c
+++ b/src/dhcp.c
@@ -422,8 +422,7 @@ static bool apply_lease_available_on_network(GDHCPClient *dhcp_client,
 		g_free(dhcp->pac);
 		dhcp->pac = pac;
 
-		__connman_ipconfig_set_proxy_autoconfig(dhcp->ipconfig,
-								dhcp->pac);
+		__connman_service_set_proxy_autoconfig(service, dhcp->pac);
 	}
 
 	if (connman_setting_get_bool("Enable6to4"))
diff --git a/src/dnsproxy.c b/src/dnsproxy.c
index cf1d36c7..22730047 100644
--- a/src/dnsproxy.c
+++ b/src/dnsproxy.c
@@ -223,6 +223,7 @@ static GHashTable *listener_table = NULL;
 static time_t next_refresh;
 static GHashTable *partial_tcp_req_table;
 static guint cache_timer = 0;
+static in_port_t dns_listen_port = 53;
 
 static guint16 get_id(void)
 {
@@ -233,7 +234,7 @@ static guint16 get_id(void)
 	return rand;
 }
 
-static int protocol_offset(int protocol)
+static size_t protocol_offset(int protocol)
 {
 	switch (protocol) {
 	case IPPROTO_UDP:
@@ -243,9 +244,9 @@ static int protocol_offset(int protocol)
 		return 2;
 
 	default:
-		return -EINVAL;
+		/* this should never happen */
+		abort();
 	}
-
 }
 
 /*
@@ -480,13 +481,11 @@ static void send_response(int sk, unsigned char *buf, size_t len,
 				int protocol)
 {
 	struct domain_hdr *hdr;
-	int err, offset = protocol_offset(protocol);
+	int err;
+	size_t offset = protocol_offset(protocol);
 
 	debug("sk %d", sk);
 
-	if (offset < 0)
-		return;
-
 	if (len < sizeof(*hdr) + offset)
 		return;
 
@@ -802,16 +801,12 @@ static struct cache_entry *cache_check(gpointer request, int *qtype, int proto)
 	struct cache_entry *entry;
 	struct domain_question *q;
 	uint16_t type;
-	int offset, proto_offset;
+	int offset;
 
 	if (!request)
 		return NULL;
 
-	proto_offset = protocol_offset(proto);
-	if (proto_offset < 0)
-		return NULL;
-
-	question = request + proto_offset + 12;
+	question = request + protocol_offset(proto) + 12;
 
 	offset = strlen(question) + 1;
 	q = (void *) (question + offset);
@@ -1383,7 +1378,7 @@ static int reply_query_type(unsigned char *msg, int len)
 static int cache_update(struct server_data *srv, unsigned char *msg,
 			unsigned int msg_len)
 {
-	int offset = protocol_offset(srv->protocol);
+	size_t offset = protocol_offset(srv->protocol);
 	int err, qlen, ttl = 0;
 	uint16_t answers = 0, type = 0, class = 0;
 	struct domain_hdr *hdr = (void *)(msg + offset);
@@ -1411,10 +1406,7 @@ static int cache_update(struct server_data *srv, unsigned char *msg,
 		next_refresh = current_time + 30;
 	}
 
-	if (offset < 0)
-		return 0;
-
-	debug("offset %d hdr %p msg %p rcode %d", offset, hdr, msg, hdr->rcode);
+	debug("offset %zd hdr %p msg %p rcode %d", offset, hdr, msg, hdr->rcode);
 
 	/* Continue only if response code is 0 (=ok) */
 	if (hdr->rcode != ns_r_noerror)
@@ -1678,17 +1670,14 @@ static int ns_resolv(struct server_data *server, struct request_data *req,
 		char *domain;
 		unsigned char alt[1024];
 		struct domain_hdr *hdr = (void *) &alt;
-		int altlen, domlen, offset;
+		int altlen, domlen;
+		size_t offset = protocol_offset(server->protocol);
 
 		domain = list->data;
 
 		if (!domain)
 			continue;
 
-		offset = protocol_offset(server->protocol);
-		if (offset < 0)
-			return offset;
-
 		domlen = strlen(domain) + 1;
 		if (domlen < 5)
 			return -EINVAL;
@@ -1947,13 +1936,12 @@ static int forward_dns_reply(unsigned char *reply, int reply_len, int protocol,
 {
 	struct domain_hdr *hdr;
 	struct request_data *req;
-	int dns_id, sk, err, offset = protocol_offset(protocol);
+	int dns_id, sk, err;
+	size_t offset = protocol_offset(protocol);
 
-	if (offset < 0)
-		return offset;
 	if (reply_len < 0)
 		return -EINVAL;
-	if (reply_len < offset + 1)
+	if ((size_t)reply_len < offset + 1)
 		return -EINVAL;
 	if ((size_t)reply_len < sizeof(struct domain_hdr))
 		return -EINVAL;
@@ -2843,8 +2831,7 @@ int __connman_dnsproxy_append(int index, const char *domain,
 	return 0;
 }
 
-static void remove_server(int index, const char *domain,
-			const char *server, int protocol)
+static void remove_server(int index, const char *server, int protocol)
 {
 	struct server_data *data;
 	GSList *list;
@@ -2856,7 +2843,7 @@ static void remove_server(int index, const char *domain,
 	destroy_server(data);
 
 	for (list = server_list; list; list = list->next) {
-		struct server_data *data = list->data;
+		data = list->data;
 
 		if (data->index != -1 && data->enabled == true)
 			return;
@@ -2885,8 +2872,8 @@ int __connman_dnsproxy_remove(int index, const char *domain,
 	if (g_str_equal(server, "::1"))
 		return -ENODEV;
 
-	remove_server(index, domain, server, IPPROTO_UDP);
-	remove_server(index, domain, server, IPPROTO_TCP);
+	remove_server(index, server, IPPROTO_UDP);
+	remove_server(index, server, IPPROTO_TCP);
 
 	return 0;
 }
@@ -3718,7 +3705,7 @@ static GIOChannel *get_listener(int family, int protocol, int index)
 	if (family == AF_INET6) {
 		memset(&s.sin6, 0, sizeof(s.sin6));
 		s.sin6.sin6_family = AF_INET6;
-		s.sin6.sin6_port = htons(53);
+		s.sin6.sin6_port = htons(dns_listen_port);
 		slen = sizeof(s.sin6);
 
 		if (__connman_inet_get_interface_address(index,
@@ -3735,7 +3722,7 @@ static GIOChannel *get_listener(int family, int protocol, int index)
 	} else if (family == AF_INET) {
 		memset(&s.sin, 0, sizeof(s.sin));
 		s.sin.sin_family = AF_INET;
-		s.sin.sin_port = htons(53);
+		s.sin.sin_port = htons(dns_listen_port);
 		slen = sizeof(s.sin);
 
 		if (__connman_inet_get_interface_address(index,
@@ -4064,3 +4051,8 @@ void __connman_dnsproxy_cleanup(void)
 	if (ipv6_resolve)
 		g_resolv_unref(ipv6_resolve);
 }
+
+void __connman_dnsproxy_set_listen_port(unsigned int port)
+{
+	dns_listen_port = port;
+}
diff --git a/src/ipconfig.c b/src/ipconfig.c
index 34b1724a..9f17f498 100644
--- a/src/ipconfig.c
+++ b/src/ipconfig.c
@@ -1172,7 +1172,7 @@ int __connman_ipconfig_gateway_add(struct connman_ipconfig *ipconfig)
 
 	DBG("");
 
-	if (!ipconfig->address)
+	if (!ipconfig->address || !ipconfig->address->gateway)
 		return -EINVAL;
 
 	service = __connman_service_lookup_from_index(ipconfig->index);
diff --git a/src/main.c b/src/main.c
index e209cf26..70277f66 100644
--- a/src/main.c
+++ b/src/main.c
@@ -54,6 +54,7 @@
  */
 #define DEFAULT_ONLINE_CHECK_INITIAL_INTERVAL 1
 #define DEFAULT_ONLINE_CHECK_MAX_INTERVAL 12
+#define DEFAULT_LOCALTIME "/etc/localtime"
 
 #define MAINFILE "main.conf"
 #define CONFIGMAINFILE CONFIGDIR "/" MAINFILE
@@ -107,6 +108,9 @@ static struct {
 	bool auto_connect_roaming_services;
 	bool acd;
 	bool use_gateways_as_timeservers;
+	char *localtime;
+	bool regdom_follows_timezone;
+	char *resolv_conf;
 } connman_settings  = {
 	.bg_scan = true,
 	.pref_timeservers = NULL,
@@ -134,6 +138,8 @@ static struct {
 	.auto_connect_roaming_services = false,
 	.acd = false,
 	.use_gateways_as_timeservers = false,
+	.localtime = NULL,
+	.resolv_conf = NULL,
 };
 
 #define CONF_BG_SCAN                    "BackgroundScanning"
@@ -162,6 +168,9 @@ static struct {
 #define CONF_AUTO_CONNECT_ROAMING_SERVICES "AutoConnectRoamingServices"
 #define CONF_ACD                        "AddressConflictDetection"
 #define CONF_USE_GATEWAYS_AS_TIMESERVERS "UseGatewaysAsTimeservers"
+#define CONF_LOCALTIME                  "Localtime"
+#define CONF_REGDOM_FOLLOWS_TIMEZONE    "RegdomFollowsTimezone"
+#define CONF_RESOLV_CONF                "ResolvConf"
 
 static const char *supported_options[] = {
 	CONF_BG_SCAN,
@@ -190,6 +199,9 @@ static const char *supported_options[] = {
 	CONF_AUTO_CONNECT_ROAMING_SERVICES,
 	CONF_ACD,
 	CONF_USE_GATEWAYS_AS_TIMESERVERS,
+	CONF_LOCALTIME,
+	CONF_REGDOM_FOLLOWS_TIMEZONE,
+	CONF_RESOLV_CONF,
 	NULL
 };
 
@@ -318,11 +330,17 @@ static void parse_config(GKeyFile *config)
 
 	if (!config) {
 		connman_settings.auto_connect =
-			parse_service_types(default_auto_connect, CONF_ARRAY_SIZE(default_auto_connect));
+			parse_service_types(default_auto_connect,
+					CONF_ARRAY_SIZE(default_auto_connect));
 		connman_settings.favorite_techs =
-			parse_service_types(default_favorite_techs, CONF_ARRAY_SIZE(default_favorite_techs));
+			parse_service_types(default_favorite_techs,
+					CONF_ARRAY_SIZE(default_favorite_techs));
 		connman_settings.blacklisted_interfaces =
 			g_strdupv(default_blacklist);
+		connman_settings.online_check_ipv4_url =
+			g_strdup(DEFAULT_ONLINE_CHECK_IPV4_URL);
+		connman_settings.online_check_ipv6_url =
+			g_strdup(DEFAULT_ONLINE_CHECK_IPV6_URL);
 		return;
 	}
 
@@ -565,6 +583,29 @@ static void parse_config(GKeyFile *config)
 		connman_settings.use_gateways_as_timeservers = boolean;
 
 	g_clear_error(&error);
+
+	string = __connman_config_get_string(config, "General",
+				CONF_LOCALTIME, &error);
+	if (!error)
+		connman_settings.localtime = string;
+	else
+		g_free(string);
+
+	g_clear_error(&error);
+
+	boolean = __connman_config_get_bool(config, "General",
+				CONF_REGDOM_FOLLOWS_TIMEZONE, &error);
+	if (!error)
+		connman_settings.regdom_follows_timezone = boolean;
+
+	string = __connman_config_get_string(config, "General",
+				CONF_RESOLV_CONF, &error);
+	if (!error)
+		connman_settings.resolv_conf = string;
+	else
+		g_free(string);
+
+	g_clear_error(&error);
 }
 
 static int config_init(const char *file)
@@ -755,6 +796,10 @@ char *connman_setting_get_string(const char *key)
 			return option_wifi;
 	}
 
+	if (g_str_equal(key, CONF_LOCALTIME))
+		return connman_settings.localtime ?
+			connman_settings.localtime : DEFAULT_LOCALTIME;
+
 	return NULL;
 }
 
@@ -793,6 +838,12 @@ bool connman_setting_get_bool(const char *key)
 	if (g_str_equal(key, CONF_USE_GATEWAYS_AS_TIMESERVERS))
 		return connman_settings.use_gateways_as_timeservers;
 
+	if (g_str_equal(key, CONF_REGDOM_FOLLOWS_TIMEZONE))
+		return connman_settings.regdom_follows_timezone;
+
+	if (g_str_equal(key, CONF_RESOLV_CONF))
+		return connman_settings.resolv_conf;
+
 	return false;
 }
 
@@ -1031,6 +1082,7 @@ int main(int argc, char *argv[])
 	g_free(connman_settings.vendor_class_id);
 	g_free(connman_settings.online_check_ipv4_url);
 	g_free(connman_settings.online_check_ipv6_url);
+	g_free(connman_settings.localtime);
 
 	g_free(option_debug);
 	g_free(option_wifi);
diff --git a/src/network.c b/src/network.c
index 1cbdf9cf..2090e7fe 100644
--- a/src/network.c
+++ b/src/network.c
@@ -1848,6 +1848,19 @@ int __connman_network_disconnect(struct connman_network *network)
 	return err;
 }
 
+int __connman_network_forget(struct connman_network *network)
+{
+	DBG("network %p", network);
+
+	if (!network->driver)
+		return -EUNATCH;
+
+	if (network->driver->forget)
+		return network->driver->forget(network);
+
+	return 0;
+}
+
 int __connman_network_clear_ipconfig(struct connman_network *network,
 					struct connman_ipconfig *ipconfig)
 {
diff --git a/src/resolver.c b/src/resolver.c
index 618353fd..4ab51d6b 100644
--- a/src/resolver.c
+++ b/src/resolver.c
@@ -103,6 +103,7 @@ static int resolvfile_export(void)
 	int fd, err;
 	unsigned int count;
 	mode_t old_umask;
+	const char *resolv_conf;
 
 	content = g_string_new("# Generated by Connection Manager\n");
 
@@ -161,15 +162,33 @@ static int resolvfile_export(void)
 
 	old_umask = umask(022);
 
-	fd = open(RESOLV_CONF_STATEDIR, O_RDWR | O_CREAT | O_CLOEXEC,
-					S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
-	if (fd < 0) {
-		connman_warn_once("Cannot create "RESOLV_CONF_STATEDIR" "
-			"falling back to "RESOLV_CONF_ETC);
+	resolv_conf = connman_setting_get_string("ResolvConf");
+	/*
+	 * TODO: This is mainly for backward compatibility. In some future version,
+	 * "ResolvConf" setting should default to RESOLV_CONF_STATEDIR or
+	 * RESOLV_CONF_ETC and this branch can be removed.
+	 */
+	if (resolv_conf == NULL) {
+		fd = open(RESOLV_CONF_STATEDIR, O_RDWR | O_CREAT | O_CLOEXEC,
+						S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+		if (fd < 0) {
+			connman_warn_once("Cannot create "RESOLV_CONF_STATEDIR" "
+				"falling back to "RESOLV_CONF_ETC);
 
-		fd = open(RESOLV_CONF_ETC, O_RDWR | O_CREAT | O_CLOEXEC,
-					S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+			fd = open(RESOLV_CONF_ETC, O_RDWR | O_CREAT | O_CLOEXEC,
+						S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 
+			if (fd < 0) {
+				err = -errno;
+				goto done;
+			}
+		}
+	} else if (resolv_conf[0] == '\0' || strcmp(resolv_conf, "/dev/null") == 0) {
+		err = 0;
+		goto done;
+	} else {
+		fd = open(resolv_conf, O_RDWR | O_CREAT | O_CLOEXEC,
+						S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 		if (fd < 0) {
 			err = -errno;
 			goto done;
diff --git a/src/service.c b/src/service.c
index 1d2b78a6..079c7a6c 100644
--- a/src/service.c
+++ b/src/service.c
@@ -137,7 +137,8 @@ struct connman_service {
 	char *pac;
 	bool wps;
 	bool wps_advertizing;
-	guint online_timeout;
+	guint online_timeout_ipv4;
+	guint online_timeout_ipv6;
 	unsigned int online_check_interval_ipv4;
 	unsigned int online_check_interval_ipv6;
 	bool do_split_routing;
@@ -1438,12 +1439,16 @@ static bool check_proxy_setup(struct connman_service *service)
 
 static void cancel_online_check(struct connman_service *service)
 {
-	if (service->online_timeout == 0)
-		return;
-
-	g_source_remove(service->online_timeout);
-	service->online_timeout = 0;
-	connman_service_unref(service);
+	if (service->online_timeout_ipv4) {
+		g_source_remove(service->online_timeout_ipv4);
+		service->online_timeout_ipv4 = 0;
+		connman_service_unref(service);
+	}
+	if (service->online_timeout_ipv6) {
+		g_source_remove(service->online_timeout_ipv6);
+		service->online_timeout_ipv6 = 0;
+		connman_service_unref(service);
+	}
 }
 
 static void start_online_check(struct connman_service *service,
@@ -1461,7 +1466,7 @@ static void start_online_check(struct connman_service *service,
 	online_check_max_interval =
 		connman_setting_get_uint("OnlineCheckMaxInterval");
 
-	if (type != CONNMAN_IPCONFIG_TYPE_IPV4 || check_proxy_setup(service)) {
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV6 || check_proxy_setup(service)) {
 		cancel_online_check(service);
 		__connman_service_wispr_start(service, type);
 	}
@@ -1476,7 +1481,8 @@ static void address_updated(struct connman_service *service,
 		nameserver_add_all(service, type);
 		start_online_check(service, type);
 
-		__connman_timeserver_sync(service);
+		__connman_timeserver_sync(service,
+				CONNMAN_TIMESERVER_SYNC_REASON_ADDRESS_UPDATE);
 	}
 }
 
@@ -2592,7 +2598,6 @@ static void append_properties(DBusMessageIter *dict, dbus_bool_t limited,
 	case CONNMAN_SERVICE_TYPE_UNKNOWN:
 	case CONNMAN_SERVICE_TYPE_SYSTEM:
 	case CONNMAN_SERVICE_TYPE_GPS:
-	case CONNMAN_SERVICE_TYPE_VPN:
 	case CONNMAN_SERVICE_TYPE_P2P:
 		break;
 	case CONNMAN_SERVICE_TYPE_CELLULAR:
@@ -2603,6 +2608,7 @@ static void append_properties(DBusMessageIter *dict, dbus_bool_t limited,
 		connman_dbus_dict_append_dict(dict, "Ethernet",
 						append_ethernet, service);
 		break;
+	case CONNMAN_SERVICE_TYPE_VPN:
 	case CONNMAN_SERVICE_TYPE_WIFI:
 	case CONNMAN_SERVICE_TYPE_ETHERNET:
 	case CONNMAN_SERVICE_TYPE_BLUETOOTH:
@@ -4562,7 +4568,10 @@ static DBusMessage *connect_service(DBusConnection *conn,
 
 	DBG("service %p", service);
 
-	if (service->pending)
+	/* Hidden services do not keep the pending msg, check it from agent */
+	if (service->pending || (service->hidden &&
+				__connman_agent_is_request_pending(service,
+						dbus_message_get_sender(msg))))
 		return __connman_error_in_progress(msg);
 
 	index = __connman_service_get_index(service);
@@ -4631,6 +4640,8 @@ bool __connman_service_remove(struct connman_service *service)
 		return false;
 
 	__connman_service_disconnect(service);
+	if (service->network)
+		__connman_network_forget(service->network);
 
 	g_free(service->passphrase);
 	service->passphrase = NULL;
@@ -6324,20 +6335,20 @@ static void service_rp_filter(struct connman_service *service,
 static void redo_wispr(struct connman_service *service,
 					enum connman_ipconfig_type type)
 {
-	service->online_timeout = 0;
-	connman_service_unref(service);
-
 	DBG("Retrying %s WISPr for %p %s",
 		__connman_ipconfig_type2string(type),
 		service, service->name);
 
 	__connman_wispr_start(service, type);
+	connman_service_unref(service);
 }
 
 static gboolean redo_wispr_ipv4(gpointer user_data)
 {
 	struct connman_service *service = user_data;
 
+	service->online_timeout_ipv4 = 0;
+
 	redo_wispr(service, CONNMAN_IPCONFIG_TYPE_IPV4);
 
 	return FALSE;
@@ -6347,6 +6358,8 @@ static gboolean redo_wispr_ipv6(gpointer user_data)
 {
 	struct connman_service *service = user_data;
 
+	service->online_timeout_ipv6 = 0;
+
 	redo_wispr(service, CONNMAN_IPCONFIG_TYPE_IPV6);
 
 	return FALSE;
@@ -6359,6 +6372,10 @@ void __connman_service_online_check(struct connman_service *service,
 	GSourceFunc redo_func;
 	unsigned int *interval;
 	enum connman_service_state current_state;
+	int timeout;
+
+	DBG("service %p type %s success %d\n",
+		service, __connman_ipconfig_type2string(type), success);
 
 	if (type == CONNMAN_IPCONFIG_TYPE_IPV4) {
 		interval = &service->online_check_interval_ipv4;
@@ -6387,8 +6404,12 @@ redo_func:
 	DBG("service %p type %s interval %d", service,
 		__connman_ipconfig_type2string(type), *interval);
 
-	service->online_timeout = g_timeout_add_seconds(*interval * *interval,
+	timeout = g_timeout_add_seconds(*interval * *interval,
 				redo_func, connman_service_ref(service));
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
+		service->online_timeout_ipv4 = timeout;
+	else
+		service->online_timeout_ipv6 = timeout;
 
 	/* Increment the interval for the next time, set a maximum timeout of
 	 * online_check_max_interval seconds * online_check_max_interval seconds.
@@ -6501,7 +6522,8 @@ int __connman_service_ipconfig_indicate_state(struct connman_service *service,
 	if (!is_connected(old_state) && is_connected(new_state))
 		nameserver_add_all(service, type);
 
-	__connman_timeserver_sync(service);
+	__connman_timeserver_sync(service,
+				CONNMAN_TIMESERVER_SYNC_REASON_STATE_UPDATE);
 
 	return service_indicate_state(service);
 }
diff --git a/src/timeserver.c b/src/timeserver.c
index feef8e83..4c25d4b8 100644
--- a/src/timeserver.c
+++ b/src/timeserver.c
@@ -47,6 +47,7 @@ static GResolv *resolv = NULL;
 static int resolv_id = 0;
 
 static void sync_next(void);
+static void ts_set_nameservers(struct connman_service *service);
 
 static void resolv_debug(const char *str, void *data)
 {
@@ -183,6 +184,7 @@ static void sync_next(void)
 	}
 
 	__connman_ntp_stop();
+	ts_set_nameservers(ts_service);
 
 	while (ts_list) {
 		ts_current = ts_list->data;
@@ -307,7 +309,8 @@ static gboolean ts_recheck(gpointer user_data)
 		g_slist_free_full(ts, g_free);
 
 		service = connman_service_get_default();
-		__connman_timeserver_sync(service);
+		__connman_timeserver_sync(service,
+				CONNMAN_TIMESERVER_SYNC_REASON_TS_CHANGE);
 
 		return FALSE;
 	}
@@ -347,24 +350,34 @@ static void ts_recheck_enable(void)
 			NULL);
 }
 
-static void ts_reset(struct connman_service *service)
+static int ts_setup_resolv(struct connman_service *service)
 {
-	char **nameservers;
 	int i;
 
+	i = __connman_service_get_index(service);
+	if (i < 0)
+		return -EINVAL;
+
+	if (resolv) {
+		g_resolv_unref(resolv);
+		resolv = NULL;
+	}
+
+	resolv = g_resolv_new(i);
 	if (!resolv)
-		return;
+		return -ENOMEM;
 
-	__connman_timeserver_set_synced(false);
+	if (getenv("CONNMAN_RESOLV_DEBUG"))
+		g_resolv_set_debug(resolv, resolv_debug, "RESOLV");
 
-	/*
-	 * Before we start creating the new timeserver list we must stop
-	 * any ongoing ntp query and server resolution.
-	 */
+	return 0;
+}
 
-	__connman_ntp_stop();
 
-	ts_recheck_disable();
+static void ts_set_nameservers(struct connman_service *service)
+{
+	char **nameservers;
+	int i;
 
 	if (resolv_id > 0)
 		g_resolv_cancel_lookup(resolv, resolv_id);
@@ -378,6 +391,25 @@ static void ts_reset(struct connman_service *service)
 
 		g_strfreev(nameservers);
 	}
+}
+
+static void ts_reset(struct connman_service *service)
+{
+	if (!resolv)
+		return;
+
+	__connman_timeserver_set_synced(false);
+
+	/*
+	 * Before we start creating the new timeserver list we must stop
+	 * any ongoing ntp query and server resolution.
+	 */
+
+	__connman_ntp_stop();
+
+	ts_recheck_disable();
+
+	ts_set_nameservers(service);
 
 	g_slist_free_full(timeservers_list, g_free);
 
@@ -396,10 +428,26 @@ static void ts_reset(struct connman_service *service)
 	timeserver_sync_start();
 }
 
-void __connman_timeserver_sync(struct connman_service *service)
+void __connman_timeserver_sync(struct connman_service *service,
+			enum connman_timeserver_sync_reason reason)
 {
-	if (!service || ts_service == service)
+	if (!service)
+		return;
+
+	switch (reason) {
+	case CONNMAN_TIMESERVER_SYNC_REASON_START:
+	case CONNMAN_TIMESERVER_SYNC_REASON_STATE_UPDATE:
+		if (ts_service == service)
+			return;
+		break;
+	case CONNMAN_TIMESERVER_SYNC_REASON_ADDRESS_UPDATE:
+	case CONNMAN_TIMESERVER_SYNC_REASON_TS_CHANGE:
+		if (ts_service != service)
+			return;
+		break;
+	default:
 		return;
+	}
 
 	ts_reset(service);
 }
@@ -434,44 +482,19 @@ void __connman_timeserver_set_synced(bool status)
 
 static int timeserver_start(struct connman_service *service)
 {
-	char **nameservers;
-	int i;
+	int rv;
 
 	DBG("service %p", service);
 
-	i = __connman_service_get_index(service);
-	if (i < 0)
-		return -EINVAL;
-
-	nameservers = connman_service_get_nameservers(service);
-
-	/* Stop an already ongoing resolution, if there is one */
-	if (resolv && resolv_id > 0)
-		g_resolv_cancel_lookup(resolv, resolv_id);
-
 	/* get rid of the old resolver */
-	if (resolv) {
-		g_resolv_unref(resolv);
-		resolv = NULL;
-	}
-
-	resolv = g_resolv_new(i);
-	if (!resolv) {
-		g_strfreev(nameservers);
-		return -ENOMEM;
-	}
+	rv = ts_setup_resolv(service);
+	if (rv)
+		return rv;
 
-	if (getenv("CONNMAN_RESOLV_DEBUG"))
-		g_resolv_set_debug(resolv, resolv_debug, "RESOLV");
-
-	if (nameservers) {
-		for (i = 0; nameservers[i]; i++)
-			g_resolv_add_nameserver(resolv, nameservers[i], 53, 0);
-
-		g_strfreev(nameservers);
-	}
+	ts_set_nameservers(service);
 
-	__connman_timeserver_sync(service);
+	__connman_timeserver_sync(service,
+			CONNMAN_TIMESERVER_SYNC_REASON_START);
 
 	return 0;
 }
diff --git a/src/timezone.c b/src/timezone.c
index cc499097..f8d192df 100644
--- a/src/timezone.c
+++ b/src/timezone.c
@@ -38,9 +38,9 @@
 
 #include "connman.h"
 
-#define ETC_LOCALTIME		"/etc/localtime"
 #define ETC_SYSCONFIG_CLOCK	"/etc/sysconfig/clock"
 #define USR_SHARE_ZONEINFO	"/usr/share/zoneinfo"
+#define USR_SHARE_ZONEINFO_MAP	USR_SHARE_ZONEINFO "/zone1970.tab"
 
 static char *read_key_file(const char *pathname, const char *key)
 {
@@ -228,18 +228,104 @@ static char *find_origin(void *src_map, struct stat *src_st,
 	return NULL;
 }
 
+static char *get_timezone_alpha2(const char *zone)
+{
+	GIOChannel *channel;
+	struct stat st;
+	char **tokens;
+	char *line;
+	char *alpha2 = NULL;
+	gsize len;
+	int fd;
+
+	if (!zone)
+		return NULL;
+
+	fd = open(USR_SHARE_ZONEINFO_MAP, O_RDONLY | O_CLOEXEC);
+	if (fd < 0) {
+		connman_warn("failed to open zoneinfo map %s",
+							USR_SHARE_ZONEINFO_MAP);
+		return NULL;
+	}
+
+	if (fstat(fd, &st) < 0 || !S_ISREG(st.st_mode)) {
+		connman_warn("zoneinfo map does not exist/not regular file");
+		close(fd);
+		return NULL;
+	}
+
+	channel = g_io_channel_unix_new(fd);
+	if (!channel) {
+		connman_warn("failed to create io channel for %s",
+							USR_SHARE_ZONEINFO_MAP);
+		close(fd);
+		return NULL;
+	}
+
+	DBG("read %s for %s", USR_SHARE_ZONEINFO_MAP, zone);
+	g_io_channel_set_encoding(channel, "UTF-8", NULL);
+
+	while (g_io_channel_read_line(channel, &line, &len, NULL, NULL) ==
+							G_IO_STATUS_NORMAL) {
+		if (!line || !*line || *line == '#' || *line == '\n') {
+			g_free(line);
+			continue;
+		}
+
+		/* File format: Countrycodes Coordinates TZ Comments */
+		tokens = g_strsplit_set(line, " \t", 4);
+		if (!tokens) {
+			connman_warn("line %s failed to parse", line);
+			g_free(line);
+			continue;
+		}
+
+		if (g_strv_length(tokens) >= 3 && !g_strcmp0(
+						g_strstrip(tokens[2]), zone)) {
+			/*
+			 * Multiple country codes can be listed, use the first
+			 * 2 chars.
+			 */
+			alpha2 = g_strndup(g_strstrip(tokens[0]), 2);
+		}
+
+		g_strfreev(tokens);
+		g_free(line);
+
+		if (alpha2) {
+			if (strlen(alpha2) != 2) {
+				connman_warn("Invalid ISO3166 code %s", alpha2);
+				g_free(alpha2);
+				alpha2 = NULL;
+			} else {
+				DBG("Zone %s ISO3166 country code %s", zone,
+									alpha2);
+			}
+
+			break;
+		}
+	}
+
+	g_io_channel_unref(channel);
+	close(fd);
+
+	return alpha2;
+}
+
 char *__connman_timezone_lookup(void)
 {
 	struct stat st;
 	void *map;
 	int fd;
 	char *zone;
+	char *alpha2;
 
 	zone = read_key_file(ETC_SYSCONFIG_CLOCK, "ZONE");
 
 	DBG("sysconfig zone %s", zone);
 
-	fd = open(ETC_LOCALTIME, O_RDONLY | O_CLOEXEC);
+	fd = open(connman_setting_get_string("Localtime"),
+							O_RDONLY | O_CLOEXEC);
 	if (fd < 0) {
 		g_free(zone);
 		return NULL;
@@ -283,6 +369,15 @@ done:
 
 	DBG("localtime zone %s", zone);
 
+	if (connman_setting_get_bool("RegdomFollowsTimezone")) {
+		alpha2 = get_timezone_alpha2(zone);
+		if (alpha2) {
+			DBG("change regdom to %s", alpha2);
+			connman_technology_set_regdom(alpha2);
+			g_free(alpha2);
+		}
+	}
+
 	return zone;
 }
 
@@ -338,7 +433,7 @@ int __connman_timezone_change(const char *zone)
 		return -EIO;
 	}
 
-	err = write_file(map, &st, ETC_LOCALTIME);
+	err = write_file(map, &st, connman_setting_get_string("Localtime"));
 
 	munmap(map, st.st_size);
 
@@ -432,9 +527,9 @@ int __connman_timezone_init(void)
 
 	g_io_channel_unref(channel);
 
-	dirname = g_path_get_dirname(ETC_LOCALTIME);
+	dirname = g_path_get_dirname(connman_setting_get_string("Localtime"));
 
-	wd = inotify_add_watch(fd, dirname, IN_DONT_FOLLOW |
+	wd = inotify_add_watch(fd, dirname, IN_CREATE | IN_DONT_FOLLOW |
 						IN_CLOSE_WRITE | IN_MOVED_TO);
 
 	g_free(dirname);
diff --git a/src/wispr.c b/src/wispr.c
index 56007a37..a4372018 100644
--- a/src/wispr.c
+++ b/src/wispr.c
@@ -56,6 +56,7 @@ struct wispr_route {
 };
 
 struct connman_wispr_portal_context {
+	int refcount;
 	struct connman_service *service;
 	enum connman_ipconfig_type type;
 	struct connman_wispr_portal *wispr_portal;
@@ -91,16 +92,19 @@ struct connman_wispr_portal {
 
 static bool wispr_portal_web_result(GWebResult *result, gpointer user_data);
 
-static GHashTable *wispr_portal_list = NULL;
+static GHashTable *wispr_portal_hash = NULL;
 
 static char *online_check_ipv4_url = NULL;
 static char *online_check_ipv6_url = NULL;
 static bool enable_online_to_ready_transition = false;
 
+#define wispr_portal_context_ref(wp_context) \
+	wispr_portal_context_ref_debug(wp_context, __FILE__, __LINE__, __func__)
+#define wispr_portal_context_unref(wp_context) \
+	wispr_portal_context_unref_debug(wp_context, __FILE__, __LINE__, __func__)
+
 static void connman_wispr_message_init(struct connman_wispr_message *msg)
 {
-	DBG("");
-
 	msg->has_error = false;
 	msg->current_element = NULL;
 
@@ -160,11 +164,6 @@ static void free_wispr_routes(struct connman_wispr_portal_context *wp_context)
 static void free_connman_wispr_portal_context(
 		struct connman_wispr_portal_context *wp_context)
 {
-	DBG("context %p", wp_context);
-
-	if (!wp_context)
-		return;
-
 	if (wp_context->wispr_portal) {
 		if (wp_context->wispr_portal->ipv4_context == wp_context)
 			wp_context->wispr_portal->ipv4_context = NULL;
@@ -201,9 +200,38 @@ static void free_connman_wispr_portal_context(
 	g_free(wp_context);
 }
 
+static struct connman_wispr_portal_context *
+wispr_portal_context_ref_debug(struct connman_wispr_portal_context *wp_context,
+			const char *file, int line, const char *caller)
+{
+	DBG("%p ref %d by %s:%d:%s()", wp_context,
+		wp_context->refcount + 1, file, line, caller);
+
+	__sync_fetch_and_add(&wp_context->refcount, 1);
+
+	return wp_context;
+}
+
+static void wispr_portal_context_unref_debug(
+		struct connman_wispr_portal_context *wp_context,
+		const char *file, int line, const char *caller)
+{
+	if (!wp_context)
+		return;
+
+	DBG("%p ref %d by %s:%d:%s()", wp_context,
+		wp_context->refcount - 1, file, line, caller);
+
+	if (__sync_fetch_and_sub(&wp_context->refcount, 1) != 1)
+		return;
+
+	free_connman_wispr_portal_context(wp_context);
+}
+
 static struct connman_wispr_portal_context *create_wispr_portal_context(void)
 {
-	return g_try_new0(struct connman_wispr_portal_context, 1);
+	return wispr_portal_context_ref(
+		g_new0(struct connman_wispr_portal_context, 1));
 }
 
 static void free_connman_wispr_portal(gpointer data)
@@ -215,8 +243,8 @@ static void free_connman_wispr_portal(gpointer data)
 	if (!wispr_portal)
 		return;
 
-	free_connman_wispr_portal_context(wispr_portal->ipv4_context);
-	free_connman_wispr_portal_context(wispr_portal->ipv6_context);
+	wispr_portal_context_unref(wispr_portal->ipv4_context);
+	wispr_portal_context_unref(wispr_portal->ipv6_context);
 
 	g_free(wispr_portal);
 }
@@ -451,9 +479,6 @@ static void portal_manage_status(GWebResult *result,
 				&str))
 		connman_info("Client-Timezone: %s", str);
 
-	if (!enable_online_to_ready_transition)
-		free_connman_wispr_portal_context(wp_context);
-
 	__connman_service_ipconfig_indicate_state(service,
 					CONNMAN_SERVICE_STATE_ONLINE, type);
 
@@ -512,16 +537,20 @@ static bool wispr_route_request(const char *address, int ai_family,
 static void wispr_portal_request_portal(
 		struct connman_wispr_portal_context *wp_context)
 {
-	DBG("");
+	DBG("wp_context %p %s", wp_context,
+		__connman_ipconfig_type2string(wp_context->type));
 
+	wispr_portal_context_ref(wp_context);
 	wp_context->request_id = g_web_request_get(wp_context->web,
 					wp_context->status_url,
 					wispr_portal_web_result,
 					wispr_route_request,
 					wp_context);
 
-	if (wp_context->request_id == 0)
+	if (wp_context->request_id == 0) {
 		wispr_portal_error(wp_context);
+		wispr_portal_context_unref(wp_context);
+	}
 }
 
 static bool wispr_input(const guint8 **data, gsize *length,
@@ -576,7 +605,7 @@ static void wispr_portal_browser_reply_cb(struct connman_service *service,
 	if (index < 0)
 		return;
 
-	wispr_portal = g_hash_table_lookup(wispr_portal_list,
+	wispr_portal = g_hash_table_lookup(wispr_portal_hash,
 					GINT_TO_POINTER(index));
 	if (!wispr_portal)
 		return;
@@ -586,13 +615,15 @@ static void wispr_portal_browser_reply_cb(struct connman_service *service,
 		return;
 
 	if (!authentication_done) {
-		wispr_portal_error(wp_context);
 		free_wispr_routes(wp_context);
+		wispr_portal_error(wp_context);
+		wispr_portal_context_unref(wp_context);
 		return;
 	}
 
 	/* Restarting the test */
 	__connman_service_wispr_start(service, wp_context->type);
+	wispr_portal_context_unref(wp_context);
 }
 
 static void wispr_portal_request_wispr_login(struct connman_service *service,
@@ -616,7 +647,7 @@ static void wispr_portal_request_wispr_login(struct connman_service *service,
 				return;
 		}
 
-		free_connman_wispr_portal_context(wp_context);
+		wispr_portal_context_unref(wp_context);
 		return;
 	}
 
@@ -668,11 +699,13 @@ static bool wispr_manage_message(GWebResult *result,
 
 		wp_context->wispr_result = CONNMAN_WISPR_RESULT_LOGIN;
 
+		wispr_portal_context_ref(wp_context);
 		if (__connman_agent_request_login_input(wp_context->service,
 					wispr_portal_request_wispr_login,
-					wp_context) != -EINPROGRESS)
+					wp_context) != -EINPROGRESS) {
 			wispr_portal_error(wp_context);
-		else
+			wispr_portal_context_unref(wp_context);
+		} else
 			return true;
 
 		break;
@@ -721,6 +754,7 @@ static bool wispr_portal_web_result(GWebResult *result, gpointer user_data)
 		if (length > 0) {
 			g_web_parser_feed_data(wp_context->wispr_parser,
 								chunk, length);
+			/* read more data */
 			return true;
 		}
 
@@ -738,6 +772,7 @@ static bool wispr_portal_web_result(GWebResult *result, gpointer user_data)
 
 	switch (status) {
 	case 000:
+		wispr_portal_context_ref(wp_context);
 		__connman_agent_request_browser(wp_context->service,
 				wispr_portal_browser_reply_cb,
 				wp_context->status_url, wp_context);
@@ -749,11 +784,12 @@ static bool wispr_portal_web_result(GWebResult *result, gpointer user_data)
 		if (g_web_result_get_header(result, "X-ConnMan-Status",
 						&str)) {
 			portal_manage_status(result, wp_context);
-			return false;
-		} else
+		} else {
+			wispr_portal_context_ref(wp_context);
 			__connman_agent_request_browser(wp_context->service,
 					wispr_portal_browser_reply_cb,
 					wp_context->redirect_url, wp_context);
+		}
 
 		break;
 	case 300:
@@ -766,6 +802,7 @@ static bool wispr_portal_web_result(GWebResult *result, gpointer user_data)
 			!g_web_result_get_header(result, "Location",
 							&redirect)) {
 
+			wispr_portal_context_ref(wp_context);
 			__connman_agent_request_browser(wp_context->service,
 					wispr_portal_browser_reply_cb,
 					wp_context->status_url, wp_context);
@@ -776,6 +813,7 @@ static bool wispr_portal_web_result(GWebResult *result, gpointer user_data)
 
 		wp_context->redirect_url = g_strdup(redirect);
 
+		wispr_portal_context_ref(wp_context);
 		wp_context->request_id = g_web_request_get(wp_context->web,
 				redirect, wispr_portal_web_result,
 				wispr_route_request, wp_context);
@@ -788,6 +826,7 @@ static bool wispr_portal_web_result(GWebResult *result, gpointer user_data)
 
 		break;
 	case 505:
+		wispr_portal_context_ref(wp_context);
 		__connman_agent_request_browser(wp_context->service,
 				wispr_portal_browser_reply_cb,
 				wp_context->status_url, wp_context);
@@ -800,26 +839,51 @@ static bool wispr_portal_web_result(GWebResult *result, gpointer user_data)
 	wp_context->request_id = 0;
 done:
 	wp_context->wispr_msg.message_type = -1;
+	wispr_portal_context_unref(wp_context);
 	return false;
 }
 
+static char *parse_proxy(const char *proxy)
+{
+	char *proxy_server;
+
+	if (!g_strcmp0(proxy, "DIRECT"))
+		return NULL;
+
+	if (!g_str_has_prefix(proxy, "PROXY "))
+		return NULL;
+
+	proxy_server = g_strdup(proxy + 6);
+
+	/* Use first proxy server */
+	for (char *c = proxy_server; *c != '\0'; ++c) {
+		if (*c == ';') {
+			*c = '\0';
+			break;
+		}
+	}
+
+	g_strstrip(proxy_server);
+
+	return proxy_server;
+}
+
 static void proxy_callback(const char *proxy, void *user_data)
 {
 	struct connman_wispr_portal_context *wp_context = user_data;
+	char *proxy_server;
 
 	DBG("proxy %s", proxy);
 
-	if (!wp_context)
+	if (!wp_context || !proxy)
 		return;
 
 	wp_context->token = 0;
 
-	if (proxy && g_strcmp0(proxy, "DIRECT") != 0) {
-		if (g_str_has_prefix(proxy, "PROXY")) {
-			proxy += 5;
-			for (; *proxy == ' ' && *proxy != '\0'; proxy++);
-		}
-		g_web_set_proxy(wp_context->web, proxy);
+	proxy_server = parse_proxy(proxy);
+	if (proxy_server) {
+		g_web_set_proxy(wp_context->web, proxy_server);
+		g_free(proxy_server);
 	}
 
 	g_web_set_accept(wp_context->web, NULL);
@@ -834,6 +898,7 @@ static void proxy_callback(const char *proxy, void *user_data)
 					xml_wispr_parser_callback, wp_context);
 
 	wispr_portal_request_portal(wp_context);
+	wispr_portal_context_unref(wp_context);
 }
 
 static gboolean no_proxy_callback(gpointer user_data)
@@ -850,7 +915,6 @@ static gboolean no_proxy_callback(gpointer user_data)
 static int wispr_portal_detect(struct connman_wispr_portal_context *wp_context)
 {
 	enum connman_service_proxy_method proxy_method;
-	enum connman_service_type service_type;
 	char *interface = NULL;
 	char **nameservers = NULL;
 	int if_index;
@@ -860,23 +924,6 @@ static int wispr_portal_detect(struct connman_wispr_portal_context *wp_context)
 	DBG("wispr/portal context %p service %p", wp_context,
 		wp_context->service);
 
-	service_type = connman_service_get_type(wp_context->service);
-
-	switch (service_type) {
-	case CONNMAN_SERVICE_TYPE_ETHERNET:
-	case CONNMAN_SERVICE_TYPE_WIFI:
-	case CONNMAN_SERVICE_TYPE_BLUETOOTH:
-	case CONNMAN_SERVICE_TYPE_CELLULAR:
-	case CONNMAN_SERVICE_TYPE_GADGET:
-		break;
-	case CONNMAN_SERVICE_TYPE_UNKNOWN:
-	case CONNMAN_SERVICE_TYPE_SYSTEM:
-	case CONNMAN_SERVICE_TYPE_GPS:
-	case CONNMAN_SERVICE_TYPE_VPN:
-	case CONNMAN_SERVICE_TYPE_P2P:
-		return -EOPNOTSUPP;
-	}
-
 	interface = connman_service_get_interface(wp_context->service);
 	if (!interface)
 		return -EINVAL;
@@ -928,7 +975,7 @@ static int wispr_portal_detect(struct connman_wispr_portal_context *wp_context)
 
 		if (wp_context->token == 0) {
 			err = -EINVAL;
-			free_connman_wispr_portal_context(wp_context);
+			wispr_portal_context_unref(wp_context);
 		}
 	} else if (wp_context->timeout == 0) {
 		wp_context->timeout = g_idle_add(no_proxy_callback, wp_context);
@@ -946,42 +993,58 @@ int __connman_wispr_start(struct connman_service *service,
 {
 	struct connman_wispr_portal_context *wp_context = NULL;
 	struct connman_wispr_portal *wispr_portal = NULL;
-	int index;
+	int index, err;
 
-	DBG("service %p", service);
+	DBG("service %p %s", service,
+		__connman_ipconfig_type2string(type));
 
-	if (!wispr_portal_list)
+	if (!wispr_portal_hash)
 		return -EINVAL;
 
+	switch (connman_service_get_type(service)) {
+	case CONNMAN_SERVICE_TYPE_ETHERNET:
+	case CONNMAN_SERVICE_TYPE_WIFI:
+	case CONNMAN_SERVICE_TYPE_BLUETOOTH:
+	case CONNMAN_SERVICE_TYPE_CELLULAR:
+	case CONNMAN_SERVICE_TYPE_GADGET:
+		break;
+	case CONNMAN_SERVICE_TYPE_UNKNOWN:
+	case CONNMAN_SERVICE_TYPE_SYSTEM:
+	case CONNMAN_SERVICE_TYPE_GPS:
+	case CONNMAN_SERVICE_TYPE_VPN:
+	case CONNMAN_SERVICE_TYPE_P2P:
+		return -EOPNOTSUPP;
+	}
+
 	index = __connman_service_get_index(service);
 	if (index < 0)
 		return -EINVAL;
 
-	wispr_portal = g_hash_table_lookup(wispr_portal_list,
+	wispr_portal = g_hash_table_lookup(wispr_portal_hash,
 					GINT_TO_POINTER(index));
 	if (!wispr_portal) {
 		wispr_portal = g_try_new0(struct connman_wispr_portal, 1);
 		if (!wispr_portal)
 			return -ENOMEM;
 
-		g_hash_table_replace(wispr_portal_list,
+		g_hash_table_replace(wispr_portal_hash,
 					GINT_TO_POINTER(index), wispr_portal);
 	}
 
 	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
 		wp_context = wispr_portal->ipv4_context;
-	else if (type == CONNMAN_IPCONFIG_TYPE_IPV6)
-		wp_context = wispr_portal->ipv6_context;
 	else
-		return -EINVAL;
+		wp_context = wispr_portal->ipv6_context;
 
 	/* If there is already an existing context, we wipe it */
 	if (wp_context)
-		free_connman_wispr_portal_context(wp_context);
+		wispr_portal_context_unref(wp_context);
 
 	wp_context = create_wispr_portal_context();
-	if (!wp_context)
-		return -ENOMEM;
+	if (!wp_context) {
+		err = -ENOMEM;
+		goto free_wp;
+	}
 
 	wp_context->service = service;
 	wp_context->type = type;
@@ -992,7 +1055,14 @@ int __connman_wispr_start(struct connman_service *service,
 	else
 		wispr_portal->ipv6_context = wp_context;
 
-	return wispr_portal_detect(wp_context);
+	err = wispr_portal_detect(wp_context);
+	if (err)
+		goto free_wp;
+	return 0;
+
+free_wp:
+	g_hash_table_remove(wispr_portal_hash, GINT_TO_POINTER(index));
+	return err;
 }
 
 void __connman_wispr_stop(struct connman_service *service)
@@ -1002,36 +1072,30 @@ void __connman_wispr_stop(struct connman_service *service)
 
 	DBG("service %p", service);
 
-	if (!wispr_portal_list)
+	if (!wispr_portal_hash)
 		return;
 
 	index = __connman_service_get_index(service);
 	if (index < 0)
 		return;
 
-	wispr_portal = g_hash_table_lookup(wispr_portal_list,
+	wispr_portal = g_hash_table_lookup(wispr_portal_hash,
 					GINT_TO_POINTER(index));
 	if (!wispr_portal)
 		return;
 
-	if (wispr_portal->ipv4_context) {
-		if (service == wispr_portal->ipv4_context->service)
-			g_hash_table_remove(wispr_portal_list,
-					GINT_TO_POINTER(index));
-	}
-
-	if (wispr_portal->ipv6_context) {
-		if (service == wispr_portal->ipv6_context->service)
-			g_hash_table_remove(wispr_portal_list,
-					GINT_TO_POINTER(index));
-	}
+	if ((wispr_portal->ipv4_context &&
+	     service == wispr_portal->ipv4_context->service) ||
+	    (wispr_portal->ipv6_context &&
+	     service == wispr_portal->ipv6_context->service))
+		g_hash_table_remove(wispr_portal_hash, GINT_TO_POINTER(index));
 }
 
 int __connman_wispr_init(void)
 {
 	DBG("");
 
-	wispr_portal_list = g_hash_table_new_full(g_direct_hash,
+	wispr_portal_hash = g_hash_table_new_full(g_direct_hash,
 						g_direct_equal, NULL,
 						free_connman_wispr_portal);
 
@@ -1050,6 +1114,6 @@ void __connman_wispr_cleanup(void)
 {
 	DBG("");
 
-	g_hash_table_destroy(wispr_portal_list);
-	wispr_portal_list = NULL;
+	g_hash_table_destroy(wispr_portal_hash);
+	wispr_portal_hash = NULL;
 }
diff --git a/tools/dnsproxy-simple-test b/tools/dnsproxy-simple-test
new file mode 100755
index 00000000..b8fd7f77
--- /dev/null
+++ b/tools/dnsproxy-simple-test
@@ -0,0 +1,112 @@
+#!/bin/bash
+
+# this script runs the dnsproxy-standalone test program and runs a couple of
+# standard DNS queries against it, using the currently configured DNS server
+# in the system as dnsproxy configuration.
+
+echoerr() {
+	echo $@ 1>&2
+	exit 1
+}
+
+while [ $# -gt 0 ]; do
+	case "$1" in
+	"--valgrind")
+		VALGRIND=`which valgrind`
+		if [ -z "$VALGRIND" ]; then
+			echoerr "no valgrind executable found"
+		fi
+		;;
+	"-h")
+		echo "$0 [--valgrind]"
+		echo "--valgrind: run dnsproxy-standalone in valgrind"
+		exit 2
+		;;
+	*)
+		echoerr "Unknown argument $1"
+		;;
+	esac
+	shift
+done
+
+if [ -e "Makefile" ]; then
+	BUILDROOT="$PWD"
+else
+	if [ ! -n "$BUILDROOT" ]; then
+		echoerr "You need to set the BUILDROOT environment variable or run this script from the connman build tree root"
+	fi
+
+	pushd "$BUILDROOT" >/dev/null || echoerr "couldn't enter $BUILDROOT"
+fi
+make tools/dnsproxy-standalone || echoerr "failed to build dnsproxy-standalone"
+
+HOST=`which host`
+if [ -z "$HOST" ]; then
+	echoerr "Couldn't find 'host' DNS utility"
+fi
+
+DNSPROXY="$BUILDROOT/tools/dnsproxy-standalone"
+
+if [ ! -f "$DNSPROXY" ]; then
+	echoerr "standalone dnsproxy does not exist at $DNSPROXY"
+fi
+
+NS1=`grep -w nameserver -m 1 /etc/resolv.conf | cut -d ' ' -f 2`
+if [ -z "$NS1" ]; then
+	echoerr "Failed to determine system's nameserver from /etc/resolv.conf"
+fi
+
+DOMAIN1=`grep -w search -m 1 /etc/resolv.conf | cut -d ' ' -f 2`
+if [ -z "$DOMAIN1" ]; then
+	echoerr "Failed to determine default DNS domain from /etc/resolv.conf"
+fi
+
+# use an unprivileged port for the proxy so we don't need special permissions
+# to run this test
+PORT=8053
+
+# run the proxy in the background
+$VALGRIND $DNSPROXY $PORT "$DOMAIN1" "$NS1" &
+proxy_pid=$!
+
+cleanup() {
+	if [ $proxy_pid -eq -1 ]; then
+		return 0
+	fi
+	kill $proxy_pid
+	wait $proxy_pid
+	ret=$?
+	proxy_pid=-1
+	return $ret
+}
+
+trap cleanup err exit
+
+sleep 1
+echo -e "\n\n"
+
+# test both UDP and TCP mode
+for TRANSPORT in -U -T; do
+	# test both IPv4 and IPv6
+	for IP in -4 -6; do
+		echo "Testing resolution using transport $TRANSPORT and IP${IP}"
+		set -x
+		$HOST $TRANSPORT $IP -p$PORT www.example.com 127.0.0.1
+		RES=$?
+		set +x
+		if [ $RES -ne 0 ]; then
+			echoerr "resolution failed"
+		fi
+
+		echo -e "\n\n"
+	done
+done
+
+echo -e "\n\nDNS resolution succeeded for all test combinations"
+cleanup
+if [ $? -eq 0 ]; then
+	exit 0
+else
+	echoerr "dnsproxy returned non-zero exit status $?"
+fi
+
diff --git a/tools/dnsproxy-standalone.c b/tools/dnsproxy-standalone.c
new file mode 100644
index 00000000..1b9698bd
--- /dev/null
+++ b/tools/dnsproxy-standalone.c
@@ -0,0 +1,155 @@
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/signalfd.h>
+#include <unistd.h>
+
+#include <glib.h>
+
+#include "connman.h"
+
+/*
+ * This is a minimal connman setup  that only runs the internal dnsproxy
+ * component for testing. The advantage is that we can do a full integration
+ * test of the dnsproxy logic without requiring root privileges or setting up
+ * other complexities like D-Bus access etc.
+ */
+
+static GMainLoop *main_loop = NULL;
+
+static void usage(const char *prog)
+{
+	fprintf(stderr, "%s: <listen-port> <dns-domain> <dns-server>\n", prog);
+	exit(1);
+}
+
+static unsigned int to_uint(const char *s)
+{
+	char *end = NULL;
+	unsigned int ret;
+
+	ret = strtoul(s, &end, 10);
+
+	if (*end != '\0') {
+		fprintf(stderr, "invalid argument: %s", s);
+		exit(1);
+	}
+
+	return ret;
+}
+
+static gboolean signal_handler(GIOChannel *channel, GIOCondition cond,
+							gpointer user_data)
+{
+	struct signalfd_siginfo si;
+	ssize_t result;
+	int fd;
+
+	if (cond & (G_IO_NVAL | G_IO_ERR | G_IO_HUP))
+		return FALSE;
+
+	fd = g_io_channel_unix_get_fd(channel);
+
+	result = read(fd, &si, sizeof(si));
+	if (result != sizeof(si))
+		return FALSE;
+
+	switch (si.ssi_signo) {
+	case SIGINT:
+	case SIGTERM:
+		printf("Terminating due to signal\n");
+		g_main_loop_quit(main_loop);
+		break;
+	}
+
+	return TRUE;
+}
+
+static guint setup_signalfd(void)
+{
+	GIOChannel *channel;
+	guint source;
+	sigset_t mask;
+	int fd;
+
+	sigemptyset(&mask);
+	sigaddset(&mask, SIGINT);
+	sigaddset(&mask, SIGTERM);
+
+	if (sigprocmask(SIG_BLOCK, &mask, NULL) < 0) {
+		perror("Failed to set signal mask");
+		return 0;
+	}
+
+	fd = signalfd(-1, &mask, 0);
+	if (fd < 0) {
+		perror("Failed to create signal descriptor");
+		return 0;
+	}
+
+	channel = g_io_channel_unix_new(fd);
+
+	g_io_channel_set_close_on_unref(channel, TRUE);
+	g_io_channel_set_encoding(channel, NULL, NULL);
+	g_io_channel_set_buffered(channel, FALSE);
+
+	source = g_io_add_watch(channel,
+				G_IO_IN | G_IO_HUP | G_IO_ERR | G_IO_NVAL,
+				signal_handler, NULL);
+
+	g_io_channel_unref(channel);
+
+	return source;
+}
+
+int main(int argc, const char **argv)
+{
+	unsigned int port = 0;
+	const char *domain = argv[2];
+	const char *server = argv[3];
+	guint signal = 0;
+
+	if (argc != 4)
+	{
+		usage(argv[0]);
+	}
+
+	port = to_uint(argv[1]);
+
+	__connman_util_init();
+	printf("Listening on local port %u\n", port);
+	__connman_dnsproxy_set_listen_port(port);
+
+	if (__connman_dnsproxy_init() < 0) {
+		fprintf(stderr, "failed to initialize dnsproxy\n");
+		return 1;
+	}
+
+	printf("Using DNS server %s on domain %s\n", server, domain);
+
+	if (__connman_dnsproxy_append(-1, domain, server) < 0) {
+		fprintf(stderr, "failed to add DNS server\n");
+		return 1;
+	}
+
+	/* we need to trick a bit to make the server entry enter "enabled"
+	 * state in dnsproxy. Appending and removing an arbitrary entry causes
+	 * "enable_fallback()" to be called which does what we want. Doesn't
+	 * make much sense but it is good enough for the standalone server at
+	 * the moment.
+	 */
+	__connman_dnsproxy_append(15, domain, server);
+	__connman_dnsproxy_remove(15, domain, server);
+
+	signal = setup_signalfd();
+
+	main_loop = g_main_loop_new(NULL, FALSE);
+
+	g_main_loop_run(main_loop);
+
+	__connman_dnsproxy_cleanup();
+	__connman_util_cleanup();
+	g_source_remove(signal);
+
+	return 0;
+}
diff --git a/tools/dnsproxy-test.c b/tools/dnsproxy-test.c
index 371e2e23..01dcc515 100644
--- a/tools/dnsproxy-test.c
+++ b/tools/dnsproxy-test.c
@@ -99,6 +99,8 @@ static unsigned char msg_invalid[] = {
 	0x31, 0xC0, /* tran id */
 };
 
+static const char *dns_port = "53";
+
 static int create_tcp_socket(int family)
 {
 	int sk, err;
@@ -139,7 +141,7 @@ static int connect_tcp_socket(char *server)
 	hints.ai_socktype = SOCK_STREAM;
 	hints.ai_family = AF_UNSPEC;
 	hints.ai_flags = AI_NUMERICSERV | AI_NUMERICHOST;
-	getaddrinfo(server, "53", &hints, &rp);
+	getaddrinfo(server, dns_port, &hints, &rp);
 
 	sk = create_tcp_socket(rp->ai_family);
 	err = sk;
@@ -201,7 +203,7 @@ static int connect_udp_socket(char *server, struct sockaddr *sa,
 	hints.ai_socktype = SOCK_DGRAM;
 	hints.ai_family = AF_UNSPEC;
 	hints.ai_flags = AI_NUMERICSERV | AI_NUMERICHOST;
-	getaddrinfo(server, "53", &hints, &rp);
+	getaddrinfo(server, dns_port, &hints, &rp);
 
 	sk = create_udp_socket(rp->ai_family);
 	err = sk;
@@ -430,6 +432,11 @@ int main(int argc, char *argv[])
 {
 	g_test_init(&argc, &argv, NULL);
 
+	if (argc == 2) {
+		/* alternative dns port */
+		dns_port = argv[1];
+	}
+
 	g_test_add_func("/dnsproxy/ipv4 udp msg",
 			test_ipv4_udp_msg);
 
diff --git a/vpn/plugins/vpnc.c b/vpn/plugins/vpnc.c
index d11b9111..73012c5b 100644
--- a/vpn/plugins/vpnc.c
+++ b/vpn/plugins/vpnc.c
@@ -54,7 +54,7 @@
 #include "../vpn.h"
 
 #define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))
-#define PID_PATH_ROOT "/var/run/user"
+#define PID_PATH_ROOT RUNSTATEDIR "/user"
 
 enum {
 	OPT_STRING = 1,
diff --git a/vpn/vpn-polkit.policy b/vpn/vpn-polkit.policy
index 0c427220..b187b377 100644
--- a/vpn/vpn-polkit.policy
+++ b/vpn/vpn-polkit.policy
@@ -13,7 +13,7 @@
     <message>Policy prevents modification of settings</message>
     <defaults>
       <allow_inactive>no</allow_inactive>
-      <allow_active>auth_self_keep_session</allow_active>
+      <allow_active>auth_self_keep</allow_active>
     </defaults>
   </action>
 
@@ -22,7 +22,7 @@
     <message>Policy prevents modification of secrets</message>
     <defaults>
       <allow_inactive>no</allow_inactive>
-      <allow_active>auth_admin_keep_session</allow_active>
+      <allow_active>auth_admin_keep</allow_active>
     </defaults>
   </action>
 
diff --git a/vpn/vpn-util.c b/vpn/vpn-util.c
index 9ef14d38..bc3b01dd 100644
--- a/vpn/vpn-util.c
+++ b/vpn/vpn-util.c
@@ -102,8 +102,8 @@ struct group *vpn_util_get_group(const char *groupname)
  * running a VPN plugin as a different user and thus, user specific run dir is
  * allowed and limitation to access any other system dir is restricted.
  */
-static const char *allowed_prefixes[] = { "/var/run/connman-vpn/",
-					"/var/run/user/", "/tmp/", NULL };
+static const char *allowed_prefixes[] = { RUNSTATEDIR "/connman-vpn/",
+					RUNSTATEDIR "/user/", "/tmp/", NULL };
 
 static int is_path_allowed(const char *path)
 {
