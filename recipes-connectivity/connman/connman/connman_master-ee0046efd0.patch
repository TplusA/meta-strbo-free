diff --git a/Makefile.am b/Makefile.am
index 1a3dbe3c..fad129c8 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -117,7 +117,7 @@ src_connmand_SOURCES = $(gdhcp_sources) $(gweb_sources) $(stats_sources) \
 			$(backtrace_sources) $(builtin_sources) $(shared_sources) \
 			src/connman.ver src/main.c src/connman.h src/log.c \
 			src/error.c src/plugin.c src/task.c \
-			src/device.c src/network.c src/connection.c \
+			src/device.c src/network.c src/gateway.c \
 			src/manager.c src/service.c \
 			src/clock.c src/timezone.c src/agent-connman.c \
 			src/agent.c src/notifier.c src/provider.c \
@@ -543,6 +543,8 @@ endif
 
 EXTRA_DIST += vpn/connman-task.te
 
+EXTRA_DIST += scripts/libppp-compat.h
+
 do_subst = $(AM_V_GEN)$(SED) \
 		-e 's,[@]prefix[@],$(prefix),g' \
 		-e 's,[@]sbindir[@],$(sbindir),g' \
diff --git a/README b/README
index e3268c82..2dee1e5f 100644
--- a/README
+++ b/README
@@ -408,17 +408,74 @@ from ipv4.connman.net (for IPv4 connectivity) and ipv6.connman.net
 (for IPv6 connectivity). The used URL looks like this
 http://ipv{4|6}.connman.net/online/status.html
 
-When an online check request fails, another one is triggered after a
-longer interval. The intervals follow the square series of numbers
-in a specific range, by default [1, 12], corresponding to the following
-intervals, in seconds: 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121 and 144.
-
-See connman.conf(5) for the EnableOnlineCheck option, if you need to
-disable the feature.
-It is also possible to specify other URLs via OnlineCheckIPv4URL and
-OnlineCheckIPv6URL options.
-The range of intervals between two online check requests can be fine-tuned
-via OnlineCheckInitialInterval and OnlineCheckMaxInterval options.
+The online check operates in one of three modes:
+
+  * "none"
+  * "one-shot"
+  * "continuous"
+
+where "one-shot" is the default and is governed by the
+"OnlineCheckMode" setting.
+
+In "none" mode, there are no "online" HTTP-based Internet
+reachability checks. Any connected service and the manager state
+will terminate at the Ready state and will not progress to
+Online.
+
+In "one-shot", the default mode, there is a single, one-shot "online"
+HTTP-based Internet reachability check for the default service (that
+is, the service with the high-priority (metric 0) gateway default
+route). When the check succeeds, the associated service and the
+manager state will terminate at the "online" state. When the check
+fails, subsequent checks will be rescheduled according to
+"OnlineCheckIntervalStyle", "OnlineCheckInitialInterval", and
+"OnlineCheckMaxInterval" and will continue indefinitely until one
+succeeds or until the service is disconnected.
+
+In "continuous" mode, there are ongoing "online" HTTP-based Internet
+reachability checks for the default service (that is, the service with
+the high-priority (metric 0) gateway default route). As with
+"one-shot" mode, when the first check succeeds, the associated service
+and the manager state will terminate at the Online state. Thereafter,
+subsequent checks will be scheduled according to
+"OnlineCheckIntervalStyle" and "OnlineCheckMaxInterval". When the
+check fails, subsequent checks will be rescheduled according to
+"OnlineCheckIntervalStyle", "OnlineCheckInitialInterval", and
+"OnlineCheckMaxInterval". When and if "OnlineCheckFailuresThreshold"
+is met, the service and manager state will be demoted to Ready and the
+service will have its "Error" property set to "online-check-failed"
+while subsequent checks will continue. In the interim, if available,
+another service may be promoted to the default service and online
+checks will be initiated for it. When and if, for the demoted service,
+"OnlineCheckSuccessesThreshold" is met, the service "Error" property
+will be cleared and the service state promoted to Online, potentially
+causing it to become the default service again.
+
+See connman.conf(5) for the "OnlineCheckMode" option, if you need to
+disable the feature. It is also possible to specify other URLs via
+"OnlineCheckIPv4URL" and "OnlineCheckIPv6URL" options. The range of
+intervals between two online check requests can be fine-tuned via
+"OnlineCheckInitialInterval" and "OnlineCheckMaxInterval" options as
+well as with the "OnlineCheckIntervalStyle" option.
+
+As intimated above, for the "one-shot" and "continuous" modes, when an
+online check request fails (or, in the case of "continuous" mode,
+succeeds as well), another one is triggered after a longer
+interval. The intervals follows one of two mathemetical sequences,
+depending on the "OnlineCheckIntervalStyle" setting: "fibonacci" or
+"geometric", with a default of "geometric". The geometric setting is
+the square series of numbers in the range specified by
+"OnlineCheckInitialInterval" and "OnlineCheckMaxInterval".  The
+default values for "OnlineCheckInitialInterval" and
+"OnlineCheckMaxInterval" are the range [1, 12], which correspond to
+the following "geometric" intervals, in seconds: 1, 4, 9, 16, 25, 36,
+49, 64, 81, 100, 121 and 144 over that range. By contrast, the
+correspending "fibonacci" sequence over that range is 1, 1, 2, 3, 5,
+8, 13, 21, 34, 55, 89, and 144. The "fibonacci" series and style is
+more aggressive in check rate up to 12 steps (its equivalence point
+with "geometric" at 144 seconds) than "geometric" but backs off far
+more aggressively past that point reaching an hour at interval 19
+which "geometric" does not reach until interval 60.
 
 During the online check procedure, ConnMan will temporarily install
 a host route to both the ipv4.connman.net and ipv6.connman.net so that
diff --git a/acinclude.m4 b/acinclude.m4
index 262465d8..facc8699 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -10,9 +10,45 @@ AC_DEFUN([AC_PROG_CC_PIE], [
 	])
 ])
 
+AC_DEFUN([AC_PROG_CC_ASAN], [
+	AC_CACHE_CHECK([whether ${CC-cc} accepts -fsanitize=address], ac_cv_prog_cc_asan, [
+		echo 'void f(){}' > conftest.c
+		if test -z "`${CC-cc} -fsanitize=address -c conftest.c 2>&1`"; then
+			ac_cv_prog_cc_asan=yes
+		else
+			ac_cv_prog_cc_asan=no
+		fi
+		rm -rf conftest*
+	])
+])
+
+AC_DEFUN([AC_PROG_CC_LSAN], [
+	AC_CACHE_CHECK([whether ${CC-cc} accepts -fsanitize=leak], ac_cv_prog_cc_lsan, [
+		echo 'void f(){}' > conftest.c
+		if test -z "`${CC-cc} -fsanitize=leak -c conftest.c 2>&1`"; then
+			ac_cv_prog_cc_lsan=yes
+		else
+			ac_cv_prog_cc_lsan=no
+		fi
+		rm -rf conftest*
+	])
+])
+
+AC_DEFUN([AC_PROG_CC_UBSAN], [
+	AC_CACHE_CHECK([whether ${CC-cc} accepts -fsanitize=undefined], ac_cv_prog_cc_ubsan, [
+		echo 'void f(){}' > conftest.c
+		if test -z "`${CC-cc} -fsanitize=undefined -c conftest.c 2>&1`"; then
+			ac_cv_prog_cc_ubsan=yes
+		else
+			ac_cv_prog_cc_ubsan=no
+		fi
+		rm -rf conftest*
+	])
+])
+
 AC_DEFUN([COMPILER_FLAGS], [
 	if (test "${CFLAGS}" = ""); then
-		CFLAGS="-Wall -O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2"
+		CFLAGS="-Wall -fsigned-char -fno-exceptions"
 	fi
 	if (test "$USE_MAINTAINER_MODE" = "yes"); then
 		CFLAGS+=" -Werror -Wextra"
@@ -21,9 +57,16 @@ AC_DEFUN([COMPILER_FLAGS], [
 		CFLAGS+=" -Wdeclaration-after-statement"
 		CFLAGS+=" -Wmissing-declarations"
 		CFLAGS+=" -Wredundant-decls"
-                if ( $CC -v 2>/dev/null | grep "gcc version" ); then
-                        CFLAGS+=" -Wcast-align"
-                fi
-		CFLAGS="$CFLAGS -DG_DISABLE_DEPRECATED"
+		CFLAGS+=" -DG_DISABLE_DEPRECATED"
+	fi
+
+	if (test "$CC" = "clang"); then
+		CFLAGS+=" -Wno-unknown-warning-option"
+		CFLAGS+=" -Wno-unknown-pragmas"
 	fi
+
+	if (test "$CC" = "gcc"); then
+		CFLAGS="$CFLAGS -Wcast-align"
+	fi
+
 ])
diff --git a/configure.ac b/configure.ac
index f224bcc7..367b5304 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,5 +1,5 @@
-AC_PREREQ(2.60)
-AC_INIT(connman, 1.42)
+AC_PREREQ([2.69])
+AC_INIT([connman], [1.42])
 
 AC_CONFIG_MACRO_DIR([m4])
 
@@ -19,31 +19,38 @@ COMPILER_FLAGS
 AC_SUBST(abs_top_srcdir)
 AC_SUBST(abs_top_builddir)
 
-AC_LANG_C
+AC_LANG([C])
 AC_USE_SYSTEM_EXTENSIONS
 
-AC_PROG_CC_C99
+AC_PROG_CC
 AM_PROG_CC_C_O
 AC_PROG_CC_PIE
+AC_PROG_CC_ASAN
+AC_PROG_CC_LSAN
+AC_PROG_CC_UBSAN
 AC_PROG_INSTALL
 AC_PROG_MKDIR_P
 
 m4_define([_LT_AC_TAGCONFIG], [])
 m4_ifdef([AC_LIBTOOL_TAGS], [AC_LIBTOOL_TAGS([])])
 
-AC_DISABLE_STATIC
-AC_PROG_LIBTOOL
+LT_PREREQ(2.2)
+LT_INIT([disable-static])
 
 gl_CONFIGMAKE_PREP
 
-AC_ARG_ENABLE(optimization, AC_HELP_STRING([--disable-optimization],
+AC_ARG_ENABLE(optimization, AS_HELP_STRING([--disable-optimization],
 			[disable code optimization through compiler]), [
 	if (test "${enableval}" = "no"); then
-		CFLAGS="$CFLAGS -O0 -U_FORTIFY_SOURCE"
+		CFLAGS="$CFLAGS -O0"
 	fi
 ])
 
-AC_ARG_ENABLE(debug, AC_HELP_STRING([--enable-debug],
+if (test "${enable_optimization}" != "no"); then
+	CFLAGS+=" -O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2"
+fi
+
+AC_ARG_ENABLE(debug, AS_HELP_STRING([--enable-debug],
 			[enable compiling with debugging information]), [
 	if (test "${enableval}" = "yes" &&
 				test "${ac_cv_prog_cc_g}" = "yes"); then
@@ -51,7 +58,7 @@ AC_ARG_ENABLE(debug, AC_HELP_STRING([--enable-debug],
 	fi
 ])
 
-AC_ARG_ENABLE(pie, AC_HELP_STRING([--enable-pie],
+AC_ARG_ENABLE(pie, AS_HELP_STRING([--enable-pie],
 			[enable position independent executables flag]), [
 	if (test "${enableval}" = "yes" &&
 				test "${ac_cv_prog_cc_pie}" = "yes"); then
@@ -60,17 +67,59 @@ AC_ARG_ENABLE(pie, AC_HELP_STRING([--enable-pie],
 	fi
 ])
 
+save_LIBS=$LIBS
+AC_CHECK_LIB(asan, _init)
+LIBS=$save_LIBS
+
+AC_ARG_ENABLE(asan, AS_HELP_STRING([--enable-asan],
+			[enable linking with address sanitizer]), [
+	if (test "${enableval}" = "yes" &&
+				test "${ac_cv_lib_asan__init}" = "yes" &&
+				test "${ac_cv_prog_cc_asan}" = "yes"); then
+		CFLAGS="$CFLAGS -fsanitize=address";
+		LDFLAGS="$LDFLAGS -fsanitize=address"
+	fi
+])
+
+save_LIBS=$LIBS
+AC_CHECK_LIB(lsan, _init)
+LIBS=$save_LIBS
+
+AC_ARG_ENABLE(lsan, AS_HELP_STRING([--enable-lsan],
+			[enable linking with leak sanitizer]), [
+	if (test "${enableval}" = "yes" &&
+				test "${ac_cv_lib_lsan__init}" = "yes" &&
+				test "${ac_cv_prog_cc_lsan}" = "yes"); then
+		CFLAGS="$CFLAGS -fsanitize=leak";
+		LDFLAGS="$LDFLAGS -fsanitize=leak"
+	fi
+])
+
+save_LIBS=$LIBS
+AC_CHECK_LIB(ubsan, _init)
+LIBS=$save_LIBS
+
+AC_ARG_ENABLE(ubsan, AS_HELP_STRING([--enable-ubsan],
+			[enable linking with undefined behavior sanitizer]), [
+	if (test "${enableval}" = "yes" &&
+				test "${ac_cv_lib_ubsan__init}" = "yes" &&
+				test "${ac_cv_prog_cc_ubsan}" = "yes"); then
+		CFLAGS="$CFLAGS -fsanitize=undefined";
+		LDFLAGS="$LDFLAGS -fsanitize=undefined"
+	fi
+])
+
 AC_ARG_ENABLE(hh2serial-gps,
-	AC_HELP_STRING([--enable-hh2serial-gps], [enable hh2serial GPS support]),
+	AS_HELP_STRING([--enable-hh2serial-gps], [enable hh2serial GPS support]),
 			[enable_hh2serial_gps=${enableval}], [enable_hh2serial_gps="no"])
 AM_CONDITIONAL(HH2SERIAL_GPS, test "${enable_hh2serial_gps}" != "no")
 AM_CONDITIONAL(HH2SERIAL_GPS_BUILTIN, test "${enable_hh2serial_gps}" = "builtin")
 
-AC_ARG_WITH(openconnect, AC_HELP_STRING([--with-openconnect=PROGRAM],
+AC_ARG_WITH(openconnect, AS_HELP_STRING([--with-openconnect=PROGRAM],
         [specify location of openconnect binary]), [path_openconnect=${withval}])
 
 AC_ARG_ENABLE(openconnect,
-	AC_HELP_STRING([--enable-openconnect], [enable openconnect support]),
+	AS_HELP_STRING([--enable-openconnect], [enable openconnect support]),
 			[enable_openconnect=${enableval}], [enable_openconnect="no"])
 if (test "${enable_openconnect}" != "no"); then
 	if (test -z "${path_openconnect}"); then
@@ -88,11 +137,11 @@ fi
 AM_CONDITIONAL(OPENCONNECT, test "${enable_openconnect}" != "no")
 AM_CONDITIONAL(OPENCONNECT_BUILTIN, test "${enable_openconnect}" = "builtin")
 
-AC_ARG_WITH(openvpn, AC_HELP_STRING([--with-openvpn=PROGRAM],
+AC_ARG_WITH(openvpn, AS_HELP_STRING([--with-openvpn=PROGRAM],
         [specify location of openvpn binary]), [path_openvpn=${withval}])
 
 AC_ARG_ENABLE(openvpn,
-	AC_HELP_STRING([--enable-openvpn], [enable openvpn support]),
+	AS_HELP_STRING([--enable-openvpn], [enable openvpn support]),
 			[enable_openvpn=${enableval}], [enable_openvpn="no"])
 if (test "${enable_openvpn}" != "no"); then
 	if (test -z "${path_openvpn}"); then
@@ -108,11 +157,11 @@ fi
 AM_CONDITIONAL(OPENVPN, test "${enable_openvpn}" != "no")
 AM_CONDITIONAL(OPENVPN_BUILTIN, test "${enable_openvpn}" = "builtin")
 
-AC_ARG_WITH(vpnc, AC_HELP_STRING([--with-vpnc=PROGRAM],
+AC_ARG_WITH(vpnc, AS_HELP_STRING([--with-vpnc=PROGRAM],
 	[specify location of vpnc binary]), [path_vpnc=${withval}])
 
 AC_ARG_ENABLE(vpnc,
-	AC_HELP_STRING([--enable-vpnc], [enable vpnc support]),
+	AS_HELP_STRING([--enable-vpnc], [enable vpnc support]),
 		[enable_vpnc=${enableval}], [enable_vpnc="no"])
 if (test "${enable_vpnc}" != "no"); then
 	if (test -z "${path_vpnc}"); then
@@ -128,11 +177,11 @@ fi
 AM_CONDITIONAL(VPNC, test "${enable_vpnc}" != "no")
 AM_CONDITIONAL(VPNC_BUILTIN, test "${enable_vpnc}" = "builtin")
 
-AC_ARG_WITH(l2tp, AC_HELP_STRING([--with-l2tp=PROGRAM],
+AC_ARG_WITH(l2tp, AS_HELP_STRING([--with-l2tp=PROGRAM],
         [specify location of l2tp binary]), [path_l2tp=${withval}])
 
 AC_ARG_ENABLE(l2tp,
-	AC_HELP_STRING([--enable-l2tp], [enable l2tp support]),
+	AS_HELP_STRING([--enable-l2tp], [enable l2tp support]),
 			[enable_l2tp=${enableval}], [enable_l2tp="no"])
 if (test "${enable_l2tp}" != "no"); then
 	if (test -z "${path_l2tp}"); then
@@ -145,11 +194,11 @@ fi
 AM_CONDITIONAL(L2TP, test "${enable_l2tp}" != "no")
 AM_CONDITIONAL(L2TP_BUILTIN, test "${enable_l2tp}" = "builtin")
 
-AC_ARG_WITH(pptp, AC_HELP_STRING([--with-pptp=PROGRAM],
+AC_ARG_WITH(pptp, AS_HELP_STRING([--with-pptp=PROGRAM],
         [specify location of pptp binary]), [path_pptp=${withval}])
 
 AC_ARG_ENABLE(pptp,
-	AC_HELP_STRING([--enable-pptp], [enable pptp support]),
+	AS_HELP_STRING([--enable-pptp], [enable pptp support]),
 			[enable_pptp=${enableval}], [enable_pptp="no"])
 if (test "${enable_pptp}" != "no"); then
 	if (test -z "${path_pptp}"); then
@@ -208,23 +257,23 @@ AC_CHECK_FUNC(signalfd, dummy=yes,
 AC_CHECK_LIB(dl, dlopen, dummy=yes,
 			AC_MSG_ERROR(dynamic linking loader is required))
 
-AC_ARG_ENABLE(iospm, AC_HELP_STRING([--enable-iospm],
+AC_ARG_ENABLE(iospm, AS_HELP_STRING([--enable-iospm],
 		[enable Intel OSPM support]), [enable_iospm=${enableval}])
 AM_CONDITIONAL(IOSPM, test "${enable_iospm}" = "yes")
 
 AC_ARG_ENABLE(tist,
-	AC_HELP_STRING([--enable-tist], [enable TI Shared Transport support]),
+	AS_HELP_STRING([--enable-tist], [enable TI Shared Transport support]),
 			[enable_tist=${enableval}], [enable_tist="no"])
 AM_CONDITIONAL(TIST, test "${enable_tist}" != "no")
 AM_CONDITIONAL(TIST_BUILTIN, test "${enable_tist}" = "builtin")
 
 AC_ARG_ENABLE(session-policy-local,
-	AC_HELP_STRING([--enable-session-policy-local], [enable local file Session policy configuration support]),
+	AS_HELP_STRING([--enable-session-policy-local], [enable local file Session policy configuration support]),
 			[enable_session_policy_local=${enableval}], [enable_session_policy_local="no"])
 AM_CONDITIONAL(SESSION_POLICY_LOCAL, test "${enable_session_policy_local}" != "no")
 AM_CONDITIONAL(SESSION_POLICY_LOCAL_BUILTIN, test "${enable_session_policy_local}" = "builtin")
 
-AC_ARG_WITH(stats-max-file-size, AC_HELP_STRING([--with-stats-max-file-size=SIZE],
+AC_ARG_WITH(stats-max-file-size, AS_HELP_STRING([--with-stats-max-file-size=SIZE],
 			[Maximal size of a statistics round robin file]),
 			[stats_max_file_size=${withval}])
 
@@ -245,7 +294,7 @@ PKG_CHECK_MODULES(DBUS, dbus-1 >= 1.4, dummy=yes,
 AC_SUBST(DBUS_CFLAGS)
 AC_SUBST(DBUS_LIBS)
 
-AC_ARG_WITH(dbusconfdir, AC_HELP_STRING([--with-dbusconfdir=PATH],
+AC_ARG_WITH(dbusconfdir, AS_HELP_STRING([--with-dbusconfdir=PATH],
 	[path to D-Bus config directory]), [path_dbusconf=${withval}],
 		[path_dbusconf="`$PKG_CONFIG --variable=datadir dbus-1`"])
 if (test -z "${path_dbusconf}"); then
@@ -255,7 +304,7 @@ else
 fi
 AC_SUBST(DBUS_CONFDIR)
 
-AC_ARG_WITH(dbusdatadir, AC_HELP_STRING([--with-dbusdatadir=PATH],
+AC_ARG_WITH(dbusdatadir, AS_HELP_STRING([--with-dbusdatadir=PATH],
 	[path to D-Bus data directory]), [path_dbusdata=${withval}],
 		[path_dbusdata="`$PKG_CONFIG --variable=datadir dbus-1`"])
 if (test -z "${path_dbusdata}"); then
@@ -265,7 +314,7 @@ else
 fi
 AC_SUBST(DBUS_DATADIR)
 
-AC_ARG_WITH([systemdunitdir], AC_HELP_STRING([--with-systemdunitdir=DIR],
+AC_ARG_WITH([systemdunitdir], AS_HELP_STRING([--with-systemdunitdir=DIR],
 	[path to systemd service directory]), [path_systemdunit=${withval}],
 		[path_systemdunit="`$PKG_CONFIG --variable=systemdsystemunitdir systemd`"])
 if (test -n "${path_systemdunit}"); then
@@ -274,7 +323,7 @@ if (test -n "${path_systemdunit}"); then
 fi
 AM_CONDITIONAL(SYSTEMD, test -n "${path_systemdunit}")
 
-AC_ARG_WITH([tmpfilesdir], AC_HELP_STRING([--with-tmpfilesdir=DIR],
+AC_ARG_WITH([tmpfilesdir], AS_HELP_STRING([--with-tmpfilesdir=DIR],
 	[path to systemd tmpfiles.d directory]), [path_tmpfiles=${withval}],
 		[path_tmpfiles="`$PKG_CONFIG --variable=tmpfilesdir systemd`"])
 if (test -n "${path_tmpfiles}"); then
@@ -282,7 +331,7 @@ if (test -n "${path_tmpfiles}"); then
 	AC_SUBST(SYSTEMD_TMPFILESDIR)
 fi
 
-AC_ARG_WITH(firewall, AC_HELP_STRING([--with-firewall=TYPE],
+AC_ARG_WITH(firewall, AS_HELP_STRING([--with-firewall=TYPE],
 			[specify which firewall type is used iptables or nftables [default=iptables]]),
 		[firewall_type=${withval}],
 		[firewall_type="iptables"])
@@ -320,16 +369,16 @@ if (test "${firewall_type}" = "nftables"); then
 fi
 AM_CONDITIONAL(NFTABLES, test "${found_nftables}" != "no")
 
-AC_ARG_ENABLE(test, AC_HELP_STRING([--enable-test],
+AC_ARG_ENABLE(test, AS_HELP_STRING([--enable-test],
 		[enable test/example scripts]), [enable_test=${enableval}])
 AM_CONDITIONAL(TEST, test "${enable_test}" = "yes")
 
-AC_ARG_ENABLE(nmcompat, AC_HELP_STRING([--enable-nmcompat],
+AC_ARG_ENABLE(nmcompat, AS_HELP_STRING([--enable-nmcompat],
 				[enable Network Manager support]),
 			[enable_nmcompat=${enableval}], [enable_nmcompat="no"])
 AM_CONDITIONAL(NMCOMPAT, test "${enable_nmcompat}" != "no")
 
-AC_ARG_ENABLE(polkit, AC_HELP_STRING([--enable-polkit],
+AC_ARG_ENABLE(polkit, AS_HELP_STRING([--enable-polkit],
 				[enable PolicyKit support]),
 			[enable_polkit=${enableval}], [enable_polkit="no"])
 if (test "${enable_polkit}" != "no"); then
@@ -342,78 +391,78 @@ if (test "${enable_polkit}" != "no"); then
 fi
 AM_CONDITIONAL(POLKIT, test "${enable_polkit}" != "no")
 
-AC_ARG_ENABLE(selinux, AC_HELP_STRING([--enable-selinux],
+AC_ARG_ENABLE(selinux, AS_HELP_STRING([--enable-selinux],
 				[enable selinux support]),
 			[enable_selinux=${enableval}], [enable_selinux="no"])
 AM_CONDITIONAL(SELINUX, test "${enable_selinux}" != "no")
 
-AC_ARG_ENABLE(loopback, AC_HELP_STRING([--disable-loopback],
+AC_ARG_ENABLE(loopback, AS_HELP_STRING([--disable-loopback],
 				[disable loopback support]),
 					[enable_loopback=${enableval}])
 AM_CONDITIONAL(LOOPBACK, test "${enable_loopback}" != "no")
 
-AC_ARG_ENABLE(ethernet, AC_HELP_STRING([--disable-ethernet],
+AC_ARG_ENABLE(ethernet, AS_HELP_STRING([--disable-ethernet],
 				[disable Ethernet support]),
 					[enable_ethernet=${enableval}])
 AM_CONDITIONAL(ETHERNET, test "${enable_ethernet}" != "no")
 
-AC_ARG_ENABLE(wireguard, AC_HELP_STRING([--disable-wireguard],
+AC_ARG_ENABLE(wireguard, AS_HELP_STRING([--disable-wireguard],
 				[disable Wireguard support]),
 					[enable_wireguard=${enableval}])
 AM_CONDITIONAL(WIREGUARD, test "${enable_wireguard}" != "no")
 AM_CONDITIONAL(WIREGUARD_BUILTIN, test "${enable_wireguard}" = "builtin")
 
-AC_ARG_ENABLE(gadget, AC_HELP_STRING([--disable-gadget],
+AC_ARG_ENABLE(gadget, AS_HELP_STRING([--disable-gadget],
 				[disable USB Gadget support]),
 					[enable_gadget=${enableval}])
 AM_CONDITIONAL(GADGET, test "${enable_gadget}" != "no")
 
-AC_ARG_ENABLE(wifi, AC_HELP_STRING([--disable-wifi],
+AC_ARG_ENABLE(wifi, AS_HELP_STRING([--disable-wifi],
 				[disable WiFi support]),
 					[enable_wifi=${enableval}])
 AM_CONDITIONAL(WIFI, test "${enable_wifi}" != "no")
 
-AC_ARG_ENABLE(iwd, AC_HELP_STRING([--enable-iwd],
+AC_ARG_ENABLE(iwd, AS_HELP_STRING([--enable-iwd],
 				[enable iwd support]),
 					[enable_iwd=${enableval}])
 AM_CONDITIONAL(IWD, test "${enable_iwd}" = "yes")
 
-AC_ARG_ENABLE(bluetooth, AC_HELP_STRING([--disable-bluetooth],
+AC_ARG_ENABLE(bluetooth, AS_HELP_STRING([--disable-bluetooth],
 				[disable Bluetooth support]),
 					[enable_bluetooth=${enableval}])
 AM_CONDITIONAL(BLUETOOTH, test "${enable_bluetooth}" != "no")
 
-AC_ARG_ENABLE(ofono, AC_HELP_STRING([--disable-ofono],
+AC_ARG_ENABLE(ofono, AS_HELP_STRING([--disable-ofono],
 				[disable oFono support]),
 					[enable_ofono=${enableval}])
 AM_CONDITIONAL(OFONO, test "${enable_ofono}" != "no")
 
-AC_ARG_ENABLE(dundee, AC_HELP_STRING([--disable-dundee],
+AC_ARG_ENABLE(dundee, AS_HELP_STRING([--disable-dundee],
 				[disable dundee support (Bluetooth DUN)]),
 					[enable_dundee=${enableval}])
 AM_CONDITIONAL(DUNDEE, test "${enable_dundee}" != "no")
 
-AC_ARG_ENABLE(pacrunner, AC_HELP_STRING([--disable-pacrunner],
+AC_ARG_ENABLE(pacrunner, AS_HELP_STRING([--disable-pacrunner],
 				[disable PACrunner support]),
 					[enable_pacrunner=${enableval}])
 AM_CONDITIONAL(PACRUNNER, test "${enable_pacrunner}" != "no")
 
-AC_ARG_ENABLE(neard, AC_HELP_STRING([--disable-neard],
+AC_ARG_ENABLE(neard, AS_HELP_STRING([--disable-neard],
 				[disable Neard support]),
 					[enable_neard=${enableval}])
 AM_CONDITIONAL(NEARD, test "${enable_neard}" != "no")
 
-AC_ARG_ENABLE(wispr, AC_HELP_STRING([--disable-wispr],
+AC_ARG_ENABLE(wispr, AS_HELP_STRING([--disable-wispr],
 				[disable WISPr support]),
 					[enable_wispr=${enableval}])
 AM_CONDITIONAL(WISPR, test "${enable_wispr}" != "no")
 
-AC_ARG_ENABLE(tools, AC_HELP_STRING([--disable-tools],
+AC_ARG_ENABLE(tools, AS_HELP_STRING([--disable-tools],
 				[disable testing tools]),
 					[enable_tools=${enableval}])
 AM_CONDITIONAL(TOOLS, test "${enable_tools}" != "no")
 
-AC_ARG_ENABLE(stats, AC_HELP_STRING([--disable-stats],
+AC_ARG_ENABLE(stats, AS_HELP_STRING([--disable-stats],
 				[disable statistics round robin file generation]),
 					[enable_stats=${enableval}])
 AM_CONDITIONAL(STATS, test "${enable_stats}" != "no")
@@ -432,7 +481,7 @@ fi
 AC_SUBST(IPTABLES_SAVE)
 AC_SUBST(IP6TABLES_SAVE)
 
-AC_ARG_ENABLE(client, AC_HELP_STRING([--disable-client],
+AC_ARG_ENABLE(client, AS_HELP_STRING([--disable-client],
 				[disable command line client]),
 					[enable_client=${enableval}])
 AM_CONDITIONAL(CLIENT, test "${enable_client}" != "no")
@@ -460,7 +509,7 @@ if (test "${enable_wifi}" != "no"); then
 						$PATH:/sbin:/usr/sbin)
 fi
 
-AC_ARG_ENABLE(datafiles, AC_HELP_STRING([--disable-datafiles],
+AC_ARG_ENABLE(datafiles, AS_HELP_STRING([--disable-datafiles],
 			[don't install configuration and data files]),
 					[enable_datafiles=${enableval}])
 AM_CONDITIONAL(DATAFILES, test "${enable_datafiles}" != "no")
@@ -478,7 +527,7 @@ AM_CONDITIONAL(VPN, test "${enable_openconnect}" != "no" -o \
 			"${enable_wireguard}" != "no")
 
 AC_MSG_CHECKING(which DNS backend to use)
-AC_ARG_WITH(dns-backend, AC_HELP_STRING([--with-dns-backend=TYPE],
+AC_ARG_WITH(dns-backend, AS_HELP_STRING([--with-dns-backend=TYPE],
             [specify which DNS backend to use: internal or systemd-resolved [default=internal]]),
 		[dns_backend=${withval}],
 		[dns_backend="internal"])
@@ -491,4 +540,5 @@ AM_CONDITIONAL(INTERNAL_DNS_BACKEND, test "${dns_backend}" = "internal")
 AM_CONDITIONAL(SYSTEMD_RESOLVED_DNS_BACKEND, test "${dns_backend}" = "systemd-resolved")
 AC_MSG_RESULT(${dns_backend})
 
-AC_OUTPUT(Makefile include/version.h connman.pc)
+AC_CONFIG_FILES(Makefile include/version.h connman.pc)
+AC_OUTPUT
diff --git a/doc/connman.conf.5.in b/doc/connman.conf.5.in
index 1f9b2908..3eb240f5 100644
--- a/doc/connman.conf.5.in
+++ b/doc/connman.conf.5.in
@@ -166,7 +166,49 @@ ConnMan will issue an HTTP GET request to verify that end-to-end
 connectivity is successful. Only then the service will be
 transitioned to ONLINE state.
 If this setting is false, the default service will remain in READY state.
-Default value is true.
+Default value is \fBtrue\fR.
+
+\fBNOTE:\fR \fBEnableOnlineCheck\fR is deprecated; please use
+\fBOnlineCheckMode\fR with a mode of either \fBone-shot\fR or
+\fBnone\fR.
+
+.TP
+.BI OnlineCheckMode= mode
+This indicates the "online" HTTP-based Internet reachability check
+mode and supercedes and deprecates \fBEnableOnlineCheck\fR. Possible
+values for \fImode\fR are \fBnone\fR, \fBone-shot\fR, and
+\fBcontinuous\fR. The default value of \fImode\fR is \fBone-shot\fR.
+
+In \fBnone\fR mode, there are no "online" HTTP-based Internet reachability
+checks. Any connected service and the manager state will terminate at
+the "ready" state and will not progress to "online".
+
+In \fBone-shot\fR mode, there is a single, one-shot "online" HTTP-based
+Internet reachability check for the default service. When the check
+succeeds, the associated service and the manager state will terminate
+at the "online" state. When the check fails, subsequent checks will be
+rescheduled according to \fBOnlineCheckIntervalStyle\fR,
+\fBOnlineCheckInitialInterval\fR, and \fBOnlineCheckMaxInterval\fR and will
+continue indefinitely until one succeeds or unti the service is
+disconnected.
+
+In \fBcontinuous\fR mode, there are ongoing "online" HTTP-based Internet
+reachability check for the default service. As with "one-shot" mode,
+when the first check succeeds, the associated service and the manager
+state will terminate at the "online" state. Thereafter, subsequent
+checks will be scheduled according to \fBOnlineCheckIntervalStyle\fR and
+\fBOnlineCheckMaxInterval\fR. When the check fails, subsequent checks will
+be rescheduled according to \fBOnlineCheckIntervalStyle\fR,
+\fBOnlineCheckInitialInterval\fR, and \fBOnlineCheckMaxInterval\fR. When and
+if \fBOnlineCheckFailuresThreshold\fR is met, the service and manager
+state will be demoted to "ready" and the service will have its "Error"
+property set to "online-check-failed" while subsequent checks will
+continue. In the interim, if available, another service may be
+promoted to the default service and online checks will be initiated
+for it. When and if, for the demoted service,
+\fBOnlineCheckSuccessesThreshold\fR is met, the service "Error" property
+will be cleared and the service state promoted to "online",
+potentially causing it to become the default service again.
 .TP
 .BI OnlineCheckIPv4URL= url, OnlineCheckIPv6URL= url
 Urls (IPv4 and IPv6 respectively) used during the online status check.
@@ -174,13 +216,42 @@ Please refer to the README for more detailed information.
 Default values are http://ipv4.connman.net/online/status.html and
 http://ipv6.connman.net/online/status.html respectively.
 .TP
-.BI OnlineCheckInitialInterval= secs, OnlineCheckMaxInterval= secs
+.BI OnlineCheckConnectTimeout= secs[.milliseconds]
+The time, in decimal seconds (for example, 12.3), to wait for a
+successful TCP connection to the host associated with
+\fBOnlineCheckIPv4URL\fR or \fBOnlineCheckIPv6URL\fR (see above). Connections
+that take longer than \fBOnlineCheckConnectTimeout\fR will be aborted. The
+default value is zero ('0') which indicates that no explicit
+connection timeout will be used, leaving the timeout to the underlying
+operating system and network stack.
+.TP
+.BI OnlineCheckInitialInterval= interval, OnlineCheckMaxInterval= interval
 Range of intervals between two online check requests.
 Please refer to the README for more detailed information.
 Default values are 1 and 12 respectively.
 .TP
+.BI OnlineCheckIntervalStyle=fibonacci\ \fR|\fB\ geometric
+The style or mathematical series function used to compute the actual
+time, in seconds, between two "ready" to "online" HTTP-based Internet
+reachability checks. The value of which may be either "geometric" or
+"fibonacci" with a default value of "geometric".
+
+The "geometric" style or function simply takes the square of the
+online check interval (see OnlineCheckInitialInterval and
+OnlineCheckMaxInterval above). For example, at a check interval of 6,
+the time, in seconds, is 36 (6^2) seconds.
+
+The "fibonacci" style or function takes the value of the Fibonacci
+sequence at the online check interval. For example, at a check interval
+of 6, the time, in seconds, is 8 seconds.
+
+The "fibonacci" series and style is more aggressive in check rate up to 12
+steps (its equivalence point with "geometric" at 144 seconds) than
+"geometric" but backs off far more aggressively past that point reaching
+an hour at interval 19 which "geometric" does not reach until interval
+60.
+.TP
 .BI EnableOnlineToReadyTransition=true\ \fR|\fB\ false
-WARNING: Experimental feature!!!
 In addition to EnableOnlineCheck setting, enable or disable use of HTTP GET
 to detect the loss of end-to-end connectivity.
 If this setting is false, when the default service transitions to ONLINE
@@ -190,7 +261,46 @@ If this setting is true, the HTTP GET request keeps beeing called to guarantee
 that end-to-end connectivity is still successful. If not, the default service
 will transition to READY state, enabling another service to become the
 default one, in replacement.
-Default value is false.
+Default value is \fBfalse\fR.
+
+\fBNOTE:\fR \fBEnableOnlineToReadyTransition\fR is deprecated; please use
+\fBOnlineCheckMode\fR with a mode of either \fBcontinuous\fR or
+\fBnone\fR.
+.TP
+.BI OnlineCheckFailuresThreshold= failures
+When \fBOnlineCheckMode\fR is "continuous", this is the number of
+failed back-to-back "ready" to "online" HTTP-based Internet
+reachability checks that will be allowed before marking a service as
+"failed" from a reachability perspective, sorting it at a lower
+priority than other services not so marked.
+
+Lower values may result in higher-frequency network service cycling
+while higher values may result in a longer period of time before
+failing from a non-Internet reachable service to one that might be.
+
+See \fBOnlineCheckIntervalStyle\fR, \fBOnlineCheckInitialInterval\fR, and
+\fBOnlineCheckMaxInterval\fR for other values that influence network
+service failure/recovery transition time.
+The default value is 6.
+.TP
+.BI OnlineCheckSuccessesThreshold= successes
+When \fBOnlineCheckMode\fR is "continuous", this is the number of
+successful back-to-back "ready" to "online" HTTP-based Internet
+reachability checks that must be met before clearing a service as
+"failed" from a reachability perspective and allowing it to transition
+to the "online" state again, allowing it to sort back to a higher
+priority relative to other network services.
+
+Lower values may result in higher-frequency network service cycling
+while higher values may result in a longer period of time before
+transitioning back to more a preferred, Internet reachable network
+service.
+
+See \fBOnlineCheckIntervalStyle\fR, \fBOnlineCheckInitialInterval\fR, and
+\fBOnlineCheckMaxInterval\fR for other values that influence network
+service failure/recovery transition time.
+
+The default value is 6.
 .TP
 .BI AutoConnectRoamingServices=true\ \fR|\fB\ false
 Automatically connect roaming services. This is not recommended unless you know
diff --git a/doc/connmanctl.1.in b/doc/connmanctl.1.in
index d87472c3..cf662ca3 100644
--- a/doc/connmanctl.1.in
+++ b/doc/connmanctl.1.in
@@ -10,7 +10,7 @@ SYNOPSIS
 .BI enable \ technology\fR|offline\ |
 .BI disable \ technology\fR|offline\ |
 .BI tether \ technology\ \fRon|off\ |
-.BI tether\fR\ wifi\ on|off\  ssid\ passphrase\fR\ |
+.BI tether\fR\ wifi\ on|off\  ssid\ passphrase\ freq\fR\ |
 .BR services \ [\fIservice\fR]\ |
 .BI peers \ peer\fR\ |
 .BI scan \ technology\fR\ |
@@ -86,7 +86,7 @@ by default since tethering it usually breaks local networks. See
 for enabling.
 .PP
 .TP
-.BR tether\ wifi\ on \ |\  off \ \fIssid\ passphrase
+.BR tether\ wifi\ on \ |\  off \ \fIssid\ passphrase\ [freq]
 Enable or disable wireless tethering, as well set the SSID and passphrase.
 .PP
 .TP
diff --git a/doc/service-api.txt b/doc/service-api.txt
index c0d5adbb..89208a6d 100644
--- a/doc/service-api.txt
+++ b/doc/service-api.txt
@@ -157,7 +157,8 @@ Properties	string State [readonly]
 
 			Currently defined error codes are: "out-of-range",
 			"pin-missing", "dhcp-failed", "connect-failed",
-			"login-failed", "auth-failed" and "invalid-key".
+			"login-failed", "auth-failed", "invalid-key",
+			"blocked", and "online-check-failed".
 
 		string Name [readonly]
 
diff --git a/gweb/gweb.c b/gweb/gweb.c
index 13c6c5f2..ce49e8d3 100644
--- a/gweb/gweb.c
+++ b/gweb/gweb.c
@@ -75,6 +75,7 @@ struct web_session {
 	char *content_type;
 
 	GIOChannel *transport_channel;
+	guint connect_timeout;
 	guint transport_watch;
 	guint send_watch;
 
@@ -124,6 +125,7 @@ struct _GWeb {
 	char *user_agent_profile;
 	char *http_version;
 	bool close_connection;
+	guint connect_timeout_ms;
 
 	GWebDebugFunc debug_func;
 	gpointer debug_data;
@@ -132,6 +134,8 @@ struct _GWeb {
 #define debug(web, format, arg...)				\
 	_debug(web, __FILE__, __func__, format, ## arg)
 
+static void close_session_transport(struct web_session *session);
+
 static void _debug(GWeb *web, const char *file, const char *caller,
 						const char *format, ...)
 {
@@ -153,6 +157,169 @@ static void _debug(GWeb *web, const char *file, const char *caller,
 	va_end(ap);
 }
 
+static inline void call_result_func(struct web_session *session, guint16 status)
+{
+
+	if (!session->result_func)
+		return;
+
+	if (status != GWEB_HTTP_STATUS_CODE_UNKNOWN)
+		session->result.status = status;
+
+	session->result_func(&session->result, session->user_data);
+
+}
+
+static inline void call_route_func(struct web_session *session)
+{
+	if (session->route_func)
+		session->route_func(session->address, session->addr->ai_family,
+				session->web->index, session->user_data);
+}
+
+/**
+ *  @brief
+ *    Handle a TCP connection timeout.
+ *
+ *  This callback handles a TCP connection timeout for a GWeb
+ *  connection. The session transport is closed and the GWeb
+ *  transaction is terminated with
+ *  #GWEB_HTTP_STATUS_CODE_REQUEST_TIMEOUT status.
+ *
+ *  param[in,out]  user_data  A pointer to the mutable GWeb session
+ *                            for which the TCP connection timed out.
+ *
+ *  @returns
+ *    G_SOURCE_REMOVE (that is, FALSE) unconditionally, indicating
+ *    that the timeout source that triggered this callback should be
+ *    removed on callback completion.
+ *
+ *  @sa add_connect_timeout
+ *  @sa cancel_connect_timeout
+ *
+ */
+static gboolean connect_timeout_cb(gpointer user_data)
+{
+	struct web_session *session = user_data;
+
+	debug(session->web, "session %p connect timeout after %ums",
+			session, g_web_get_connect_timeout(session->web));
+
+	session->connect_timeout = 0;
+
+	close_session_transport(session);
+
+	session->result.buffer = NULL;
+	session->result.length = 0;
+
+	call_result_func(session, GWEB_HTTP_STATUS_CODE_REQUEST_TIMEOUT);
+
+	return G_SOURCE_REMOVE;
+}
+
+/**
+ *  @brief
+ *    Add a TCP connection timeout.
+ *
+ *  This attempts to add TCP connection timeout and callback to the
+ *  specified GWeb session. The timeout is successfully added if @a
+ *  session is non-null and @a timeout_ms is greater than zero.
+ *
+ *  @param[in,out]  session     A pointer to the mutable GWeb session
+ *                              to add the TCP connection timeout
+ *                              callback to.
+ *  param[in]       timeout_ms  The time, in milliseconds, for the TCP
+ *                              connection timeout. Connections that
+ *                              take longer than this will be
+ *                              aborted. A value of zero ('0')
+ *                              indicates that no explicit connection
+ *                              timeout will be used, leaving the
+ *                              timeout to the underlying operating
+ *                              system and its network stack.
+ *
+ *  @sa cancel_connect_timeout
+ *  @sa connect_timeout_cb
+ *
+ */
+static void add_connect_timeout(struct web_session *session,
+						guint timeout_ms)
+{
+	if (!session || !timeout_ms)
+		return;
+
+	debug(session->web, "add connect timeout %u ms", timeout_ms);
+
+	session->connect_timeout = g_timeout_add(timeout_ms,
+				connect_timeout_cb, session);
+}
+
+/**
+ *  @brief
+ *    Cancel a TCP connection timeout.
+ *
+ *  This attempts to cancel a TCP connection timeout and callback from
+ *  the specified GWeb session. The timeout is successfully cancelled
+ *  if @a session is non-null and its associated connect timeout
+ *  identifier is valid.
+ *
+ *  @param[in,out]  session     A pointer to the mutable GWeb session
+ *                              on which to cancel the TCP connection
+ *                              timeout.
+ *
+ *  @sa add_connect_timeout
+ *
+ */
+static void cancel_connect_timeout(struct web_session *session)
+{
+	if (!session)
+		return;
+
+	if (session->connect_timeout > 0) {
+		g_source_remove(session->connect_timeout);
+		session->connect_timeout = 0;
+
+		debug(session->web, "cancelled connect timeout");
+	}
+}
+
+/**
+ *  @brief
+ *    Close the TCP transport a GWeb sesssion.
+ *
+ *  This closes the TCP transport associated with the specified GWeb
+ *  session, removing its transport and send watches and releasing the
+ *  reference to the transport channel.
+ *
+ *  @param[in,out]  session     A pointer to the mutable GWeb session
+ *                              for which to close the session
+ *                              transport.
+ *
+ *  @sa connect_session_transport
+ *
+ */
+static void close_session_transport(struct web_session *session)
+{
+	if (!session)
+		return;
+
+	debug(session->web, "closing session transport");
+
+	if (session->transport_watch > 0) {
+		g_source_remove(session->transport_watch);
+		session->transport_watch = 0;
+	}
+
+	if (session->send_watch > 0) {
+		g_source_remove(session->send_watch);
+		session->send_watch = 0;
+	}
+
+	if (session->transport_channel) {
+		g_io_channel_unref(session->transport_channel);
+		session->transport_channel = NULL;
+	}
+}
+
 static void free_session(struct web_session *session)
 {
 	GWeb *web;
@@ -160,6 +327,8 @@ static void free_session(struct web_session *session)
 	if (!session)
 		return;
 
+	debug(session->web, "session %p", session);
+
 	g_free(session->request);
 
 	web = session->web;
@@ -170,14 +339,9 @@ static void free_session(struct web_session *session)
 	if (session->resolv_action > 0)
 		g_resolv_cancel_lookup(web->resolv, session->resolv_action);
 
-	if (session->transport_watch > 0)
-		g_source_remove(session->transport_watch);
-
-	if (session->send_watch > 0)
-		g_source_remove(session->send_watch);
+	cancel_connect_timeout(session);
 
-	if (session->transport_channel)
-		g_io_channel_unref(session->transport_channel);
+	close_session_transport(session);
 
 	g_free(session->result.last_key);
 
@@ -206,6 +370,8 @@ static void flush_sessions(GWeb *web)
 {
 	GList *list;
 
+	debug(web, "flushing sessions...");
+
 	for (list = g_list_first(web->session_list);
 					list; list = g_list_next(list))
 		free_session(list->data);
@@ -252,18 +418,17 @@ GWeb *g_web_ref(GWeb *web)
 	if (!web)
 		return NULL;
 
+	debug(web, "ref %d",
+		web->ref_count + 1);
+
 	__sync_fetch_and_add(&web->ref_count, 1);
 
 	return web;
 }
 
-void g_web_unref(GWeb *web)
+static void g_web_free(GWeb *web)
 {
-	if (!web)
-		return;
-
-	if (__sync_fetch_and_sub(&web->ref_count, 1) != 1)
-		return;
+	debug(web, "freeing...");
 
 	flush_sessions(web);
 
@@ -279,6 +444,20 @@ void g_web_unref(GWeb *web)
 	g_free(web);
 }
 
+void g_web_unref(GWeb *web)
+{
+	if (!web)
+		return;
+
+	debug(web, "ref %d",
+		web->ref_count - 1);
+
+	if (__sync_fetch_and_sub(&web->ref_count, 1) != 1)
+		return;
+
+	g_web_free(web);
+}
+
 bool g_web_supports_tls(void)
 {
 	return g_io_channel_supports_tls();
@@ -445,24 +624,69 @@ bool g_web_get_close_connection(GWeb *web)
 	return web->close_connection;
 }
 
-static inline void call_result_func(struct web_session *session, guint16 status)
+/**
+ *  @brief
+ *    Set the TCP connection timeout.
+ *
+ *  This sets the TCP connection timeout, in milliseconds, for the
+ *  specified GWeb object.
+ *
+ *  param[in,out]  web         A pointer to the mutable GWeb object
+ *                             for which the TCP connection timeout is
+ *                             to be set.
+ *  param[in]      timeout_ms  The time, in milliseconds, for the TCP
+ *                             connection timeout. Connections that
+ *                             take longer than this will be
+ *                             aborted. A value of zero ('0')
+ *                             indicates that no explicit connection
+ *                             timeout will be used, leaving the
+ *                             timeout to the underlying operating
+ *                             system and its network stack.
+ *
+ *  @sa g_web_get_connect_timeout
+ *
+ */
+void g_web_set_connect_timeout(GWeb *web, guint timeout_ms)
 {
-
-	if (!session->result_func)
+	if (!web)
 		return;
 
-	if (status != 0)
-		session->result.status = status;
-
-	session->result_func(&session->result, session->user_data);
+	debug(web, "timeout %ums", timeout_ms);
 
+	web->connect_timeout_ms = timeout_ms;
 }
 
-static inline void call_route_func(struct web_session *session)
+/**
+ *  @brief
+ *    Set the TCP connection timeout.
+ *
+ *  This sets the TCP connection timeout, in milliseconds, for the
+ *  specified GWeb object.
+ *
+ *  param[in]  web             A pointer to the immutable GWeb object
+ *                             for which the TCP connection timeout is
+ *                             to be returned.
+ *
+ *  @returns
+ *    The TCP connection timeout, in milliseconds. A value of zero
+ *    ('0') indicates that no explicit connection timeout has been
+ *    set, leaving the timeout to the underlying operating system and
+ *    its network stack.
+ *
+ *  @sa g_web_set_connect_timeout
+ *
+ */
+guint g_web_get_connect_timeout(const GWeb *web)
 {
-	if (session->route_func)
-		session->route_func(session->address, session->addr->ai_family,
-				session->web->index, session->user_data);
+	guint timeout_ms = 0;
+
+	if (!web)
+		goto done;
+
+	timeout_ms = web->connect_timeout_ms;
+
+done:
+	return timeout_ms;
 }
 
 static bool process_send_buffer(struct web_session *session)
@@ -729,7 +953,8 @@ static int decode_chunked(struct web_session *session,
 			if (session->chunk_left <= len) {
 				session->result.buffer = ptr;
 				session->result.length = session->chunk_left;
-				call_result_func(session, 0);
+				call_result_func(session,
+					GWEB_HTTP_STATUS_CODE_UNKNOWN);
 
 				len -= session->chunk_left;
 				ptr += session->chunk_left;
@@ -744,7 +969,8 @@ static int decode_chunked(struct web_session *session,
 			/* more data */
 			session->result.buffer = ptr;
 			session->result.length = len;
-			call_result_func(session, 0);
+			call_result_func(session,
+				GWEB_HTTP_STATUS_CODE_UNKNOWN);
 
 			session->chunk_left -= len;
 			session->total_len += len;
@@ -769,7 +995,8 @@ static int handle_body(struct web_session *session,
 		if (len > 0) {
 			session->result.buffer = buf;
 			session->result.length = len;
-			call_result_func(session, 0);
+			call_result_func(session,
+				GWEB_HTTP_STATUS_CODE_UNKNOWN);
 		}
 		return 0;
 	}
@@ -780,7 +1007,7 @@ static int handle_body(struct web_session *session,
 
 		session->result.buffer = NULL;
 		session->result.length = 0;
-		call_result_func(session, 400);
+		call_result_func(session, GWEB_HTTP_STATUS_CODE_BAD_REQUEST);
 	}
 
 	return err;
@@ -872,11 +1099,13 @@ static gboolean received_data(GIOChannel *channel, GIOCondition cond,
 	gsize bytes_read;
 	GIOStatus status;
 
+	cancel_connect_timeout(session);
+
 	if (cond & (G_IO_NVAL | G_IO_ERR | G_IO_HUP)) {
 		session->transport_watch = 0;
 		session->result.buffer = NULL;
 		session->result.length = 0;
-		call_result_func(session, 400);
+		call_result_func(session, GWEB_HTTP_STATUS_CODE_BAD_REQUEST);
 		return FALSE;
 	}
 
@@ -890,7 +1119,7 @@ static gboolean received_data(GIOChannel *channel, GIOCondition cond,
 		session->transport_watch = 0;
 		session->result.buffer = NULL;
 		session->result.length = 0;
-		call_result_func(session, 0);
+		call_result_func(session, GWEB_HTTP_STATUS_CODE_UNKNOWN);
 		return FALSE;
 	}
 
@@ -1032,7 +1261,41 @@ static inline int bind_socket(int sk, int index, int family)
 	return err;
 }
 
-static int connect_session_transport(struct web_session *session)
+/**
+ *  @brief
+ *    Establish TCP connection for a GWeb session.
+ *
+ *  This attempts to establish a TCP connection for the specified GWeb
+ *  session with the session-specified address family, peer address,
+ *  and bound network interface.
+ *
+ *  @param[in,out]  session             A pointer to the mutable GWeb
+ *                                      session for which to establish
+ *                                      the session transport.
+ *  param[in]       connect_timeout_ms  The time, in milliseconds, for
+ *                                      the TCP connection timeout.
+ *                                      Connections that take longer
+ *                                      than this will be aborted. A
+ *                                      value of zero ('0') indicates
+ *                                      that no explicit connection
+ *                                      timeout will be used, leaving
+ *                                      the timeout to the underlying
+ *                                      operating system and its
+ *                                      network stack.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EIO     If a socket could not be created for the specified
+ *                    session address family, the socket could not be
+ *                    bound to the specified session network
+ *                    interface, or the socket could not connect to
+ *                    the specified session peer address.
+ *  @retval  -ENOMEM  If a GLib transport channel could not be created.
+ *
+ *  @sa close_session_transport
+ *
+ */
+static int connect_session_transport(struct web_session *session,
+			guint connect_timeout_ms)
 {
 	GIOFlags flags;
 	int sk;
@@ -1090,6 +1353,8 @@ static int connect_session_transport(struct web_session *session)
 				G_IO_OUT | G_IO_HUP | G_IO_NVAL | G_IO_ERR,
 						send_data, session);
 
+	add_connect_timeout(session, connect_timeout_ms);
+
 	return 0;
 }
 
@@ -1097,7 +1362,8 @@ static int create_transport(struct web_session *session)
 {
 	int err;
 
-	err = connect_session_transport(session);
+	err = connect_session_transport(session,
+			g_web_get_connect_timeout(session->web));
 	if (err < 0)
 		return err;
 
@@ -1107,101 +1373,824 @@ static int create_transport(struct web_session *session)
 	return 0;
 }
 
-static int parse_url(struct web_session *session,
-				const char *url, const char *proxy)
+/**
+ *  @brief
+ *    Attempt to parse the scheme component from a URL.
+ *
+ *  This attempts to parse the scheme component from the specified URL
+ *  of the provided length at the specified cursor point in the
+ *  URL. If provided, the parsed scheme is copied and
+ *  assigned to @a scheme.
+ *
+ *  @note
+ *    The caller is responsible for deallocating the memory assigned
+ *    to @a *scheme, if provided, on success.
+ *
+ *  @param[in]      url             A pointer to the immutable string,
+ *                                  of length @a url_length, from
+ *                                  which to parse the scheme
+ *                                  component.
+ *  @param[in]      url_length      The length, in bytes, of @a url.
+ *  @param[in,out]  cursor          A pointer to the current parsing
+ *                                  position within @a url at which to
+ *                                  start parsing the scheme. On
+ *                                  success, this is updated to the
+ *                                  first byte past the parsed scheme.
+ *  @param[in,out]  scheme          An optional pointer to storage to
+ *                                  assign a copy of the parsed scheme
+ *                                  on success.
+ *
+ *  @retval  0        If successful.
+ *  @retavl  -EINVAL  If @a url was null, @a url_length was zero, or @a
+ *                    cursor was null.
+ *
+ *  @sa parse_url_components
+ *
+ */
+static int parse_url_scheme(const char *url, size_t url_length,
+						const char **cursor,
+						char **scheme)
 {
-	char *scheme, *host, *port, *path;
+	static const char * const scheme_delimiter = "://";
+	static const size_t scheme_delimiter_length = 3;
+	const char *result;
+	size_t remaining_length;
+	size_t scheme_length = 0;
 
-	scheme = g_strdup(url);
-	if (!scheme)
+	if (!url || !url_length || !cursor)
 		return -EINVAL;
 
-	host = strstr(scheme, "://");
-	if (host) {
-		*host = '\0';
-		host += 3;
+	remaining_length = url_length - (size_t)(*cursor - url);
+	if (remaining_length) {
+		result = memmem(*cursor,
+					remaining_length,
+					scheme_delimiter,
+					scheme_delimiter_length);
+		if (result) {
+			scheme_length = (size_t)(result - *cursor);
 
-		if (strcasecmp(scheme, "https") == 0) {
-			session->port = 443;
-			session->flags |= SESSION_FLAG_USE_TLS;
-		} else if (strcasecmp(scheme, "http") == 0) {
-			session->port = 80;
-		} else {
-			g_free(scheme);
+			if (scheme)
+				*scheme = g_strndup(*cursor, scheme_length);
+
+			*cursor += scheme_length + scheme_delimiter_length;
+		} else if (scheme)
+			*scheme = NULL;
+	} else if (scheme)
+		*scheme = NULL;
+
+	return 0;
+}
+
+/**
+ *  @brief
+ *    Attempt to parse the host component from a URL.
+ *
+ *  This attempts to parse the host component from the specified
+ *  URL of the provided length at the specified cursor point in the
+ *  URL. If provided, the parsed host is copied and assigned to @a
+ *  host.
+ *
+ *  Compliant with RFC 2732, the format of the host component of the
+ *  URL may be one of the following:
+ *
+ *    1. "[\<IPv6 Address>]"
+ *    2. "[\<IPv6 Address>]:<Port>"
+ *    4. "\<IPv4 Address>"
+ *    5. "\<IPv4 Address>:<Port>"
+ *    6. "\<Host Name>"
+ *    7. "\<Host Name>:<Port>"
+ *
+ *  @note
+ *    The caller is responsible for deallocating the memory assigned
+ *    to @a *host, if provided, on success.
+ *
+ *  @param[in]      url             A pointer to the immutable string,
+ *                                  of length @a url_length, from
+ *                                  which to parse the host
+ *                                  component.
+ *  @param[in]      url_length      The length, in bytes, of @a url.
+ *  @param[in,out]  cursor          A pointer to the current parsing
+ *                                  position within @a url at which to
+ *                                  start parsing the host. On
+ *                                  success, this is updated to the
+ *                                  first byte past the parsed host.
+ *  @param[in,out]  host            An optional pointer to storage to
+ *                                  assign a copy of the parsed host
+ *                                  on success.
+ *
+ *  @retval  0        If successful.
+ *  @retavl  -EINVAL  If @a url was null, @a url_length was zero, @a
+ *                    cursor was null, or if the host portion of @a
+ *                    url is malformed.
+ *
+ *  @sa parse_url_host_and_port
+ *  @sa parse_url_components
+ *
+ */
+static int parse_url_host(const char *url, size_t url_length,
+						const char **cursor,
+						char **host)
+{
+	static char port_delimiter = ':';
+	static char path_delimiter = '/';
+	size_t remaining_length;
+	size_t host_length	= 0;
+	const char *result;
+	const char *opening_bracket;
+	const char *closing_bracket;
+	int err = 0;
+
+	if (!url || !url_length || !cursor)
+		return -EINVAL;
+
+	/*
+	 * Since it's the easiest to detect, first rule out an IPv6
+	 * address. The only reliably way to do so is to search for the
+	 * delimiting '[' and ']'. Searching for ':' may incorrectly yield
+	 * one of the other forms above (for example, (2), (5), or (7)).
+	 */
+	remaining_length = url_length - (size_t)(*cursor - url);
+
+	opening_bracket = memchr(*cursor, '[', remaining_length);
+	if (opening_bracket) {
+		/*
+		 * We found an opening bracket; this might be an IPv6
+		 * address. Search for its peer closing bracket.
+		 */
+		remaining_length = url_length - (size_t)(opening_bracket - url);
+
+		closing_bracket = memchr(opening_bracket,
+								']',
+								remaining_length);
+		if (!closing_bracket)
 			return -EINVAL;
-		}
+
+		/*
+		 * Assign the first character of the IPv6 address after the
+		 * opening bracket up to, but not including, the closing
+		 * bracket to the host name.
+		 */
+		host_length = closing_bracket - opening_bracket - 1;
+
+		if (host_length && host)
+			*host = g_strndup(opening_bracket + 1, host_length);
 	} else {
-		host = scheme;
-		session->port = 80;
-	}
+		/*
+		 * At this point, we either have an IPv4 address or a host
+		 * name, maybe with a port and maybe with a path.
+		 *
+		 * Whether we have a port or not, we definitively know where
+		 * the IPv4 address or host name ends. If we have a port, it
+		 * ends at the port delimiter, ':'. If we don't have a port,
+		 * then it ends at the end of the string or at the path
+		 * delimiter, if any.
+		 */
+		result = memchr(*cursor, port_delimiter, remaining_length);
+
+		/*
+		 * There was no port delimiter; attempt to find a path
+		 * delimiter.
+		 */
+		if (!result)
+			result = memchr(*cursor, path_delimiter, remaining_length);
+
+		/*
+		 * Whether stopping at the port or path delimiter, if we had a
+		 * result, the end of the host is the span from the cursor to
+		 * that result. Otherwise, it is simply the remaining length
+		 * of the string.
+		 */
+		if (result)
+			host_length = result - *cursor;
+		else
+			host_length = remaining_length;
 
-	path = strchr(host, '/');
-	if (path)
-		*(path++) = '\0';
+		if (host_length && host)
+			*host = g_strndup(*cursor, host_length);
+	}
 
-	if (!proxy)
-		session->request = g_strdup_printf("/%s", path ? path : "");
+	if (!host_length)
+		err = -EINVAL;
 	else
-		session->request = g_strdup(url);
+		*cursor += host_length;
+
+	return err;
+}
+
+/**
+ *  @brief
+ *    Attempt to parse the port component from a URL.
+ *
+ *  This attempts to parse the port component from the specified URL
+ *  of the provided length at the specified cursor point in the
+ *  URL. If provided, the parsed port is assigned to @a port.
+ *
+ *  Compliant with RFC 2732, the format of the host component of the
+ *  URL may be one of the following:
+ *
+ *    1. "[\<IPv6 Address>]"
+ *    2. "[\<IPv6 Address>]:<Port>"
+ *    4. "\<IPv4 Address>"
+ *    5. "\<IPv4 Address>:<Port>"
+ *    6. "\<Host Name>"
+ *    7. "\<Host Name>:<Port>"
+ *
+ *  @param[in]      url             A pointer to the immutable string,
+ *                                  of length @a url_length, from
+ *                                  which to parse the port
+ *                                  component.
+ *  @param[in]      url_length      The length, in bytes, of @a url.
+ *  @param[in,out]  cursor          A pointer to the current parsing
+ *                                  position within @a url at which to
+ *                                  start parsing the port. On
+ *                                  success, this is updated to the
+ *                                  first byte past the parsed port.
+ *  @param[in,out]  port            An optional pointer to storage to
+ *                                  assign the parsed port on
+ *                                  success. On failure or absence of
+ *                                  a port to parsed, this is assigned
+ *                                  -1.
+ *
+ *  @retval  0        If successful.
+ *  @retavl  -EINVAL  If @a url was null, @a url_length was zero, @a
+ *                    cursor was null, or if there were no characters
+ *                    to parse after the port delimiter (':').
+ *  @retval  -ERANGE  If the parsed port was outside of the range [0,
+ *                    65535], inclusive.
+ *
+ *  @sa parse_url_host_and_port
+ *  @sa parse_url_components
+ *
+ */
+static int parse_url_port(const char *url, size_t url_length,
+						const char **cursor,
+						int16_t *port)
+{
+	static char port_delimiter = ':';
+	static const size_t port_delimiter_length = 1;
+	const char *result;
+	size_t remaining_length;
+	size_t port_length = 0;
+	char *end;
+	unsigned long tmp_port;
+
+	if (!url || !url_length || !cursor)
+		return -EINVAL;
+
+	remaining_length = url_length - (size_t)(*cursor - url);
+
+	result = memchr(*cursor, port_delimiter, remaining_length);
+	if (result) {
+		tmp_port = strtoul(result + port_delimiter_length, &end, 10);
+		if (tmp_port == ULONG_MAX)
+			return -ERANGE;
+		else if (tmp_port > UINT16_MAX)
+			return -ERANGE;
+		else if (result + port_delimiter_length == end)
+			return -EINVAL;
+
+		port_length = end - (result + port_delimiter_length);
+
+		*cursor += port_length;
+	} else
+		tmp_port = -1;
+
+	if (port)
+		*port = (int16_t)tmp_port;
+
+	return 0;
+}
+
+/**
+ *  @brief
+ *    Attempt to parse the host and port components from a URL.
+ *
+ *  This attempts to parse the host and port components from the
+ *  specified URL of the provided length at the specified cursor point
+ *  in the URL. If provided, the parsed host is copied and assigned to
+ *  @a host and, if provided, the parsed port is assigned to @a port.
+ *
+ *  Compliant with RFC 2732, the format of the host component of the
+ *  URL may be one of the following:
+ *
+ *    1. "[\<IPv6 Address>]"
+ *    2. "[\<IPv6 Address>]:<Port>"
+ *    4. "\<IPv4 Address>"
+ *    5. "\<IPv4 Address>:<Port>"
+ *    6. "\<Host Name>"
+ *    7. "\<Host Name>:<Port>"
+ *
+ *  @note
+ *    The caller is responsible for deallocating the memory assigned
+ *    to @a *host, if provided, on success.
+ *
+ *  @param[in]      url             A pointer to the immutable string,
+ *                                  of length @a url_length, from
+ *                                  which to parse the host and port
+ *                                  components.
+ *  @param[in]      url_length      The length, in bytes, of @a url.
+ *  @param[in,out]  cursor          A pointer to the current parsing
+ *                                  position within @a url at which to
+ *                                  start parsing the host and
+ *                                  port. On success, this is updated
+ *                                  to the first byte past the parsed
+ *                                  host or port, if present.
+ *  @param[in,out]  host            An optional pointer to storage to
+ *                                  assign a copy of the parsed host
+ *                                  on success.
+ *  @param[in,out]  port            An optional pointer to storage to
+ *                                  assign the parsed port on
+ *                                  success. On failure or absence of
+ *                                  a port to parsed, this is assigned
+ *                                  -1.
+ *
+ *  @retval  0        If successful.
+ *  @retavl  -EINVAL  If @a url was null, @a url_length was zero, @a
+ *                    cursor was null, if the host portion of @a url
+ *                    is malformed, or if there were no characters to
+ *                    parse after the port delimiter (':').
+ *  @retval  -ERANGE  If the parsed port was outside of the range [0,
+ *                    65535], inclusive.
+ *
+ *  @sa parse_url_host
+ *  @sa parse_url_port
+ *  @sa parse_url_components
+ *
+ */
+static int parse_url_host_and_port(const char *url, size_t url_length,
+						const char **cursor,
+						char **host,
+						int16_t *port)
+{
+	g_autofree char *temp_host = NULL;
+	int err = 0;
+
+	if (!url || !url_length || !cursor)
+		return -EINVAL;
+
+	/* Attempt to handle the host component. */
+
+	err = parse_url_host(url, url_length, cursor, &temp_host);
+	if (err != 0)
+		goto done;
+
+	/* Attempt to handle the port component. */
+
+	err = parse_url_port(url, url_length, cursor, port);
+	if (err != 0)
+		goto done;
+
+	if (host)
+		*host = g_steal_pointer(&temp_host);
+
+done:
+	return err;
+}
+
+/**
+ *  @brief
+ *    Attempt to parse the path component from a URL.
+ *
+ *  This attempts to parse the path component from the specified
+ *  URL of the provided length at the specified cursor point in the
+ *  URL. If provided, the parsed path is copied and assigned to @a
+ *  path.
+ *
+ *  @note
+ *    The caller is responsible for deallocating the memory assigned
+ *    to @a *path, if provided, on success.
+ *
+ *  @param[in]      url             A pointer to the immutable string,
+ *                                  of length @a url_length, from
+ *                                  which to parse the path
+ *                                  component.
+ *  @param[in]      url_length      The length, in bytes, of @a url.
+ *  @param[in,out]  cursor          A pointer to the current parsing
+ *                                  position within @a url at which to
+ *                                  start parsing the path. On
+ *                                  success, this is updated to the
+ *                                  first byte past the parsed path.
+ *  @param[in,out]  path            An optional pointer to storage to
+ *                                  assign a copy of the parsed path
+ *                                  on success.
+ *
+ *  @retval  0        If successful.
+ *  @retavl  -EINVAL  If @a url was null, @a url_length was zero, or @a
+ *                    cursor was null.
+ *
+ *  @sa parse_url_components
+ *
+ */
+static int parse_url_path(const char *url, size_t url_length,
+						const char **cursor,
+						char **path)
+{
+	static char path_delimiter = '/';
+	static const size_t path_delimiter_length = 1;
+	const char *result;
+	size_t remaining_length;
+	size_t path_length = 0;
+
+	if (!url || !url_length || !cursor)
+		return -EINVAL;
+
+	remaining_length = url_length - (size_t)(*cursor - url);
+
+	result = memchr(*cursor, path_delimiter, remaining_length);
+	if (result) {
+		path_length = url_length -
+			(size_t)(result + path_delimiter_length - url);
+
+		if (path)
+			*path = g_strndup(result + path_delimiter_length, path_length);
+
+		*cursor += path_length + path_delimiter_length;
+	} else if (path)
+		*path = NULL;
+
+	return 0;
+}
+
+/**
+ *  @brief
+ *    Attempt to parse the scheme, host, port, and path components
+ *    from a URL.
+ *
+ *  This attempts to parse the scheme, host, port, and path components
+ *  from the specified URL. If provided, the parsed scheme, host and
+ *  path are copied and assigned to @a scheme, @a host, and @a path,
+ *  respective and the parsed port is assigned to @a port.
+ *
+ *  Compliant with RFC 2732, the format of the host component of the
+ *  URL may be one of the following:
+ *
+ *    1. "[\<IPv6 Address>]"
+ *    2. "[\<IPv6 Address>]:<Port>"
+ *    4. "\<IPv4 Address>"
+ *    5. "\<IPv4 Address>:<Port>"
+ *    6. "\<Host Name>"
+ *    7. "\<Host Name>:<Port>"
+ *
+ *  @param[in]      url             A pointer to the immutable null-
+ *                                  terminated C string from which to
+ *                                  parse the scheme, host, port, and
+ *                                  path components.
+ *  @param[in,out]  scheme          An optional pointer to storage to
+ *                                  assign a copy of the parsed scheme
+ *                                  on success.
+ *  @param[in,out]  host            An optional pointer to storage to
+ *                                  assign a copy of the parsed host
+ *                                  on success.
+ *  @param[in,out]  port            An optional pointer to storage to
+ *                                  assign the parsed port on
+ *                                  success. On failure or absence of
+ *                                  a port to parsed, this is assigned
+ *                                  -1.
+ *  @param[in,out]  path            An optional pointer to storage to
+ *                                  assign a copy of the parsed path
+ *                                  on success.
+ *
+ *  @retval  0        If successful.
+ *  @retavl  -EINVAL  If @a url was null, @a url length was zero, if
+ *                    the host portion of @a url is malformed, or if
+ *                    there were no characters to parse after the port
+ *                    delimiter (':').
+ *  @retval  -ERANGE  If the parsed port was outside of the range [0,
+ *                    65535], inclusive.
+ *
+ *  @sa parse_url_scheme_with_default
+ *  @sa parse_url_scheme
+ *  @sa parse_url_host
+ *  @sa parse_url_port
+ *  @sa parse_url_host_and_port
+ *  @sa parse_url_path
+ *
+ */
+static int parse_url_components(const char *url,
+						char **scheme,
+						char **host,
+						int16_t *port,
+						char **path)
+{
+	size_t total_length;
+	const char *p;
+	g_autofree char *temp_scheme = NULL;
+	g_autofree char *temp_host = NULL;
+	int err = 0;
+
+	if (!url)
+		return -EINVAL;
+
+	p = url;
+
+	total_length = strlen(p);
+	if (!total_length)
+		return -EINVAL;
+
+	/* Skip any leading space, if any. */
+
+	while (g_ascii_isspace(*p))
+		p++;
+
+	/* Attempt to handle the scheme component. */
+
+	err = parse_url_scheme(url, total_length, &p, &temp_scheme);
+	if (err != 0)
+		goto done;
+
+	/* Attempt to handle the host component. */
+
+	err = parse_url_host_and_port(url, total_length, &p, &temp_host, port);
+	if (err != 0)
+		goto done;
+
+	/* Attempt to handle the path component. */
+
+	err = parse_url_path(url, total_length, &p, path);
+	if (err != 0)
+		goto done;
+
+	if (scheme)
+		*scheme = g_steal_pointer(&temp_scheme);
+
+	if (host)
+		*host = g_steal_pointer(&temp_host);
+
+done:
+	return err;
+}
+
+/**
+ *	@brief
+ *	  Attempt to parse the request URL for the web request session.
+ *
+ *	This attempts to parse the specified request URL for the specified
+ *	web request session. From the request URL, the scheme is parsed,
+ *	mapped and assigned to the @a session port field and the host and
+ *	path are parsed, copied, and assigned to the host and request
+ *	fields, respectively.
+ *
+ *	Compliant with RFC 2732, the format of the host component of the
+ *	request and proxy URLs may be one of the following:
+ *
+ *	  1. "[\<IPv6 Address>]"
+ *	  2. "[\<IPv6 Address>]:<Port>"
+ *	  4. "\<IPv4 Address>"
+ *	  5. "\<IPv4 Address>:<Port>"
+ *	  6. "\<Host Name>"
+ *	  7. "\<Host Name>:<Port>"
+ *
+ *	@note
+ *	  The caller is responsible for deallocating the memory assigned
+ *	  to the @a session host, request, and address fields.
+ *
+ *	@param[in,out]	session	     A pointer to the mutable web session
+ *							     request object to be populated from
+ *							     @a url and, if provided, @a proxy. On
+ *							     success, the session port, host,
+ *							     request, and address fields will be
+ *							     populated from the parsed request URL.
+ *	@param[in]		request_url  A pointer to the immutable null-
+ *							     terminated C string containing the
+ *							     request URL to parse.
+ *
+ *	@retval	 0		  If successful.
+ *	@retval	 -EINVAL  If @request_url was not a valid URL.
+ *
+ *  @sa parse_url_components
+ *
+ */
+static int parse_request_url(struct web_session *session,
+				const char *request_url, bool has_proxy_url)
+{
+	g_autofree char *scheme = NULL;
+	g_autofree char *host = NULL;
+	g_autofree char *path = NULL;
+	int16_t port = -1;
+	int err = 0;
 
-	port = strrchr(host, ':');
-	if (port) {
-		char *end;
-		int tmp = strtol(port + 1, &end, 10);
+	if (!session || !request_url)
+		return -EINVAL;
 
-		if (*end == '\0') {
-			*port = '\0';
-			session->port = tmp;
+	/* Parse the request URL components. */
+
+	err = parse_url_components(request_url,
+			&scheme,
+			&host,
+			&port,
+			&path);
+	if (err != 0)
+		goto done;
+
+	/*
+	 * Handle the URL scheme, if any, for the session, defaulting to
+	 * the "http" scheme and port 80.
+	 */
+	if (scheme) {
+		if (g_ascii_strcasecmp(scheme, "https") == 0)
+			session->port = 443;
+		else if (g_ascii_strcasecmp(scheme, "http") == 0)
+			session->port = 80;
+		else {
+			err = -EINVAL;
+			goto done;
 		}
+	} else
+		session->port = 80;
+
+	/* Handle the URL host and port, if any, for the session. */
+
+	if (port != -1) {
+		session->port = port;
 
-		if (!proxy)
+		if (!has_proxy_url)
 			session->host = g_strdup(host);
 		else
-			session->host = g_strdup_printf("%s:%u", host, tmp);
+			session->host = g_strdup_printf("%s:%u", host, port);
 	} else
 		session->host = g_strdup(host);
 
-	g_free(scheme);
+	/* Handle the URL path, if any, for the session. */
 
-	if (!proxy)
-		return 0;
+	if (!has_proxy_url)
+		session->request = g_strdup_printf("/%s", path ? path : "");
+	else
+		session->request = g_strdup(request_url);
+
+done:
+	return err;
+}
 
-	scheme = g_strdup(proxy);
-	if (!scheme)
+/**
+ *	@brief
+ *	  Attempt to parse the proxy URL for the web request session.
+ *
+ *	This attempts to parse the specified proxy URL for the specified
+ *	web request session. From the proxy URL, the port component is
+ *	parsed and assigned to the @a session port field and the host
+ *	component is parsed, copied, and assigned to the address field.
+ *
+ *	Compliant with RFC 2732, the format of the host component of the
+ *	request and proxy URLs may be one of the following:
+ *
+ *	  1. "[\<IPv6 Address>]"
+ *	  2. "[\<IPv6 Address>]:<Port>"
+ *	  4. "\<IPv4 Address>"
+ *	  5. "\<IPv4 Address>:<Port>"
+ *	  6. "\<Host Name>"
+ *	  7. "\<Host Name>:<Port>"
+ *
+ *	@note
+ *	  The caller is responsible for deallocating the memory assigned
+ *	  to the @a session address field.
+ *
+ *	@param[in,out]	session	     A pointer to the mutable web session
+ *							     request object to be populated from
+ *							     @a url and, if provided, @a proxy. On
+ *							     success, the session port and address
+ *							     fields will be populated from the
+ *							     parsed proxy URL.
+ *	@param[in]		proxy_url    A pointer to the immutable null-
+ *							     terminated C string containing the
+ *							     web proxy URL to parse.
+ *
+ *	@retval	 0		  If successful.
+ *	@retval	 -EINVAL  If @a proxy_url was not a valid URL.
+ *
+ *  @sa parse_url_scheme
+ *  @sa parse_url_host_and_port
+ *
+ */
+static int parse_proxy_url(struct web_session *session, const char *proxy_url)
+{
+	const char *p;
+	size_t proxy_length;
+	g_autofree char *scheme = NULL;
+	g_autofree char *host = NULL;
+	int16_t port = -1;
+	int err = 0;
+
+	if (!session || !proxy_url)
 		return -EINVAL;
 
-	host = strstr(proxy, "://");
-	if (host) {
-		*host = '\0';
-		host += 3;
+	/*
+	 * Parse the proxy URL scheme, host, and port, the only three
+	 * components we care about.
+	 */
+	p = proxy_url;
+	proxy_length = strlen(p);
+
+	err = parse_url_scheme(proxy_url,
+			proxy_length,
+			&p,
+			&scheme);
+	if (err != 0)
+		goto done;
+
+	err = parse_url_host_and_port(proxy_url,
+			proxy_length,
+			&p,
+			&host,
+			&port);
+	if (err != 0)
+		goto done;
+
+	/*
+	 * Handle the proxy URL scheme, if any, for the session. Only
+	 * "http" is allowed.
+	 */
+	if (scheme && g_ascii_strcasecmp(scheme, "http") != 0) {
+		err = -EINVAL;
+		goto done;
+	}
 
-		if (strcasecmp(scheme, "http") != 0) {
-			g_free(scheme);
-			return -EINVAL;
-		}
-	} else
-		host = scheme;
+	/*
+	 * Handle the proxy URL host and port for the session.
+	 */
+	if (host)
+		session->address = host;
 
-	path = strchr(host, '/');
-	if (path)
-		*(path++) = '\0';
+	if (port != -1)
+		session->port = port;
 
-	port = strrchr(host, ':');
-	if (port) {
-		char *end;
-		int tmp = strtol(port + 1, &end, 10);
+done:
+	return err;
+}
 
-		if (*end == '\0') {
-			*port = '\0';
-			session->port = tmp;
-		}
-	}
+/**
+ *  @brief
+ *    Attempt to parse the request and proxy URLs for the web request
+ *    session.
+ *
+ *  This attempts to parse the specified request and optional proxy
+ *  URL for the specified web request session. From the request URL,
+ *  the scheme is parsed, mapped and assigned to the @a session port
+ *  field and the host and path are parsed, copied, and assigned to
+ *  the host and request fields, respectively. From the proxy URL, if
+ *  present, the port component is parsed and assigned to the @a
+ *  session port field and the host component is parsed, copied, and
+ *  assigned to the address field.
+ *
+ *  Compliant with RFC 2732, the format of the host component of the
+ *  request and proxy URLs may be one of the following:
+ *
+ *    1. "[\<IPv6 Address>]"
+ *    2. "[\<IPv6 Address>]:<Port>"
+ *    4. "\<IPv4 Address>"
+ *    5. "\<IPv4 Address>:<Port>"
+ *    6. "\<Host Name>"
+ *    7. "\<Host Name>:<Port>"
+ *
+ *  @note
+ *    The caller is responsible for deallocating the memory assigned
+ *    to the @a session host, request, and address fields.
+ *
+ *  @param[in,out]  session  A pointer to the mutable web session request
+ *                           object to be populated from @a url and,
+ *                           if provided, @a proxy. On success, the
+ *                           session port, host, request, and address
+ *                           fields will be populated from the parsed
+ *                           request URL and/or proxy URLs.
+ *  @param[in]      url      A pointer to the immutable null-terminated
+ *                           C string containing the request URL to
+ *                           parse.
+ *  @param[in]      proxy    An optional pointer to the immutable null-
+ *                           terminated C string containing the web
+ *                           proxy URL, if any, to parse.
+ *
+ *  @retval  0         If successful.
+ *  @retval  -EINVAL  If @url was not a valid URL.
+ *
+ *  @sa parse_request_url
+ *  @sa parse_proxy_url
+ *
+ */
+static int parse_request_and_proxy_urls(struct web_session *session,
+				const char *url, const char *proxy)
+{
+	const bool has_proxy_url = (proxy != NULL);
+	int err = 0;
 
-	session->address = g_strdup(host);
+	if (!session || !url)
+		return -EINVAL;
 
-	g_free(scheme);
+	/* Parse and handle the request URL */
 
-	return 0;
+	err = parse_request_url(session, url, has_proxy_url);
+	if (err != 0)
+		goto done;
+
+	if (!has_proxy_url)
+		goto done;
+
+	/* Parse and handle the proxy URL */
+
+	err = parse_proxy_url(session, proxy);
+	if (err != 0)
+		goto done;
+
+done:
+	return err;
 }
 
 static void handle_resolved_address(struct web_session *session)
@@ -1225,14 +2214,14 @@ static void handle_resolved_address(struct web_session *session)
 	ret = getaddrinfo(session->address, port, &hints, &session->addr);
 	g_free(port);
 	if (ret != 0 || !session->addr) {
-		call_result_func(session, 400);
+		call_result_func(session, GWEB_HTTP_STATUS_CODE_BAD_REQUEST);
 		return;
 	}
 
 	call_route_func(session);
 
 	if (create_transport(session) < 0) {
-		call_result_func(session, 409);
+		call_result_func(session, GWEB_HTTP_STATUS_CODE_CONFLICT);
 		return;
 	}
 }
@@ -1253,7 +2242,7 @@ static void resolv_result(GResolvResultStatus status,
 	struct web_session *session = user_data;
 
 	if (!results || !results[0]) {
-		call_result_func(session, 404);
+		call_result_func(session, GWEB_HTTP_STATUS_CODE_NOT_FOUND);
 		return;
 	}
 
@@ -1283,23 +2272,31 @@ static bool is_ip_address(const char *host)
 static guint do_request(GWeb *web, const char *url,
 				const char *type, GWebInputFunc input,
 				int fd, gsize length, GWebResultFunc func,
-				GWebRouteFunc route, gpointer user_data)
+				GWebRouteFunc route, gpointer user_data,
+				int *err)
 {
 	struct web_session *session;
 	const gchar *host;
+	int request_id = 0;
+	int status = 0;
 
-	if (!web || !url)
-		return 0;
+	if (!web || !url) {
+		status = -EINVAL;
+		goto done;
+	}
 
 	debug(web, "request %s", url);
 
 	session = g_try_new0(struct web_session, 1);
-	if (!session)
-		return 0;
+	if (!session) {
+		status = -ENOMEM;
+		goto done;
+	}
 
-	if (parse_url(session, url, web->proxy) < 0) {
+	status = parse_request_and_proxy_urls(session, url, web->proxy);
+	if (status < 0) {
 		free_session(session);
-		return 0;
+		goto done;
 	}
 
 	debug(web, "proxy host %s", session->address);
@@ -1327,14 +2324,16 @@ static guint do_request(GWeb *web, const char *url,
 	session->receive_buffer = g_try_malloc(DEFAULT_BUFFER_SIZE);
 	if (!session->receive_buffer) {
 		free_session(session);
-		return 0;
+		status = -ENOMEM;
+		goto done;
 	}
 
 	session->result.headers = g_hash_table_new_full(g_str_hash, g_str_equal,
 							g_free, g_free);
 	if (!session->result.headers) {
 		free_session(session);
-		return 0;
+		status = -ENOMEM;
+		goto done;
 	}
 
 	session->receive_space = DEFAULT_BUFFER_SIZE;
@@ -1353,33 +2352,52 @@ static guint do_request(GWeb *web, const char *url,
 	} else {
 		session->resolv_action = g_resolv_lookup_hostname(web->resolv,
 					host, resolv_result, session);
-		if (session->resolv_action == 0) {
+		if (session->resolv_action <= 0) {
 			free_session(session);
-			return 0;
+			/*
+			 * While the return signature of #g_resolv_lookup_hostname
+			 * is 'guint', it overloads this, treating it as 'int' and
+			 * does potentially return -EIO. Consequently, apply the
+			 * 'int' casts to handle these cases.
+			 */
+			status = (int)session->resolv_action < 0 ?
+						(int)session->resolv_action :
+						-ENOENT;
+			goto done;
 		}
 	}
 
 	web->session_list = g_list_append(web->session_list, session);
 
-	return web->next_query_id++;
+	request_id = web->next_query_id++;
+
+done:
+	if (err)
+		*err = status;
+
+	return request_id;
 }
 
 guint g_web_request_get(GWeb *web, const char *url, GWebResultFunc func,
-		GWebRouteFunc route, gpointer user_data)
+		GWebRouteFunc route, gpointer user_data, int *err)
 {
-	return do_request(web, url, NULL, NULL, -1, 0, func, route, user_data);
+	return do_request(web, url, NULL, NULL, -1, 0,
+		func, route, user_data, err);
 }
 
 guint g_web_request_post(GWeb *web, const char *url,
 				const char *type, GWebInputFunc input,
-				GWebResultFunc func, gpointer user_data)
+				GWebResultFunc func, gpointer user_data,
+				int *err)
 {
-	return do_request(web, url, type, input, -1, 0, func, NULL, user_data);
+	return do_request(web, url, type, input, -1, 0,
+		func, NULL, user_data, err);
 }
 
 guint g_web_request_post_file(GWeb *web, const char *url,
 				const char *type, const char *file,
-				GWebResultFunc func, gpointer user_data)
+				GWebResultFunc func, gpointer user_data,
+				int *err)
 {
 	struct stat st;
 	int fd;
@@ -1393,7 +2411,7 @@ guint g_web_request_post_file(GWeb *web, const char *url,
 		return 0;
 
 	ret = do_request(web, url, type, NULL, fd, st.st_size, func, NULL,
-			user_data);
+			user_data, err);
 	if (ret == 0)
 		close(fd);
 
diff --git a/gweb/gweb.h b/gweb/gweb.h
index 6c28542a..7c65aebf 100644
--- a/gweb/gweb.h
+++ b/gweb/gweb.h
@@ -31,6 +31,76 @@
 extern "C" {
 #endif
 
+/**
+ *  Hypertext Transfer Protocol (HTTP) Status Code mnemonics.
+ *
+ *  From <https://www.iana.org/assignments/http-status-codes/
+ *  http-status-codes.xhtml>
+ */
+enum GWebStatusCode {
+	GWEB_HTTP_STATUS_CODE_UNKNOWN = 000,
+	GWEB_HTTP_STATUS_CODE_CONTINUE = 100,
+	GWEB_HTTP_STATUS_CODE_SWITCHING_PROTOCOLS = 101,
+	GWEB_HTTP_STATUS_CODE_PROCESSING = 102,
+	GWEB_HTTP_STATUS_CODE_EARLY_HINTS = 103,
+	GWEB_HTTP_STATUS_CODE_OK = 200,
+	GWEB_HTTP_STATUS_CODE_CREATED = 201,
+	GWEB_HTTP_STATUS_CODE_ACCEPTED = 202,
+	GWEB_HTTP_STATUS_CODE_NON_AUTHORITATIVE_INFORMATION = 203,
+	GWEB_HTTP_STATUS_CODE_NO_CONTENT = 204,
+	GWEB_HTTP_STATUS_CODE_RESET_CONTENT = 205,
+	GWEB_HTTP_STATUS_CODE_PARTIAL_CONTENT = 206,
+	GWEB_HTTP_STATUS_CODE_MULTI_STATUS = 207,
+	GWEB_HTTP_STATUS_CODE_ALREADY_REPORTED = 208,
+	GWEB_HTTP_STATUS_CODE_IM_USED = 226,
+	GWEB_HTTP_STATUS_CODE_MULTIPLE_CHOICES = 300,
+	GWEB_HTTP_STATUS_CODE_MOVED_PERMANENTLY = 301,
+	GWEB_HTTP_STATUS_CODE_FOUND = 302,
+	GWEB_HTTP_STATUS_CODE_SEE_OTHER = 303,
+	GWEB_HTTP_STATUS_CODE_NOT_MODIFIED = 304,
+	GWEB_HTTP_STATUS_CODE_USE_PROXY = 305,
+	GWEB_HTTP_STATUS_CODE_TEMPORARY_REDIRECT = 307,
+	GWEB_HTTP_STATUS_CODE_PERMANENT_REDIRECT = 308,
+	GWEB_HTTP_STATUS_CODE_BAD_REQUEST = 400,
+	GWEB_HTTP_STATUS_CODE_UNAUTHORIZED = 401,
+	GWEB_HTTP_STATUS_CODE_PAYMENT_REQUIRED = 402,
+	GWEB_HTTP_STATUS_CODE_FORBIDDEN = 403,
+	GWEB_HTTP_STATUS_CODE_NOT_FOUND = 404,
+	GWEB_HTTP_STATUS_CODE_METHOD_NOT_ALLOWED = 405,
+	GWEB_HTTP_STATUS_CODE_NOT_ACCEPTABLE = 406,
+	GWEB_HTTP_STATUS_CODE_PROXY_AUTHENTICATION_REQUIRED = 407,
+	GWEB_HTTP_STATUS_CODE_REQUEST_TIMEOUT = 408,
+	GWEB_HTTP_STATUS_CODE_CONFLICT = 409,
+	GWEB_HTTP_STATUS_CODE_GONE = 410,
+	GWEB_HTTP_STATUS_CODE_LENGTH_REQUIRED = 411,
+	GWEB_HTTP_STATUS_CODE_PRECONDITION_FAILED = 412,
+	GWEB_HTTP_STATUS_CODE_CONTENT_TOO_LARGE = 413,
+	GWEB_HTTP_STATUS_CODE_URI_TOO_LONG = 414,
+	GWEB_HTTP_STATUS_CODE_UNSUPPORTED_MEDIA_TYPE = 415,
+	GWEB_HTTP_STATUS_CODE_RANGE_NOT_SATISFIABLE = 416,
+	GWEB_HTTP_STATUS_CODE_EXPECTATION_FAILED = 417,
+	GWEB_HTTP_STATUS_CODE_MISDIRECTED_REQUEST = 421,
+	GWEB_HTTP_STATUS_CODE_UNPROCESSABLE_CONTENT = 422,
+	GWEB_HTTP_STATUS_CODE_LOCKED = 423,
+	GWEB_HTTP_STATUS_CODE_FAILED_DEPENDENCY = 424,
+	GWEB_HTTP_STATUS_CODE_TOO_EARLY = 425,
+	GWEB_HTTP_STATUS_CODE_UPGRADE_REQUIRED = 426,
+	GWEB_HTTP_STATUS_CODE_PRECONDITION_REQUIRED = 428,
+	GWEB_HTTP_STATUS_CODE_TOO_MANY_REQUESTS = 429,
+	GWEB_HTTP_STATUS_CODE_REQUEST_HEADER_FIELDS_TOO_LARGE = 431,
+	GWEB_HTTP_STATUS_CODE_UNAVAILABLE_FOR_LEGAL_REASONS = 451,
+	GWEB_HTTP_STATUS_CODE_INTERNAL_SERVER_ERROR = 500,
+	GWEB_HTTP_STATUS_CODE_NOT_IMPLEMENTED = 501,
+	GWEB_HTTP_STATUS_CODE_BAD_GATEWAY = 502,
+	GWEB_HTTP_STATUS_CODE_SERVICE_UNAVAILABLE = 503,
+	GWEB_HTTP_STATUS_CODE_GATEWAY_TIMEOUT = 504,
+	GWEB_HTTP_STATUS_CODE_HTTP_VERSION_NOT_SUPPORTED = 505,
+	GWEB_HTTP_STATUS_CODE_VARIANT_ALSO_NEGOTIATES = 506,
+	GWEB_HTTP_STATUS_CODE_INSUFFICIENT_STORAGE = 507,
+	GWEB_HTTP_STATUS_CODE_LOOP_DETECTED = 508,
+	GWEB_HTTP_STATUS_CODE_NETWORK_AUTHENTICATION_REQUIRED = 511
+};
+
 struct _GWeb;
 struct _GWebResult;
 struct _GWebParser;
@@ -72,18 +142,23 @@ bool g_web_set_ua_profile(GWeb *web, const char *profile);
 
 bool g_web_set_http_version(GWeb *web, const char *version);
 
+void g_web_set_connect_timeout(GWeb *web, guint timeout_ms);
+guint g_web_get_connect_timeout(const GWeb *web);
+
 void g_web_set_close_connection(GWeb *web, bool enabled);
 bool g_web_get_close_connection(GWeb *web);
 
 guint g_web_request_get(GWeb *web, const char *url,
 				GWebResultFunc func, GWebRouteFunc route,
-				gpointer user_data);
+				gpointer user_data, int *err);
 guint g_web_request_post(GWeb *web, const char *url,
 				const char *type, GWebInputFunc input,
-				GWebResultFunc func, gpointer user_data);
+				GWebResultFunc func, gpointer user_data,
+				int *err);
 guint g_web_request_post_file(GWeb *web, const char *url,
 				const char *type, const char *file,
-				GWebResultFunc func, gpointer user_data);
+				GWebResultFunc func, gpointer user_data,
+				int *err);
 
 bool g_web_cancel_request(GWeb *web, guint id);
 
diff --git a/include/inet.h b/include/inet.h
index 9245eef8..5b2015ed 100644
--- a/include/inet.h
+++ b/include/inet.h
@@ -42,8 +42,30 @@ bool connman_inet_is_ifup(int index);
 
 int connman_inet_set_address(int index, struct connman_ipaddress *ipaddress);
 int connman_inet_clear_address(int index, struct connman_ipaddress *ipaddress);
-int connman_inet_add_host_route(int index, const char *host, const char *gateway);
-int connman_inet_del_host_route(int index, const char *host);
+int connman_inet_add_host_route_with_metric(int index,
+					const char *host,
+					const char *gateway,
+					uint32_t metric);
+int connman_inet_del_host_route_with_metric(int index,
+					const char *host,
+					const char *gateway,
+					uint32_t metric);
+int connman_inet_add_host_route(int index,
+					const char *host,
+					const char *gateway);
+int connman_inet_del_host_route(int index,
+					const char *host,
+					const char *gateway);
+int connman_inet_add_network_route_with_metric(int index,
+					const char *host,
+					const char *gateway,
+					uint8_t prefix_len,
+					uint32_t metric);
+int connman_inet_del_network_route_with_metric(int index,
+					const char *host,
+					const char *gateway,
+					uint8_t prefix_len,
+					uint32_t metric);
 int connman_inet_add_network_route(int index, const char *host, const char *gateway,
 					const char *netmask);
 int connman_inet_del_network_route(int index, const char *host);
@@ -56,13 +78,35 @@ int connman_inet_set_ipv6_address(int index,
 		struct connman_ipaddress *ipaddress);
 int connman_inet_clear_ipv6_address(int index,
 					struct connman_ipaddress *ipaddress);
+int connman_inet_add_ipv6_host_route_with_metric(int index,
+					const char *host,
+					const char *gateway,
+					uint32_t metric);
+int connman_inet_del_ipv6_host_route_with_metric(int index,
+					const char *host,
+					const char *gateway,
+					uint32_t metric);
+int connman_inet_add_ipv6_host_route(int index,
+					const char *host,
+					const char *gateway);
+int connman_inet_del_ipv6_host_route(int index,
+					const char *host,
+					const char *gateway);
+int connman_inet_del_ipv6_network_route_with_metric(int index,
+					const char *host,
+					const char *gateway,
+					uint8_t prefix_len,
+					uint32_t metric);
+int connman_inet_add_ipv6_network_route_with_metric(int index,
+					const char *host,
+					const char *gateway,
+					uint8_t prefix_len,
+					uint32_t metric);
 int connman_inet_add_ipv6_network_route(int index, const char *host,
-					const char *gateway, unsigned char prefix_len);
-int connman_inet_add_ipv6_host_route(int index, const char *host,
-						const char *gateway);
+					const char *gateway,
+					unsigned char prefix_len);
 int connman_inet_del_ipv6_network_route(int index, const char *host,
 					unsigned char prefix_len);
-int connman_inet_del_ipv6_host_route(int index, const char *host);
 int connman_inet_clear_ipv6_gateway_address(int index, const char *gateway);
 int connman_inet_set_ipv6_gateway_interface(int index);
 int connman_inet_clear_ipv6_gateway_interface(int index);
diff --git a/include/log.h b/include/log.h
index 8b00e9dc..f4e1e3a1 100644
--- a/include/log.h
+++ b/include/log.h
@@ -49,6 +49,10 @@ void connman_debug(const char *format, ...)
 	}						\
 } while (0)
 
+/**
+ *  Debug-level logging descriptor that may be used to control debug
+ *  output on a per-file or -symbol basis.
+ */
 struct connman_debug_desc {
 	const char *name;
 	const char *file;
@@ -58,28 +62,89 @@ struct connman_debug_desc {
 	unsigned int flags;
 } __attribute__((aligned(8)));
 
-#define CONNMAN_DEBUG_DEFINE(name) \
-	static struct connman_debug_desc __debug_alias_ ## name \
+/**
+ *  @def CONNMAN_DEBUG_DESC_INSTANTIATE(symbol, _name, _file, _flags)
+ *
+ *  @brief
+ *    Convenience preprocessor macro for declaring and instantiating an
+ *    instance of #connmand_debug_desc.
+ *
+ *  @param[in]  symbol   The name of the #connman_debug_desc instance
+ *                       to instantiate.
+ *  @param[in]  _name    An optional pointer to an immutable null-
+ *                       terminated C string containing the name of
+ *                       the #connman_debug_desc- controlled symbol.
+ *  @param[in]  _file    A pointer to an immutable null-terminated C
+ *                       string containing the name of the
+ *                       #connman_debug_desc-controlled source file.
+ *  @param[in]  _flags   Flags that control the interpretation and
+ *                       behavior of the instantiated
+ *                       #connman_debug_desc instance.
+ *
+ */
+#define CONNMAN_DEBUG_DESC_INSTANTIATE(symbol, _name, _file, _flags) \
+	static struct connman_debug_desc symbol \
 	__attribute__((used, section("__debug"), aligned(8))) = { \
-		#name, __FILE__, CONNMAN_DEBUG_FLAG_ALIAS \
-	};
+		.name = _name, .file = _file, .flags = _flags \
+	}
+
+/**
+ *  @def CONNMAN_DEBUG_ALIAS(suffix)
+ *
+ *  @brief
+ *    Convenience preprocessor macro for declaring and instantiating
+ *    an alias (see #CONNMAN_DEBUG_FLAG_ALIAS) instance of
+ *    #connmand_debug_desc.
+ *
+ *  @param[in]  suffix  The suffix to concatenate to the name of the
+ *                      #connman_debug_desc alias instance to
+ *                      instantiate.
+ *
+ */
+#define CONNMAN_DEBUG_ALIAS(suffix) \
+	CONNMAN_DEBUG_DESC_INSTANTIATE(__debug_alias_##suffix, \
+		#suffix, \
+		__FILE__, \
+		CONNMAN_DEBUG_FLAG_ALIAS)
 
 /**
- * DBG:
- * @fmt: format string
- * @arg...: list of arguments
+ *  @def DBG(fmt, arg...)
+ *
+ *  @brief
+ *    Convenience preprocessor macro for declaring an instance of
+ *    #connmand_debug_desc for controlling an invocation of
+ *    #connman_debug with it that includes both the file and function
+ *    name the macro was invoked in.
+ *
+ *  This instantiates a scoped-instance of #connmand_debug_desc and
+ *  then, if that instance has its #CONNMAN_DEBUG_FLAG_PRINT flag
+ *  asserted, invokes a call to #connman_debug with the format:
+ *
+ *    "<file>:<function>() <fmt> ..."
+ *
+ *  where <file> is the preprocessor symbol __FILE__, <function> is
+ *  the preprocessor symbol __func__, <fmt> is from @a fmt, and
+ *  '...' is from @a 'arg...'.
+ *
+ *  @param[in]  fmt      A pointer to an immutable null-terminated C
+ *                       string container the log message, consisting
+ *                       of a printf-style format string composed of
+ *                       zero or more output conversion directives.
+ *  @param[in]  arg...   A variadic argument list, where each
+ *                       argument corresponds with its peer output
+ *                       conversion directive in @a fmt.
+ *
+ *  @sa connman_debug
  *
- * Simple macro around connman_debug() which also include the function
- * name it is called in.
  */
 #define DBG(fmt, arg...) do { \
-	static struct connman_debug_desc __connman_debug_desc \
-	__attribute__((used, section("__debug"), aligned(8))) = { \
-		.file = __FILE__, .flags = CONNMAN_DEBUG_FLAG_DEFAULT, \
-	}; \
-	if (__connman_debug_desc.flags & CONNMAN_DEBUG_FLAG_PRINT) \
-		connman_debug("%s:%s() " fmt, \
-					__FILE__, __FUNCTION__ , ## arg); \
+	CONNMAN_DEBUG_DESC_INSTANTIATE(__connman_debug_desc, \
+		0, \
+		__FILE__, \
+		CONNMAN_DEBUG_FLAG_DEFAULT); \
+		if (__connman_debug_desc.flags & CONNMAN_DEBUG_FLAG_PRINT) \
+			connman_debug("%s:%s() " fmt, \
+					__FILE__, __func__, ##arg); \
 } while (0)
 
 #ifdef __cplusplus
diff --git a/include/network.h b/include/network.h
index 5bca62ad..2078509e 100644
--- a/include/network.h
+++ b/include/network.h
@@ -81,11 +81,11 @@ connman_network_ref_debug(struct connman_network *network,
 void connman_network_unref_debug(struct connman_network *network,
 			const char *file, int line, const char *caller);
 
-enum connman_network_type connman_network_get_type(struct connman_network *network);
-const char *connman_network_get_identifier(struct connman_network *network);
+enum connman_network_type connman_network_get_type(const struct connman_network *network);
+const char *connman_network_get_identifier(const struct connman_network *network);
 
 void connman_network_set_index(struct connman_network *network, int index);
-int connman_network_get_index(struct connman_network *network);
+int connman_network_get_index(const struct connman_network *network);
 
 void connman_network_set_group(struct connman_network *network,
 						const char *group);
@@ -129,9 +129,6 @@ uint8_t connman_network_get_strength(struct connman_network *network);
 int connman_network_set_frequency(struct connman_network *network,
 					uint16_t frequency);
 uint16_t connman_network_get_frequency(struct connman_network *network);
-int connman_network_set_wifi_channel(struct connman_network *network,
-					uint16_t channel);
-uint16_t connman_network_get_wifi_channel(struct connman_network *network);
 int connman_network_set_autoconnect(struct connman_network *network,
 				bool autoconnect);
 
diff --git a/include/provider.h b/include/provider.h
index 1f120990..3f2e36ad 100644
--- a/include/provider.h
+++ b/include/provider.h
@@ -94,7 +94,7 @@ int connman_provider_indicate_error(struct connman_provider *provider,
 					enum connman_provider_error error);
 
 void connman_provider_set_index(struct connman_provider *provider, int index);
-int connman_provider_get_index(struct connman_provider *provider);
+int connman_provider_get_index(const struct connman_provider *provider);
 
 void connman_provider_set_data(struct connman_provider *provider, void *data);
 void *connman_provider_get_data(struct connman_provider *provider);
diff --git a/include/service.h b/include/service.h
index 8f6b36b4..f194422f 100644
--- a/include/service.h
+++ b/include/service.h
@@ -71,15 +71,23 @@ enum connman_service_state {
 };
 
 enum connman_service_error {
-	CONNMAN_SERVICE_ERROR_UNKNOWN        = 0,
-	CONNMAN_SERVICE_ERROR_OUT_OF_RANGE   = 1,
-	CONNMAN_SERVICE_ERROR_PIN_MISSING    = 2,
-	CONNMAN_SERVICE_ERROR_DHCP_FAILED    = 3,
-	CONNMAN_SERVICE_ERROR_CONNECT_FAILED = 4,
-	CONNMAN_SERVICE_ERROR_LOGIN_FAILED  = 5,
-	CONNMAN_SERVICE_ERROR_AUTH_FAILED    = 6,
-	CONNMAN_SERVICE_ERROR_INVALID_KEY    = 7,
-	CONNMAN_SERVICE_ERROR_BLOCKED        = 8,
+	CONNMAN_SERVICE_ERROR_UNKNOWN             = 0,
+	CONNMAN_SERVICE_ERROR_OUT_OF_RANGE        = 1,
+	CONNMAN_SERVICE_ERROR_PIN_MISSING         = 2,
+	CONNMAN_SERVICE_ERROR_DHCP_FAILED         = 3,
+	CONNMAN_SERVICE_ERROR_CONNECT_FAILED      = 4,
+	CONNMAN_SERVICE_ERROR_LOGIN_FAILED        = 5,
+	CONNMAN_SERVICE_ERROR_AUTH_FAILED         = 6,
+	CONNMAN_SERVICE_ERROR_INVALID_KEY         = 7,
+	CONNMAN_SERVICE_ERROR_BLOCKED             = 8,
+
+	/**
+	 *	In "continuous" online check mode,
+	 *	the back-to-back online check
+	 *	failures threshold was met or
+	 *	exceeded.
+	 */
+	CONNMAN_SERVICE_ERROR_ONLINE_CHECK_FAILED = 9,
 };
 
 enum connman_service_proxy_method {
@@ -114,24 +122,24 @@ connman_service_ref_debug(struct connman_service *service,
 void connman_service_unref_debug(struct connman_service *service,
 			const char *file, int line, const char *caller);
 
-enum connman_service_type connman_service_get_type(struct connman_service *service);
-enum connman_service_state connman_service_get_state(struct connman_service *service);
-char *connman_service_get_interface(struct connman_service *service);
+enum connman_service_type connman_service_get_type(const struct connman_service *service);
+enum connman_service_state connman_service_get_state(const struct connman_service *service);
+char *connman_service_get_interface(const struct connman_service *service);
 
-const char *connman_service_get_identifier(struct connman_service *service);
-const char *connman_service_get_domainname(struct connman_service *service);
-const char *connman_service_get_dbuspath(struct connman_service *service);
-char **connman_service_get_nameservers(struct connman_service *service);
-char **connman_service_get_timeservers_config(struct connman_service *service);
-char **connman_service_get_timeservers(struct connman_service *service);
+const char *connman_service_get_identifier(const struct connman_service *service);
+const char *connman_service_get_domainname(const struct connman_service *service);
+const char *connman_service_get_dbuspath(const struct connman_service *service);
+char **connman_service_get_nameservers(const struct connman_service *service);
+const char * const *connman_service_get_timeservers_config(const struct connman_service *service);
+const char * const *connman_service_get_timeservers(const struct connman_service *service);
 void connman_service_set_proxy_method(struct connman_service *service, enum connman_service_proxy_method method);
-enum connman_service_proxy_method connman_service_get_proxy_method(struct connman_service *service);
+enum connman_service_proxy_method connman_service_get_proxy_method(const struct connman_service *service);
 char **connman_service_get_proxy_servers(struct connman_service *service);
 char **connman_service_get_proxy_excludes(struct connman_service *service);
-const char *connman_service_get_proxy_url(struct connman_service *service);
+const char *connman_service_get_proxy_url(const struct connman_service *service);
 const char *connman_service_get_proxy_autoconfig(struct connman_service *service);
-bool connman_service_get_favorite(struct connman_service *service);
-bool connman_service_get_autoconnect(struct connman_service *service);
+bool connman_service_get_favorite(const struct connman_service *service);
+bool connman_service_get_autoconnect(const struct connman_service *service);
 bool connman_service_set_autoconnect(struct connman_service *service,
 							bool autoconnect);
 
diff --git a/plugins/iwd.c b/plugins/iwd.c
index 2fe49a23..1955140d 100644
--- a/plugins/iwd.c
+++ b/plugins/iwd.c
@@ -90,6 +90,10 @@ struct iwd_device {
 	char *mode;
 
 	struct connman_device *device;
+
+	char *network;
+	char *pending_network;
+	bool disconnecting;
 };
 
 /*
@@ -243,12 +247,6 @@ static void update_network_connected(struct iwd_network *iwdn)
 	connman_network_set_connected(iwdn->network, true);
 }
 
-static void update_network_disconnected(struct iwd_network *iwdn)
-{
-	DBG("interface name %s", iwdn->name);
-	connman_network_set_connected(iwdn->network, false);
-}
-
 static void cm_network_connect_cb(DBusMessage *message, void *user_data)
 {
 	const char *path = user_data;
@@ -279,21 +277,58 @@ static void cm_network_connect_cb(DBusMessage *message, void *user_data)
 	update_network_connected(iwdn);
 }
 
+static void abort_pending_network(struct iwd_device *iwdd,
+					enum connman_network_error error)
+{
+	struct iwd_network *iwdn;
+
+	if (!iwdd->pending_network)
+		return;
+
+	iwdn = g_hash_table_lookup(networks, iwdd->pending_network);
+	if (iwdn)
+		connman_network_set_error(iwdn->network, error);
+
+	g_free(iwdd->pending_network);
+	iwdd->pending_network = NULL;
+}
+
 static int cm_network_connect(struct connman_network *network)
 {
 	struct iwd_network *iwdn = connman_network_get_data(network);
+	struct iwd_device *iwdd;
+	int err;
 
-	if (!iwdn)
+	if (!iwdn || !iwdn->iwdd)
 		return -EINVAL;
 
+	iwdd = iwdn->iwdd;
+	if (iwdd->disconnecting) {
+		if (g_strcmp0(iwdn->path, iwdd->pending_network)) {
+			abort_pending_network(iwdd,
+					CONNMAN_NETWORK_ERROR_CONNECT_FAIL);
+			iwdd->pending_network = g_strdup(iwdn->path);
+		}
+		return -EINPROGRESS;
+	}
+
 	if (!g_dbus_proxy_method_call(iwdn->proxy, "Connect",
 			NULL, cm_network_connect_cb,
-			g_strdup(iwdn->path), g_free))
-		return -EIO;
+			g_strdup(iwdn->path), g_free)) {
+		err = -EIO;
+		goto out;
+	}
 
 	connman_network_set_associating(iwdn->network, true);
 
-	return -EINPROGRESS;
+	g_free(iwdd->network);
+	iwdd->network = g_strdup(iwdn->path);
+
+	err = -EINPROGRESS;
+
+out:
+	abort_pending_network(iwdd, CONNMAN_NETWORK_ERROR_UNKNOWN);
+	return err;
 }
 
 static void cm_network_forget_cb(DBusMessage *message, void *user_data)
@@ -336,6 +371,45 @@ static int cm_network_forget(struct connman_network *network)
 	return 0;
 }
 
+static void update_network_disconnected(struct iwd_network *iwdn)
+{
+	struct iwd_network *iwdn_pending = NULL;
+	struct iwd_device *iwdd;
+
+	if (!iwdn || !iwdn->iwdd)
+		return;
+
+	iwdd = iwdn->iwdd;
+
+	DBG("interface name %s", iwdn->name);
+
+	if (iwdd->pending_network) {
+		iwdn_pending =
+			g_hash_table_lookup(networks, iwdd->pending_network);
+	}
+
+	if (!iwdn_pending || g_strcmp0(iwdn->path, iwdd->pending_network))
+		connman_network_set_connected(iwdn->network, false);
+
+	iwdd->disconnecting = false;
+
+	if (g_strcmp0(iwdn->path, iwdd->network)) {
+		if (!g_strcmp0(iwdn->path, iwdd->pending_network)) {
+			abort_pending_network(iwdd,
+					CONNMAN_NETWORK_ERROR_CONNECT_FAIL);
+		}
+		DBG("current wifi network has changed since disconnection");
+		return;
+	}
+
+	g_free(iwdd->network);
+	iwdd->network = NULL;
+
+	if (iwdn_pending) {
+		cm_network_connect(iwdn_pending->network);
+	}
+}
+
 static void cm_network_disconnect_cb(DBusMessage *message, void *user_data)
 {
 	const char *path = user_data;
@@ -345,6 +419,9 @@ static void cm_network_disconnect_cb(DBusMessage *message, void *user_data)
 	if (!iwdn)
 		return;
 
+	if (iwdn->iwdd)
+		iwdn->iwdd->disconnecting = false;
+
 	if (dbus_message_get_type(message) == DBUS_MESSAGE_TYPE_ERROR) {
 		const char *dbus_error = dbus_message_get_error_name(message);
 
@@ -369,11 +446,16 @@ static int cm_network_disconnect(struct connman_network *network)
 {
 	struct iwd_network *iwdn = connman_network_get_data(network);
 	struct iwd_station *iwds;
+	struct iwd_device *iwdd;
 
-	if (!iwdn && !iwdn->iwdd)
+	if (!iwdn || !iwdn->iwdd)
 		return -EINVAL;
 
-	iwds = g_hash_table_lookup(stations, iwdn->iwdd->path);
+	iwdd = iwdn->iwdd;
+	if (iwdd->disconnecting)
+		return -EALREADY;
+
+	iwds = g_hash_table_lookup(stations, iwdd->path);
 	if (!iwds)
 		return -EIO;
 
@@ -383,6 +465,8 @@ static int cm_network_disconnect(struct connman_network *network)
 			NULL, cm_network_disconnect_cb, g_strdup(iwdn->path), g_free))
 		return -EIO;
 
+	iwdd->disconnecting = true;
+
 	return 0;
 }
 
@@ -582,6 +666,12 @@ static void device_powered_cb(const DBusError *error, void *user_data)
 	}
 
 	connman_device_set_powered(iwdd->device, cbd->powered);
+
+	if (!cbd->powered) {
+		abort_pending_network(iwdd,
+					CONNMAN_NETWORK_ERROR_CONNECT_FAIL);
+		iwdd->disconnecting = false;
+	}
 out:
 	g_free(cbd->path);
 	g_free(cbd);
@@ -1424,6 +1514,10 @@ static void device_free(gpointer data)
 	g_free(iwdd->adapter);
 	g_free(iwdd->name);
 	g_free(iwdd->address);
+
+	g_free(iwdd->network);
+	g_free(iwdd->pending_network);
+
 	g_free(iwdd);
 }
 
diff --git a/plugins/ofono.c b/plugins/ofono.c
index 8bb53949..65a722fd 100644
--- a/plugins/ofono.c
+++ b/plugins/ofono.c
@@ -52,8 +52,6 @@
 #define OFONO_NETREG_INTERFACE		OFONO_SERVICE ".NetworkRegistration"
 #define OFONO_CM_INTERFACE		OFONO_SERVICE ".ConnectionManager"
 #define OFONO_CONTEXT_INTERFACE		OFONO_SERVICE ".ConnectionContext"
-#define OFONO_CDMA_CM_INTERFACE		OFONO_SERVICE ".cdma.ConnectionManager"
-#define OFONO_CDMA_NETREG_INTERFACE	OFONO_SERVICE ".cdma.NetworkRegistration"
 
 #define MODEM_ADDED			"ModemAdded"
 #define MODEM_REMOVED			"ModemRemoved"
@@ -72,8 +70,6 @@ enum ofono_api {
 	OFONO_API_SIM =		0x1,
 	OFONO_API_NETREG =	0x2,
 	OFONO_API_CM =		0x4,
-	OFONO_API_CDMA_NETREG =	0x8,
-	OFONO_API_CDMA_CM =	0x10,
 };
 
 /*
@@ -103,27 +99,6 @@ enum ofono_api {
  * successful the modem is connected to the network. oFono will inform
  * the plugin about IP configuration through the updating the context's
  * properties.
- *
- * CDMA working flow:
- *
- * When a new modem appears, the plugin always powers it up. This
- * allows the plugin to create connman_device either using IMSI either
- * using modem Serial if the modem got a SIM interface or not.
- *
- * As for GSM, the core will call modem_enable() if the technology
- * is enabled. modem_enable() will then set the modem online.
- * If the technology is disabled then modem_disable() will just set the
- * modem offline. The modem is always kept powered all the time.
- *
- * After setting the modem online the plugin waits for CdmaConnectionManager
- * interface to appear. Then, once CdmaNetworkRegistration appears, a new
- * Service will be created and registered at the core.
- *
- * When asked to connect to the network (network_connect()) the plugin
- * will power up the CdmaConnectionManager interface.
- * If the operation is successful the modem is connected to the network.
- * oFono will inform the plugin about IP configuration through the
- * updating CdmaConnectionManager settings properties.
  */
 
 static DBusConnection *connection;
@@ -166,9 +141,6 @@ struct modem_data {
 
 	bool set_powered;
 
-	/* CDMA ConnectionManager Interface */
-	bool cdma_cm_powered;
-
 	/* ConnectionManager Interface */
 	bool attached;
 	bool cm_powered;
@@ -179,7 +151,6 @@ struct modem_data {
 	/* Netreg Interface */
 	char *name;
 	uint8_t strength;
-	uint8_t data_strength; /* 1xEVDO signal strength */
 	bool registered;
 	bool roaming;
 
@@ -198,10 +169,6 @@ static const char *api2string(enum ofono_api api)
 		return "netreg";
 	case OFONO_API_CM:
 		return "cm";
-	case OFONO_API_CDMA_NETREG:
-		return "cdma-netreg";
-	case OFONO_API_CDMA_CM:
-		return "cmda-cm";
 	}
 
 	return "unknown";
@@ -660,63 +627,6 @@ static int context_set_active(struct modem_data *modem,
 	return err;
 }
 
-static void cdma_cm_set_powered_reply(struct modem_data *modem,
-				struct network_context *context, bool success)
-{
-	DBG("%s", context->path);
-
-	if (success) {
-		/*
-		 * Don't handle do anything on success here. oFono will send
-		 * the change via PropertyChanged signal.
-		 */
-		return;
-	}
-
-	/*
-	 * Powered = True might fail due a timeout. That means oFono
-	 * still tries to go online. If we retry to set Powered = True,
-	 * we just get a InProgress error message. Should we power
-	 * cycle the modem in such cases?
-	 */
-
-	if (!context->network) {
-		/*
-		 * In the case where we power down the device
-		 * we don't wait for the reply, therefore the network
-		 * might already be gone.
-		 */
-		return;
-	}
-
-	connman_network_set_error(context->network,
-				CONNMAN_NETWORK_ERROR_ASSOCIATE_FAIL);
-}
-
-static int cdma_cm_set_powered(struct modem_data *modem, dbus_bool_t powered)
-{
-	int err;
-	struct network_context *context = NULL;
-
-	if (!modem->context_list)
-		return -1;
-
-	DBG("%s powered %d", modem->path, powered);
-
-	/* In case of CDMA, there is only one context */
-	context = modem->context_list->data;
-	err = set_property(modem, context, modem->path,
-				OFONO_CDMA_CM_INTERFACE,
-				"Powered", DBUS_TYPE_BOOLEAN,
-				&powered,
-				cdma_cm_set_powered_reply);
-
-	if (!powered && err == -EINPROGRESS)
-		return 0;
-
-	return err;
-}
-
 static int modem_set_online(struct modem_data *modem, dbus_bool_t online)
 {
 	DBG("%s online %d", modem->path, online);
@@ -793,10 +703,6 @@ static uint8_t extract_interfaces(DBusMessageIter *array)
 			interfaces |= OFONO_API_NETREG;
 		else if (g_str_equal(name, OFONO_CM_INTERFACE))
 			interfaces |= OFONO_API_CM;
-		else if (g_str_equal(name, OFONO_CDMA_CM_INTERFACE))
-			interfaces |= OFONO_API_CDMA_CM;
-		else if (g_str_equal(name, OFONO_CDMA_NETREG_INTERFACE))
-			interfaces |= OFONO_API_CDMA_NETREG;
 
 		dbus_message_iter_next(&entry);
 	}
@@ -1018,27 +924,19 @@ out:
 	g_free(gateway);
 }
 
+/*
+ * This functions tests if we have the necessary information gathered
+ * before we are able to create a device.
+ */
 static bool ready_to_create_device(struct modem_data *modem)
 {
-	/*
-	 * There are three different modem types which behave slightly
-	 * different:
-	 * - GSM modems will expose the SIM interface then the
-	 *   CM interface.
-	 * - CDMA modems will expose CM first and sometime later
-	 *   a unique serial number.
-	 *
-	 * This functions tests if we have the necessary information gathered
-	 * before we are able to create a device.
-	 */
-
 	if (modem->device)
 		return false;
 
-	if (modem->imsi || modem->serial)
-		return true;
+	if (!modem->imsi)
+		return false;
 
-	return false;
+	return true;
 }
 
 static void create_device(struct modem_data *modem)
@@ -1050,8 +948,6 @@ static void create_device(struct modem_data *modem)
 
 	if (modem->imsi)
 		ident = modem->imsi;
-	else if (modem->serial)
-		ident = modem->serial;
 
 	if (!connman_dbus_validate_ident(ident))
 		ident = connman_dbus_encode_string(ident);
@@ -1611,22 +1507,6 @@ static void netreg_update_strength(struct modem_data *modem,
 	if (!modem->context_list)
 		return;
 
-	/*
-	 * GSM:
-	 * We don't have 2 signal notifications we always report the strength
-	 * signal. data_strength is always equal to 0.
-	 *
-	 * CDMA:
-	 * In the case we have a data_strength signal (from 1xEVDO network)
-	 * we don't need to update the value with strength signal (from 1xCDMA)
-	 * because the modem is registered to 1xEVDO network for data call.
-	 * In case we have no data_strength signal (not registered to 1xEVDO
-	 * network), we must report the strength signal (registered to 1xCDMA
-	 * network e.g slow mode).
-	 */
-	if (modem->data_strength != 0)
-		return;
-
 	/* For all the context */
 	for (list = modem->context_list; list; list = list->next) {
 		struct network_context *context = list->data;
@@ -1639,39 +1519,6 @@ static void netreg_update_strength(struct modem_data *modem,
 	}
 }
 
-/* Retrieve 1xEVDO Data Strength signal */
-static void netreg_update_datastrength(struct modem_data *modem,
-					DBusMessageIter *value)
-{
-	GSList *list;
-
-	dbus_message_iter_get_basic(value, &modem->data_strength);
-
-	DBG("%s Data Strength %d", modem->path, modem->data_strength);
-
-	if (!modem->context_list)
-		return;
-
-	/*
-	 * CDMA modem is not registered to 1xEVDO network, let
-	 * update_signal_strength() reporting the value on the Strength signal
-	 * notification.
-	 */
-	if (modem->data_strength == 0)
-		return;
-
-	/* For all the context */
-	for (list = modem->context_list; list; list = list->next) {
-		struct network_context *context = list->data;
-
-		if (context->network) {
-			connman_network_set_strength(context->network,
-							modem->data_strength);
-			connman_network_update(context->network);
-		}
-	}
-}
-
 static void netreg_update_status(struct modem_data *modem,
 					DBusMessageIter *value)
 {
@@ -1821,115 +1668,6 @@ static int netreg_get_properties(struct modem_data *modem)
 			netreg_properties_reply, modem);
 }
 
-static void add_cdma_network(struct modem_data *modem)
-{
-	struct network_context *context = NULL;
-	/* Be sure that device is created before adding CDMA network */
-	if (!modem->device)
-		return;
-
-	/*
-	 * CDMA modems don't need contexts for data call, however the current
-	 * add_network() logic needs one, so we create one to proceed.
-	 */
-	if (!modem->context_list) {
-		context = network_context_alloc(modem->path);
-		modem->context_list = g_slist_prepend(modem->context_list,
-							context);
-	} else
-		context = modem->context_list->data;
-
-	if (!modem->name)
-		modem->name = g_strdup("CDMA Network");
-
-	add_network(modem, context);
-
-	if (modem->cdma_cm_powered)
-		set_connected(modem, context);
-}
-
-static gboolean cdma_netreg_changed(DBusConnection *conn,
-					DBusMessage *message,
-					void *user_data)
-{
-	const char *path = dbus_message_get_path(message);
-	struct modem_data *modem;
-	DBusMessageIter iter, value;
-	const char *key;
-
-	DBG("");
-
-	modem = g_hash_table_lookup(modem_hash, path);
-	if (!modem)
-		return TRUE;
-
-	if (modem->ignore)
-		return TRUE;
-
-	if (!dbus_message_iter_init(message, &iter))
-		return TRUE;
-
-	dbus_message_iter_get_basic(&iter, &key);
-
-	dbus_message_iter_next(&iter);
-	dbus_message_iter_recurse(&iter, &value);
-
-	if (g_str_equal(key, "Name"))
-		netreg_update_name(modem, &value);
-	else if (g_str_equal(key, "Strength"))
-		netreg_update_strength(modem, &value);
-	else if (g_str_equal(key, "DataStrength"))
-		netreg_update_datastrength(modem, &value);
-	else if (g_str_equal(key, "Status"))
-		netreg_update_status(modem, &value);
-
-	if (modem->registered)
-		add_cdma_network(modem);
-	else
-		remove_all_networks(modem);
-
-	return TRUE;
-}
-
-static void cdma_netreg_properties_reply(struct modem_data *modem,
-					DBusMessageIter *dict)
-{
-	DBG("%s", modem->path);
-
-	while (dbus_message_iter_get_arg_type(dict) == DBUS_TYPE_DICT_ENTRY) {
-		DBusMessageIter entry, value;
-		const char *key;
-
-		dbus_message_iter_recurse(dict, &entry);
-		dbus_message_iter_get_basic(&entry, &key);
-
-		dbus_message_iter_next(&entry);
-		dbus_message_iter_recurse(&entry, &value);
-
-		if (g_str_equal(key, "Name"))
-			netreg_update_name(modem, &value);
-		else if (g_str_equal(key, "Strength"))
-			netreg_update_strength(modem, &value);
-		else if (g_str_equal(key, "DataStrength"))
-			netreg_update_datastrength(modem, &value);
-		else if (g_str_equal(key, "Status"))
-			netreg_update_status(modem, &value);
-
-		dbus_message_iter_next(dict);
-	}
-
-	if (modem->registered)
-		add_cdma_network(modem);
-	else
-		remove_all_networks(modem);
-}
-
-static int cdma_netreg_get_properties(struct modem_data *modem)
-{
-	return get_properties(modem->path, OFONO_CDMA_NETREG_INTERFACE,
-			cdma_netreg_properties_reply, modem);
-}
-
 static void cm_update_attached(struct modem_data *modem,
 				DBusMessageIter *value)
 {
@@ -1999,67 +1737,6 @@ static gboolean cm_changed(DBusConnection *conn, DBusMessage *message,
 	return TRUE;
 }
 
-static void cdma_cm_update_powered(struct modem_data *modem,
-					DBusMessageIter *value)
-{
-	struct network_context *context =  NULL;
-	dbus_bool_t cdma_cm_powered;
-
-	dbus_message_iter_get_basic(value, &cdma_cm_powered);
-	modem->cdma_cm_powered = cdma_cm_powered;
-
-	DBG("%s CDMA cm Powered %d", modem->path, modem->cdma_cm_powered);
-
-	if (!modem->context_list)
-		return;
-
-	/* In case of CDMA, there is only one context */
-	context = modem->context_list->data;
-	if (modem->cdma_cm_powered)
-		set_connected(modem, context);
-	else
-		set_disconnected(context);
-}
-
-static void cdma_cm_update_settings(struct modem_data *modem,
-					DBusMessageIter *value)
-{
-	DBG("%s Settings", modem->path);
-
-	extract_ipv4_settings(value, modem->context_list->data);
-}
-
-static gboolean cdma_cm_changed(DBusConnection *conn,
-				DBusMessage *message, void *user_data)
-{
-	const char *path = dbus_message_get_path(message);
-	struct modem_data *modem;
-	DBusMessageIter iter, value;
-	const char *key;
-
-	modem = g_hash_table_lookup(modem_hash, path);
-	if (!modem)
-		return TRUE;
-
-	if (modem->online && !modem->context_list)
-		cdma_netreg_get_properties(modem);
-
-	if (!dbus_message_iter_init(message, &iter))
-		return TRUE;
-
-	dbus_message_iter_get_basic(&iter, &key);
-
-	dbus_message_iter_next(&iter);
-	dbus_message_iter_recurse(&iter, &value);
-
-	if (g_str_equal(key, "Powered"))
-		cdma_cm_update_powered(modem, &value);
-	if (g_str_equal(key, "Settings"))
-		cdma_cm_update_settings(modem, &value);
-
-	return TRUE;
-}
-
 static void cm_properties_reply(struct modem_data *modem, DBusMessageIter *dict)
 {
 	DBG("%s", modem->path);
@@ -2089,39 +1766,6 @@ static int cm_get_properties(struct modem_data *modem)
 				cm_properties_reply, modem);
 }
 
-static void cdma_cm_properties_reply(struct modem_data *modem,
-					DBusMessageIter *dict)
-{
-	DBG("%s", modem->path);
-
-	if (modem->online)
-		cdma_netreg_get_properties(modem);
-
-	while (dbus_message_iter_get_arg_type(dict) == DBUS_TYPE_DICT_ENTRY) {
-		DBusMessageIter entry, value;
-		const char *key;
-
-		dbus_message_iter_recurse(dict, &entry);
-		dbus_message_iter_get_basic(&entry, &key);
-
-		dbus_message_iter_next(&entry);
-		dbus_message_iter_recurse(&entry, &value);
-
-		if (g_str_equal(key, "Powered"))
-			cdma_cm_update_powered(modem, &value);
-		if (g_str_equal(key, "Settings"))
-			cdma_cm_update_settings(modem, &value);
-
-		dbus_message_iter_next(dict);
-	}
-}
-
-static int cdma_cm_get_properties(struct modem_data *modem)
-{
-	return get_properties(modem->path, OFONO_CDMA_CM_INTERFACE,
-				cdma_cm_properties_reply, modem);
-}
-
 static void sim_update_imsi(struct modem_data *modem,
 				DBusMessageIter *value)
 {
@@ -2279,25 +1923,11 @@ static void modem_update_interfaces(struct modem_data *modem,
 		}
 	}
 
-	if (api_added(old_ifaces, new_ifaces, OFONO_API_CDMA_CM)) {
-		if (ready_to_create_device(modem)) {
-			create_device(modem);
-			if (modem->registered)
-				add_cdma_network(modem);
-		}
-
-		if (modem->device)
-			cdma_cm_get_properties(modem);
-	}
-
 	if (api_added(old_ifaces, new_ifaces, OFONO_API_NETREG)) {
 		if (modem->attached)
 			netreg_get_properties(modem);
 	}
 
-	if (api_added(old_ifaces, new_ifaces, OFONO_API_CDMA_NETREG))
-		cdma_netreg_get_properties(modem);
-
 	if (api_removed(old_ifaces, new_ifaces, OFONO_API_CM)) {
 		if (modem->call_get_contexts) {
 			DBG("cancelling pending GetContexts call");
@@ -2308,14 +1938,8 @@ static void modem_update_interfaces(struct modem_data *modem,
 		remove_all_contexts(modem);
 	}
 
-	if (api_removed(old_ifaces, new_ifaces, OFONO_API_CDMA_CM))
-		remove_all_contexts(modem);
-
 	if (api_removed(old_ifaces, new_ifaces, OFONO_API_NETREG))
 		remove_all_networks(modem);
-
-	if (api_removed(old_ifaces, new_ifaces, OFONO_API_CDMA_NETREG))
-		remove_all_networks(modem);
 }
 
 static gboolean modem_changed(DBusConnection *conn, DBusMessage *message,
@@ -2345,12 +1969,11 @@ static gboolean modem_changed(DBusConnection *conn, DBusMessage *message,
 		dbus_bool_t powered;
 
 		dbus_message_iter_get_basic(&value, &powered);
+
 		modem->powered = powered;
+		modem->set_powered = powered;
 
 		DBG("%s Powered %d", modem->path, modem->powered);
-
-		/* Set the powered according to the value */
-		modem_set_powered(modem, powered);
 	} else if (g_str_equal(key, "Online")) {
 		dbus_bool_t online;
 
@@ -2385,15 +2008,6 @@ static gboolean modem_changed(DBusConnection *conn, DBusMessage *message,
 		modem->serial = g_strdup(serial);
 
 		DBG("%s Serial %s", modem->path, modem->serial);
-
-		if (has_interface(modem->interfaces,
-					 OFONO_API_CDMA_CM)) {
-			if (ready_to_create_device(modem)) {
-				create_device(modem);
-				if (modem->registered)
-					add_cdma_network(modem);
-			}
-		}
 	}
 
 	return TRUE;
@@ -2717,8 +2331,6 @@ static int network_connect(struct connman_network *network)
 
 	if (has_interface(modem->interfaces, OFONO_API_CM))
 		return context_set_active(modem, context, TRUE);
-	else if (has_interface(modem->interfaces, OFONO_API_CDMA_CM))
-		return cdma_cm_set_powered(modem, TRUE);
 
 	connman_error("Connection manager interface not available");
 
@@ -2741,8 +2353,6 @@ static int network_disconnect(struct connman_network *network)
 
 	if (has_interface(modem->interfaces, OFONO_API_CM))
 		return context_set_active(modem, context, FALSE);
-	else if (has_interface(modem->interfaces, OFONO_API_CDMA_CM))
-		return cdma_cm_set_powered(modem, FALSE);
 
 	connman_error("Connection manager interface not available");
 
@@ -2833,8 +2443,6 @@ static guint context_added_watch;
 static guint context_removed_watch;
 static guint netreg_watch;
 static guint context_watch;
-static guint cdma_cm_watch;
-static guint cdma_netreg_watch;
 
 static int ofono_init(void)
 {
@@ -2907,25 +2515,11 @@ static int ofono_init(void)
 						netreg_changed,
 						NULL, NULL);
 
-	cdma_cm_watch = g_dbus_add_signal_watch(connection, OFONO_SERVICE,
-						NULL, OFONO_CDMA_CM_INTERFACE,
-						PROPERTY_CHANGED,
-						cdma_cm_changed,
-						NULL, NULL);
-
-	cdma_netreg_watch = g_dbus_add_signal_watch(connection, OFONO_SERVICE,
-						NULL, OFONO_CDMA_NETREG_INTERFACE,
-						PROPERTY_CHANGED,
-						cdma_netreg_changed,
-						NULL, NULL);
-
-
 	if (watch == 0 || modem_added_watch == 0 || modem_removed_watch == 0 ||
 			modem_watch == 0 || cm_watch == 0 || sim_watch == 0 ||
 			context_added_watch == 0 ||
 			context_removed_watch == 0 ||
-			context_watch == 0 || netreg_watch == 0 ||
-			cdma_cm_watch == 0 || cdma_netreg_watch == 0) {
+			context_watch == 0 || netreg_watch == 0) {
 		err = -EIO;
 		goto remove;
 	}
@@ -2950,8 +2544,6 @@ static int ofono_init(void)
 	return 0;
 
 remove:
-	g_dbus_remove_watch(connection, cdma_netreg_watch);
-	g_dbus_remove_watch(connection, cdma_cm_watch);
 	g_dbus_remove_watch(connection, netreg_watch);
 	g_dbus_remove_watch(connection, context_watch);
 	g_dbus_remove_watch(connection, context_removed_watch);
@@ -2994,8 +2586,6 @@ static void ofono_exit(void)
 	connman_device_driver_unregister(&modem_driver);
 	connman_network_driver_unregister(&network_driver);
 
-	g_dbus_remove_watch(connection, cdma_netreg_watch);
-	g_dbus_remove_watch(connection, cdma_cm_watch);
 	g_dbus_remove_watch(connection, netreg_watch);
 	g_dbus_remove_watch(connection, context_watch);
 	g_dbus_remove_watch(connection, context_removed_watch);
diff --git a/src/6to4.c b/src/6to4.c
index 71a28827..5542b339 100644
--- a/src/6to4.c
+++ b/src/6to4.c
@@ -318,7 +318,7 @@ static void tun_newlink(unsigned flags, unsigned change, void *user_data)
 			g_web_set_debug(web, web_debug, "6to4");
 
 		web_request_id = g_web_request_get(web, STATUS_URL,
-				web_result, NULL,  NULL);
+				web_result, NULL,  NULL, NULL);
 
 		newlink_timeout(NULL);
 	}
diff --git a/src/config.c b/src/config.c
index 33fdc737..d2832187 100644
--- a/src/config.c
+++ b/src/config.c
@@ -819,6 +819,9 @@ static bool load_service_from_keyfile(GKeyFile *keyfile,
 	groups = g_key_file_get_groups(keyfile, NULL);
 
 	for (i = 0; groups[i]; i++) {
+		if (g_strcmp0(groups[i], "global") == 0)
+			continue;
+
 		if (!g_str_has_prefix(groups[i], "service_")) {
 			connman_warn("Ignore group named '%s' because prefix "
 				"is not 'service_'", groups[i]);
diff --git a/src/connection.c b/src/connection.c
deleted file mode 100644
index 9d2c6961..00000000
--- a/src/connection.c
+++ /dev/null
@@ -1,1127 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007-2013  Intel Corporation. All rights reserved.
- *  Copyright (C) 2011-2014  BMW Car IT GmbH.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <errno.h>
-#include <string.h>
-#include <net/if.h>
-
-#include <gdbus.h>
-
-#include "connman.h"
-
-struct gateway_config {
-	bool active;
-	char *gateway;
-
-	/* VPN extra data */
-	bool vpn;
-	char *vpn_ip;
-	int vpn_phy_index;
-	char *vpn_phy_ip;
-};
-
-struct gateway_data {
-	int index;
-	struct connman_service *service;
-	struct gateway_config *ipv4_gateway;
-	struct gateway_config *ipv6_gateway;
-	bool default_checked;
-};
-
-static GHashTable *gateway_hash = NULL;
-
-static struct gateway_config *find_gateway(int index, const char *gateway)
-{
-	GHashTableIter iter;
-	gpointer value, key;
-
-	if (!gateway)
-		return NULL;
-
-	g_hash_table_iter_init(&iter, gateway_hash);
-
-	while (g_hash_table_iter_next(&iter, &key, &value)) {
-		struct gateway_data *data = value;
-
-		if (data->ipv4_gateway && data->index == index &&
-				g_str_equal(data->ipv4_gateway->gateway,
-					gateway))
-			return data->ipv4_gateway;
-
-		if (data->ipv6_gateway && data->index == index &&
-				g_str_equal(data->ipv6_gateway->gateway,
-					gateway))
-			return data->ipv6_gateway;
-	}
-
-	return NULL;
-}
-
-static struct gateway_data *lookup_gateway_data(struct gateway_config *config)
-{
-	GHashTableIter iter;
-	gpointer value, key;
-
-	if (!config)
-		return NULL;
-
-	g_hash_table_iter_init(&iter, gateway_hash);
-
-	while (g_hash_table_iter_next(&iter, &key, &value)) {
-		struct gateway_data *data = value;
-
-		if (data->ipv4_gateway &&
-				data->ipv4_gateway == config)
-			return data;
-
-		if (data->ipv6_gateway &&
-				data->ipv6_gateway == config)
-			return data;
-	}
-
-	return NULL;
-}
-
-static struct gateway_data *find_vpn_gateway(int index, const char *gateway)
-{
-	GHashTableIter iter;
-	gpointer value, key;
-
-	if (!gateway)
-		return NULL;
-
-	g_hash_table_iter_init(&iter, gateway_hash);
-
-	while (g_hash_table_iter_next(&iter, &key, &value)) {
-		struct gateway_data *data = value;
-
-		if (data->ipv4_gateway && data->index == index &&
-				g_str_equal(data->ipv4_gateway->gateway,
-					gateway))
-			return data;
-
-		if (data->ipv6_gateway && data->index == index &&
-				g_str_equal(data->ipv6_gateway->gateway,
-					gateway))
-			return data;
-	}
-
-	return NULL;
-}
-
-struct get_gateway_params {
-	char *vpn_gateway;
-	int vpn_index;
-};
-
-static void get_gateway_cb(const char *gateway, int index, void *user_data)
-{
-	struct gateway_config *config;
-	struct gateway_data *data;
-	struct get_gateway_params *params = user_data;
-	int family;
-
-	if (index < 0)
-		goto out;
-
-	DBG("phy index %d phy gw %s vpn index %d vpn gw %s", index, gateway,
-		params->vpn_index, params->vpn_gateway);
-
-	data = find_vpn_gateway(params->vpn_index, params->vpn_gateway);
-	if (!data) {
-		DBG("Cannot find VPN link route, index %d addr %s",
-			params->vpn_index, params->vpn_gateway);
-		goto out;
-	}
-
-	family = connman_inet_check_ipaddress(params->vpn_gateway);
-
-	if (family == AF_INET)
-		config = data->ipv4_gateway;
-	else if (family == AF_INET6)
-		config = data->ipv6_gateway;
-	else
-		goto out;
-
-	config->vpn_phy_index = index;
-
-	DBG("vpn %s phy index %d", config->vpn_ip, config->vpn_phy_index);
-
-out:
-	g_free(params->vpn_gateway);
-	g_free(params);
-}
-
-static void set_vpn_routes(struct gateway_data *new_gateway,
-			struct connman_service *service,
-			const char *gateway,
-			enum connman_ipconfig_type type,
-			const char *peer,
-			struct gateway_data *active_gateway)
-{
-	struct gateway_config *config;
-	struct connman_ipconfig *ipconfig;
-	char *dest;
-
-	DBG("new %p service %p gw %s type %d peer %s active %p",
-		new_gateway, service, gateway, type, peer, active_gateway);
-
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV4) {
-		ipconfig = __connman_service_get_ip4config(service);
-		config = new_gateway->ipv4_gateway;
-	} else if (type == CONNMAN_IPCONFIG_TYPE_IPV6) {
-		ipconfig = __connman_service_get_ip6config(service);
-		config = new_gateway->ipv6_gateway;
-	} else
-		return;
-
-	if (config) {
-		int index = __connman_ipconfig_get_index(ipconfig);
-		struct get_gateway_params *params;
-
-		config->vpn = true;
-		if (peer)
-			config->vpn_ip = g_strdup(peer);
-		else if (gateway)
-			config->vpn_ip = g_strdup(gateway);
-
-		params = g_try_malloc(sizeof(struct get_gateway_params));
-		if (!params)
-			return;
-
-		params->vpn_index = index;
-		params->vpn_gateway = g_strdup(gateway);
-
-		/*
-		 * Find the gateway that is serving the VPN link
-		 */
-		__connman_inet_get_route(gateway, get_gateway_cb, params);
-	}
-
-	if (!active_gateway)
-		return;
-
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV4) {
-		/*
-		 * Special route to VPN server via gateway. This
-		 * is needed so that we can access hosts behind
-		 * the VPN. The route might already exist depending
-		 * on network topology.
-		 */
-		if (!active_gateway->ipv4_gateway)
-			return;
-
-
-		/*
-		 * If VPN server is on same subnet as we are, skip adding
-		 * route.
-		 */
-		if (connman_inet_compare_subnet(active_gateway->index,
-								gateway))
-			return;
-
-		DBG("active gw %s", active_gateway->ipv4_gateway->gateway);
-
-		if (g_strcmp0(active_gateway->ipv4_gateway->gateway,
-							"0.0.0.0") != 0)
-			dest = active_gateway->ipv4_gateway->gateway;
-		else
-			dest = NULL;
-
-		connman_inet_add_host_route(active_gateway->index, gateway,
-									dest);
-
-	} else if (type == CONNMAN_IPCONFIG_TYPE_IPV6) {
-
-		if (!active_gateway->ipv6_gateway)
-			return;
-
-		if (connman_inet_compare_ipv6_subnet(active_gateway->index,
-								gateway))
-			return;
-
-		DBG("active gw %s", active_gateway->ipv6_gateway->gateway);
-
-		if (g_strcmp0(active_gateway->ipv6_gateway->gateway,
-								"::") != 0)
-			dest = active_gateway->ipv6_gateway->gateway;
-		else
-			dest = NULL;
-
-		connman_inet_add_ipv6_host_route(active_gateway->index,
-								gateway, dest);
-	}
-}
-
-static int del_routes(struct gateway_data *data,
-			enum connman_ipconfig_type type)
-{
-	int status4 = 0, status6 = 0;
-	bool do_ipv4 = false, do_ipv6 = false;
-
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
-		do_ipv4 = true;
-	else if (type == CONNMAN_IPCONFIG_TYPE_IPV6)
-		do_ipv6 = true;
-	else
-		do_ipv4 = do_ipv6 = true;
-
-	if (do_ipv4 && data->ipv4_gateway) {
-		if (data->ipv4_gateway->vpn) {
-			status4 = connman_inet_clear_gateway_address(
-						data->index,
-						data->ipv4_gateway->vpn_ip);
-
-		} else if (g_strcmp0(data->ipv4_gateway->gateway,
-							"0.0.0.0") == 0) {
-			status4 = connman_inet_clear_gateway_interface(
-								data->index);
-		} else {
-			connman_inet_del_host_route(data->index,
-						data->ipv4_gateway->gateway);
-			status4 = connman_inet_clear_gateway_address(
-						data->index,
-						data->ipv4_gateway->gateway);
-		}
-	}
-
-	if (do_ipv6 && data->ipv6_gateway) {
-		if (data->ipv6_gateway->vpn) {
-			status6 = connman_inet_clear_ipv6_gateway_address(
-						data->index,
-						data->ipv6_gateway->vpn_ip);
-
-		} else if (g_strcmp0(data->ipv6_gateway->gateway, "::") == 0) {
-			status6 = connman_inet_clear_ipv6_gateway_interface(
-								data->index);
-		} else {
-			connman_inet_del_ipv6_host_route(data->index,
-						data->ipv6_gateway->gateway);
-			status6 = connman_inet_clear_ipv6_gateway_address(
-						data->index,
-						data->ipv6_gateway->gateway);
-		}
-	}
-
-	return (status4 < 0 ? status4 : status6);
-}
-
-static int disable_gateway(struct gateway_data *data,
-			enum connman_ipconfig_type type)
-{
-	bool active = false;
-
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV4) {
-		if (data->ipv4_gateway)
-			active = data->ipv4_gateway->active;
-	} else if (type == CONNMAN_IPCONFIG_TYPE_IPV6) {
-		if (data->ipv6_gateway)
-			active = data->ipv6_gateway->active;
-	} else
-		active = true;
-
-	DBG("type %d active %d", type, active);
-
-	if (active)
-		return del_routes(data, type);
-
-	return 0;
-}
-
-static struct gateway_data *add_gateway(struct connman_service *service,
-					int index, const char *gateway,
-					enum connman_ipconfig_type type)
-{
-	struct gateway_data *data, *old;
-	struct gateway_config *config;
-
-	if (!gateway || strlen(gateway) == 0)
-		return NULL;
-
-	data = g_try_new0(struct gateway_data, 1);
-	if (!data)
-		return NULL;
-
-	data->index = index;
-
-	config = g_try_new0(struct gateway_config, 1);
-	if (!config) {
-		g_free(data);
-		return NULL;
-	}
-
-	config->gateway = g_strdup(gateway);
-	config->vpn_ip = NULL;
-	config->vpn_phy_ip = NULL;
-	config->vpn = false;
-	config->vpn_phy_index = -1;
-	config->active = false;
-
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
-		data->ipv4_gateway = config;
-	else if (type == CONNMAN_IPCONFIG_TYPE_IPV6)
-		data->ipv6_gateway = config;
-	else {
-		g_free(config->gateway);
-		g_free(config);
-		g_free(data);
-		return NULL;
-	}
-
-	data->service = service;
-
-	/*
-	 * If the service is already in the hash, then we
-	 * must not replace it blindly but disable the gateway
-	 * of the type we are replacing and take the other type
-	 * from old gateway settings.
-	 */
-	old = g_hash_table_lookup(gateway_hash, service);
-	if (old) {
-		DBG("Replacing gw %p ipv4 %p ipv6 %p", old,
-			old->ipv4_gateway, old->ipv6_gateway);
-		disable_gateway(old, type);
-		if (type == CONNMAN_IPCONFIG_TYPE_IPV4) {
-			data->ipv6_gateway = old->ipv6_gateway;
-			old->ipv6_gateway = NULL;
-		} else if (type == CONNMAN_IPCONFIG_TYPE_IPV6) {
-			data->ipv4_gateway = old->ipv4_gateway;
-			old->ipv4_gateway = NULL;
-		}
-	}
-
-	connman_service_ref(data->service);
-	g_hash_table_replace(gateway_hash, service, data);
-
-	return data;
-}
-
-static void set_default_gateway(struct gateway_data *data,
-				enum connman_ipconfig_type type)
-{
-	int index;
-	int status4 = 0, status6 = 0;
-	bool do_ipv4 = false, do_ipv6 = false;
-
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
-		do_ipv4 = true;
-	else if (type == CONNMAN_IPCONFIG_TYPE_IPV6)
-		do_ipv6 = true;
-	else
-		do_ipv4 = do_ipv6 = true;
-
-	DBG("type %d gateway ipv4 %p ipv6 %p", type, data->ipv4_gateway,
-						data->ipv6_gateway);
-
-	if (do_ipv4 && data->ipv4_gateway &&
-					data->ipv4_gateway->vpn) {
-		connman_inet_set_gateway_interface(data->index);
-		data->ipv4_gateway->active = true;
-
-		DBG("set %p index %d vpn %s index %d phy %s",
-			data, data->index, data->ipv4_gateway->vpn_ip,
-			data->ipv4_gateway->vpn_phy_index,
-			data->ipv4_gateway->vpn_phy_ip);
-
-		__connman_service_indicate_default(data->service);
-
-		return;
-	}
-
-	if (do_ipv6 && data->ipv6_gateway &&
-					data->ipv6_gateway->vpn) {
-		connman_inet_set_ipv6_gateway_interface(data->index);
-		data->ipv6_gateway->active = true;
-
-		DBG("set %p index %d vpn %s index %d phy %s",
-			data, data->index, data->ipv6_gateway->vpn_ip,
-			data->ipv6_gateway->vpn_phy_index,
-			data->ipv6_gateway->vpn_phy_ip);
-
-		__connman_service_indicate_default(data->service);
-
-		return;
-	}
-
-	index = __connman_service_get_index(data->service);
-
-	if (do_ipv4 && data->ipv4_gateway &&
-			g_strcmp0(data->ipv4_gateway->gateway,
-							"0.0.0.0") == 0) {
-		if (connman_inet_set_gateway_interface(index) < 0)
-			return;
-		data->ipv4_gateway->active = true;
-		goto done;
-	}
-
-	if (do_ipv6 && data->ipv6_gateway &&
-			g_strcmp0(data->ipv6_gateway->gateway,
-							"::") == 0) {
-		if (connman_inet_set_ipv6_gateway_interface(index) < 0)
-			return;
-		data->ipv6_gateway->active = true;
-		goto done;
-	}
-
-	if (do_ipv6 && data->ipv6_gateway)
-		status6 = __connman_inet_add_default_to_table(RT_TABLE_MAIN,
-					index, data->ipv6_gateway->gateway);
-
-	if (do_ipv4 && data->ipv4_gateway)
-		status4 = __connman_inet_add_default_to_table(RT_TABLE_MAIN,
-					index, data->ipv4_gateway->gateway);
-
-	if (status4 < 0 || status6 < 0)
-		return;
-
-done:
-	__connman_service_indicate_default(data->service);
-}
-
-static void unset_default_gateway(struct gateway_data *data,
-				enum connman_ipconfig_type type)
-{
-	int index;
-	bool do_ipv4 = false, do_ipv6 = false;
-
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
-		do_ipv4 = true;
-	else if (type == CONNMAN_IPCONFIG_TYPE_IPV6)
-		do_ipv6 = true;
-	else
-		do_ipv4 = do_ipv6 = true;
-
-	DBG("type %d gateway ipv4 %p ipv6 %p", type, data->ipv4_gateway,
-						data->ipv6_gateway);
-
-	if (do_ipv4 && data->ipv4_gateway &&
-					data->ipv4_gateway->vpn) {
-		connman_inet_clear_gateway_interface(data->index);
-		data->ipv4_gateway->active = false;
-
-		DBG("unset %p index %d vpn %s index %d phy %s",
-			data, data->index, data->ipv4_gateway->vpn_ip,
-			data->ipv4_gateway->vpn_phy_index,
-			data->ipv4_gateway->vpn_phy_ip);
-
-		return;
-	}
-
-	if (do_ipv6 && data->ipv6_gateway &&
-					data->ipv6_gateway->vpn) {
-		connman_inet_clear_ipv6_gateway_interface(data->index);
-		data->ipv6_gateway->active = false;
-
-		DBG("unset %p index %d vpn %s index %d phy %s",
-			data, data->index, data->ipv6_gateway->vpn_ip,
-			data->ipv6_gateway->vpn_phy_index,
-			data->ipv6_gateway->vpn_phy_ip);
-
-		return;
-	}
-
-	index = __connman_service_get_index(data->service);
-
-	if (do_ipv4 && data->ipv4_gateway &&
-			g_strcmp0(data->ipv4_gateway->gateway,
-							"0.0.0.0") == 0) {
-		connman_inet_clear_gateway_interface(index);
-		data->ipv4_gateway->active = false;
-		return;
-	}
-
-	if (do_ipv6 && data->ipv6_gateway &&
-			g_strcmp0(data->ipv6_gateway->gateway,
-							"::") == 0) {
-		connman_inet_clear_ipv6_gateway_interface(index);
-		data->ipv6_gateway->active = false;
-		return;
-	}
-
-	if (do_ipv6 && data->ipv6_gateway)
-		connman_inet_clear_ipv6_gateway_address(index,
-						data->ipv6_gateway->gateway);
-
-	if (do_ipv4 && data->ipv4_gateway)
-		connman_inet_clear_gateway_address(index,
-						data->ipv4_gateway->gateway);
-}
-
-static struct gateway_data *find_default_gateway(void)
-{
-	struct connman_service *service;
-
-	service = connman_service_get_default();
-	if (!service)
-		return NULL;
-
-	return g_hash_table_lookup(gateway_hash, service);
-}
-
-static bool choose_default_gateway(struct gateway_data *data,
-					struct gateway_data *candidate)
-{
-	bool downgraded = false;
-
-	/*
-	 * If the current default is not active, then we mark
-	 * this one as default. If the other one is already active
-	 * we mark this one as non default.
-	 */
-	if (data->ipv4_gateway && candidate->ipv4_gateway) {
-
-		if (!candidate->ipv4_gateway->active) {
-			DBG("ipv4 downgrading %p", candidate);
-			unset_default_gateway(candidate,
-						CONNMAN_IPCONFIG_TYPE_IPV4);
-		}
-
-		if (candidate->ipv4_gateway->active &&
-				__connman_service_compare(candidate->service,
-							data->service) < 0) {
-			DBG("ipv4 downgrading this %p", data);
-			unset_default_gateway(data, CONNMAN_IPCONFIG_TYPE_IPV4);
-			downgraded = true;
-		}
-	}
-
-	if (data->ipv6_gateway && candidate->ipv6_gateway) {
-		if (!candidate->ipv6_gateway->active) {
-			DBG("ipv6 downgrading %p", candidate);
-			unset_default_gateway(candidate,
-						CONNMAN_IPCONFIG_TYPE_IPV6);
-		}
-
-		if (candidate->ipv6_gateway->active &&
-			__connman_service_compare(candidate->service,
-						data->service) < 0) {
-			DBG("ipv6 downgrading this %p", data);
-			unset_default_gateway(data, CONNMAN_IPCONFIG_TYPE_IPV6);
-			downgraded = true;
-		}
-	}
-
-	return downgraded;
-}
-
-static void connection_newgateway(int index, const char *gateway)
-{
-	struct gateway_config *config;
-	struct gateway_data *data;
-	GHashTableIter iter;
-	gpointer value, key;
-	bool found = false;
-
-	DBG("index %d gateway %s", index, gateway);
-
-	config = find_gateway(index, gateway);
-	if (!config)
-		return;
-
-	config->active = true;
-
-	/*
-	 * It is possible that we have two default routes atm
-	 * if there are two gateways waiting rtnl activation at the
-	 * same time.
-	 */
-	data = lookup_gateway_data(config);
-	if (!data)
-		return;
-
-	if (data->default_checked)
-		return;
-
-	/*
-	 * The next checks are only done once, otherwise setting
-	 * the default gateway could lead into rtnl forever loop.
-	 */
-
-	g_hash_table_iter_init(&iter, gateway_hash);
-
-	while (g_hash_table_iter_next(&iter, &key, &value)) {
-		struct gateway_data *candidate = value;
-
-		if (candidate == data)
-			continue;
-
-		found = choose_default_gateway(data, candidate);
-		if (found)
-			break;
-	}
-
-	if (!found) {
-		if (data->ipv4_gateway)
-			set_default_gateway(data, CONNMAN_IPCONFIG_TYPE_IPV4);
-
-		if (data->ipv6_gateway)
-			set_default_gateway(data, CONNMAN_IPCONFIG_TYPE_IPV6);
-	}
-
-	data->default_checked = true;
-}
-
-static void remove_gateway(gpointer user_data)
-{
-	struct gateway_data *data = user_data;
-
-	DBG("gateway ipv4 %p ipv6 %p", data->ipv4_gateway, data->ipv6_gateway);
-
-	if (data->ipv4_gateway) {
-		g_free(data->ipv4_gateway->gateway);
-		g_free(data->ipv4_gateway->vpn_ip);
-		g_free(data->ipv4_gateway->vpn_phy_ip);
-		g_free(data->ipv4_gateway);
-	}
-
-	if (data->ipv6_gateway) {
-		g_free(data->ipv6_gateway->gateway);
-		g_free(data->ipv6_gateway->vpn_ip);
-		g_free(data->ipv6_gateway->vpn_phy_ip);
-		g_free(data->ipv6_gateway);
-	}
-
-	connman_service_unref(data->service);
-
-	g_free(data);
-}
-
-static void connection_delgateway(int index, const char *gateway)
-{
-	struct gateway_config *config;
-	struct gateway_data *data;
-
-	DBG("index %d gateway %s", index, gateway);
-
-	config = find_gateway(index, gateway);
-	if (config)
-		config->active = false;
-
-	data = find_default_gateway();
-	if (data)
-		set_default_gateway(data, CONNMAN_IPCONFIG_TYPE_ALL);
-}
-
-static struct connman_rtnl connection_rtnl = {
-	.name		= "connection",
-	.newgateway	= connection_newgateway,
-	.delgateway	= connection_delgateway,
-};
-
-static struct gateway_data *find_active_gateway(void)
-{
-	GHashTableIter iter;
-	gpointer value, key;
-
-	DBG("");
-
-	g_hash_table_iter_init(&iter, gateway_hash);
-
-	while (g_hash_table_iter_next(&iter, &key, &value)) {
-		struct gateway_data *data = value;
-
-		if (data->ipv4_gateway &&
-				data->ipv4_gateway->active)
-			return data;
-
-		if (data->ipv6_gateway &&
-				data->ipv6_gateway->active)
-			return data;
-	}
-
-	return NULL;
-}
-
-static void add_host_route(int family, int index, const char *gateway,
-			enum connman_service_type service_type)
-{
-	switch (family) {
-	case AF_INET:
-		if (g_strcmp0(gateway, "0.0.0.0") != 0) {
-			/*
-			 * We must not set route to the phy dev gateway in
-			 * VPN link. The packets to VPN link might be routed
-			 * back to itself and not routed into phy link gateway.
-			 */
-			if (service_type != CONNMAN_SERVICE_TYPE_VPN)
-				connman_inet_add_host_route(index, gateway,
-									NULL);
-		} else {
-			/*
-			 * Add host route to P-t-P link so that services can
-			 * be moved around and we can have some link to P-t-P
-			 * network (although those P-t-P links have limited
-			 * usage if default route is not directed to them)
-			 */
-			char *dest;
-			if (connman_inet_get_dest_addr(index, &dest) == 0) {
-				connman_inet_add_host_route(index, dest, NULL);
-				g_free(dest);
-			}
-		}
-		break;
-
-	case AF_INET6:
-		if (g_strcmp0(gateway, "::") != 0) {
-			if (service_type != CONNMAN_SERVICE_TYPE_VPN)
-				connman_inet_add_ipv6_host_route(index,
-								gateway, NULL);
-		} else {
-			/* P-t-P link, add route to destination */
-			char *dest;
-			if (connman_inet_ipv6_get_dest_addr(index,
-								&dest) == 0) {
-				connman_inet_add_ipv6_host_route(index, dest,
-								NULL);
-				g_free(dest);
-			}
-		}
-		break;
-	}
-}
-
-int __connman_connection_gateway_add(struct connman_service *service,
-					const char *gateway,
-					enum connman_ipconfig_type type,
-					const char *peer)
-{
-	struct gateway_data *active_gateway = NULL;
-	struct gateway_data *new_gateway = NULL;
-	enum connman_ipconfig_type type4 = CONNMAN_IPCONFIG_TYPE_UNKNOWN,
-		type6 = CONNMAN_IPCONFIG_TYPE_UNKNOWN;
-	enum connman_service_type service_type =
-					connman_service_get_type(service);
-	int index;
-
-	index = __connman_service_get_index(service);
-
-	/*
-	 * If gateway is NULL, it's a point to point link and the default
-	 * gateway for ipv4 is 0.0.0.0 and for ipv6 is ::, meaning the
-	 * interface
-	 */
-	if (!gateway && type == CONNMAN_IPCONFIG_TYPE_IPV4)
-		gateway = "0.0.0.0";
-
-	if (!gateway && type == CONNMAN_IPCONFIG_TYPE_IPV6)
-		gateway = "::";
-
-	DBG("service %p index %d gateway %s vpn ip %s type %d",
-		service, index, gateway, peer, type);
-
-	new_gateway = add_gateway(service, index, gateway, type);
-	if (!new_gateway)
-		return -EINVAL;
-
-	active_gateway = find_active_gateway();
-
-	DBG("active %p index %d new %p", active_gateway,
-		active_gateway ? active_gateway->index : -1, new_gateway);
-
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV4 &&
-				new_gateway->ipv4_gateway) {
-		add_host_route(AF_INET, index, gateway, service_type);
-		__connman_service_nameserver_add_routes(service,
-					new_gateway->ipv4_gateway->gateway);
-		type4 = CONNMAN_IPCONFIG_TYPE_IPV4;
-	}
-
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV6 &&
-				new_gateway->ipv6_gateway) {
-		add_host_route(AF_INET6, index, gateway, service_type);
-		__connman_service_nameserver_add_routes(service,
-					new_gateway->ipv6_gateway->gateway);
-		type6 = CONNMAN_IPCONFIG_TYPE_IPV6;
-	}
-
-	if (service_type == CONNMAN_SERVICE_TYPE_VPN) {
-
-		set_vpn_routes(new_gateway, service, gateway, type, peer,
-							active_gateway);
-
-	} else {
-		if (type == CONNMAN_IPCONFIG_TYPE_IPV4 &&
-					new_gateway->ipv4_gateway)
-			new_gateway->ipv4_gateway->vpn = false;
-
-		if (type == CONNMAN_IPCONFIG_TYPE_IPV6 &&
-					new_gateway->ipv6_gateway)
-			new_gateway->ipv6_gateway->vpn = false;
-	}
-
-	if (!active_gateway) {
-		set_default_gateway(new_gateway, type);
-		goto done;
-	}
-
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV4 &&
-				new_gateway->ipv4_gateway &&
-				new_gateway->ipv4_gateway->vpn) {
-		if (!__connman_service_is_split_routing(new_gateway->service))
-			connman_inet_clear_gateway_address(
-					active_gateway->index,
-					active_gateway->ipv4_gateway->gateway);
-	}
-
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV6 &&
-				new_gateway->ipv6_gateway &&
-				new_gateway->ipv6_gateway->vpn) {
-		if (!__connman_service_is_split_routing(new_gateway->service))
-			connman_inet_clear_ipv6_gateway_address(
-					active_gateway->index,
-					active_gateway->ipv6_gateway->gateway);
-	}
-
-done:
-	if (type4 == CONNMAN_IPCONFIG_TYPE_IPV4)
-		__connman_service_ipconfig_indicate_state(service,
-						CONNMAN_SERVICE_STATE_READY,
-						CONNMAN_IPCONFIG_TYPE_IPV4);
-
-	if (type6 == CONNMAN_IPCONFIG_TYPE_IPV6)
-		__connman_service_ipconfig_indicate_state(service,
-						CONNMAN_SERVICE_STATE_READY,
-						CONNMAN_IPCONFIG_TYPE_IPV6);
-	return 0;
-}
-
-void __connman_connection_gateway_remove(struct connman_service *service,
-					enum connman_ipconfig_type type)
-{
-	struct gateway_data *data = NULL;
-	bool set_default4 = false, set_default6 = false;
-        bool do_ipv4 = false, do_ipv6 = false;
-	int err;
-
-	DBG("service %p type %d", service, type);
-
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
-		do_ipv4 = true;
-	else if (type == CONNMAN_IPCONFIG_TYPE_IPV6)
-		do_ipv6 = true;
-	else
-		do_ipv4 = do_ipv6 = true;
-
-	__connman_service_nameserver_del_routes(service, type);
-
-	data = g_hash_table_lookup(gateway_hash, service);
-	if (!data)
-		return;
-
-	if (do_ipv4 && data->ipv4_gateway)
-		set_default4 = data->ipv4_gateway->vpn;
-
-	if (do_ipv6 && data->ipv6_gateway)
-		set_default6 = data->ipv6_gateway->vpn;
-
-	DBG("ipv4 gateway %s ipv6 gateway %s vpn %d/%d",
-		data->ipv4_gateway ? data->ipv4_gateway->gateway : "<null>",
-		data->ipv6_gateway ? data->ipv6_gateway->gateway : "<null>",
-		set_default4, set_default6);
-
-	if (do_ipv4 && data->ipv4_gateway &&
-			data->ipv4_gateway->vpn && data->index >= 0)
-		connman_inet_del_host_route(data->ipv4_gateway->vpn_phy_index,
-						data->ipv4_gateway->gateway);
-
-	if (do_ipv6 && data->ipv6_gateway &&
-			data->ipv6_gateway->vpn && data->index >= 0)
-		connman_inet_del_ipv6_host_route(
-					data->ipv6_gateway->vpn_phy_index,
-						data->ipv6_gateway->gateway);
-
-	err = disable_gateway(data, type);
-
-	/*
-	 * We remove the service from the hash only if all the gateway
-	 * settings are to be removed.
-	 */
-	if (do_ipv4 == do_ipv6 ||
-		(data->ipv4_gateway && !data->ipv6_gateway
-			&& do_ipv4) ||
-		(data->ipv6_gateway && !data->ipv4_gateway
-			&& do_ipv6)) {
-		g_hash_table_remove(gateway_hash, service);
-	} else
-		DBG("Not yet removing gw ipv4 %p/%d ipv6 %p/%d",
-			data->ipv4_gateway, do_ipv4,
-			data->ipv6_gateway, do_ipv6);
-
-	/* with vpn this will be called after the network was deleted,
-	 * we need to call set_default here because we will not receive any
-	 * gateway delete notification.
-	 * We hit the same issue if remove_gateway() fails.
-	 */
-	if (set_default4 || set_default6 || err < 0) {
-		data = find_default_gateway();
-		if (data)
-			set_default_gateway(data, type);
-	}
-}
-
-bool __connman_connection_update_gateway(void)
-{
-	struct gateway_data *default_gateway;
-	bool updated = false;
-	GHashTableIter iter;
-	gpointer value, key;
-
-	if (!gateway_hash)
-		return updated;
-
-	default_gateway = find_default_gateway();
-
-	DBG("default %p", default_gateway);
-
-	/*
-	 * There can be multiple active gateways so we need to
-	 * check them all.
-	 */
-	g_hash_table_iter_init(&iter, gateway_hash);
-
-	while (g_hash_table_iter_next(&iter, &key, &value)) {
-		struct gateway_data *active_gateway = value;
-
-		if (active_gateway == default_gateway)
-			continue;
-
-		if (active_gateway->ipv4_gateway &&
-				active_gateway->ipv4_gateway->active) {
-
-			unset_default_gateway(active_gateway,
-						CONNMAN_IPCONFIG_TYPE_IPV4);
-			updated = true;
-		}
-
-		if (active_gateway->ipv6_gateway &&
-				active_gateway->ipv6_gateway->active) {
-
-			unset_default_gateway(active_gateway,
-						CONNMAN_IPCONFIG_TYPE_IPV6);
-			updated = true;
-		}
-	}
-
-	/*
-	 * Set default gateway if it has been updated or if it has not been
-	 * set as active yet.
-	 */
-	if (default_gateway) {
-		if (default_gateway->ipv4_gateway &&
-			(updated || !default_gateway->ipv4_gateway->active))
-			set_default_gateway(default_gateway,
-					CONNMAN_IPCONFIG_TYPE_IPV4);
-
-		if (default_gateway->ipv6_gateway &&
-			(updated || !default_gateway->ipv6_gateway->active))
-			set_default_gateway(default_gateway,
-					CONNMAN_IPCONFIG_TYPE_IPV6);
-	}
-
-	return updated;
-}
-
-int __connman_connection_get_vpn_index(int phy_index)
-{
-	GHashTableIter iter;
-	gpointer value, key;
-
-	g_hash_table_iter_init(&iter, gateway_hash);
-
-	while (g_hash_table_iter_next(&iter, &key, &value)) {
-		struct gateway_data *data = value;
-
-		if (data->ipv4_gateway &&
-				data->ipv4_gateway->vpn_phy_index == phy_index)
-			return data->index;
-
-		if (data->ipv6_gateway &&
-				data->ipv6_gateway->vpn_phy_index == phy_index)
-			return data->index;
-	}
-
-	return -1;
-}
-
-int __connman_connection_get_vpn_phy_index(int vpn_index)
-{
-	GHashTableIter iter;
-	gpointer value, key;
-
-	g_hash_table_iter_init(&iter, gateway_hash);
-
-	while (g_hash_table_iter_next(&iter, &key, &value)) {
-		struct gateway_data *data = value;
-
-		if (data->index != vpn_index)
-			continue;
-
-		if (data->ipv4_gateway)
-			return data->ipv4_gateway->vpn_phy_index;
-
-		if (data->ipv6_gateway)
-			return data->ipv6_gateway->vpn_phy_index;
-	}
-
-	return -1;
-}
-
-int __connman_connection_init(void)
-{
-	int err;
-
-	DBG("");
-
-	gateway_hash = g_hash_table_new_full(g_direct_hash, g_direct_equal,
-							NULL, remove_gateway);
-
-	err = connman_rtnl_register(&connection_rtnl);
-	if (err < 0)
-		connman_error("Failed to setup RTNL gateway driver");
-
-	return err;
-}
-
-void __connman_connection_cleanup(void)
-{
-	GHashTableIter iter;
-	gpointer value, key;
-
-	DBG("");
-
-	connman_rtnl_unregister(&connection_rtnl);
-
-	g_hash_table_iter_init(&iter, gateway_hash);
-
-	while (g_hash_table_iter_next(&iter, &key, &value)) {
-		struct gateway_data *data = value;
-
-		disable_gateway(data, CONNMAN_IPCONFIG_TYPE_ALL);
-	}
-
-	g_hash_table_destroy(gateway_hash);
-	gateway_hash = NULL;
-}
diff --git a/src/connman.h b/src/connman.h
index b955d98b..32ba5591 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -19,6 +19,13 @@
  *
  */
 
+/**
+ *  @file
+ *    This file defines internal, non-public (that is, neither visible
+ *    nor consumable by plugins), cross-module interfaces.
+ *
+ */
+
 #include <stdbool.h>
 
 #include <glib.h>
@@ -167,6 +174,8 @@ int __connman_inet_get_interface_mac_address(int index, uint8_t *mac_address);
 
 bool __connman_inet_is_any_addr(const char *address, int family);
 
+const char *__connman_inet_table2string(uint32_t table_id);
+
 #include <netinet/ip6.h>
 #include <netinet/icmp6.h>
 
@@ -235,7 +244,8 @@ int __connman_inet_rtnl_send(struct __connman_inet_rtnl_handle *rtnl,
 {
 	return __connman_inet_rtnl_talk(rtnl, n, 0, NULL, NULL);
 }
-
+int __connman_inet_rtnl_recv(const struct __connman_inet_rtnl_handle *rtnl,
+			struct nlmsghdr **n);
 void __connman_inet_rtnl_close(struct __connman_inet_rtnl_handle *rth);
 int __connman_inet_rtnl_addattr_l(struct nlmsghdr *n, size_t max_length,
 			int type, const void *data, size_t data_length);
@@ -245,9 +255,17 @@ int __connman_inet_rtnl_addattr32(struct nlmsghdr *n, size_t maxlen,
 int __connman_inet_add_fwmark_rule(uint32_t table_id, int family, uint32_t fwmark);
 int __connman_inet_del_fwmark_rule(uint32_t table_id, int family, uint32_t fwmark);
 int __connman_inet_add_default_to_table(uint32_t table_id, int ifindex, const char *gateway);
+int __connman_inet_add_default_to_table_with_metric(uint32_t table_id,
+			int ifindex,
+			const char *gateway,
+			uint32_t metric);
 int __connman_inet_add_subnet_to_table(uint32_t table_id, int ifindex,
 			const char *gateway, unsigned char prefixlen);
 int __connman_inet_del_default_from_table(uint32_t table_id, int ifindex, const char *gateway);
+int __connman_inet_del_default_from_table_with_metric(uint32_t table_id,
+			int ifindex,
+			const char *gateway,
+			uint32_t metric);
 int __connman_inet_del_subnet_from_table(uint32_t table_id, int ifindex,
 			const char *gateway, unsigned char prefixlen);
 int __connman_inet_get_address_netmask(int ifindex,
@@ -334,7 +352,7 @@ void __connman_ipconfig_unref_debug(struct connman_ipconfig *ipconfig,
 void *__connman_ipconfig_get_data(struct connman_ipconfig *ipconfig);
 void __connman_ipconfig_set_data(struct connman_ipconfig *ipconfig, void *data);
 
-int __connman_ipconfig_get_index(struct connman_ipconfig *ipconfig);
+int __connman_ipconfig_get_index(const struct connman_ipconfig *ipconfig);
 
 void __connman_ipconfig_set_ops(struct connman_ipconfig *ipconfig,
 				const struct connman_ipconfig_ops *ops);
@@ -358,9 +376,15 @@ int __connman_ipconfig_newaddr(int index, int family, const char *label,
 void __connman_ipconfig_deladdr(int index, int family, const char *label,
 				unsigned char prefixlen, const char *address);
 void __connman_ipconfig_newroute(int index, int family, unsigned char scope,
-					const char *dst, const char *gateway);
+					const char *dst,
+					unsigned char dst_prefixlen,
+					const char *gateway,
+					uint32_t table_id, uint32_t metric);
 void __connman_ipconfig_delroute(int index, int family, unsigned char scope,
-					const char *dst, const char *gateway);
+					const char *dst,
+					unsigned char dst_prefixlen,
+					const char *gateway,
+					uint32_t table_id, uint32_t metric);
 
 void __connman_ipconfig_foreach(void (*function) (int index, void *user_data),
 							void *user_data);
@@ -378,7 +402,7 @@ const char *__connman_ipconfig_get_peer(struct connman_ipconfig *ipconfig);
 void __connman_ipconfig_set_peer(struct connman_ipconfig *ipconfig, const char *address);
 const char *__connman_ipconfig_get_broadcast(struct connman_ipconfig *ipconfig);
 void __connman_ipconfig_set_broadcast(struct connman_ipconfig *ipconfig, const char *broadcast);
-const char *__connman_ipconfig_get_gateway(struct connman_ipconfig *ipconfig);
+const char *__connman_ipconfig_get_gateway(const struct connman_ipconfig *ipconfig);
 void __connman_ipconfig_set_gateway(struct connman_ipconfig *ipconfig, const char *gateway);
 unsigned char __connman_ipconfig_get_prefixlen(struct connman_ipconfig *ipconfig);
 void __connman_ipconfig_set_prefixlen(struct connman_ipconfig *ipconfig, unsigned char prefixlen);
@@ -410,8 +434,8 @@ enum connman_ipconfig_method __connman_ipconfig_get_method(
 int __connman_ipconfig_address_add(struct connman_ipconfig *ipconfig);
 int __connman_ipconfig_address_remove(struct connman_ipconfig *ipconfig);
 int __connman_ipconfig_address_unset(struct connman_ipconfig *ipconfig);
-int __connman_ipconfig_gateway_add(struct connman_ipconfig *ipconfig);
-void __connman_ipconfig_gateway_remove(struct connman_ipconfig *ipconfig);
+int __connman_ipconfig_gateway_add(const struct connman_ipconfig *ipconfig);
+void __connman_ipconfig_gateway_remove(const struct connman_ipconfig *ipconfig);
 
 int __connman_ipconfig_set_proxy_autoconfig(struct connman_ipconfig *ipconfig,
 							const char *url);
@@ -450,7 +474,7 @@ char **__connman_timeserver_system_get();
 
 GSList *__connman_timeserver_add_list(GSList *server_list,
 		const char *timeserver);
-GSList *__connman_timeserver_get_all(struct connman_service *service);
+GSList *__connman_timeserver_get_all(const struct connman_service *service);
 void __connman_timeserver_sync(struct connman_service *service,
 				enum connman_timeserver_sync_reason reason);
 void __connman_timeserver_conf_update(struct connman_service *service);
@@ -499,19 +523,19 @@ int __connman_dhcpv6_start_pd_release(struct connman_network *network,
 int __connman_ipv4_init(void);
 void __connman_ipv4_cleanup(void);
 
-int __connman_connection_init(void);
-void __connman_connection_cleanup(void);
+int __connman_gateway_init(void);
+void __connman_gateway_cleanup(void);
 
-int __connman_connection_gateway_add(struct connman_service *service,
+int __connman_gateway_add(struct connman_service *service,
 					const char *gateway,
 					enum connman_ipconfig_type type,
 					const char *peer);
-void __connman_connection_gateway_remove(struct connman_service *service,
+void __connman_gateway_remove(struct connman_service *service,
 					enum connman_ipconfig_type type);
-int __connman_connection_get_vpn_index(int phy_index);
-int __connman_connection_get_vpn_phy_index(int vpn_index);
+int __connman_gateway_get_vpn_index(int phy_index);
+int __connman_gateway_get_vpn_phy_index(int vpn_index);
 
-bool __connman_connection_update_gateway(void);
+bool __connman_gateway_update(void);
 
 typedef void (*__connman_ntp_cb_t) (bool success, void *user_data);
 int __connman_ntp_start(char *server, __connman_ntp_cb_t callback,
@@ -523,9 +547,18 @@ void __connman_wpad_cleanup(void);
 int __connman_wpad_start(struct connman_service *service);
 void __connman_wpad_stop(struct connman_service *service);
 
+typedef void (*__connman_wispr_cb_t) (struct connman_service *service,
+				enum connman_ipconfig_type type,
+				bool success,
+				int err);
+
 int __connman_wispr_init(void);
 void __connman_wispr_cleanup(void);
 int __connman_wispr_start(struct connman_service *service,
+					enum connman_ipconfig_type type,
+					guint connect_timeout_ms,
+					__connman_wispr_cb_t callback);
+int __connman_wispr_cancel(struct connman_service *service,
 					enum connman_ipconfig_type type);
 void __connman_wispr_stop(struct connman_service *service);
 
@@ -562,6 +595,7 @@ void __connman_technology_remove_interface(enum connman_service_type type,
 				int index, const char *ident);
 void __connman_technology_notify_regdom_by_device(struct connman_device *device,
 						int result, const char *alpha2);
+const char *__connman_technology_get_regdom(enum connman_service_type type);
 
 #include <connman/device.h>
 
@@ -614,7 +648,7 @@ int __connman_network_clear_ipconfig(struct connman_network *network,
 int __connman_network_enable_ipconfig(struct connman_network *network,
 				struct connman_ipconfig *ipconfig);
 
-const char *__connman_network_get_type(struct connman_network *network);
+const char *__connman_network_get_type(const struct connman_network *network);
 const char *__connman_network_get_group(struct connman_network *network);
 const char *__connman_network_get_ident(struct connman_network *network);
 bool __connman_network_get_weakness(struct connman_network *network);
@@ -700,6 +734,8 @@ void __connman_service_remove_from_network(struct connman_network *network);
 void __connman_service_read_ip4config(struct connman_service *service);
 void __connman_service_read_ip6config(struct connman_service *service);
 
+int __connman_service_get_route_metric(const struct connman_service *service,
+				uint32_t *metric);
 struct connman_ipconfig *__connman_service_get_ip4config(
 				struct connman_service *service);
 struct connman_ipconfig *__connman_service_get_ip6config(
@@ -708,16 +744,16 @@ struct connman_ipconfig *__connman_service_get_ipconfig(
 				struct connman_service *service, int family);
 void __connman_service_notify_ipv4_configuration(
 				struct connman_service *service);
-void __connman_service_wispr_start(struct connman_service *service,
+int __connman_service_wispr_start(struct connman_service *service,
                                 enum connman_ipconfig_type type);
-bool __connman_service_is_connected_state(struct connman_service *service,
+bool __connman_service_is_connected_state(const struct connman_service *service,
 					enum connman_ipconfig_type type);
-const char *__connman_service_get_path(struct connman_service *service);
-const char *__connman_service_get_name(struct connman_service *service);
+const char *__connman_service_get_path(const struct connman_service *service);
+const char *__connman_service_get_name(const struct connman_service *service);
 struct connman_network *__connman_service_get_network(struct connman_service *service);
-enum connman_service_security __connman_service_get_security(struct connman_service *service);
-const char *__connman_service_get_phase2(struct connman_service *service);
-bool __connman_service_wps_enabled(struct connman_service *service);
+enum connman_service_security __connman_service_get_security(const struct connman_service *service);
+const char *__connman_service_get_phase2(const struct connman_service *service);
+bool __connman_service_wps_enabled(const struct connman_service *service);
 int __connman_service_set_favorite(struct connman_service *service,
 						bool favorite);
 int __connman_service_set_favorite_delayed(struct connman_service *service,
@@ -734,9 +770,6 @@ int __connman_service_set_mdns(struct connman_service *service,
 
 void __connman_service_set_string(struct connman_service *service,
 					const char *key, const char *value);
-void __connman_service_online_check(struct connman_service *service,
-					enum connman_ipconfig_type type,
-					bool success);
 int __connman_service_ipconfig_indicate_state(struct connman_service *service,
 					enum connman_service_state new_state,
 					enum connman_ipconfig_type type);
@@ -755,9 +788,6 @@ int __connman_service_disconnect(struct connman_service *service);
 void __connman_service_set_active_session(bool enable, GSList *list);
 void __connman_service_auto_connect(enum connman_service_connect_reason reason);
 bool __connman_service_remove(struct connman_service *service);
-bool __connman_service_is_provider_pending(struct connman_service *service);
-void __connman_service_set_provider_pending(struct connman_service *service,
-							DBusMessage *msg);
 void __connman_service_set_hidden_data(struct connman_service *service,
 				gpointer user_data);
 void __connman_service_return_error(struct connman_service *service,
@@ -771,14 +801,31 @@ const char *__connman_service_type2string(enum connman_service_type type);
 enum connman_service_type __connman_service_string2type(const char *str);
 enum connman_service_security __connman_service_string2security(const char *str);
 
+enum service_online_check_mode {
+	CONNMAN_SERVICE_ONLINE_CHECK_MODE_UNKNOWN    = 0,
+	CONNMAN_SERVICE_ONLINE_CHECK_MODE_NONE       = 1,
+	CONNMAN_SERVICE_ONLINE_CHECK_MODE_ONE_SHOT   = 2,
+	CONNMAN_SERVICE_ONLINE_CHECK_MODE_CONTINUOUS = 3
+};
+
+const char *__connman_service_online_check_mode2string(
+		enum service_online_check_mode mode);
+enum service_online_check_mode __connman_service_online_check_string2mode(
+		const char *mode);
+enum service_online_check_mode __connman_service_get_online_check_mode(void);
+bool __connman_service_is_online_check_enabled(void);
+bool __connman_service_is_online_check_mode(
+		enum service_online_check_mode mode);
+
 int __connman_service_nameserver_append(struct connman_service *service,
 				const char *nameserver, bool is_auto);
 int __connman_service_nameserver_remove(struct connman_service *service,
 				const char *nameserver, bool is_auto);
 void __connman_service_nameserver_clear(struct connman_service *service);
-void __connman_service_nameserver_add_routes(struct connman_service *service,
+void __connman_service_nameserver_add_routes(const struct connman_service *service,
 						const char *gw);
-void __connman_service_nameserver_del_routes(struct connman_service *service,
+void __connman_service_nameserver_del_routes(const struct connman_service *service,
+					const char *gw,
 					enum connman_ipconfig_type type);
 void __connman_service_set_timeservers(struct connman_service *service,
 						char **timeservers);
@@ -790,40 +837,28 @@ void __connman_service_timeserver_changed(struct connman_service *service,
 		GSList *ts_list);
 void __connman_service_set_pac(struct connman_service *service,
 					const char *pac);
-bool __connman_service_is_hidden(struct connman_service *service);
-bool __connman_service_is_split_routing(struct connman_service *service);
+bool __connman_service_is_hidden(const struct connman_service *service);
+bool __connman_service_is_split_routing(const struct connman_service *service);
 bool __connman_service_index_is_split_routing(int index);
 void __connman_service_set_split_routing(struct connman_service *service,
 						bool split_routing);
 void __connman_service_split_routing_changed(struct connman_service *service);
-int __connman_service_get_index(struct connman_service *service);
+int __connman_service_get_index(const struct connman_service *service);
 void __connman_service_set_hidden(struct connman_service *service);
 void __connman_service_set_hostname(struct connman_service *service,
 						const char *hostname);
-const char *__connman_service_get_hostname(struct connman_service *service);
+const char *__connman_service_get_hostname(const struct connman_service *service);
 void __connman_service_set_domainname(struct connman_service *service,
 						const char *domainname);
 const char *__connman_service_get_nameserver(struct connman_service *service);
 void __connman_service_set_proxy_autoconfig(struct connman_service *service,
 							const char *url);
 
-void __connman_service_set_identity(struct connman_service *service,
-					const char *identity);
-void __connman_service_set_anonymous_identity(struct connman_service *service,
-					const char *anonymous_identity);
-void __connman_service_set_subject_match(struct connman_service *service,
-					const char *subject_match);
-void __connman_service_set_altsubject_match(struct connman_service *service,
-					const char *altsubject_match);
-void __connman_service_set_domain_suffix_match(struct connman_service *service,
-					const char *domain_suffix_match);
-void __connman_service_set_domain_match(struct connman_service *service,
-					const char *domain_match);
 void __connman_service_set_agent_identity(struct connman_service *service,
 						const char *agent_identity);
 int __connman_service_set_passphrase(struct connman_service *service,
 					const char *passphrase);
-const char *__connman_service_get_passphrase(struct connman_service *service);
+const char *__connman_service_get_passphrase(const struct connman_service *service);
 int __connman_service_check_passphrase(enum connman_service_security security,
 					const char *passphrase);
 int __connman_service_reset_ipconfig(struct connman_service *service,
diff --git a/src/device.c b/src/device.c
index 264c5e2d..55670099 100644
--- a/src/device.c
+++ b/src/device.c
@@ -589,6 +589,7 @@ int connman_device_set_powered(struct connman_device *device,
 {
 	struct connman_device_scan_params params;
 	enum connman_service_type type;
+	const char *alpha2;
 	int i;
 
 	DBG("device %p powered %d", device, powered);
@@ -607,6 +608,16 @@ int connman_device_set_powered(struct connman_device *device,
 	if (!device->powered) {
 		__connman_technology_disabled(type);
 		return 0;
+	} else {
+		/*
+		 * Check if the technology has regdom set and apply it for the
+		 * device. Regdom may have been changed when the device was
+		 * powered off and, thus, the new regdom has not been applied
+		 * here.
+		 */
+		alpha2 = __connman_technology_get_regdom(type);
+		if (alpha2)
+			connman_device_set_regdom(device, alpha2);
 	}
 
 	__connman_technology_enabled(type);
diff --git a/src/dnsproxy.c b/src/dnsproxy.c
index 7ebffbc0..d4242560 100644
--- a/src/dnsproxy.c
+++ b/src/dnsproxy.c
@@ -383,7 +383,7 @@ static void dummy_resolve_func(GResolvResultStatus status,
  * Refresh a DNS entry, but also age the hit count a bit */
 static void refresh_dns_entry(struct cache_entry *entry, char *name)
 {
-	int age = 1;
+	unsigned int age = 1;
 
 	if (!ipv4_resolve) {
 		ipv4_resolve = g_resolv_new(0);
@@ -485,9 +485,11 @@ static void send_cached_response(int sk, const unsigned char *ptr, size_t len,
 	 * so skip them for UDP.
 	 */
 	const size_t skip_bytes = offset ? 0 : DNS_HEADER_TCP_EXTRA_BYTES;
+	size_t dns_len;
+
 	ptr += skip_bytes;
 	len -= skip_bytes;
-	const size_t dns_len = protocol == IPPROTO_UDP ? len : ntohs(*((uint16_t*)ptr));
+	dns_len = protocol == IPPROTO_UDP ? len : ntohs(*((uint16_t*)ptr));
 
 
 	if (len < DNS_HEADER_SIZE)
@@ -847,14 +849,19 @@ static void create_cache(void)
 
 static struct cache_entry *cache_check(gpointer request, uint16_t *qtype, int proto)
 {
+	const char *question;
+	size_t offset;
+	const struct domain_question *q;
+	uint16_t type;
+	struct cache_entry *entry;
+
 	if (!request)
 		return NULL;
 
-	const char *question = request + protocol_offset(proto) + DNS_HEADER_SIZE;
-	const size_t offset = strlen(question) + 1;
-	const struct domain_question *q = (void *) (question + offset);
-	const uint16_t type = ntohs(q->type);
-	struct cache_entry *entry;
+	question = request + protocol_offset(proto) + DNS_HEADER_SIZE;
+	offset = strlen(question) + 1;
+	q = (void *) (question + offset);
+	type = ntohs(q->type);
 
 	/* We only cache either A (1) or AAAA (28) requests */
 	if (type != DNS_TYPE_A && type != DNS_TYPE_AAAA)
@@ -1028,6 +1035,9 @@ static int parse_response(const unsigned char *buf, size_t buflen,
 	uint16_t ancount, qclass;
 	GSList *aliases = NULL;
 	const size_t maxlen = *response_len;
+	uint16_t qdcount;
+	const unsigned char *ptr;
+	const unsigned char *eptr;
 
 	*response_len = 0;
 	*answers = 0;
@@ -1035,9 +1045,9 @@ static int parse_response(const unsigned char *buf, size_t buflen,
 	if (buflen < DNS_HEADER_SIZE)
 		return -EINVAL;
 
-	const uint16_t qdcount = ntohs(hdr->qdcount);
-	const unsigned char *ptr = buf + DNS_HEADER_SIZE;
-	const unsigned char *eptr = buf + buflen;
+	qdcount = ntohs(hdr->qdcount);
+	ptr = buf + DNS_HEADER_SIZE;
+	eptr = buf + buflen;
 
 	debug("qr %d qdcount %d", hdr->qr, qdcount);
 
@@ -2010,40 +2020,47 @@ static int dns_reply_fixup_domains(
 	int new_an_len;
 	const struct domain_hdr *hdr = (void *)(reply + offset);
 	const char *eom = reply + reply_len;
-	const uint16_t header_len = offset + DNS_HEADER_SIZE;
+	uint16_t header_len = offset + DNS_HEADER_SIZE;
+	uint16_t domain_len;
+	struct qtype_qclass *qtc;
+	uint16_t dns_type;
+	uint16_t dns_class;
+	uint16_t section_counts[3];
+	const char *ptr;
+	uint8_t host_len;
+	const char *domain;
+
 	/* full header plus at least one byte for the hostname length */
 	if (reply_len < header_len + 1)
 		return -EINVAL;
 
-	const uint16_t section_counts[] = {
-		hdr->ancount,
-		hdr->nscount,
-		hdr->arcount
-	};
+	section_counts[0] = hdr->ancount;
+	section_counts[1] = hdr->nscount;
+	section_counts[2] = hdr->arcount;
 
 	/*
 	 * length octet of the hostname.
 	 * ->hostname.domain.net
 	 */
-	const char *ptr = reply + header_len;
-	const uint8_t host_len = *ptr;
-	const char *domain = ptr + host_len + 1;
+	ptr = reply + header_len;
+	host_len = *ptr;
+	domain = ptr + host_len + 1;
 	if (domain >= eom)
 		return -EINVAL;
 
-	const uint16_t domain_len = host_len ? strnlen(domain, eom - domain) : 0;
+	domain_len = host_len ? strnlen(domain, eom - domain) : 0;
 
 	/*
 	 * If the query type is anything other than A or AAAA, then bail out
 	 * and pass the message as is.  We only want to deal with IPv4 or IPv6
 	 * addresses.
 	 */
-	const struct qtype_qclass *qtc = (void*)(domain + domain_len + 1);
+	qtc = (void*)(domain + domain_len + 1);
 	if (((const char*)(qtc + 1)) > eom)
 		return -EINVAL;
 
-	const uint16_t dns_type = ntohs(qtc->qtype);
-	const uint16_t dns_class = ntohs(qtc->qclass);
+	dns_type = ntohs(qtc->qtype);
+	dns_class = ntohs(qtc->qclass);
 
 	if (domain_len == 0) {
 		/* nothing to do */
@@ -3003,7 +3020,7 @@ static void dnsproxy_default_changed(struct connman_service *service)
 	 * the VPN must be enabled as well, when the transport becomes the
 	 * default service.
 	 */
-	vpn_index = __connman_connection_get_vpn_index(index);
+	vpn_index = __connman_gateway_get_vpn_index(index);
 
 	for (GSList *list = server_list; list; list = list->next) {
 		struct server_data *data = list->data;
@@ -3288,9 +3305,12 @@ read_another:
 	 */
 	entry = cache_check(client->buf, &qtype, IPPROTO_TCP);
 	if (entry) {
-		debug("cache hit %s type %s", query, qtype == DNS_TYPE_A ? "A" : "AAAA");
-		struct cache_data *data = qtype == DNS_TYPE_A ?
-			entry->ipv4 : entry->ipv6;
+		struct cache_data *data;
+
+		debug("cache hit %s type %s", query,
+					qtype == DNS_TYPE_A ? "A" : "AAAA");
+
+		data = qtype == DNS_TYPE_A ? entry->ipv4 : entry->ipv6;
 
 		if (data) {
 			int ttl_left = data->valid_until - time(NULL);
@@ -3401,6 +3421,13 @@ static gboolean tcp_client_event(GIOChannel *channel, GIOCondition condition,
 {
 	struct tcp_partial_client_data *client = user_data;
 	int client_sk = g_io_channel_unix_get_fd(channel);
+	int len;
+	struct sockaddr_in6 client_addr6;
+	socklen_t client_addr6_len = sizeof(client_addr6);
+	struct sockaddr_in client_addr4;
+	socklen_t client_addr4_len = sizeof(client_addr4);
+	void *client_addr;
+	socklen_t *client_addr_len;
 
 	if (condition & (G_IO_NVAL | G_IO_ERR | G_IO_HUP)) {
 		g_hash_table_remove(partial_tcp_req_table,
@@ -3410,13 +3437,6 @@ static gboolean tcp_client_event(GIOChannel *channel, GIOCondition condition,
 		return FALSE;
 	}
 
-	struct sockaddr_in6 client_addr6;
-	socklen_t client_addr6_len = sizeof(client_addr6);
-	struct sockaddr_in client_addr4;
-	socklen_t client_addr4_len = sizeof(client_addr4);
-	void *client_addr;
-	socklen_t *client_addr_len;
-
 	switch (client->family) {
 	case AF_INET:
 		client_addr = &client_addr4;
@@ -3433,7 +3453,7 @@ static gboolean tcp_client_event(GIOChannel *channel, GIOCondition condition,
 		return FALSE;
 	}
 
-	const int len = recvfrom(client_sk, client->buf + client->buf_end,
+	len = recvfrom(client_sk, client->buf + client->buf_end,
 			TCP_MAX_BUF_LEN - client->buf_end, 0,
 			client_addr, client_addr_len);
 	if (len < 0) {
@@ -3924,7 +3944,9 @@ static void destroy_tcp_listener(struct listener_data *ifdata)
 
 static int create_listener(struct listener_data *ifdata)
 {
-	int err = create_dns_listener(IPPROTO_UDP, ifdata);
+	int index, err;
+
+	err = create_dns_listener(IPPROTO_UDP, ifdata);
 	if ((err & UDP_FAILED) == UDP_FAILED)
 		return -EIO;
 
@@ -3934,7 +3956,7 @@ static int create_listener(struct listener_data *ifdata)
 		return -EIO;
 	}
 
-	int index = connman_inet_ifindex("lo");
+	index = connman_inet_ifindex("lo");
 	if (ifdata->index == index) {
 		if ((err & IPv6_FAILED) != IPv6_FAILED)
 			__connman_resolvfile_append(index, NULL, "::1");
diff --git a/src/gateway.c b/src/gateway.c
new file mode 100644
index 00000000..16c87f83
--- /dev/null
+++ b/src/gateway.c
@@ -0,0 +1,4086 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2013  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2011-2014  BMW Car IT GmbH.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+/**
+ *  @file
+ *    This implements non-client-facing functionality for managing
+ *    network service gateways and routes. It also serves as a Linux
+ *    Routing Netlink (rtnl) listener for routing table additions and
+ *    deletions in the Linux kernel.
+ *
+ *    Gateway lifecycle is generally top-down, from user space to
+ *    kernel. That is, Connection Manager manages and adds/sets or
+ *    gateway routes and then uses notifications from the kernel
+ *    Routing Netlink (rtnl) to confirm and "activate" those
+ *    routes. Likewise, Connection Manager removes/clears/deletes
+ *    gateway routes and then uses notifications from the kernel
+ *    Routing Netlink (rtnl) to confirm and "inactivate" those
+ *    routes. The following is the state machine for that lifecycle:
+ *
+ *                              .----------.    SIOCADDRT /
+ *                              |          |    RTM_NEWROUTE
+ *           .------------------| Inactive |--------------------.
+ *           |                  |          |                    |
+ *           |                  '----------'                    |
+ *           | connman_rtnl                                     |
+ *           | .delgateway                                      |
+ *           |                                                  V
+ *      .---------.         SIOCADDRT / RTM_NEWROUTE        .-------.
+ *      |         |---------------------------------------->|       |
+ *      | Removed |                                         | Added |
+ *      |         |<----------------------------------------|       |
+ *      '---------'         SIOCDELRT / RTM_DELROUTE        '-------'
+ *           ^                                                  |
+ *           | SIOCDELRT /                                      |
+ *           | RTM_DELROUTE                                     |
+ *           |                   .--------.     connman_rtnl    |
+ *           |                   |        |     .newgateway     |
+ *           '-------------------| Active |<--------------------'
+ *                               |        |
+ *                               '--------'
+ *
+ *    Gateways, and their associated routes, are generally of two types:
+ *
+ *      1. High-priority (that is, metric 0) default route.
+ *
+ *         This is used by the default service and its underlying
+ *         network interface.
+ *
+ *      2. Low-priority (that is, metric > 0) default route.
+ *
+ *         This is used by non-default services and their underlying
+ *         network interface.
+ *
+ *         For IPv6, these are handled and managed automatically by
+ *         the kernel as part of Router Discovery (RD) Router
+ *         Advertisements (RAs) and because link-local addresses and
+ *         multi-homing are a natural part of IPv6, nothing needs to
+ *         be done here. These routes show up in 'ip -6 route show'
+ *         as:
+ *
+ *             default via fe80::f29f:c2ff:fe10:271e dev eth0
+ *                 proto ra metric 1024 expires 1622sec hoplimit 64
+ *                 pref medium
+ *             default via fe80::f29f:c2ff:fe10:271e dev wlan0
+ *                 proto ra metric 1024 expires 1354sec hoplimit 64
+ *                 pref medium
+ *
+ *         For IPv4, largely invented before the advent of link-local
+ *         addresses and multi-homing hosts, these need to be
+ *         fully-managed here and, with such management, show up in
+ *         'ip -4 route show' as low-priority (that is, high metric
+ *         value) default routes:
+ *
+ *             default via 192.168.2.1 dev wlan0 metric 4294967295
+ *
+ *         The other alternative to low-priority routes would be to
+ *         use "def1" default routes commonly used by VPNs that have a
+ *         prefix length of 1 (hence the "def1" name). These would
+ *         show up as:
+ *
+ *             0.0.0.0/1 via 192.168.2.1 dev wlan0
+ *             128.0.0.0/1 via 192.168.2.1 dev wlan0
+ *
+ *         However, since these require twice the number of routing
+ *         table entries and seem no more effective than the
+ *         low-priority route approach, this alternative is not used
+ *         here at present.
+ *
+ *    VPNs and point-to-point (P2P) links get special treatment but
+ *    otherwise utilize the same states and types as described above.
+ *
+ *    Operationally, down calls from outside this module generally
+ *    come from the following three functions:
+ *
+ *      1. __connman_gateway_add
+ *      2. __connman_gateway_remove
+ *      3. __connman_gateway_update
+ *
+ *    and up calls generally come from the following two functions:
+ *
+ *      1. gateway_rtnl_new
+ *      2. gateway_rtnl_del
+ *
+ *    From these five functions above, we are then attempting to do
+ *    the following for a gateway associated with a network service
+ *    and its underlying network interface:
+ *
+ *      1. Set, or add, the high- or low-priority default route(s).
+ *      2. Unset, or remove, the high- or low-priority default route(s).
+ *      3. Promote the default route from low- to high-priority.
+ *      4. Demote the default route from high- to low-priority.
+ *
+ *    The call trees for these operations amount to:
+ *
+ *      set_default_gateway (1)
+ *        |
+ *        '-mutate_default_gateway
+ *            |
+ *            |-set_ipv4_high_priority_default_gateway
+ *            |   |
+ *            |   '-set_default_gateway_route_common
+ *            |       |
+ *            |       '-set_ipv4_high_priority_default_gateway_route_cb
+ *            |
+ *            '-set_ipv6_high_priority_default_gateway
+ *                |
+ *                '-set_default_gateway_route_common
+ *                    |
+ *                    '-set_ipv6_high_priority_default_gateway_route_cb
+ *
+ *      set_low_priority_default_gateway (1)
+ *        |
+ *        '-mutate_default_gateway
+ *            |
+ *            '-set_ipv4_low_priority_default_gateway
+ *                |
+ *                '-set_default_gateway_route_common
+ *                    |
+ *                    '-set_ipv4_low_priority_default_gateway_route_cb
+ *                        |
+ *                        '-compute_low_priority_metric
+ *
+ *      unset_default_gateway (2)
+ *        |
+ *        '-mutate_default_gateway
+ *            |
+ *            |-unset_ipv4_high_priority_default_gateway
+ *            |   |
+ *            |   '-unset_default_gateway_route_common
+ *            |       |
+ *            |       '-unset_ipv4_high_priority_default_gateway_route_cb
+ *            |
+ *            '-unset_ipv6_high_priority_default_gateway
+ *                |
+ *                '-unset_default_gateway_route_common
+ *                    |
+ *                    '-unset_ipv6_high_priority_default_gateway_route_cb
+ *
+ *      unset_low_priority_default_gateway (2)
+ *        |
+ *        '-mutate_default_gateway
+ *            |
+ *            '-unset_ipv4_low_priority_default_gateway
+ *                |
+ *                '-unset_default_gateway_route_common
+ *                    |
+ *                    '-unset_ipv4_low_priority_default_gateway_route_cb
+ *                        |
+ *                        '-compute_low_priority_metric
+ *
+ *      promote_default_gateway (3)
+ *        |
+ *        |-unset_low_priority_default_gateway (2)
+ *        |
+ *        '-set_default_gateway (1)
+ *
+ *      demote_default_gateway (4)
+ *        |
+ *        |-unset_default_gateway (2)
+ *        |
+ *        '-set_low_priority_default_gateway (1)
+ *
+ *    where:
+ *
+ *      * 'mutate_default_gateway' and
+ *        '{un,}set_default_gateway_route_common' are abstract,
+ *        generalized handlers that manage the broad error conditions
+ *        and gateway data and configuration lifecycle management.
+ *
+ *      * '*_route_cb' callbacks handle the actual routing table
+ *        manipulation as appropriate for the IP configuration and
+ *        gateway type, largely through the use of gateway
+ *        configuration "ops" to help neutralize differences between
+ *        IPv4 and IPv6.
+ *
+ *        In the fullness of time, the use of the gateway
+ *        configuration "ops" should allow further collapsing the IPv4
+ *        and IPv6 cases and simplifying the IP type-specific branches
+ *        of the above call trees.
+ *
+ *        The low-priority metric is determined on a per-network
+ *        interface basis and is computed by
+ *        'compute_low_priority_metric'.
+ *
+ *    There is one exception to the above. When the Linux kernel
+ *    recognizes that the next hop for a route becomes unreachable, it
+ *    is automatically purged from the routing table with no
+ *    RTM_DELROUTE RTNL notification.
+ *
+ *    Historically, this file started life as "connection.c". However,
+ *    it was renamed to "gateway.c" since its primary focus is gateway
+ *    routes and gateway route management.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+#include <string.h>
+#include <net/if.h>
+
+#include <gdbus.h>
+
+#include "connman.h"
+
+/*
+ * There are many call sites throughout this module for these
+ * functions. These are macros to help, during debugging, to acertain
+ * where they were called from.
+ */
+
+#define SET_DEFAULT_GATEWAY(data, type) \
+	set_default_gateway(data, type, __func__)
+
+#define UNSET_DEFAULT_GATEWAY(data, type) \
+	unset_default_gateway(data, type, __func__)
+
+#define SET_LOW_PRIORITY_DEFAULT_GATEWAY(data, type) \
+	set_low_priority_default_gateway(data, type, __func__)
+
+#define UNSET_LOW_PRIORITY_DEFAULT_GATEWAY(data, type) \
+	unset_low_priority_default_gateway(data, type, __func__)
+
+#define PROMOTE_DEFAULT_GATEWAY(data, type) \
+	promote_default_gateway(data, type, __func__)
+
+#define DEMOTE_DEFAULT_GATEWAY(data, type) \
+	demote_default_gateway(data, type, __func__)
+
+#define GATEWAY_CONFIG_DBG(description, config) \
+	gateway_config_debug(__func__, description, config)
+
+#define GATEWAY_DATA_DBG(description, data) \
+	gateway_data_debug(__func__, description, data)
+
+/**
+ *  Flags governing the state and use of a gateway configuration.
+ */
+enum gateway_config_flags {
+	/**
+	 *	Indicates there are no gateway configuration flags asserted.
+	 */
+	CONNMAN_GATEWAY_CONFIG_FLAG_NONE = 0,
+
+	/**
+	 *	Indicates whether the gateway configuration is part of a VPN.
+	 */
+	CONNMAN_GATEWAY_CONFIG_FLAG_VPN	 = 1U << 0
+};
+
+/**
+ *	@brief
+ *    Indicates the current lifecycle state of the gateway
+ *    configuration.
+ *
+ *  Gateway lifecycle is generally top-down, from user space to
+ *  kernel. That is, Connection Manager manages and adds/sets or
+ *  gateway routes and then uses notifications from the kernel Routing
+ *  Netlink (rtnl) to confirm and "activate" those routes. Likewise,
+ *  Connection Manager removes/clears/deletes gateway routes an then
+ *  uses notifications from the kernel Routing Netlink (rtnl) to
+ *  confirm and "inactivate" those routes. The following is the state
+ *  machine for that lifecycle:
+ *
+ *                              .----------.    SIOCADDRT /
+ *                              |          |    RTM_NEWROUTE
+ *           .------------------| Inactive |--------------------.
+ *           |                  |          |                    |
+ *           |                  '----------'                    |
+ *           | connman_rtnl                                     |
+ *           | .delgateway                                      |
+ *           |                                                  V
+ *      .---------.         SIOCADDRT / RTM_NEWROUTE        .-------.
+ *      |         |---------------------------------------->|       |
+ *      | Removed |                                         | Added |
+ *      |         |<----------------------------------------|       |
+ *      '---------'         SIOCDELRT / RTM_DELROUTE        '-------'
+ *           ^                                                  |
+ *           | SIOCDELRT /                                      |
+ *           | RTM_DELROUTE                                     |
+ *           |                   .--------.     connman_rtnl    |
+ *           |                   |        |     .newgateway     |
+ *           '-------------------| Active |<--------------------'
+ *                               |        |
+ *                               '--------'
+ *
+ */
+enum gateway_config_state {
+	/**
+	 *	Indicates whether the gateway, or default router, is inactive.
+	 */
+	CONNMAN_GATEWAY_CONFIG_STATE_INACTIVE = 0,
+
+	/**
+	 *	Indicates whether the gateway has been added, or set, to the
+	 *	kernel but not acknowledged round-trip.
+	 */
+	CONNMAN_GATEWAY_CONFIG_STATE_ADDED	  = 1,
+
+	/**
+	 *	Indicates whether the gateway, or default router, is added and
+	 *	acknowledged by the kernel through a Routing Netlink (rtnl)
+	 *	notification and, consequently, is active (that is, in use).
+	 */
+	CONNMAN_GATEWAY_CONFIG_STATE_ACTIVE	  = 2,
+
+	/**
+	 *	Indicates whether the gateway has been removed, or cleared,
+	 *	from the kernel but not acknowledged round-trip.
+	 */
+	CONNMAN_GATEWAY_CONFIG_STATE_REMOVED  = 3
+};
+
+/**
+ *	Indicates the current type or use of the gateway configuration.
+ */
+enum gateway_config_type {
+	/**
+	 *	Indicates the gateway, or default router, is not used for any
+	 *	route.
+	 */
+	CONNMAN_GATEWAY_CONFIG_TYPE_NONE				  = 0,
+
+	/**
+	 *	Indicates the gateway, or default router, is a high-priority
+	 *	(that is, metric 0) default route.
+	 */
+	CONNMAN_GATEWAY_CONFIG_TYPE_HIGH_PRIORITY_DEFAULT = 1,
+
+	/**
+	 *	Indicates the gateway, or default router, is a low-priority
+	 *	(that is, metric > 0) default route.
+	 */
+	CONNMAN_GATEWAY_CONFIG_TYPE_LOW_PRIORITY_DEFAULT  = 2
+};
+
+/**
+ *  Gateway configuration function pointers for IP configuration
+ *  type-specific route set/clear/add/delete operations.
+ */
+struct gateway_config_ops {
+	bool (*compare_subnet)(int index,
+		const char *address);
+
+	int (*get_dest_addr)(int index,
+		char **dest);
+
+	int (*add_interface_route)(int index);
+	int (*del_interface_route)(int index);
+
+	int (*add_default_route)(uint32_t table,
+		int index,
+		const char *gateway);
+	int (*del_default_route)(uint32_t table,
+		int index,
+		const char *gateway);
+
+	int (*add_default_route_with_metric)(uint32_t table,
+		int index,
+		const char *gateway,
+		uint32_t metric);
+	int (*del_default_route_with_metric)(uint32_t table,
+		int index,
+		const char *gateway,
+		uint32_t metric);
+
+	int (*add_host_route)(int index,
+		const char *host,
+		const char *gateway);
+	int (*del_host_route)(int index,
+		const char *host,
+		const char *gateway);
+};
+
+/**
+ *	An IP configuration type-specific data structure used to maintain
+ *	gateway-specific configuration information about a gateway, or
+ *	default router, and, for VPNs, the VPN peer.
+ */
+struct gateway_config {
+	/**
+	 *	A 32-bit flag bitfield governing the state and use of the
+	 *	configuration. See #gateway_config_flags.
+	 */
+	uint32_t flags;
+
+	/**
+	 *	Indicates the current state of the gateway configuration. See
+	 *	#gateway_config_state.
+	 */
+	enum gateway_config_state state;
+
+	/**
+	 *	Indicates the current type or use of the gateway configuration.
+	 *	See #gateway_config_type.
+	 */
+	enum gateway_config_type type;
+
+	/**
+	 *  A pointer to immutable function pointers for route
+	 *  set/clear/add/delete operations.
+	 */
+	const struct gateway_config_ops *ops;
+
+	/**
+	 *	A pointer to a mutable, dynamically-allocated null-terminated
+	 *	C string containing the text-formatted address of the gateway,
+	 *	or default router.
+	 */
+	char *gateway;
+
+	/* VPN extra data */
+	char *vpn_ip;
+	int vpn_phy_index;
+	char *vpn_phy_ip;
+};
+
+/**
+ *	The key data structure used to associate a network service with a
+ *	gateway, or default router.
+ */
+struct gateway_data {
+	/**
+	 *	The network interface index associated with the underlying
+	 *	network interface for the assigned @a service field.
+	 */
+	int index;
+
+	/**
+	 *	A strong (that is, uses #connman_service_{ref,unref})
+	 *	reference to the network service associated with this gateway.
+	 */
+	struct connman_service *service;
+
+	/**
+	 *	An optional weak reference to dynamically-allocated storage
+	 *	for the gateway-specific configuration, if the gateway is IPv4.
+	 */
+	struct gateway_config *ipv4_config;
+
+	/**
+	 *	An optional weak reference to dynamically-allocated storage
+	 *	for the gateway-specific configuration, if the gateway is IPv6.
+	 */
+	struct gateway_config *ipv6_config;
+
+	/**
+	 *	A Boolean indicating whether this gateway / network interface
+	 *	index tuple has been handled by the #connman_rtnl @a
+	 *	newgateway Linux Routing Netlink (rtnl) new gateway listener
+	 *	method and, specifically, whether that method has checked a
+	 *	new, incoming gateway against the current gateway / default
+	 *	router.
+	 */
+	bool default_checked;
+};
+
+/**
+ *	Function pointers to mutating (including, but not limited to,
+ *	adding/setting or clearing/deleting/removing routes) IPv4 and/or
+ *	IPv6 default gateways.
+ */
+struct mutate_default_gateway_ops {
+	/**
+	 *  An optional pointer to a function for mutating (including, but
+	 *  not limited to, adding/setting or clearing/deleting/removing
+	 *  routes) an IPv4 default gateway.
+	 *
+	 *  @param[in,out]  data    A pointer to the mutable IPv4 gateway
+	 *                          data to mutate.
+	 *  @param[in,out]  config  A pointer to the mutable IPv4 gateway
+	 *                          configuration to mutate.
+	 *
+	 *  @returns
+	 *    0 if successful; otherwise, < 0 on error.
+	 *
+	 */
+	int (*mutate_ipv4)(struct gateway_data *data,
+				struct gateway_config *config);
+
+	/**
+	 *  An optional pointer to a function for mutating (including, but
+	 *  not limited to, adding/setting or clearing/deleting/removing
+	 *  routes) an IPv6 default gateway.
+	 *
+	 *  @param[in,out]  data    A pointer to the mutable IPv6 gateway
+	 *                          data to mutate.
+	 *  @param[in,out]  config  A pointer to the mutable IPv6 gateway
+	 *                          configuration to mutate.
+	 *
+	 *  @returns
+	 *    0 if successful; otherwise, < 0 on error.
+	 *
+	 */
+	int (*mutate_ipv6)(struct gateway_data *data,
+				struct gateway_config *config);
+};
+
+/**
+ *  Prototype for a function callback to mutate (that is, add/set or
+ *  clear/delete/remove) a default route for a gateway using a function
+ *  utilizing a SIOCADDRT / SIOCDELRT socket ioctl or a RTM_NEWROUTE /
+ *  RTM_DELROUTE Linux Routing Netlink (rtnl) command to modify the Linux
+ *  routing table.
+ *
+ *  @param[in,out]  data    A pointer to the mutable gateway data to
+ *                          use to mutate the default route.
+ *  @param[in,out]  config  A pointer to the mutable gateway
+ *                          configuration to use to mutate the
+ *                          default route.
+ *
+ *  @returns
+ *    0 if successful; otherwise, < 0 on error.
+ *
+ */
+typedef int (*mutate_default_gateway_route_cb_t)(struct gateway_data *data,
+				struct gateway_config *config);
+
+static int unset_default_gateway(struct gateway_data *data,
+				enum connman_ipconfig_type type,
+				const char *function);
+static int unset_low_priority_default_gateway(struct gateway_data *data,
+				enum connman_ipconfig_type type,
+				const char *function);
+
+static const struct gateway_config_ops ipv4_gateway_config_ops = {
+	.compare_subnet				   =
+		connman_inet_compare_subnet,
+
+	.get_dest_addr				   =
+		connman_inet_get_dest_addr,
+
+	.add_interface_route		   =
+		connman_inet_set_gateway_interface,
+	.del_interface_route		   =
+		connman_inet_clear_gateway_interface,
+
+	.add_default_route			   =
+		__connman_inet_add_default_to_table,
+	.del_default_route			   =
+		__connman_inet_del_default_from_table,
+
+	.add_default_route_with_metric =
+		__connman_inet_add_default_to_table_with_metric,
+	.del_default_route_with_metric =
+		__connman_inet_del_default_from_table_with_metric,
+
+	.add_host_route				   =
+		connman_inet_add_host_route,
+	.del_host_route				   =
+		connman_inet_del_host_route
+};
+
+static const struct gateway_config_ops ipv6_gateway_config_ops = {
+	.compare_subnet				   =
+		connman_inet_compare_ipv6_subnet,
+
+	.get_dest_addr				   =
+		connman_inet_ipv6_get_dest_addr,
+
+	.add_interface_route		   =
+		connman_inet_set_ipv6_gateway_interface,
+	.del_interface_route		   =
+		connman_inet_clear_ipv6_gateway_interface,
+
+	.add_default_route			   =
+		__connman_inet_add_default_to_table,
+	.del_default_route			   =
+		__connman_inet_del_default_from_table,
+
+	.add_default_route_with_metric =
+		__connman_inet_add_default_to_table_with_metric,
+	.del_default_route_with_metric =
+		__connman_inet_del_default_from_table_with_metric,
+
+	.add_host_route				   =
+		connman_inet_add_ipv6_host_route,
+	.del_host_route				   =
+		connman_inet_del_ipv6_host_route
+};
+
+/*
+ * These are declared as 'const char *const' to effect an immutable
+ * pointer to an immutable null-terminated character string such that
+ * they end up in .text, not .data (which would otherwise be the case
+ * for a 'const char *' declaration), and with the 'static'
+ * storage/scope qualifier, the compiler can optimize their use within
+ * this file as it sees fit.
+ */
+static const char *const ipv4_addr_any_str = "0.0.0.0";
+static const char *const ipv6_addr_any_str = "::";
+
+/**
+ *	A dictionary / hash table of network services to gateway, or
+ *	default router, data.
+ *
+ */
+static GHashTable *gateway_hash = NULL;
+
+/**
+ *  @brief
+ *    Return the specified pointer if non-null; otherwise, the
+ *    immutable "<null>" string.
+ *
+ *  @param[in]  pointer  The pointer to be returned if non-null.
+ *
+ *  @returns
+ *     @a pointer if non-null; otherwise the "<null>" immutable
+ *     null-terminated C string.
+ *
+ */
+static const char *maybe_null(const void *pointer)
+{
+	return pointer ? pointer : "<null>";
+}
+
+static bool is_gateway_config_flags_set(const struct gateway_config *config,
+		uint32_t flags)
+{
+	return config && ((config->flags & flags) == flags);
+}
+
+static void gateway_config_flags_clear(struct gateway_config *config,
+		uint32_t flags)
+{
+	config->flags &= ~flags;
+}
+
+static void gateway_config_flags_set(struct gateway_config *config,
+	uint32_t flags)
+{
+	config->flags |= flags;
+}
+
+static bool is_gateway_config_vpn(const struct gateway_config *config)
+{
+	static const uint32_t flags =
+		CONNMAN_GATEWAY_CONFIG_FLAG_VPN;
+
+	return is_gateway_config_flags_set(config, flags);
+}
+
+static void gateway_config_set_vpn(struct gateway_config *config)
+{
+	static const uint32_t flags =
+		CONNMAN_GATEWAY_CONFIG_FLAG_VPN;
+
+	return gateway_config_flags_set(config, flags);
+}
+
+static void gateway_config_clear_vpn(struct gateway_config *config)
+{
+	static const uint32_t flags =
+		CONNMAN_GATEWAY_CONFIG_FLAG_VPN;
+
+	return gateway_config_flags_clear(config, flags);
+}
+
+static const char *gateway_config_state2string(enum gateway_config_state state)
+{
+	switch (state) {
+	case CONNMAN_GATEWAY_CONFIG_STATE_INACTIVE:
+		return "inactive";
+	case CONNMAN_GATEWAY_CONFIG_STATE_ADDED:
+		return "added";
+	case CONNMAN_GATEWAY_CONFIG_STATE_ACTIVE:
+		return "active";
+	case CONNMAN_GATEWAY_CONFIG_STATE_REMOVED:
+		return "removed";
+	}
+
+	return NULL;
+}
+
+static const char *gateway_config_type2string(enum gateway_config_type type)
+{
+	switch (type) {
+	case CONNMAN_GATEWAY_CONFIG_TYPE_NONE:
+		return "none";
+	case CONNMAN_GATEWAY_CONFIG_TYPE_HIGH_PRIORITY_DEFAULT:
+		return "high-priority default";
+	case CONNMAN_GATEWAY_CONFIG_TYPE_LOW_PRIORITY_DEFAULT:
+		return "low-priority default";
+	}
+
+	return NULL;
+}
+
+static void gateway_config_state_set(struct gateway_config *config,
+				enum gateway_config_state state)
+{
+	DBG("config %p old state %d (%s) => new state %d (%s)",
+		config,
+		config->state, gateway_config_state2string(config->state),
+		state, gateway_config_state2string(state));
+
+	config->state = state;
+}
+
+static bool is_gateway_config_state(const struct gateway_config *config,
+				enum gateway_config_state state)
+{
+	return config->state == state;
+}
+
+static bool is_gateway_config_state_inactive(
+				const struct gateway_config *config)
+{
+	return is_gateway_config_state(config,
+				CONNMAN_GATEWAY_CONFIG_STATE_INACTIVE);
+}
+
+static bool is_gateway_config_state_added(const struct gateway_config *config)
+{
+	return is_gateway_config_state(config,
+				CONNMAN_GATEWAY_CONFIG_STATE_ADDED);
+}
+
+static bool is_gateway_config_state_removed(
+				const struct gateway_config *config)
+{
+	return is_gateway_config_state(config,
+				CONNMAN_GATEWAY_CONFIG_STATE_REMOVED);
+}
+
+static bool is_gateway_config_state_active(const struct gateway_config *config)
+{
+	return is_gateway_config_state(config,
+				CONNMAN_GATEWAY_CONFIG_STATE_ACTIVE);
+}
+
+static void gateway_config_type_set(struct gateway_config *config,
+				enum gateway_config_type type)
+{
+	DBG("config %p old type %d (%s) => new type %d (%s)",
+		config,
+		config->type, gateway_config_type2string(config->type),
+		type, gateway_config_type2string(type));
+
+	config->type = type;
+}
+
+static bool is_gateway_config_type(const struct gateway_config *config,
+				enum gateway_config_type type)
+{
+	return config->type == type;
+}
+
+static void gateway_config_set_active(struct gateway_config *config)
+{
+	gateway_config_state_set(config, CONNMAN_GATEWAY_CONFIG_STATE_ACTIVE);
+}
+
+static void gateway_config_set_inactive(struct gateway_config *config)
+{
+	gateway_config_state_set(config,
+		CONNMAN_GATEWAY_CONFIG_STATE_INACTIVE);
+
+	gateway_config_type_set(config,
+		CONNMAN_GATEWAY_CONFIG_TYPE_NONE);
+}
+
+/**
+ *  @brief
+ *    Conditionally log the specified gateway configuration.
+ *
+ *  This conditionally logs at the debug level the specified
+ *  #gateway_config gateway configuration, @a config, with the
+ *  provided description, @a description, attributed to the provided
+ *  function name, @a function.
+ *
+ *  @param[in]  function     A pointer to an immutable null-terminated
+ *                           C string containing the function name to
+ *                           which the call to this function should be
+ *                           attributed.
+ *  @param[in]  description  A pointer to an immutable null-terminated
+ *                           C string briefly describing @a
+ *                           config. For example, "ipv4_config".
+ *  @param[in]  config       A pointer to the immutable gateway
+ *                           configuration to conditionally log.
+ *
+ *  @sa DBG
+ *
+ */
+static void gateway_config_debug(const char *function,
+				const char *description,
+				const struct gateway_config *config)
+{
+	g_autofree char *vpn_phy_interface = NULL;
+
+	if (!function || !description)
+		return;
+
+	if (!config)
+		DBG("from %s() %s %p", function, description, config);
+	else {
+		if (config->vpn_phy_index >= 0)
+			vpn_phy_interface =
+				connman_inet_ifname(config->vpn_phy_index);
+
+		DBG("from %s() "
+			"%s %p: { state: %d (%s), type %d (%s), "
+			"flags: 0x%x (%s), "
+			"ops: %p, "
+			"gateway: %p (%s), "
+			"vpn_ip: %p (%s), vpn_phy_index: %d (%s), "
+			"vpn_phy_ip: %p (%s) }",
+			function,
+			description,
+			config,
+			config->state,
+			maybe_null(gateway_config_state2string(config->state)),
+			config->type,
+			maybe_null(gateway_config_type2string(config->type)),
+			config->flags,
+			is_gateway_config_vpn(config) ? "VPN" : "",
+			config->ops,
+			config->gateway, maybe_null(config->gateway),
+			config->vpn_ip, maybe_null(config->vpn_ip),
+			config->vpn_phy_index, maybe_null(vpn_phy_interface),
+			config->vpn_phy_ip, maybe_null(config->vpn_phy_ip));
+	}
+}
+
+/**
+ *  @brief
+ *    Conditionally log the specified gateway data.
+ *
+ *  This conditionally logs at the debug level the specified
+ *  #gateway_data gateway data, @a data, with the provided
+ *  description, @a description, attributed to the provided function
+ *  name, @a function.
+ *
+ *  @param[in]  function     A pointer to an immutable null-terminated
+ *                           C string containing the function name to
+ *                           which the call to this function should be
+ *                           attributed.
+ *  @param[in]  description  A pointer to an immutable null-terminated
+ *                           C string briefly describing @a
+ *                           data. For example, "default_gateway".
+ *  @param[in]  data         A pointer to the immutable gateway
+ *                           data to conditionally log.
+ *
+ *  @sa DBG
+ *  @sa gateway_config_debug
+ *
+ */
+static void gateway_data_debug(const char *function,
+				const char *description,
+				const struct gateway_data *data)
+{
+	g_autofree char *interface = NULL;
+
+	if (!function || !description)
+		return;
+
+	if (!data)
+		DBG("from %s() %s %p", function, description, data);
+	else {
+		interface = connman_inet_ifname(data->index);
+
+		DBG("from %s() %s %p: { index: %d (%s), service: %p (%s), "
+			"ipv4_config: %p, ipv6_config: %p, default_checked: %u }",
+			function,
+			description,
+			data,
+			data->index,
+			maybe_null(interface),
+			data->service,
+			connman_service_get_identifier(data->service),
+			data->ipv4_config,
+			data->ipv6_config,
+			data->default_checked);
+
+		if (data->ipv4_config)
+			gateway_config_debug(function, "ipv4_config",
+				data->ipv4_config);
+
+		if (data->ipv6_config)
+			gateway_config_debug(function, "ipv6_config",
+				data->ipv6_config);
+	}
+}
+
+/**
+ *  @brief
+ *    Return the IP-specific gateway configuration for the specified
+ *    gateway data.
+ *
+ *  @param[in]  data  A pointer to the mutable gateway data for which
+ *                    the gateway configuration is to be returned,
+ *                    specific to @a type.
+ *  @param[in]  type  The IP configuration type for which the gateway
+ *                    configuration is to be returned.
+ *
+ *  @returns
+ *    The IP-specific gateway configuration for the specified gateway
+ *    data on success; otherwise, null.
+ *
+ */
+static struct gateway_config *gateway_data_config_get(struct gateway_data *data,
+				enum connman_ipconfig_type type)
+{
+	struct gateway_config *config = NULL;
+
+	if (!data)
+		return config;
+
+	switch (type) {
+	case CONNMAN_IPCONFIG_TYPE_IPV4:
+		config = data->ipv4_config;
+		break;
+	case CONNMAN_IPCONFIG_TYPE_IPV6:
+		config = data->ipv6_config;
+		break;
+	case CONNMAN_IPCONFIG_TYPE_UNKNOWN:
+	case CONNMAN_IPCONFIG_TYPE_ALL:
+	default:
+		break;
+	}
+
+	return config;
+}
+
+/**
+ *  @brief
+ *    Determine whether the specified text-formatted IPv4 address is
+ *    the "any" or "unspecified" address.
+ *
+ *  This determines whether the specified text-formatted IPv4 address
+ *  is the "any" or "unspecified" address, that is "0.0.0.0".
+ *
+ *  @param[in]  address  A pointer to an immutable null-terminated C
+ *                       string containing the text-formatted address
+ *                       to determine whether it is the IPv4 "any" or
+ *                       "unspecified address.
+ *
+ *  @returns
+ *    True if @a address is the "any" or "unspecified" IPv4 address;
+ *    otherwise, false.
+ *
+ *  @sa is_ipv6_addr_any_str
+ *
+ */
+static bool is_ipv4_addr_any_str(const char *address)
+{
+	return g_strcmp0(ipv4_addr_any_str, address) == 0;
+}
+
+/**
+ *  @brief
+ *    Determine whether the specified text-formatted IPv6 address is
+ *    the "any" or "unspecified" address.
+ *
+ *  This determines whether the specified text-formatted IPv6 address
+ *  is the "any" or "unspecified" address, that is "::".
+ *
+ *  @param[in]  address  A pointer to an immutable null-terminated C
+ *                       string containing the text-formatted address
+ *                       to determine whether it is the IPv6 "any" or
+ *                       "unspecified address.
+ *
+ *  @returns
+ *    True if @a address is the "any" or "unspecified" IPv6 address;
+ *    otherwise, false.
+ *
+ *  @sa is_ipv4_addr_any_str
+ *
+ */
+static bool is_ipv6_addr_any_str(const char *address)
+{
+	return g_strcmp0(ipv6_addr_any_str, address) == 0;
+}
+
+/**
+ *  @brief
+ *    Determine whether the specified text-formatted IP address is
+ *    the "any" or "unspecified" address.
+ *
+ *  This determines whether the specified text-formatted IP address
+ *  is the "any" or "unspecified" address.
+ *
+ *  @param[in]  address  A pointer to an immutable null-terminated C
+ *                       string containing the text-formatted address
+ *                       to determine whether it is the IP "any" or
+ *                       "unspecified address.
+ *
+ *  @returns
+ *    True if @a address is the "any" or "unspecified" IP address;
+ *    otherwise, false.
+ *
+ *  @sa is_ipv4_addr_any_str
+ *  @sa is_ipv6_addr_any_str
+ *
+ */
+static bool is_addr_any_str(const char *address)
+{
+	if (!address)
+		return false;
+
+	return (!strchr(address, ':') && is_ipv4_addr_any_str(address)) ||
+				is_ipv6_addr_any_str(address);
+}
+
+/**
+ *  @brief
+ *    Find the gateway, or default router, configuration associated
+ *    with a network interface index.
+ *
+ *  This attempts to find a gateway, or default router, configuration
+ *  associated with the specified network interface index.
+ *
+ *  It is possible that there is both an IPv4 and IPv6 gateway, or
+ *  default router, configuration exist for an index. The IP address
+ *  family associated with @a gateway will uniqueify and select among
+ *  them.
+ *
+ *  @param[in]  index    The network interface index for which to find
+ *                       gateway, or default router, configuration.
+ *  @param[in]  gateway  A pointer to an immutable null-
+ *                       terminated C string containing the
+ *                       text-formatted address of the gateway, or
+ *                       default router, for which to find its
+ *                       associated configuration.
+ *
+ *  @returns
+ *    A pointer to the gateway, or default router, configuration
+ *    associated with the provided network interface index on success;
+ *    otherwise, null.
+ *
+ *  @sa find_gateway_data
+ *
+ */
+static struct gateway_config *find_gateway_config(int index,
+				const char *gateway)
+{
+	GHashTableIter iter;
+	gpointer value, key;
+
+	if (!gateway)
+		return NULL;
+
+	g_hash_table_iter_init(&iter, gateway_hash);
+
+	while (g_hash_table_iter_next(&iter, &key, &value)) {
+		struct gateway_data *data = value;
+
+		if (data->ipv4_config && data->index == index &&
+				g_str_equal(data->ipv4_config->gateway,
+					gateway))
+			return data->ipv4_config;
+
+		if (data->ipv6_config && data->index == index &&
+				g_str_equal(data->ipv6_config->gateway,
+					gateway))
+			return data->ipv6_config;
+	}
+
+	return NULL;
+}
+
+/**
+ *  @brief
+ *    Find the gateway, or default router, data associated
+ *    with the configuration.
+ *
+ *  This attempts to find a gateway, or default router, data
+ *  associated with the specified configuration.
+ *
+ *  @param[in]  config   A pointer to an immutable gateway, or
+ *                       default router, configuration for which to
+ *                       find the associated gateway data.
+ *
+ *  @returns
+ *    A pointer to the gateway, or default router, data associated
+ *    with the provided configuration on success; otherwise, null.
+ *
+ *  @sa find_gateway_config
+ *
+ */
+static struct gateway_data *find_gateway_data(
+				const struct gateway_config *config)
+{
+	GHashTableIter iter;
+	gpointer value, key;
+
+	if (!config)
+		return NULL;
+
+	g_hash_table_iter_init(&iter, gateway_hash);
+
+	while (g_hash_table_iter_next(&iter, &key, &value)) {
+		struct gateway_data *data = value;
+
+		if (data->ipv4_config &&
+				data->ipv4_config == config)
+			return data;
+
+		if (data->ipv6_config &&
+				data->ipv6_config == config)
+			return data;
+	}
+
+	return NULL;
+}
+
+/**
+ *  @brief
+ *    Find the first, or any, gateway data marked active.
+ *
+ *  This attempts to find the first, or any, gateway data marked
+ *  active.
+ *
+ *  @returns
+ *    A pointer to the first, or any, gateway data marked active on
+ *    success; otherwise, null.
+ *
+ *  @sa find_default_gateway_data
+ *  @sa find_gateway_data
+ *
+ */
+static struct gateway_data *find_any_active_gateway_data(void)
+{
+	GHashTableIter iter;
+	gpointer value, key;
+
+	DBG("");
+
+	g_hash_table_iter_init(&iter, gateway_hash);
+
+	while (g_hash_table_iter_next(&iter, &key, &value)) {
+		struct gateway_data *data = value;
+
+		if (data->ipv4_config &&
+				is_gateway_config_state_active(
+					data->ipv4_config))
+			return data;
+
+		if (data->ipv6_config &&
+				is_gateway_config_state_active(
+					data->ipv6_config))
+			return data;
+	}
+
+	return NULL;
+}
+
+/**
+ *  @brief
+ *    Find the gateway, or default router, data associated with the
+ *    default service.
+ *
+ *  This attempts to find the gateway, or default router, data
+ *  associated with default network service (that is, has the
+ *  high-priority default route).
+ *
+ *  @returns
+ *    A pointer to the gateway, or default router, data associated
+ *    with the default network service (that is, has the high-priority
+ *    default route) on success; otherwise, null.
+ *
+ *  @sa find_any_active_gateway_data
+ *  @sa find_gateway_data
+ *
+ */
+static struct gateway_data *find_default_gateway_data(void)
+{
+	struct connman_service *service;
+
+	service = connman_service_get_default();
+	if (!service)
+		return NULL;
+
+	return g_hash_table_lookup(gateway_hash, service);
+}
+
+static struct gateway_data *find_vpn_gateway_data(int index,
+				const char *gateway)
+{
+	GHashTableIter iter;
+	gpointer value, key;
+
+	if (!gateway)
+		return NULL;
+
+	g_hash_table_iter_init(&iter, gateway_hash);
+
+	while (g_hash_table_iter_next(&iter, &key, &value)) {
+		struct gateway_data *data = value;
+
+		if (data->ipv4_config && data->index == index &&
+				g_str_equal(data->ipv4_config->gateway,
+					gateway))
+			return data;
+
+		if (data->ipv6_config && data->index == index &&
+				g_str_equal(data->ipv6_config->gateway,
+					gateway))
+			return data;
+	}
+
+	return NULL;
+}
+
+struct get_gateway_params {
+	char *vpn_gateway;
+	int vpn_index;
+};
+
+static void get_gateway_cb(const char *gateway, int index, void *user_data)
+{
+	struct gateway_config *config;
+	struct gateway_data *data;
+	struct get_gateway_params *params = user_data;
+	int family;
+
+	if (index < 0)
+		goto out;
+
+	DBG("phy index %d phy gw %s vpn index %d vpn gw %s", index, gateway,
+		params->vpn_index, params->vpn_gateway);
+
+	data = find_vpn_gateway_data(params->vpn_index, params->vpn_gateway);
+	if (!data) {
+		DBG("Cannot find VPN link route, index %d addr %s",
+			params->vpn_index, params->vpn_gateway);
+		goto out;
+	}
+
+	family = connman_inet_check_ipaddress(params->vpn_gateway);
+
+	if (family == AF_INET)
+		config = data->ipv4_config;
+	else if (family == AF_INET6)
+		config = data->ipv6_config;
+	else
+		goto out;
+
+	config->vpn_phy_index = index;
+
+	DBG("vpn %s phy index %d", config->vpn_ip, config->vpn_phy_index);
+
+out:
+	g_free(params->vpn_gateway);
+	g_free(params);
+}
+
+static void set_vpn_routes(struct gateway_data *new_gateway,
+			struct connman_service *service,
+			const char *gateway,
+			enum connman_ipconfig_type type,
+			const char *peer,
+			struct gateway_data *active_gateway)
+{
+	struct gateway_config *config;
+	struct connman_ipconfig *ipconfig;
+	char *dest;
+
+	DBG("new %p service %p gw %s type %d peer %s active %p",
+		new_gateway, service, gateway, type, peer, active_gateway);
+
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV4) {
+		ipconfig = __connman_service_get_ip4config(service);
+		config = new_gateway->ipv4_config;
+	} else if (type == CONNMAN_IPCONFIG_TYPE_IPV6) {
+		ipconfig = __connman_service_get_ip6config(service);
+		config = new_gateway->ipv6_config;
+	} else
+		return;
+
+	if (config) {
+		int index = __connman_ipconfig_get_index(ipconfig);
+		struct get_gateway_params *params;
+
+		gateway_config_set_vpn(config);
+
+		if (peer)
+			config->vpn_ip = g_strdup(peer);
+		else if (gateway)
+			config->vpn_ip = g_strdup(gateway);
+
+		params = g_try_malloc(sizeof(struct get_gateway_params));
+		if (!params)
+			return;
+
+		params->vpn_index = index;
+		params->vpn_gateway = g_strdup(gateway);
+
+		/*
+		 * Find the gateway that is serving the VPN link
+		 */
+		__connman_inet_get_route(gateway, get_gateway_cb, params);
+	}
+
+	if (!active_gateway)
+		return;
+
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV4) {
+		/*
+		 * Special route to VPN server via gateway. This
+		 * is needed so that we can access hosts behind
+		 * the VPN. The route might already exist depending
+		 * on network topology.
+		 */
+		if (!active_gateway->ipv4_config)
+			return;
+
+
+		/*
+		 * If VPN server is on same subnet as we are, skip adding
+		 * route.
+		 */
+		if (config->ops->compare_subnet(active_gateway->index,
+								gateway))
+			return;
+
+		DBG("active gw %s", active_gateway->ipv4_config->gateway);
+
+		if (!is_addr_any_str(active_gateway->ipv4_config->gateway))
+			dest = active_gateway->ipv4_config->gateway;
+		else
+			dest = NULL;
+
+		active_gateway->ipv4_config->ops->add_host_route(
+							active_gateway->index,
+							gateway,
+							dest);
+
+	} else if (type == CONNMAN_IPCONFIG_TYPE_IPV6) {
+
+		if (!active_gateway->ipv6_config)
+			return;
+
+		if (config->ops->compare_subnet(active_gateway->index,
+								gateway))
+			return;
+
+		DBG("active gw %s", active_gateway->ipv6_config->gateway);
+
+		if (!is_addr_any_str(active_gateway->ipv6_config->gateway))
+			dest = active_gateway->ipv6_config->gateway;
+		else
+			dest = NULL;
+
+		active_gateway->ipv6_config->ops->add_host_route(
+							active_gateway->index,
+							gateway,
+							dest);
+	}
+}
+
+/**
+ *  @brief
+ *    Delete all gateway, or default router, default or host routes
+ *    for the gateway data.
+ *
+ *  This attempts to delete, or remove, all gateway, or default
+ *  router, default or host routes associated with the specified
+ *  gateway data.
+ *
+ *  @note
+ *    Deletions or removals are restricted to the network * interface
+ *    associated with the network interface index specified by * the
+ *    @a data @a index field.
+ *
+ *  @param[in]  data  A pointer to the mutable gateway data for which
+ *                    to delete or remove all gateway, or default
+ *                    router, default or host routes.
+ *  @param[in]  type  The IP configuration type for which the gateway,
+ *                    or default router, default or host routes are to
+ *                    be deleted or removed.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to delete routes.
+ *  @retval  -EINVAL  If the routing information to be deleted was
+ *                    invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    deleted was invalid.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ *  @sa connman_inet_clear_gateway_address
+ *  @sa connman_inet_clear_gateway_interface
+ *  @sa connman_inet_clear_ipv6_gateway_address
+ *  @sa connman_inet_clear_ipv6_gateway_interface
+ *  @sa connman_inet_del_host_route
+ *  @sa connman_inet_del_ipv6_host_route
+ *  @sa del_gateway_routes_if_active
+ *
+ */
+static int del_gateway_routes(struct gateway_data *data,
+			enum connman_ipconfig_type type)
+{
+	int status4 = 0, status6 = 0;
+	bool do_ipv4 = false, do_ipv6 = false;
+
+	DBG("data %p type %d (%s)", data,
+		type, __connman_ipconfig_type2string(type));
+
+	GATEWAY_DATA_DBG("data", data);
+
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
+		do_ipv4 = true;
+	else if (type == CONNMAN_IPCONFIG_TYPE_IPV6)
+		do_ipv6 = true;
+	else if (type == CONNMAN_IPCONFIG_TYPE_ALL)
+		do_ipv4 = do_ipv6 = true;
+	else
+		return -EINVAL;
+
+	if (do_ipv4 && data->ipv4_config) {
+		if (is_gateway_config_vpn(data->ipv4_config)) {
+			status4 = connman_inet_clear_gateway_address(
+						data->index,
+						data->ipv4_config->vpn_ip);
+
+		} else {
+			data->ipv4_config->ops->del_host_route(
+						data->index,
+						data->ipv4_config->gateway,
+						NULL);
+
+			status4 = UNSET_DEFAULT_GATEWAY(data, type);
+
+			UNSET_LOW_PRIORITY_DEFAULT_GATEWAY(data, type);
+		}
+	}
+
+	if (do_ipv6 && data->ipv6_config) {
+		if (is_gateway_config_vpn(data->ipv6_config)) {
+			status6 = connman_inet_clear_ipv6_gateway_address(
+						data->index,
+						data->ipv6_config->vpn_ip);
+
+		} else {
+			data->ipv6_config->ops->del_host_route(
+						data->index,
+						data->ipv6_config->gateway,
+						NULL);
+
+			status6 = UNSET_DEFAULT_GATEWAY(data, type);
+
+			UNSET_LOW_PRIORITY_DEFAULT_GATEWAY(data, type);
+		}
+	}
+
+	DBG("status4 %d (%s) status6 %d (%s)",
+		status4, strerror(-status4),
+		status6, strerror(-status6));
+
+	return (status4 < 0 ? status4 : status6);
+}
+
+/**
+ *  @brief
+ *    Delete all gateway, or default router, default or host routes
+ *    for the gateway data, if they are active.
+ *
+ *  This attempts to delete, or remove, all gateway, or default
+ *  router, default or host routes associated with the specified
+ *  gateway data, if the corresponding gateway configuration for the
+ *  specified type, @a type, is marked as active.
+ *
+ *  @note
+ *    Deletions or removals are restricted to the network interface
+ *    associated with the network interface index specified by the
+ *    @a data @a index field.
+ *
+ *  @param[in]  data  A pointer to the mutable gateway data for which
+ *                    to delete or remove all gateway, or default
+ *                    router, default or host routes, if they are
+ *                    active.
+ *  @param[in]  type  The IP configuration type for which the gateway,
+ *                    or default router, default or host routes are to
+ *                    be deleted or removed.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If data is null, if type is
+ *                    #CONNMAN_IPCONFIG_TYPE_UNKNOWN, if the routing
+ *                    information to be deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to delete routes.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    deleted was invalid.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ *  @sa del_gateway_routes
+ *
+ */
+static int del_gateway_routes_if_active(struct gateway_data *data,
+			enum connman_ipconfig_type type)
+{
+	bool active = false;
+
+	DBG("data %p type %d (%s)", data,
+		type, __connman_ipconfig_type2string(type));
+
+	if (!data || type == CONNMAN_IPCONFIG_TYPE_UNKNOWN)
+		return -EINVAL;
+
+	GATEWAY_DATA_DBG("data", data);
+
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV4) {
+		if (data->ipv4_config)
+			active = is_gateway_config_state_active(
+						data->ipv4_config);
+	} else if (type == CONNMAN_IPCONFIG_TYPE_IPV6) {
+		if (data->ipv6_config)
+			active = is_gateway_config_state_active(
+						data->ipv6_config);
+	} else if (type == CONNMAN_IPCONFIG_TYPE_ALL)
+		active = true;
+
+	DBG("active %u", active);
+
+	if (active)
+		return del_gateway_routes(data, type);
+
+	return 0;
+}
+
+/**
+ *  @brief
+ *    Associate, or add, a new gateway, or default router, with a
+ *    network service.
+ *
+ *  This attempts to associate, or add, a new gateway, or default
+ *  router, with a network service. On success, a strong (that is,
+ *  uses #connman_service_{ref,unref}) reference to @a service is
+ *  retained in the service-to-gateway data hash.
+ *
+ *  @note
+ *    The caller is responsible for deallocating the memory assigned
+ *    to @a *data on success.
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           object with which to associate @a
+ *                           gateway. On success, a strong (that is,
+ *                           uses #connman_service_{ref,unref})
+ *                           reference to this service is retained
+ *                           in the service-to-gateway data hash.
+ *  @param[in]      index    The network interface index for the
+ *                           network interface backing @a service.
+ *  @param[in]      gateway  A pointer to an immutable null-
+ *                           terminated C string containing the
+ *                           text-formatted address of the gateway, or
+ *                           default router, with which to associated
+ *                           with @a service.
+ *  @param[in]      type     The IP configuration type for the gateway,
+ *                           or default router.
+ *  @param[in,out]  data     A pointer to mutable storage for a mutable
+ *                           pointer to a #gateway_data structure. On
+ *                           success, this is assigned a newly-
+ *                           allocated and added structure that
+ *                           associates the @a gateway with @a service
+ *                           and @a type. The caller is responsible
+ *                           for deallocating the memory assigned to
+ *                           @a *data on success.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If service is null, if the network interface @a
+ *                    index is invalid, if @a gateway is null or zero
+ *                    in length, if type is not
+ *                    #CONNMAN_IPCONFIG_TYPE_IPV4 or
+ *                    #CONNMAN_IPCONFIG_TYPE_IPV6, or if @a data is
+ *                    null.
+ *  @retval  -ENOMEM  If memory could not be allocated for the
+ *                    #gateway_data structure and its associated
+ *                    #gateway_config.
+ *
+ *  @sa __connman_gateway_add
+ *  @sa del_gateway_routes_if_active
+ *
+ */
+static int add_gateway(struct connman_service *service,
+					int index, const char *gateway,
+					enum connman_ipconfig_type type,
+					struct gateway_data **data)
+{
+	g_autofree struct gateway_data *temp_data = NULL;
+	struct gateway_config *config = NULL;
+	struct gateway_data *old;
+	int err = 0;
+
+	if (!service || index < 0 || !gateway || strlen(gateway) == 0 || !data)
+		return -EINVAL;
+
+	switch (type) {
+	case CONNMAN_IPCONFIG_TYPE_IPV4:
+	case CONNMAN_IPCONFIG_TYPE_IPV6:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	temp_data = g_try_new0(struct gateway_data, 1);
+	if (!temp_data)
+		return -ENOMEM;
+
+	temp_data->index = index;
+
+	config = g_try_new0(struct gateway_config, 1);
+	if (!config)
+		return -ENOMEM;
+
+	config->state = CONNMAN_GATEWAY_CONFIG_STATE_INACTIVE;
+	config->type = CONNMAN_GATEWAY_CONFIG_TYPE_NONE;
+	config->flags = CONNMAN_GATEWAY_CONFIG_FLAG_NONE;
+	config->gateway = g_strdup(gateway);
+	config->vpn_ip = NULL;
+	config->vpn_phy_ip = NULL;
+	config->vpn_phy_index = -1;
+
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV4) {
+		temp_data->ipv4_config = config;
+		temp_data->ipv4_config->ops = &ipv4_gateway_config_ops;
+	} else if (type == CONNMAN_IPCONFIG_TYPE_IPV6) {
+		temp_data->ipv6_config = config;
+		temp_data->ipv6_config->ops = &ipv6_gateway_config_ops;
+	}
+
+	temp_data->service = service;
+
+	/*
+	 * If the service is already in the hash, then we
+	 * must not replace it blindly but disable the gateway
+	 * of the type we are replacing and take the other type
+	 * from old gateway settings.
+	 */
+	old = g_hash_table_lookup(gateway_hash, service);
+	if (old) {
+		DBG("Replacing gw %p ipv4 %p ipv6 %p", old,
+			old->ipv4_config, old->ipv6_config);
+
+		del_gateway_routes_if_active(old, type);
+
+		if (type == CONNMAN_IPCONFIG_TYPE_IPV4) {
+			temp_data->ipv6_config = old->ipv6_config;
+			old->ipv6_config = NULL;
+		} else if (type == CONNMAN_IPCONFIG_TYPE_IPV6) {
+			temp_data->ipv4_config = old->ipv4_config;
+			old->ipv4_config = NULL;
+		}
+	}
+
+	connman_service_ref(temp_data->service);
+	g_hash_table_replace(gateway_hash, service, temp_data);
+
+	*data = g_steal_pointer(&temp_data);
+
+	return err;
+}
+
+/**
+ *  @brief
+ *    Mutate the gateway for the specified IP configuration type for
+ *    the provided gateway data.
+ *
+ *  This attempts to mutate (including, but not limited to, adding/
+ *  setting or clearing/deleting/removing routes) the gateway for the
+ *  specified IP configuration type for the provided gateway data.
+ *
+ *  @param[in,out]  data      A pointer to the mutable gateway data
+ *                            to mutate.
+ *  @param[in]      type      The IP configuration type for which the
+ *                            gateway configuration will be selected
+ *                            from @a data and used for mutation.
+ *  @param[in]      ops       A pointer to the default gateway mutation
+ *                            operations to use for the mutation.
+ *  @param[in]      function  A pointer to an immutable null-terminated
+ *                            C string containing the function name to
+ *                            which the call to this function should
+ *                            be attributed.
+ *
+ *  @returns
+ *    0 if successful; otherwise, < 0 on error.
+ *
+ */
+static int mutate_default_gateway(struct gateway_data *data,
+				enum connman_ipconfig_type type,
+				const struct mutate_default_gateway_ops *ops,
+				const char *function)
+{
+	int status4 = 0, status6 = 0;
+	bool do_ipv4 = false, do_ipv6 = false;
+
+	DBG("data %p type %d (%s) ops %p from %s()", data,
+		type, __connman_ipconfig_type2string(type),
+		ops,
+		function);
+
+	if (!data || !ops || !function)
+		return -EINVAL;
+
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
+		do_ipv4 = true;
+	else if (type == CONNMAN_IPCONFIG_TYPE_IPV6)
+		do_ipv6 = true;
+	else if (type == CONNMAN_IPCONFIG_TYPE_ALL)
+		do_ipv4 = do_ipv6 = true;
+	else
+		return -EINVAL;
+
+	GATEWAY_DATA_DBG("data", data);
+
+	if (do_ipv4 && ops->mutate_ipv4 && data->ipv4_config)
+		status4 = ops->mutate_ipv4(data, data->ipv4_config);
+
+	if (do_ipv6 && ops->mutate_ipv6 && data->ipv6_config)
+		status6 = ops->mutate_ipv6(data, data->ipv6_config);
+
+	DBG("status4 %d (%s) status6 %d (%s)",
+		status4, strerror(-status4),
+		status6, strerror(-status6));
+
+	return (status4 < 0 ? status4 : status6);
+}
+
+/**
+ *  @brief
+ *    Set, or add, the default route, for the specified gateway data
+ *    and configuration using the provided gateway configuration type
+ *    and callback function.
+ *
+ *  This attempts to set, or add, the default route for the specified
+ *  gateway data and configuration using the provided gateway
+ *  configuration type and callback function.
+ *
+ *  On success, the gateway configuration type will be set to @a type
+ *  and its state to #CONNMAN_GATEWAY_CONFIG_STATE_ADDED.
+ *
+ *  @param[in,out]  data    A pointer to the mutable gateway data to
+ *                          set, or add, as the default route.
+ *  @param[in,out]  config  A pointer to the mutable gateway
+ *                          configuration to set, or add, as the
+ *                          default route.
+ *  @param[in]      type    The gateway configuration type that will
+ *                          be assigned to @a config on success.
+ *  @param[in]      cb      The callback function used to set, or
+ *                          add, the default route.
+ *
+ *  @retval  0              If successful.
+ *  @retval  -EINVAL        If @a data, @a config, or @a cb are
+ *                          null; if the gateway configuration type is
+ *                          not #CONNMAN_GATEWAY_CONFIG_TYPE_NONE or
+ *                          @a type; or if the routing information to
+ *                          be set, or added, was invalid.
+ *  @retval  -EINPROGRESS   If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_ADDED.
+ *  @retval  -EALREADY      If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_ACTIVE.
+ *  @retval  -EFAULT        If the address to the routing information
+ *                          to be set, or added, was invalid.
+ *  @retval  -EPERM         If the current process does not have the
+ *                          credentials or capabilities to set, or
+ *                          add, routes.
+ *  @retval  -EEXIST        A request was made to add an existing
+ *                          routing entry.
+ *
+ *  @sa gateway_config_state_set
+ *  @sa gateway_config_type_set
+ *  @sa is_gateway_config_state
+ *  @sa is_gateway_config_type
+ *  @sa unset_default_gateway_route_common
+ *
+ */
+static int set_default_gateway_route_common(struct gateway_data *data,
+				struct gateway_config *config,
+				enum gateway_config_type type,
+				mutate_default_gateway_route_cb_t cb)
+{
+	int err = 0;
+
+	if (!data || !config || !cb)
+		return -EINVAL;
+
+	if ((is_gateway_config_state_added(config) ||
+		is_gateway_config_state_active(config)) &&
+		!is_gateway_config_type(config, type))
+		return -EINVAL;
+
+	if (is_gateway_config_state_added(config))
+		return -EINPROGRESS;
+
+	if (is_gateway_config_state_active(config))
+		return -EALREADY;
+
+	err = cb(data, config);
+	if (err < 0)
+		goto done;
+
+	gateway_config_state_set(config,
+		CONNMAN_GATEWAY_CONFIG_STATE_ADDED);
+
+	gateway_config_type_set(config, type);
+
+done:
+	return err;
+}
+
+/**
+ *  @brief
+ *    Unset, or remove, the default route, for the specified gateway
+ *    data and configuration using the provided gateway configuration
+ *    type and callback function.
+ *
+ *  This attempts to unset, or remove, the default route for the
+ *  specified gateway data and configuration using the provided
+ *  gateway configuration type and callback function.
+ *
+ *  On success, the gateway configuration state will be set to
+ *  #CONNMAN_GATEWAY_CONFIG_STATE_REMOVED.
+ *
+ *  @param[in,out]  data    A pointer to the mutable gateway data to
+ *                          unset, or remove, as the default route.
+ *  @param[in,out]  config  A pointer to the mutable gateway
+ *                          configuration to unset, or remove, as the
+ *                          default route.
+ *  @param[in]      type    The gateway configuration type that @a
+ *                          config is expected to be.
+ *  @param[in]      cb      The callback function used to unset, or
+ *                          remove, the default route.
+ *
+ *  @retval  0              If successful.
+ *  @retval  -EINVAL        If @a data, @a config, or @a cb are
+ *                          null; if the gateway configuration type is
+ *                          not @a type; or if the routing information
+ *                          to be unset, or cleared, was invalid.
+ *  @retval  -EINPROGRESS   If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_REMOVED.
+ *  @retval  -EALREADY      If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_INACTIVE.
+ *  @retval  -EFAULT        If the address to the routing information
+ *                          to be unset, or cleared, was invalid.
+ *  @retval  -EPERM         If the current process does not have the
+ *                          credentials or capabilities to unset, or
+ *                          clear, routes.
+ *
+ *  @sa gateway_config_state_set
+ *  @sa is_gateway_config_state
+ *  @sa is_gateway_config_type
+ *  @sa set_default_gateway_route_common
+ *
+ */
+static int unset_default_gateway_route_common(struct gateway_data *data,
+				struct gateway_config *config,
+				enum gateway_config_type type,
+				mutate_default_gateway_route_cb_t cb)
+{
+	int err = 0;
+
+	if (!data || !config || !cb)
+		return -EINVAL;
+
+	if (!is_gateway_config_state_inactive(config) &&
+		!is_gateway_config_type(config, type))
+		return -EINVAL;
+
+	if (is_gateway_config_state_removed(config))
+		return -EINPROGRESS;
+
+	if (is_gateway_config_state_inactive(config))
+		return -EALREADY;
+
+	/*
+	 * Generally, we mandate that gateway routes follow the documented
+	 * lifecycle and state machine, using events and down- and upcalls
+	 * to drive the lifecycle.
+	 *
+	 * There is one exception, however. When the Linux kernel
+	 * recognizes that the next hop (that is, the "via" or RTA_GATEWAY
+	 * part of the route) for a route becomes unreachable, it is
+	 * automatically purged from the routing table with no
+	 * RTM_DELROUTE RTNL notification. Consequently, routes so purged
+	 * will return -ESRCH when we attempt to delete them here in the
+	 * mistaken belief they are still there.
+	 *
+	 * Map -ESRCH to success such that gateway configuration for such
+	 * routes is not indefinitely stuck in the "active" or "added"
+	 * states.
+	 */
+	err = cb(data, config);
+	if (err == -ESRCH)
+		err = 0;
+	else if (err < 0)
+		goto done;
+
+	gateway_config_state_set(config,
+		CONNMAN_GATEWAY_CONFIG_STATE_REMOVED);
+
+done:
+	return err;
+}
+
+/**
+ *  @brief
+ *    Set, or add, the IPv4 high-priority default route for the
+ *    specified gateway data and configuration using a function
+ *    utilizing a SIOCADDRT socket ioctl or a RTM_NEWROUTE Linux
+ *    Routing Netlink (rtnl) command.
+ *
+ *  This attempts to set, or add, the IPv4 high-priority (that is,
+ *  metric 0) default route for the specified gateway data and
+ *  configuration using a function utilizing a SIOCADDRT socket ioctl
+ *  or a RTM_NEWROUTE Linux Routing Netlink (rtnl) command to modify
+ *  the Linux routing table.
+ *
+ *  @param[in,out]  data    A pointer to the mutable gateway data to
+ *                          use to set, or add, the IPv4 high-priority
+ *                          default route.
+ *  @param[in,out]  config  A pointer to the mutable gateway
+ *                          configuration to use to set, or add,
+ *                          the IPv4 high-priority default route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a data or @a config are null; or if
+ *                    the routing information to be set, or
+ *                    added, was invalid.
+ *  @retval  -EFAULT  If the address to the routing information
+ *                    to be set, or added, was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to set, or
+ *                    add, routes.
+ *  @retval  -EEXIST  A request was made to add an existing
+ *                    routing entry.
+ *
+ *  @sa connman_inet_set_gateway_interface
+ *  @sa __connman_inet_add_default_to_table
+ *
+ */
+static int set_ipv4_high_priority_default_gateway_route_cb(
+				struct gateway_data *data,
+				struct gateway_config *config)
+{
+	int err = 0;
+
+	if (is_gateway_config_vpn(config)) {
+		err = config->ops->add_interface_route(data->index);
+		if (err < 0)
+			goto done;
+
+		DBG("set %p index %d vpn %s index %d phy %s",
+			data, data->index, config->vpn_ip,
+			config->vpn_phy_index,
+			config->vpn_phy_ip);
+	} else if (is_addr_any_str(config->gateway)) {
+		err = config->ops->add_interface_route(data->index);
+		if (err < 0)
+			goto done;
+
+		DBG("set %p index %d",
+			data, data->index);
+	} else {
+		err = config->ops->add_default_route(
+					RT_TABLE_MAIN,
+					data->index,
+					config->gateway);
+		if (err < 0)
+			goto done;
+
+		DBG("set %p index %d gateway %s",
+			data, data->index, config->gateway);
+	}
+
+done:
+	return err;
+}
+
+/**
+ *  @brief
+ *    Set, or add, the IPv6 high-priority default route for the
+ *    specified gateway data and configuration using a function
+ *    utilizing a SIOCADDRT socket ioctl or a RTM_NEWROUTE Linux
+ *    Routing Netlink (rtnl) command.
+ *
+ *  This attempts to set, or add, the IPv6 high-priority (that is,
+ *  metric 0) default route for the specified gateway data and
+ *  configuration using a function utilizing a SIOCADDRT socket ioctl
+ *  or a RTM_NEWROUTE Linux Routing Netlink (rtnl) command to modify
+ *  the Linux routing table.
+ *
+ *  @param[in,out]  data    A pointer to the mutable gateway data to
+ *                          use to set, or add, the IPv6 high-priority
+ *                          default route.
+ *  @param[in,out]  config  A pointer to the mutable gateway
+ *                          configuration to use to set, or add,
+ *                          the IPv6 high-priority default route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a data or @a config are null; or if
+ *                    the routing information to be set, or
+ *                    added, was invalid.
+ *  @retval  -EFAULT  If the address to the routing information
+ *                    to be set, or added, was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to set, or
+ *                    add, routes.
+ *  @retval  -EEXIST  A request was made to add an existing
+ *                    routing entry.
+ *
+ *  @sa connman_inet_set_ipv6_gateway_interface
+ *  @sa __connman_inet_add_default_to_table
+ *
+ */
+static int set_ipv6_high_priority_default_gateway_route_cb(
+				struct gateway_data *data,
+				struct gateway_config *config)
+{
+	int err = 0;
+
+	if (is_gateway_config_vpn(config)) {
+		err = config->ops->add_interface_route(data->index);
+		if (err < 0)
+			goto done;
+
+		DBG("set %p index %d vpn %s index %d phy %s",
+			data, data->index, config->vpn_ip,
+			config->vpn_phy_index,
+			config->vpn_phy_ip);
+	} else if (is_addr_any_str(config->gateway)) {
+		err = config->ops->add_interface_route(data->index);
+		if (err < 0)
+			goto done;
+
+		DBG("set %p index %d",
+			data, data->index);
+	} else {
+		err = config->ops->add_default_route(
+					RT_TABLE_MAIN,
+					data->index,
+					config->gateway);
+		if (err < 0)
+			goto done;
+
+		DBG("set %p index %d gateway %s",
+			data, data->index, config->gateway);
+	}
+
+done:
+	return err;
+}
+
+/**
+ *  @brief
+ *    Set, or add, the IPv4 high-priority default route for the
+ *    specified gateway data and configuration.
+ *
+ *  This attempts to set, or add, the IPv4 high-priority (that is,
+ *  metric 0) default route for the specified gateway data and
+ *  configuration.
+ *
+ *  On success, the gateway configuration type will be set to
+ *  #CONNMAN_GATEWAY_CONFIG_TYPE_HIGH_PRIORITY_DEFAULT and its state
+ *  to #CONNMAN_GATEWAY_CONFIG_STATE_ADDED.
+ *
+ *  @param[in,out]  data    A pointer to the mutable gateway data to
+ *                          assign as the IPv4 high-priority default
+ *                          route.
+ *  @param[in,out]  config  A pointer to the mutable gateway
+ *                          configuration to assign as the IPv4
+ *                          high-priority default route.
+ *
+ *  @retval  0              If successful.
+ *  @retval  -EINVAL        If @a data or @a config are
+ *                          null; if the gateway configuration type is
+ *                          not #CONNMAN_GATEWAY_CONFIG_TYPE_NONE or
+ *                          #CONNMAN_GATEWAY_CONFIG_TYPE_HIGH_PRIORITY_DEFAULT;
+ *                          or if the routing information to be set,
+ *                          or added, was invalid.
+ *  @retval  -EINPROGRESS   If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_ADDED.
+ *  @retval  -EALREADY      If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_ACTIVE.
+ *  @retval  -EFAULT        If the address to the routing information
+ *                          to be added was invalid.
+ *  @retval  -EPERM         If the current process does not have the
+ *                          credentials or capabilities to add, or
+ *                          set, routes.
+ *  @retval  -EEXIST        A request was made to add an existing
+ *                          routing entry.
+ *
+ *  @sa set_default_gateway_route_common
+ *  @sa set_ipv4_high_priority_default_gateway_func
+ *
+ */
+static int set_ipv4_high_priority_default_gateway(struct gateway_data *data,
+				struct gateway_config *config)
+{
+	static const enum gateway_config_type type =
+			CONNMAN_GATEWAY_CONFIG_TYPE_HIGH_PRIORITY_DEFAULT;
+	static const mutate_default_gateway_route_cb_t cb =
+			set_ipv4_high_priority_default_gateway_route_cb;
+
+	return set_default_gateway_route_common(data, config, type, cb);
+}
+
+/**
+ *  @brief
+ *    Set, or add, the IPv6 high-priority default route for the
+ *    specified gateway data and configuration.
+ *
+ *  This attempts to set, or add, the IPv6 high-priority (that is,
+ *  metric 0) default route for the specified gateway data and
+ *  configuration.
+ *
+ *  On success, the gateway configuration type will be set to
+ *  #CONNMAN_GATEWAY_CONFIG_TYPE_HIGH_PRIORITY_DEFAULT and its state
+ *  to #CONNMAN_GATEWAY_CONFIG_STATE_ADDED.
+ *
+ *  @param[in,out]  data    A pointer to the mutable gateway data to
+ *                          assign as the IPv6 high-priority default
+ *                          route.
+ *  @param[in,out]  config  A pointer to the mutable gateway
+ *                          configuration to assign as the IPv6
+ *                          high-priority default route.
+ *
+ *  @retval  0              If successful.
+ *  @retval  -EINVAL        If @a data or @a config are
+ *                          null; if the gateway configuration type is
+ *                          not #CONNMAN_GATEWAY_CONFIG_TYPE_NONE or
+ *                          #CONNMAN_GATEWAY_CONFIG_TYPE_HIGH_PRIORITY_DEFAULT;
+ *                          or if the routing information to be set,
+ *                          or added, was invalid.
+ *  @retval  -EINPROGRESS   If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_ADDED.
+ *  @retval  -EALREADY      If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_ACTIVE.
+ *  @retval  -EFAULT        If the address to the routing information
+ *                          to be added was invalid.
+ *  @retval  -EPERM         If the current process does not have the
+ *                          credentials or capabilities to add, or
+ *                          set, routes.
+ *  @retval  -EEXIST        A request was made to add an existing
+ *                          routing entry.
+ *
+ *  @sa set_default_gateway_route_common
+ *  @sa set_ipv6_high_priority_default_gateway_route_cb
+ *
+ */
+static int set_ipv6_high_priority_default_gateway(struct gateway_data *data,
+				struct gateway_config *config)
+{
+	static const enum gateway_config_type type =
+			CONNMAN_GATEWAY_CONFIG_TYPE_HIGH_PRIORITY_DEFAULT;
+	static const mutate_default_gateway_route_cb_t cb =
+			set_ipv6_high_priority_default_gateway_route_cb;
+
+	return set_default_gateway_route_common(data, config, type, cb);
+}
+
+/**
+ *  @brief
+ *    Set, or add, the gateway high-priority default route for the
+ *    specified IP configuration type from the provided gateway data.
+ *
+ *  This attempts to set, or add, the high-priority (that is,
+ *  metric 0) default route for the specified IP configuration type
+ *  from the provided gateway data. The network interface and, by
+ *  extension, the network service with which the gateway is
+ *  associated is determined by the @a index field of @a data.
+ *
+ *  On success, the gateway configuration state and type specific to
+ *  @a type will be set to #CONNMAN_GATEWAY_CONFIG_STATE_ADDED and
+ *  #CONNMAN_GATEWAY_CONFIG_TYPE_HIGH_PRIORITY_DEFAULT, respectively,
+ *  and the gateway data network service @a service will be signaled
+ *  as the default via #__connman_service_indicate_default.
+ *
+ *  @param[in,out]  data      A pointer to the mutable gateway data
+ *                            to assign as the high-priority default
+ *                            route.
+ *  @param[in]      type      The IP configuration type for which the
+ *                            gateway, or default router,
+ *                            configuration will be selected from @a
+ *                            data and used to set the high-priority
+ *                            default route.
+ *  @param[in]      function  A pointer to an immutable null-terminated
+ *                            C string containing the function name to
+ *                            which the call to this function should
+ *                            be attributed.
+ *
+ *  @retval  0              If successful.
+ *  @retval  -EINVAL        If @a data or @a config are
+ *                          null; if the gateway configuration type is
+ *                          not #CONNMAN_GATEWAY_CONFIG_TYPE_NONE or
+ *                          #CONNMAN_GATEWAY_CONFIG_TYPE_HIGH_PRIORITY_DEFAULT;
+ *                          or if the routing information to be set,
+ *                          or added, was invalid.
+ *  @retval  -EINPROGRESS   If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_ADDED.
+ *  @retval  -EALREADY      If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_ACTIVE.
+ *  @retval  -EFAULT        If the address to the routing information
+ *                          to be added was invalid.
+ *  @retval  -EPERM         If the current process does not have the
+ *                          credentials or capabilities to add, or
+ *                          set, routes.
+ *  @retval  -EEXIST        A request was made to add an existing
+ *                          routing entry.
+ *
+ *  @sa mutate_default_gateway
+ *  @sa set_ipv4_high_priority_default_gateway
+ *  @sa set_ipv6_high_priority_default_gateway
+ *
+ */
+static int set_default_gateway(struct gateway_data *data,
+				enum connman_ipconfig_type type,
+				const char *function)
+{
+	static const struct mutate_default_gateway_ops ops = {
+		set_ipv4_high_priority_default_gateway,
+		set_ipv6_high_priority_default_gateway
+	};
+	int status = 0;
+
+	DBG("from %s()", function);
+
+	status = mutate_default_gateway(data, type, &ops, __func__);
+	if (status < 0)
+		goto done;
+
+	__connman_service_indicate_default(data->service);
+
+done:
+	return status;
+}
+
+/**
+ *  @brief
+ *    Unset, or remove, the IPv4 high-priority default route for the
+ *    specified gateway data and configuration using a function
+ *    utilizing a SIOCDELRT socket ioctl or a RTM_DELROUTE Linux
+ *    Routing Netlink (rtnl) command.
+ *
+ *  This attempts to unset, or remove, the IPv4 high-priority (that
+ *  is, metric 0) default route for the specified gateway data and
+ *  configuration using a function utilizing a SIOCDELRT socket ioctl
+ *  or a RTM_DELROUTE Linux Routing Netlink (rtnl) command to modify
+ *  the Linux routing table.
+ *
+ *  @param[in,out]  data    A pointer to the mutable gateway data to
+ *                          use to unset, or remove, the IPv4
+ *                          high-priority default route.
+ *  @param[in,out]  config  A pointer to the mutable gateway
+ *                          configuration to use to unset, or remove,
+ *                          the IPv4 high-priority default route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a data or @a config are null; or if
+ *                    the routing information to be unset, or
+ *                    removed, was invalid.
+ *  @retval  -EFAULT  If the address to the routing information
+ *                    to be set, or added, was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to set, or
+ *                    add, routes.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ *  @sa connman_inet_clear_gateway_interface
+ *  @sa connman_inet_clear_gateway_address
+ *
+ */
+static int unset_ipv4_high_priority_default_gateway_route_cb(
+				struct gateway_data *data,
+				struct gateway_config *config)
+{
+	int err = 0;
+
+	if (is_gateway_config_vpn(config)) {
+		err = config->ops->del_interface_route(data->index);
+		if (err < 0)
+			goto done;
+
+		DBG("unset %p index %d vpn %s index %d phy %s",
+			data, data->index, config->vpn_ip,
+			config->vpn_phy_index,
+			config->vpn_phy_ip);
+	} else if (is_addr_any_str(config->gateway)) {
+		err = config->ops->del_interface_route(data->index);
+		if (err < 0)
+			goto done;
+
+		DBG("unset %p index %d",
+			data, data->index);
+	} else {
+		err = config->ops->del_default_route(
+					RT_TABLE_MAIN,
+					data->index,
+					config->gateway);
+		if (err < 0)
+			goto done;
+
+		DBG("unset %p index %d gateway %s",
+			data, data->index, config->gateway);
+	}
+
+done:
+	return err;
+}
+
+/**
+ *  @brief
+ *    Unset, or remove, the IPv6 high-priority default route for the
+ *    specified gateway data and configuration using a function
+ *    utilizing a SIOCDELRT socket ioctl or a RTM_DELROUTE Linux
+ *    Routing Netlink (rtnl) command.
+ *
+ *  This attempts to unset, or remove, the IPv6 high-priority (that
+ *  is, metric 0) default route for the specified gateway data and
+ *  configuration using a function utilizing a SIOCDELRT socket ioctl
+ *  or a RTM_DELROUTE Linux Routing Netlink (rtnl) command to modify
+ *  the Linux routing table.
+ *
+ *  @param[in,out]  data    A pointer to the mutable gateway data to
+ *                          use to unset, or remove, the IPv6
+ *                          high-priority default route.
+ *  @param[in,out]  config  A pointer to the mutable gateway
+ *                          configuration to use to unset, or remove,
+ *                          the IPv6 high-priority default route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a data or @a config are null; or if
+ *                    the routing information to be unset, or
+ *                    removed, was invalid.
+ *  @retval  -EFAULT  If the address to the routing information
+ *                    to be set, or added, was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to set, or
+ *                    add, routes.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ *  @sa connman_inet_clear_ipv6_gateway_interface
+ *  @sa connman_inet_clear_ipv6_gateway_address
+ *
+ */
+static int unset_ipv6_high_priority_default_gateway_route_cb(
+				struct gateway_data *data,
+				struct gateway_config *config)
+{
+	int err = 0;
+
+	if (is_gateway_config_vpn(config)) {
+		err = config->ops->del_interface_route(data->index);
+		if (err < 0)
+			goto done;
+
+		DBG("unset %p index %d vpn %s index %d phy %s",
+			data, data->index, config->vpn_ip,
+			config->vpn_phy_index,
+			config->vpn_phy_ip);
+	} else if (is_addr_any_str(config->gateway)) {
+		err = config->ops->del_interface_route(data->index);
+		if (err < 0)
+			goto done;
+
+		DBG("unset %p index %d",
+			data, data->index);
+	} else {
+		err = config->ops->del_default_route(
+					RT_TABLE_MAIN,
+					data->index,
+					config->gateway);
+		if (err < 0)
+			goto done;
+
+		DBG("unset %p index %d gateway %s",
+			data, data->index, config->gateway);
+	}
+
+done:
+	return err;
+}
+
+/**
+ *  @brief
+ *    Unset, or clear, the IPv4 high-priority default route for the
+ *    specified gateway data and configuration.
+ *
+ *  This attempts to unset, or clear, the IPv4 high-priority (that is,
+ *  metric 0) default route from the provided gateway data and
+ *  configuration.
+ *
+ *  @param[in,out]  data    A pointer to the mutable gateway data to
+ *                          use to unset, or remove, the IPv4
+ *                          high-priority default route.
+ *  @param[in,out]  config  A pointer to the mutable gateway
+ *                          configuration to use to unset, or remove,
+ *                          the IPv4 high-priority default route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a data or @a config are null; or if
+ *                    the routing information to be unset, or
+ *                    removed, was invalid.
+ *  @retval  -EFAULT  If the address to the routing information
+ *                    to be unset, or cleared, was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to unset, or
+ *                    clear, routes.
+ *  @retval  -ESRCH   A request was made to unset, or clear a
+ *                    non-existing routing entry.
+ *
+ *  @sa unset_default_gateway_route_common
+ *  @sa unset_ipv4_high_priority_default_gateway_route_cb
+ *
+ */
+static int unset_ipv4_high_priority_default_gateway(
+				struct gateway_data *data,
+				struct gateway_config *config)
+{
+	static const enum gateway_config_type type =
+			CONNMAN_GATEWAY_CONFIG_TYPE_HIGH_PRIORITY_DEFAULT;
+	static const mutate_default_gateway_route_cb_t cb =
+			unset_ipv4_high_priority_default_gateway_route_cb;
+
+	return unset_default_gateway_route_common(data, config, type, cb);
+}
+
+/**
+ *  @brief
+ *    Unset, or clear, the IPv6 high-priority default route for the
+ *    specified gateway data and configuration.
+ *
+ *  This attempts to unset, or clear, the IPv6 high-priority (that is,
+ *  metric 0) default route from the provided gateway data and
+ *  configuration.
+ *
+ *  @param[in,out]  data    A pointer to the mutable gateway data to
+ *                          use to unset, or remove, the IPv6
+ *                          high-priority default route.
+ *  @param[in,out]  config  A pointer to the mutable gateway
+ *                          configuration to use to unset, or remove,
+ *                          the IPv6 high-priority default route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a data or @a config are null; or if
+ *                    the routing information to be unset, or
+ *                    removed, was invalid.
+ *  @retval  -EFAULT  If the address to the routing information
+ *                    to be unset, or cleared, was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to unset, or
+ *                    clear, routes.
+ *  @retval  -ESRCH   A request was made to unset, or clear a
+ *                    non-existing routing entry.
+ *
+ *  @sa unset_default_gateway_route_common
+ *  @sa unset_ipv6_high_priority_default_gateway_route_cb
+ *
+ */
+static int unset_ipv6_high_priority_default_gateway(
+				struct gateway_data *data,
+				struct gateway_config *config)
+{
+	static const enum gateway_config_type type =
+			CONNMAN_GATEWAY_CONFIG_TYPE_HIGH_PRIORITY_DEFAULT;
+	static const mutate_default_gateway_route_cb_t cb =
+			unset_ipv6_high_priority_default_gateway_route_cb;
+
+	return unset_default_gateway_route_common(data, config, type, cb);
+}
+
+/**
+ *  @brief
+ *    Unset the high-priority default route for the specified IP
+ *    configuration type from the provided gateway data.
+ *
+ *  This attempts to unset, or clear, the high-priority (that is,
+ *  metric 0) default route for the specified IP configuration type
+ *  from the provided gateway data. The network interface and, by
+ *  extension, the network service with which the gateway is
+ *  associated is determined by the @a index field of @a data.
+ *
+ *  On success, the gateway configuration state specific to @a type
+ *  will be set to #CONNMAN_GATEWAY_CONFIG_STATE_REMOVED.
+ *
+ *  @param[in,out]  data      A pointer to the mutable gateway data
+ *                            to clear as the high-priority default
+ *                            route.
+ *  @param[in]      type      The IP configuration type for which
+ *                            the gateway, or default router,
+ *                            configuration will be selected from @a
+ *                            data and used to unset the high-priority
+ *                            default route.
+ *  @param[in]      function  A pointer to an immutable null-terminated
+ *                            C string containing the function name to
+ *                            which the call to this function should
+ *                            be attributed.
+ *
+ *  @retval  0              If successful.
+ *  @retval  -EINVAL        If @a data is null, if @a type is invalid,
+ *                          if the gateway configuration type is not
+ *                          type
+ *                          #CONNMAN_GATEWAY_CONFIG_TYPE_HIGH_PRIORITY_DEFAULT,
+ *                          or if the routing information to be unset,
+ *                          or cleared, was invalid.
+ *  @retval  -EINPROGRESS   If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_REMOVED.
+ *  @retval  -EALREADY      If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_INACTIVE.
+ *  @retval  -EFAULT        If the address to the routing information
+ *                          to be unset, or cleared, was invalid.
+ *  @retval  -EPERM         If the current process does not have the
+ *                          credentials or capabilities to unset, or
+ *                          clear, routes.
+ *  @retval  -ESRCH         A request was made to unset, or clear a
+ *                          non-existing routing entry.
+ *
+ *  @sa mutate_default_gateway
+ *  @sa unset_ipv4_default_gateway
+ *  @sa unset_ipv6_default_gateway
+ *
+ */
+static int unset_default_gateway(struct gateway_data *data,
+				enum connman_ipconfig_type type,
+				const char *function)
+{
+	static const struct mutate_default_gateway_ops ops = {
+		unset_ipv4_high_priority_default_gateway,
+		unset_ipv6_high_priority_default_gateway
+	};
+
+	DBG("from %s()", function);
+
+	return mutate_default_gateway(data, type, &ops, __func__);
+}
+
+/**
+ *  @brief
+ *    Compute and return a low-priority gateway default route metric
+ *    unique to the specified gateway data.
+ *
+ *  This computes and returns a low-priority gateway default route
+ *  metric unique to the specified gateway data, @a data.
+ *
+ *  @param[in]  data  A pointer to the immutable gateway data with
+ *                    which to compute the low-priority default route
+ *                    metric.
+ *
+ *  @returns
+ *    The low-priority default route metric/priority.
+ *
+ */
+static uint32_t compute_low_priority_metric(const struct gateway_data *data)
+{
+	static const uint32_t metric_base = UINT32_MAX;
+	static const uint32_t metric_ceiling = (1 << 20);
+	static const uint32_t metric_index_step = (1 << 10);
+
+	/*
+	 * The algorithm uses the network interface index since it is
+	 * assumed to be stable for the uptime of the network interface
+	 * and, consequently, the potential maximum lifetime of the route.
+	 *
+	 * The algorithm establishes UINT32_MAX as the metric base (the
+	 * lowest possible priority) and a somewhat-arbitrary 2^20 as the
+	 * ceiling (to keep metrics out of a range that might be used by
+	 * other applications). The metric is then adjusted in increments
+	 * of 1,024 (2^10) from the base, but less than the ceiling, by
+	 * multiplying the increment by the network interface index. This
+	 * is easy and simple to compute and is invariant on service
+	 * order.
+	 *
+	 * In the fullness of time, the "rule of least astonishment" for
+	 * Connection Manager might be that low priority metrics follow
+	 * the service order with the default service always having metric
+	 * zero (0) and lowest priority metric assigned to the lowest
+	 * priority service, etc. Achieving this would require 1) caching
+	 * the computed metric in the gateway data since services may
+	 * re-sort by the time we are asked to recompute high- and
+	 * low-priority routes and we need a stable and matching metric to
+	 * successfully delete a previously-created route and 2) having
+	 * access to an API (such as
+	 * '__connman_service_get_order(data->service)') that exposes a
+	 * strictly-in/decreasing service order with no duplicates. Today,
+	 * there is no such API nor is there such a durable service order
+	 * meeting that mathematical requirement.
+	 */
+	return MAX(metric_ceiling,
+				metric_base -
+				(data->index * metric_index_step));
+}
+
+/**
+ *  @brief
+ *    Set, or add, the IPv4 low-priority default route for the
+ *    specified gateway data and configuration using a function
+ *    utilizing a SIOCADDRT socket ioctl or a RTM_NEWROUTE Linux
+ *    Routing Netlink (rtnl) command.
+ *
+ *  This attempts to set, or add, the IPv4 low-priority (that is,
+ *  metric > 0) default route for the specified gateway data and
+ *  configuration using a function utilizing a SIOCADDRT socket ioctl
+ *  or a RTM_NEWROUTE Linux Routing Netlink (rtnl) command to modify
+ *  the Linux routing table.
+ *
+ *  @param[in,out]  data    A pointer to the mutable gateway data to
+ *                          use to set, or add, the IPv4 low-priority
+ *                          default route.
+ *  @param[in,out]  config  A pointer to the mutable gateway
+ *                          configuration to use to set, or add, the
+ *                          IPv4 low-priority default route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a data or @a config are null; or if
+ *                    the routing information to be set, or
+ *                    added, was invalid.
+ *  @retval  -EFAULT  If the address to the routing information
+ *                    to be set, or added, was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to set, or
+ *                    add, routes.
+ *  @retval  -EEXIST  A request was made to add an existing
+ *                    routing entry.
+ *
+ *  @sa connman_inet_set_gateway_interface
+ *  @sa __connman_inet_add_default_to_table
+ *
+ */
+static int set_ipv4_low_priority_default_gateway_route_cb(
+				struct gateway_data *data,
+				struct gateway_config *config)
+{
+	const uint32_t metric = compute_low_priority_metric(data);
+
+	DBG("using metric %u for index %d", metric, data->index);
+
+	return config->ops->add_default_route_with_metric(
+				RT_TABLE_MAIN,
+				data->index,
+				config->gateway,
+				metric);
+}
+
+/**
+ *  @brief
+ *    Set, or add, the IPv4 low-priority default route for the
+ *    specified gateway data and configuration.
+ *
+ *  This attempts to set, or add, the IPv4 low-priority (that is,
+ *  metric > 0) default route for the specified gateway data and
+ *  configuration.
+ *
+ *  On success, the gateway configuration type will be set to
+ *  #CONNMAN_GATEWAY_CONFIG_TYPE_LOW_PRIORITY_DEFAULT and its state
+ *  to #CONNMAN_GATEWAY_CONFIG_STATE_ADDED.
+ *
+ *  @param[in,out]  data    A pointer to the mutable gateway data to
+ *                          assign as the IPv4 low-priority default
+ *                          route.
+ *  @param[in,out]  config  A pointer to the mutable gateway
+ *                          configuration to assign as the IPv4
+ *                          low-priority default route.
+ *
+ *  @retval  0              If successful.
+ *  @retval  -EINVAL        If @a data or @a config are
+ *                          null; if the gateway configuration type is
+ *                          not #CONNMAN_GATEWAY_CONFIG_TYPE_NONE or
+ *                          #CONNMAN_GATEWAY_CONFIG_TYPE_LOW_PRIORITY_DEFAULT;
+ *                          or if the routing information to be set,
+ *                          or added, was invalid.
+ *  @retval  -EINPROGRESS   If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_ADDED.
+ *  @retval  -EALREADY      If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_ACTIVE.
+ *  @retval  -EFAULT        If the address to the routing information
+ *                          to be added was invalid.
+ *  @retval  -EPERM         If the current process does not have the
+ *                          credentials or capabilities to add, or
+ *                          set, routes.
+ *  @retval  -EEXIST        A request was made to add an existing
+ *                          routing entry.
+ *
+ *  @sa set_default_gateway_route_common
+ *  @sa set_ipv4_low_priority_default_gateway_route_cb
+ *
+ */
+static int set_ipv4_low_priority_default_gateway(
+				struct gateway_data *data,
+				struct gateway_config *config)
+{
+	static const enum gateway_config_type type =
+			CONNMAN_GATEWAY_CONFIG_TYPE_LOW_PRIORITY_DEFAULT;
+	static const mutate_default_gateway_route_cb_t cb =
+			set_ipv4_low_priority_default_gateway_route_cb;
+
+	return set_default_gateway_route_common(data, config, type, cb);
+}
+
+/**
+ *  @brief
+ *    Set, or add, the gateway low-priority default route for the
+ *    specified IP configuration type from the provided gateway data.
+ *
+ *  This attempts to set, or add, the low-priority (that is, metric
+ *  > 0) default route for the specified IP configuration type from
+ *  the provided gateway data. The network interface and, by
+ *  extension, the network service with which the gateway is
+ *  associated is determined by the @a index field of @a data.
+ *
+ *  On success, the gateway configuration state and type specific to
+ *  @a type will be set to #CONNMAN_GATEWAY_CONFIG_STATE_ADDED and
+ *  #CONNMAN_GATEWAY_CONFIG_TYPE_LOW_PRIORITY_DEFAULT, respectively.
+ *
+ *  @param[in,out]  data      A pointer to the mutable gateway data
+ *                            to assign as the low-priority default
+ *                            route.
+ *  @param[in]      type      The IP configuration type for which the
+ *                            gateway, or default router,
+ *                            configuration will be selected from @a
+ *                            data and used to set the low-priority
+ *                            default route.
+ *  @param[in]      function  A pointer to an immutable null-terminated
+ *                            C string containing the function name to
+ *                            which the call to this function should
+ *                            be attributed.
+ *
+ *  @sa mutate_default_gateway
+ *  @sa set_ipv4_low_priority_default_gateway
+ *
+ */
+static int set_low_priority_default_gateway(struct gateway_data *data,
+				enum connman_ipconfig_type type,
+				const char *function)
+{
+	static const struct mutate_default_gateway_ops ops = {
+		set_ipv4_low_priority_default_gateway,
+		NULL
+	};
+
+	DBG("from %s()", function);
+
+	return mutate_default_gateway(data, type, &ops, __func__);
+}
+
+/**
+ *  @brief
+ *    Unset, or remove, the IPv4 low-priority default route for the
+ *    specified gateway data and configuration using a function
+ *    utilizing a SIOCDELRT socket ioctl or a RTM_DELROUTE Linux
+ *    Routing Netlink (rtnl) command.
+ *
+ *  This attempts to unset, or remove, the IPv4 low-priority (that
+ *  is, metric > 0) default route for the specified gateway data and
+ *  configuration using a function utilizing a SIOCDELRT socket ioctl
+ *  or a RTM_DELROUTE Linux Routing Netlink (rtnl) command to modify
+ *  the Linux routing table.
+ *
+ *  @param[in,out]  data    A pointer to the mutable gateway data to
+ *                          use to unset, or remove, the IPv4
+ *                          low-priority default route.
+ *  @param[in,out]  config  A pointer to the mutable gateway
+ *                          configuration to use to unset, or remove,
+ *                          the IPv4 low-priority default route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a data or @a config are null; or if
+ *                    the routing information to be set, or
+ *                    added, was invalid.
+ *  @retval  -EFAULT  If the address to the routing information
+ *                    to be set, or added, was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to set, or
+ *                    add, routes.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ *  @sa __connman_inet_del_default_from_table_with_metric;
+ *
+ */
+static int unset_ipv4_low_priority_default_gateway_route_cb(
+				struct gateway_data *data,
+				struct gateway_config *config)
+{
+	const uint32_t metric = compute_low_priority_metric(data);
+
+	DBG("using metric %u for index %d", metric, data->index);
+
+	return config->ops->del_default_route_with_metric(
+				RT_TABLE_MAIN,
+				data->index,
+				config->gateway,
+				metric);
+}
+
+/**
+ *  @brief
+ *    Unset the IPv4 low-priority default route for the specified IP
+ *    configuration type from the provided gateway data.
+ *
+ *  This attempts to unset, or clear, the IPv4 low-priority (that is,
+ *  metric > 0) default route for the specified IP configuration type
+ *  from the provided gateway data. The network interface and, by
+ *  extension, the network service with which the gateway is
+ *  associated is determined by the @a index field of @a data.
+ *
+ *  On success, the gateway configuration state will be set to
+ *  #CONNMAN_GATEWAY_CONFIG_STATE_REMOVED.
+ *
+ *  @param[in,out]  data  A pointer to the mutable gateway data to
+ *                        clear as the IPv4 low-priority default
+ *                        route.
+ *  @param[in]      type  The IP configuration type for which the
+ *                        gateway, or default router, configuration
+ *                        will be selected from @a data and used to
+ *                        unset the IPv4 low-priority default route.
+ *
+ *  @retval  0              If successful.
+ *  @retval  -EINVAL        If @a data or @a config are null, if the
+ *                          gateway configuration type is not
+ *                          #CONNMAN_GATEWAY_CONFIG_TYPE_LOW_PRIORITY_DEFAULT,
+ *                          or if the routing information to be unset,
+ *                          or cleared, was invalid.
+ *  @retval  -EINPROGRESS   If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_REMOVED.
+ *  @retval  -EALREADY      If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_INACTIVE.
+ *  @retval  -EFAULT        If the address to the routing information
+ *                          to be unset, or cleared, was invalid.
+ *  @retval  -EPERM         If the current process does not have the
+ *                          credentials or capabilities to unset, or
+ *                          clear, routes.
+ *  @retval  -ESRCH         A request was made to unset, or clear a
+ *                          non-existing routing entry.
+ *
+ *  @sa unset_default_gateway_route_common
+ *  @sa unset_ipv4_low_priority_default_gateway_route_cb
+ *
+ */
+static int unset_ipv4_low_priority_default_gateway(struct gateway_data *data,
+				struct gateway_config *config)
+{
+	static const enum gateway_config_type type =
+			CONNMAN_GATEWAY_CONFIG_TYPE_LOW_PRIORITY_DEFAULT;
+	static const mutate_default_gateway_route_cb_t cb =
+			unset_ipv4_low_priority_default_gateway_route_cb;
+
+	return unset_default_gateway_route_common(data, config, type, cb);
+}
+
+/**
+ *  @brief
+ *    Unset the low-priority default route for the specified IP
+ *    configuration type from the provided gateway data.
+ *
+ *  This attempts to unset, or clear, the low-priority (that is,
+ *  metric > 0) default route for the specified IP configuration type
+ *  from the provided gateway data. The network interface and, by
+ *  extension, the network service with which the gateway is
+ *  associated is determined by the @a index field of @a data.
+ *
+ *  On success, the gateway configuration state specific to @a type
+ *  will be set to #CONNMAN_GATEWAY_CONFIG_STATE_REMOVED.
+ *
+ *  @param[in,out]  data  A pointer to the mutable gateway data to
+ *                        clear as the low-priority default route.
+ *  @param[in]      type  The IP configuration type for which the
+ *                        gateway, or default router, configuration
+ *                        will be selected from @a data and used to
+ *                        unset the low-priority default route.
+ *
+ *  @retval  0              If successful.
+ *  @retval  -EINVAL        If @a data is null, if @a type is invalid,
+ *                          if the gateway configuration type is not
+ *                          type
+ *                          #CONNMAN_GATEWAY_CONFIG_TYPE_LOW_PRIORITY_DEFAULT,
+ *                          or if the routing information to be unset,
+ *                          or cleared, was invalid.
+ *  @retval  -EINPROGRESS   If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_REMOVED.
+ *  @retval  -EALREADY      If the state of @a config is
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_INACTIVE.
+ *  @retval  -EFAULT        If the address to the routing information
+ *                          to be unset, or cleared, was invalid.
+ *  @retval  -EPERM         If the current process does not have the
+ *                          credentials or capabilities to unset, or
+ *                          clear, routes.
+ *  @retval  -ESRCH         A request was made to unset, or clear a
+ *                          non-existing routing entry.
+ *
+ *  @sa mutatate_default_gateway
+ *  @sa unset_ipv4_low_priority_default_gateway
+ *
+ */
+static int unset_low_priority_default_gateway(struct gateway_data *data,
+				enum connman_ipconfig_type type,
+				const char *function)
+{
+	static const struct mutate_default_gateway_ops ops = {
+		unset_ipv4_low_priority_default_gateway,
+		NULL
+	};
+
+	DBG("from %s()", function);
+
+	return mutate_default_gateway(data, type, &ops, __func__);
+}
+
+/**
+ *  @brief
+ *    Demote, from high- to low-priority, the default route associated
+ *    with the specified gateway data and IP configuration type.
+ *
+ *  This attempts to demote, from high- (that is, metric 0) to low-
+ *  (that is, metric > 0) priority, the default route associated with
+ *  the specified gateway data and IP configuration type.
+ *
+ *  @param[in,out]  data      The gateway data associated with the
+ *                            default route for which the priority is
+ *                            to be demoted.
+ *  @param[in]      type      The IP configuration type for which
+ *                            the gateway, or default router, is to be
+ *                            demoted.
+ *  @param[in]      function  A pointer to an immutable null-terminated
+ *                            C string containing the function name to
+ *                            which the call to this function should be
+ *                            attributed.
+ *
+ *  @retval  0              If successful.
+ *  @retval  -EINVAL        If @a data is null, if @a type is
+ *                          #CONNMAN_IPCONFIG_TYPE_UNKNOWN, if the
+ *                          gateway configuration type is invalid; or
+ *                          if the routing information to be added or
+ *                          deleted was invalid.
+ *  @retval  -EINPROGRESS   If the state of the gateway configuration
+ *                          for @a data is already
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_ADDED or
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_REMOVED.
+ *  @retval  -EALREADY      If the state of the gateway configuration
+ *                          for @a data is already
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_ACTIVE or
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_INACTIVE.
+ *  @retval  -EFAULT        If the address to the routing information
+ *                          to be added or deleted was invalid.
+ *  @retval  -EPERM         If the current process does not have the
+ *                          credentials or capabilities to add or
+ *                          delete routes.
+ *  @retval  -EEXIST        A request was made to add an existing
+ *                          routing entry.
+ *  @retval  -ESRCH         A request was made to delete a non-
+ *                          existing routing entry.
+ *
+ *  @sa unset_default_gateway
+ *  @sa set_low_priority_default_gateway
+ *  @sa promote_default_gateway
+ *
+ */
+static int demote_default_gateway(struct gateway_data *data,
+				enum connman_ipconfig_type type,
+				const char *function)
+{
+	int unset_status = 0, set_status = 0;
+
+	DBG("from %s() data %p type %d (%s)",
+		function,
+		data,
+		type, __connman_ipconfig_type2string(type));
+
+	unset_status = UNSET_DEFAULT_GATEWAY(data, type);
+
+	set_status = SET_LOW_PRIORITY_DEFAULT_GATEWAY(data, type);
+
+	DBG("unset_status %d (%s) set_status %d (%s)",
+		unset_status, strerror(-unset_status),
+		set_status, strerror(-set_status));
+
+	/*
+	 * Prefer unset status to set status since unsetting is what effects
+	 * the priority demotion.
+	 */
+	return (unset_status == 0 ? unset_status : set_status);
+}
+
+/**
+ *  @brief
+ *    Promote, from low- to high-priority, the default route
+ *    associated with the specified gateway data and IP configuration
+ *    type.
+ *
+ *  This attempts to promote, from low- (that is, metric > 0) to high-
+ *  (that is, metric 0) priority, the default route associated with
+ *  the specified gateway data and IP configuration type.
+ *
+ *  @param[in,out]  data      The gateway data associated with the
+ *                            default route for which the priority is
+ *                            to be promoted.
+ *  @param[in]      type      The IP configuration type for which
+ *                            the gateway, or default router, is to be
+ *                            promoted.
+ *  @param[in]      function  A pointer to an immutable null-terminated
+ *                            C string containing the function name to
+ *                            which the call to this function should be
+ *                            attributed.
+ *
+ *  @retval  0              If successful.
+ *  @retval  -EINVAL        If @a data is null, if @a type is
+ *                          #CONNMAN_IPCONFIG_TYPE_UNKNOWN, if the
+ *                          gateway configuration type is invalid; or
+ *                          if the routing information to be added or
+ *                          deleted was invalid.
+ *  @retval  -EINPROGRESS   If the state of the gateway configuration
+ *                          for @a data is already
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_ADDED or
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_REMOVED.
+ *  @retval  -EALREADY      If the state of the gateway configuration
+ *                          for @a data is already
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_ACTIVE or
+ *                          #CONNMAN_GATEWAY_CONFIG_STATE_INACTIVE.
+ *  @retval  -EFAULT        If the address to the routing information
+ *                          to be added or deleted was invalid.
+ *  @retval  -EPERM         If the current process does not have the
+ *                          credentials or capabilities to add or
+ *                          delete routes.
+ *  @retval  -EEXIST        A request was made to add an existing
+ *                          routing entry.
+ *  @retval  -ESRCH         A request was made to delete a non-
+ *                          existing routing entry.
+ *
+ *  @sa set_default_gateway
+ *  @sa unset_low_priority_default_gateway
+ *  @sa demote_default_gateway
+ *
+ */
+static int promote_default_gateway(struct gateway_data *data,
+				enum connman_ipconfig_type type,
+				const char *function)
+{
+	int unset_status = 0, set_status = 0;
+
+	DBG("from %s() data %p type %d (%s)",
+		function,
+		data,
+		type, __connman_ipconfig_type2string(type));
+
+	unset_status = UNSET_LOW_PRIORITY_DEFAULT_GATEWAY(data, type);
+
+	set_status = SET_DEFAULT_GATEWAY(data, type);
+
+	DBG("unset_status %d (%s) set_status %d (%s)",
+		unset_status, strerror(-unset_status),
+		set_status, strerror(-set_status));
+
+	/*
+	 * Prefer set status to unset status since setting is what effects
+	 * the priority promotion.
+	 */
+	return (set_status == 0 ? set_status : unset_status);
+}
+
+/**
+ *  @brief
+ *    Decide whether either of the specified gateways should yield the
+ *    default gateway route.
+ *
+ *  This determines whether either of the specified gateway data
+ *  should yield the IP-specific default gateway route via
+ *  #unset_default_gateway. @a activated is a newly-activated gateway
+ *  from a Routing Netlink (rtnl) notification. @a existing is an
+ *  existing gateway from the services-to-gateway data hash.
+ *
+ *  @param[in,out]  activated  A pointer to a mutable newly-activated
+ *                             gateway from a Routing Netlink (rtnl)
+ *                             notification.
+ *  @param[in,out]  existing   A pointer to a mutable existing
+ *                             gateway from the services-to-gateway
+ *                             hash.
+ *  @param[in]      type       The IP configuration type for which
+ *                             gateway, or default router, is to be
+ *                             yielded.
+ *
+ *  @returns
+ *    True if @a activated yielded the IP-specific default gateway;
+ *    otherwise, false.
+ *
+ *  @sa __connman_service_compare
+ *  @sa unset_default_gateway
+ *  @sa yield_default_gateway
+ *
+ */
+static bool yield_default_gateway_for_type(struct gateway_data *activated,
+					struct gateway_data *existing,
+					enum connman_ipconfig_type type)
+{
+	static const enum gateway_config_type config_type =
+		CONNMAN_GATEWAY_CONFIG_TYPE_HIGH_PRIORITY_DEFAULT;
+	const struct gateway_config *const activated_config =
+		gateway_data_config_get(activated, type);
+	const struct gateway_config *const existing_config =
+		gateway_data_config_get(existing, type);
+	bool yield_activated = false;
+
+	DBG("activated data %p config %p "
+		"existing data %p config %p "
+		"type %d (%s)",
+		activated, activated_config,
+		existing, existing_config,
+		type, __connman_ipconfig_type2string(type));
+
+	/*
+	 * There is only an default gateway yield decision to be
+	 * considered if there is an gateway configuration for BOTH the
+	 * activated and existing gateway data.
+	 */
+	if (!activated_config || !existing_config)
+		goto done;
+
+	/*
+	 * If the existing gateway data IS NOT active (that is, HAS
+	 * NOT made it to the RTNL notification phase of its
+	 * lifecycle), then it yields the default gateway to the
+	 * activated gateway data.
+	 */
+	if (!is_gateway_config_state_active(existing_config)) {
+		DBG("%s existing %p yielding %s",
+			__connman_ipconfig_type2string(type),
+			existing,
+			maybe_null(gateway_config_type2string(
+				config_type)));
+
+		DEMOTE_DEFAULT_GATEWAY(existing, type);
+	}
+
+	/*
+	 * If the existing gateway data IS active (that is, HAS made
+	 * it to the RTNL notification phase of its lifecycle) and if
+	 * its associated service is more "senior" in the service sort
+	 * order, then the activated gateway data yields the default
+	 * gateway to the existing gateway data.
+	 */
+	if (is_gateway_config_state_active(existing_config) &&
+		__connman_service_compare(existing->service,
+				activated->service) < 0) {
+		DBG("%s activated %p yielding %s",
+			__connman_ipconfig_type2string(type),
+			activated,
+			maybe_null(gateway_config_type2string(
+				config_type)));
+
+		DEMOTE_DEFAULT_GATEWAY(activated, type);
+
+		yield_activated = true;
+	}
+
+	DBG("yield_activated %u", yield_activated);
+
+done:
+	return yield_activated;
+}
+
+/**
+ *  @brief
+ *    Decide whether either of the specified gateways should yield the
+ *    default gateway route.
+ *
+ *  This determines whether either of the specified gateway data
+ *  should yield the default gateway route via
+ *  #unset_default_gateway. @a activated is a newly-activated gateway
+ *  from a Routing Netlink (rtnl) notification. @a existing is an
+ *  existing gateway from the services-to-gateway data hash.
+ *
+ *  @param[in,out]  activated  A pointer to a mutable newly-activated
+ *                             gateway from a Routing Netlink (rtnl)
+ *                             notification.
+ *  @param[in,out]  existing   A pointer to a mutable existing
+ *                             gateway from the services-to-gateway
+ *                             hash.
+ *
+ *  @returns
+ *    True if @a activated yielded the default gateway; otherwise,
+ *    false.
+ *
+ *  @sa check_default_gateway
+ *  @sa __connman_service_compare
+ *  @sa unset_default_gateway
+ *  @sa yield_default_gateway_for_type
+ *
+ */
+static bool yield_default_gateway(struct gateway_data *activated,
+					struct gateway_data *existing)
+{
+	bool yield_ipv4_activated = false, yield_ipv6_activated = false;
+
+	GATEWAY_DATA_DBG("activated", activated);
+	GATEWAY_DATA_DBG("existing", existing);
+
+	yield_ipv4_activated = yield_default_gateway_for_type(
+						activated,
+						existing,
+						CONNMAN_IPCONFIG_TYPE_IPV4);
+
+	yield_ipv6_activated = yield_default_gateway_for_type(
+						activated,
+						existing,
+						CONNMAN_IPCONFIG_TYPE_IPV6);
+
+	DBG("yield_ipv4_activated %u yield_ipv6_activated %u",
+		yield_ipv4_activated,
+		yield_ipv6_activated);
+
+	return yield_ipv4_activated || yield_ipv6_activated;
+}
+
+/**
+ *  @brief
+ *    Check whether the specified gateway should yield or become the
+ *    default.
+ *
+ *  This compares the specified, ostenisbly new, gateway data against
+ *  all, known existing gateway data in the service-to-gateway hash
+ *  and determines whether or not the default should be ceded from an
+ *  existing gateway and given to the new, incoming gateway or vice
+ *  versa.
+ *
+ *  @param[in,out]  activated  A pointer to the mutable gateway data
+ *                             associated with a newly-activated
+ *                             gateway route which is to be checked
+ *                             against existing gateway data.
+ *
+ *  @sa yield_default_gateway
+ *  @sa gateway_rtnl_new
+ *
+ */
+static void check_default_gateway(struct gateway_data *activated)
+{
+	GHashTableIter iter;
+	gpointer value, key;
+	bool yield_activated = false;
+
+	DBG("activated %p", activated);
+
+	GATEWAY_DATA_DBG("activated", activated);
+
+	/*
+	 * If we have already handled a Routing Netlink (rtnl)
+	 * notification and checked the newly-activated gateway against
+	 * the existing gateway / default routers, simply return.
+	 *
+	 * Otherwise, failure to use this 'default_checked' sentinel could
+	 * lead into an infinite Routing Netlink (rntl) loop as changing
+	 * the default gateway pushes a new route into the kernel and ends
+	 * up back here again (via the .newgateway method).
+	 */
+	if (activated->default_checked)
+		return;
+
+	g_hash_table_iter_init(&iter, gateway_hash);
+
+	while (g_hash_table_iter_next(&iter, &key, &value)) {
+		struct gateway_data *existing = value;
+
+		if (existing == activated)
+			continue;
+
+		yield_activated = yield_default_gateway(activated, existing);
+		if (yield_activated)
+			break;
+	}
+
+	DBG("yield_activated %u", yield_activated);
+
+	if (!yield_activated) {
+		if (activated->ipv4_config)
+			PROMOTE_DEFAULT_GATEWAY(activated,
+				CONNMAN_IPCONFIG_TYPE_IPV4);
+
+		if (activated->ipv6_config)
+			PROMOTE_DEFAULT_GATEWAY(activated,
+				CONNMAN_IPCONFIG_TYPE_IPV6);
+	}
+
+	activated->default_checked = true;
+}
+
+/**
+ *  @brief
+ *    Handler for gateway, or default route, -specific routes newly
+ *    added to the Linux kernel routing tables.
+ *
+ *  This is the Linux Routing Netlink (rtnl) handler for gateway, or
+ *  default route, -specific routes newly-added to the Linux kernel
+ *  routing tables. Its primary role and goal is to serve as a
+ *  round-trip acknowledgement that gateway-, or default route,
+ *  related routes added or set to the kernel are now active and in
+ *  use.
+ *
+ *  @param[in]  index    The network interface index associated with
+ *                       the newly-added gateway, or default router.
+ *  @param[in]  gateway  A pointer to an immutable null-terminated
+ *                       C string containing the text-
+ *                       formatted address of the gateway, or default
+ *                       router, that was added.
+ *
+ *  @sa check_default_gateway
+ *  @sa set_default_gateway
+ *  @sa gateway_rtnl_del
+ *
+ */
+static void gateway_rtnl_new(int index, const char *gateway)
+{
+	g_autofree char *interface = NULL;
+	struct gateway_config *config;
+	struct gateway_data *data;
+
+	interface = connman_inet_ifname(index);
+
+	DBG("index %d (%s) gateway %s", index, maybe_null(interface),
+		gateway);
+
+	/*
+	 * If there is no gateway configuration, then this is not a
+	 * gateway, or default router, route we added or
+	 * set. Consequently, ignore it and return.
+	 */
+	config = find_gateway_config(index, gateway);
+	if (!config)
+		return;
+
+	GATEWAY_CONFIG_DBG("config", config);
+
+    /*
+     * If the state is removed, then we may have gone a full
+     * added/removed cycle before the added gateway route was even
+     * activated. In this case, it is now a stale added
+     * activation; simply ignore it.
+     */
+	if (is_gateway_config_state_removed(config)) {
+		DBG("ignoring gateway stale added activation; "
+			"probably removed before added activation completed");
+
+		return;
+	}
+
+	if (is_gateway_config_state_inactive(config)) {
+		DBG("ignoring inactive gateway activation");
+
+		return;
+	}
+
+	/*
+	 * Otherwise, this is a gateway default route we added, or set,
+	 * and it is now acknowledged by the kernel. Consequently, mark it
+	 * as active.
+	 */
+	gateway_config_set_active(config);
+
+	/*
+	 * It is possible that we have two default routes atm
+	 * if there are two gateways waiting rtnl activation at the
+	 * same time.
+	 */
+	data = find_gateway_data(config);
+	if (!data)
+		return;
+
+	GATEWAY_DATA_DBG("data", data);
+
+	/*
+	 * Check whether this newly-activated gateway should yield or
+	 * become the default.
+	 */
+	check_default_gateway(data);
+}
+
+/**
+ *  @brief
+ *    Deallocate gateway configuration resources.
+ *
+ *  This attempts to deallocate resources associated with the
+ *  specified gateway configuration.
+ *
+ *  @param[in,out]  config  A pointer to the mutable gateway
+ *                  configuration to deallocate.
+ *
+ */
+static void gateway_config_free(struct gateway_config *config)
+{
+	DBG("config %p", config);
+
+	if (config) {
+		g_free(config->gateway);
+		g_free(config->vpn_ip);
+		g_free(config->vpn_phy_ip);
+		g_free(config);
+	}
+}
+
+static void remove_gateway(gpointer user_data)
+{
+	struct gateway_data *data = user_data;
+
+	GATEWAY_DATA_DBG("data", data);
+
+	gateway_config_free(data->ipv4_config);
+
+	gateway_config_free(data->ipv6_config);
+
+	/*
+	 * Release, and balance, the strong reference to the service
+	 * retained in #add_gateway.
+	 */
+	connman_service_unref(data->service);
+
+	g_free(data);
+}
+
+/**
+ *  @brief
+ *    Handler for gateway, or default route, -specific routes newly
+ *    removed from the Linux kernel routing tables.
+ *
+ *  This is the Linux Routing Netlink (rtnl) handler for gateway, or
+ *  default route, -specific routes newly-removed from the Linux
+ *  kernel routing tables. Its primary role and goal is to serve as
+ *  a round-trip acknowledgement that gateway-, or default route,
+ *  related routes removed or cleared from the kernel are now inactive
+ *  and are no longer in use.
+ *
+ *  @param[in]  index    The network interface index associated with
+ *                       the newly-removed gateway, or default router.
+ *  @param[in]  gateway  A pointer to an immutable null-terminated
+ *                       C string containing the text-
+ *                       formatted address of the gateway, or default
+ *                       router, that was removed.
+ *
+ *  @sa gateway_rtnl_new
+ *  @sa set_default_gateway
+ *
+ */
+static void gateway_rtnl_del(int index, const char *gateway)
+{
+	g_autofree char *interface = NULL;
+	struct gateway_config *config;
+	struct gateway_data *data;
+
+	interface = connman_inet_ifname(index);
+
+	DBG("index %d (%s) gateway %s", index, maybe_null(interface),
+		gateway);
+
+	/*
+	 * This ends the lifecycle of the gateway associated with the
+	 * newly-removed route; mark it as no longer active.
+	 */
+	config = find_gateway_config(index, gateway);
+	if (config) {
+		GATEWAY_CONFIG_DBG("config", config);
+
+		if (is_gateway_config_state_removed(config))
+			gateway_config_set_inactive(config);
+		else {
+			DBG("ignoring gateway stale removed activation; "
+			"probably added before removed activation completed");
+
+			return;
+		}
+	} else
+		DBG("no matching gateway config");
+
+	/*
+	 * Due to the newly-removed gateway route, there may have been a
+	 * concomitant change in service order that has resulted in a new,
+	 * default service, if any. If so, ensure that service acquires
+	 * the high priority default route.
+	 */
+	data = find_default_gateway_data();
+	if (data) {
+		GATEWAY_DATA_DBG("data", data);
+
+		PROMOTE_DEFAULT_GATEWAY(data, CONNMAN_IPCONFIG_TYPE_ALL);
+	} else
+		DBG("no default gateway data");
+}
+
+static struct connman_rtnl gateway_rtnl = {
+	.name		= "gateway",
+	.newgateway	= gateway_rtnl_new,
+	.delgateway	= gateway_rtnl_del,
+};
+
+/**
+ *  @brief
+ *    Add, or set, a host route for the specified IP configuration
+ *    type for the provided gateway data.
+ *
+ *  This attempts to add, or set, a host route (that is, the RTF_HOST
+ *  flag is asserted on the route) for the specified IP configuration
+ *  type for the provided gateway data.
+ *
+ *  @param[in]  data           A pointer to the mutable gateway data
+ *                             for which to add a host route.
+ *  @param[in]  ipconfig_type  The IP configuration type for which the
+ *                             gateway host route(s) are to be added.
+ *  @param[in]  service_type   The service type for the network service
+ *                             associated with @a index for which the
+ *                             host route is being added.
+ *
+ *  @sa connman_inet_add_host_route
+ *  @sa connman_inet_add_ipv6_host_route
+ *  @sa connman_inet_get_dest_addr
+ *  @sa connman_inet_ipv6_get_dest_addr
+ *
+ */
+static void add_host_route(struct gateway_data *data,
+			enum connman_ipconfig_type ipconfig_type,
+			enum connman_service_type service_type)
+{
+	const struct gateway_config *const config =
+		gateway_data_config_get(data, ipconfig_type);
+
+	if (!config)
+		return;
+
+	if (!is_addr_any_str(config->gateway)) {
+		/*
+		 * We must not set route to the phy dev gateway in
+		 * VPN link. The packets to VPN link might be routed
+		 * back to itself and not routed into phy link gateway.
+		 */
+		if (service_type != CONNMAN_SERVICE_TYPE_VPN)
+			config->ops->add_host_route(data->index,
+								config->gateway,
+								NULL);
+	} else {
+		/*
+		 * Add host route to P-t-P link so that services can
+		 * be moved around and we can have some link to P-t-P
+		 * network (although those P-t-P links have limited
+		 * usage if default route is not directed to them)
+		 */
+		char *dest;
+
+		if (config->ops->get_dest_addr(data->index, &dest) == 0) {
+			config->ops->add_host_route(data->index, dest, NULL);
+			g_free(dest);
+		}
+	}
+}
+
+/**
+ *  @brief
+ *    Add, or set, the gateway, or default router, for a network
+ *    service.
+ *
+ *  This attempts to add, or set, the gateway, or default router, for
+ *  a network service using the specified IP configuration gateway
+ *  address and network interface index as the lookup key for the
+ *  network service.
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           for which to add a gateway, or default
+ *                           router.
+ *  @param[in]      gateway  An optional pointer to an immutable null-
+ *                           terminated C string containing the
+ *                           text-formatted address of the gateway, or
+ *                           default router, to add to or associate
+ *                           with @a service.
+ *  @param[in]      type     The IP configuration type for which
+ *                           gateway, or default router, is to be
+ *                           added.
+ *  @param[in]      peer     An optional pointer to an immutable null-
+ *                           terminated C string containing the
+ *                           text-formatted address of the network
+ *                           peer, for point-to-point links,
+ *                           associated with the gateway.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If service is null or if network interface
+ *                    index associated with @a service is invalid.
+ *
+ *  @sa __connman_gateway_remove
+ *  @sa __connman_gateway_update
+ *
+ */
+int __connman_gateway_add(struct connman_service *service,
+					const char *gateway,
+					enum connman_ipconfig_type type,
+					const char *peer)
+{
+	struct gateway_data *any_active_gateway = NULL;
+	struct gateway_data *default_gateway = NULL;
+	struct gateway_data *new_gateway = NULL;
+	enum connman_service_type service_type;
+	int index;
+	g_autofree char *interface = NULL;
+	bool do_ipv4 = false, do_ipv6 = false;
+	bool is_vpn4 = false, is_vpn6 = false;
+	int err = 0;
+
+	DBG("service %p (%s) gateway %p (%s) type %d (%s) peer %p (%s)",
+		service, maybe_null(connman_service_get_identifier(service)),
+		gateway, maybe_null(gateway),
+		type, __connman_ipconfig_type2string(type),
+		peer, maybe_null(peer));
+
+	if (!service)
+		return -EINVAL;
+
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
+		do_ipv4 = true;
+	else if (type == CONNMAN_IPCONFIG_TYPE_IPV6)
+		do_ipv6 = true;
+	else
+		return -EINVAL;
+
+	index = __connman_service_get_index(service);
+	if (index < 0)
+		return -EINVAL;
+
+	interface = connman_inet_ifname(index);
+
+	DBG("index %d (%s)", index, maybe_null(interface));
+
+	service_type = connman_service_get_type(service);
+
+	/*
+	 * If gateway is NULL, it's a point to point link and the default
+	 * gateway for ipv4 is 0.0.0.0 and for ipv6 is ::, meaning the
+	 * interface
+	 */
+	if (!gateway && do_ipv4)
+		gateway = ipv4_addr_any_str;
+
+	if (!gateway && do_ipv6)
+		gateway = ipv6_addr_any_str;
+
+	err = add_gateway(service, index, gateway, type, &new_gateway);
+	if (err < 0)
+		return err;
+
+	GATEWAY_DATA_DBG("new_gateway", new_gateway);
+
+	any_active_gateway = find_any_active_gateway_data();
+
+	GATEWAY_DATA_DBG("any_active_gateway", any_active_gateway);
+
+	default_gateway = find_default_gateway_data();
+
+	GATEWAY_DATA_DBG("default_gateway", default_gateway);
+
+	if (do_ipv4 && new_gateway->ipv4_config) {
+		add_host_route(new_gateway, type, service_type);
+
+		__connman_service_nameserver_add_routes(service,
+					new_gateway->ipv4_config->gateway);
+	}
+
+	if (do_ipv6 && new_gateway->ipv6_config) {
+		add_host_route(new_gateway, type, service_type);
+
+		__connman_service_nameserver_add_routes(service,
+					new_gateway->ipv6_config->gateway);
+	}
+
+	if (service_type == CONNMAN_SERVICE_TYPE_VPN) {
+
+		set_vpn_routes(new_gateway, service, gateway, type, peer,
+							any_active_gateway);
+
+		is_vpn4 = do_ipv4 &&
+					new_gateway->ipv4_config &&
+					is_gateway_config_vpn(
+						new_gateway->ipv4_config);
+
+		is_vpn6 = do_ipv4 &&
+					new_gateway->ipv4_config &&
+					is_gateway_config_vpn(
+						new_gateway->ipv4_config);
+
+	} else {
+		if (do_ipv4 && new_gateway->ipv4_config)
+			gateway_config_clear_vpn(new_gateway->ipv4_config);
+
+		if (do_ipv6 && new_gateway->ipv6_config)
+			gateway_config_clear_vpn(new_gateway->ipv6_config);
+	}
+
+	/*
+	 * If there is no active gateway, then this is the first and only
+	 * gateway. Set the high-priority default route for the gateway
+	 * and service/network interface tuple.
+	 *
+	 * Otherwise, if there is no default gateway either, then set the
+	 * low-priority default route for the gateway and service/network
+	 * interface tuple.
+	 *
+	 * NOTE: Beyond historical momentum, it is not clear that
+	 * '!any_active_gateway' and 'find_any_active_gateway_data' are
+	 * the best fit here. This should likely be '!default_gateway'
+	 * from 'find_default_gateway_data'.
+	 */
+	if (!any_active_gateway) {
+		SET_DEFAULT_GATEWAY(new_gateway, type);
+		goto done;
+	} else if (default_gateway && !is_vpn4 && !is_vpn6) {
+		SET_LOW_PRIORITY_DEFAULT_GATEWAY(new_gateway, type);
+		goto done;
+	}
+
+	if (is_vpn4) {
+		if (!__connman_service_is_split_routing(new_gateway->service))
+			connman_inet_clear_gateway_address(
+				any_active_gateway->index,
+				any_active_gateway->ipv4_config->gateway);
+	}
+
+	if (is_vpn6) {
+		if (!__connman_service_is_split_routing(new_gateway->service))
+			connman_inet_clear_ipv6_gateway_address(
+				any_active_gateway->index,
+				any_active_gateway->ipv6_config->gateway);
+	}
+
+done:
+	if (do_ipv4)
+		__connman_service_ipconfig_indicate_state(service,
+						CONNMAN_SERVICE_STATE_READY,
+						CONNMAN_IPCONFIG_TYPE_IPV4);
+
+	if (do_ipv6)
+		__connman_service_ipconfig_indicate_state(service,
+						CONNMAN_SERVICE_STATE_READY,
+						CONNMAN_IPCONFIG_TYPE_IPV6);
+
+	return err;
+}
+
+/**
+ *  @brief
+ *    Remove, or clear, the gateway, or default router, for a network
+ *    service.
+ *
+ *  This attempts to remove, or clear, the gateway, or default router,
+ *  for a network service using the specified network service and IP
+ *  configuration type.
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           for which to remove, or clear, a gateway,
+ *                           or default router.
+ *  @param[in]      type     The IP configuration type for which
+ *                           gateway, or default router, is to be
+ *                           removed.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If service is null or if network interface
+ *                    index associated with @a service is invalid.
+ *
+ *  @sa __connman_gateway_add
+ *  @sa __connman_gateway_update
+ *
+ */
+void __connman_gateway_remove(struct connman_service *service,
+					enum connman_ipconfig_type type)
+{
+	struct gateway_data *data = NULL;
+	bool is_vpn4 = false, is_vpn6 = false;
+	bool do_ipv4 = false, do_ipv6 = false;
+	int err;
+
+	DBG("service %p (%s) type %d (%s)",
+		service, maybe_null(connman_service_get_identifier(service)),
+		type, __connman_ipconfig_type2string(type));
+
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
+		do_ipv4 = true;
+	else if (type == CONNMAN_IPCONFIG_TYPE_IPV6)
+		do_ipv6 = true;
+	else if (type == CONNMAN_IPCONFIG_TYPE_ALL)
+		do_ipv4 = do_ipv6 = true;
+	else
+		return;
+
+	/*
+	 * If there is no hash table / map entry for this service, then
+	 * there are no gateways associated with it; simply return.
+	 */
+	data = g_hash_table_lookup(gateway_hash, service);
+	if (!data)
+		return;
+
+	GATEWAY_DATA_DBG("service_data", data);
+
+	/* Delete any routes associated with this service's nameservers. */
+
+	if (do_ipv4 && data->ipv4_config)
+		__connman_service_nameserver_del_routes(service,
+			data->ipv4_config->gateway,
+			type);
+
+	if (do_ipv6 && data->ipv6_config)
+		__connman_service_nameserver_del_routes(service,
+			data->ipv6_config->gateway,
+			type);
+
+	if (do_ipv4 && data->ipv4_config)
+		is_vpn4 = is_gateway_config_vpn(data->ipv4_config);
+
+	if (do_ipv6 && data->ipv6_config)
+		is_vpn6 = is_gateway_config_vpn(data->ipv6_config);
+
+	DBG("ipv4 gateway %s ipv6 gateway %s vpn %d/%d",
+		data->ipv4_config ? data->ipv4_config->gateway : "<null>",
+		data->ipv6_config ? data->ipv6_config->gateway : "<null>",
+		is_vpn4, is_vpn6);
+
+    /* If necessary, delete any VPN-related host routes. */
+
+	if (is_vpn4 && data->index >= 0)
+		data->ipv4_config->ops->del_host_route(
+					data->ipv4_config->vpn_phy_index,
+					data->ipv4_config->gateway,
+					NULL);
+
+	if (is_vpn6 && data->index >= 0)
+		data->ipv6_config->ops->del_host_route(
+					data->ipv6_config->vpn_phy_index,
+					data->ipv6_config->gateway,
+					NULL);
+
+	/* Remove all active routes associated with this gateway data. */
+
+	err = del_gateway_routes_if_active(data, type);
+
+	/*
+	 * We remove the service from the service/gateway map only if ALL
+	 * of the gateway settings are to be removed.
+	 */
+	if (do_ipv4 == do_ipv6 ||
+		(data->ipv4_config && !data->ipv6_config
+			&& do_ipv4) ||
+		(data->ipv6_config && !data->ipv4_config
+			&& do_ipv6)) {
+		g_hash_table_remove(gateway_hash, service);
+	} else
+		DBG("Not yet removing gw ipv4 %p/%d ipv6 %p/%d",
+			data->ipv4_config, do_ipv4,
+			data->ipv6_config, do_ipv6);
+
+	/* with vpn this will be called after the network was deleted,
+	 * we need to call set_default here because we will not receive any
+	 * gateway delete notification.
+	 * We hit the same issue if remove_gateway() fails.
+	 */
+	if (is_vpn4 || is_vpn6 || err < 0) {
+		data = find_default_gateway_data();
+
+		GATEWAY_DATA_DBG("default_data", data);
+
+		if (data)
+			PROMOTE_DEFAULT_GATEWAY(data, type);
+	}
+}
+
+/**
+ *  @brief
+ *    Handle a potential change in gateways.
+ *
+ *  This may be invoked by other modules in the event of service and
+ *  technology changes to reexamine and, if necessary, update active
+ *  network interface gateways and their associated routing table
+ *  entries.
+ *
+ *  @returns
+ *    True if an active gateway was updated; otherwise, false.
+ *
+ *  @sa __connman_gateway_add
+ *  @sa __connman_gateway_remove
+ *  @sa set_default_gateway
+ *  @sa unset_default_gateway
+ *
+ */
+bool __connman_gateway_update(void)
+{
+	struct gateway_data *default_gateway;
+	GHashTableIter iter;
+	gpointer value, key;
+	enum connman_ipconfig_type type;
+	int status = 0;
+	bool updated4 = false, updated6 = false;
+
+	DBG("");
+
+	/*
+	 * If there is no service-to-gateway data hash, then there is
+	 * nothing to update and do; simply return.
+	 */
+	if (!gateway_hash)
+		goto done;
+
+	default_gateway = find_default_gateway_data();
+
+	GATEWAY_DATA_DBG("default_gateway", default_gateway);
+
+	/*
+	 * There can be multiple active gateways so we need to
+	 * check them all.
+	 */
+	g_hash_table_iter_init(&iter, gateway_hash);
+
+	while (g_hash_table_iter_next(&iter, &key, &value)) {
+		struct gateway_data *current_gateway = value;
+		struct gateway_config *current_config;
+
+		GATEWAY_DATA_DBG("current_gateway", current_gateway);
+
+		if (current_gateway == default_gateway)
+			continue;
+
+		type = CONNMAN_IPCONFIG_TYPE_IPV4;
+		current_config = gateway_data_config_get(current_gateway, type);
+
+		if (current_config &&
+				is_gateway_config_state_active(
+					current_config)) {
+			status = DEMOTE_DEFAULT_GATEWAY(current_gateway,
+						type);
+
+			updated4 = status == 0;
+		}
+
+		type = CONNMAN_IPCONFIG_TYPE_IPV6;
+		current_config = gateway_data_config_get(current_gateway, type);
+
+		if (current_config &&
+				is_gateway_config_state_active(
+					current_config)) {
+			status = DEMOTE_DEFAULT_GATEWAY(current_gateway,
+						type);
+
+			updated6 = status == 0;
+		}
+	}
+
+	DBG("updated4 %u updated6 %u", updated4, updated6);
+
+	/*
+	 * Set default gateway if it has been updated or if it has not been
+	 * set as active yet.
+	 */
+	if (default_gateway) {
+		const struct gateway_config *default_config;
+
+		type = CONNMAN_IPCONFIG_TYPE_IPV4;
+		default_config = gateway_data_config_get(default_gateway, type);
+
+		if (default_config &&
+			(updated4 ||
+			!is_gateway_config_state_active(default_config)))
+			PROMOTE_DEFAULT_GATEWAY(default_gateway, type);
+
+		type = CONNMAN_IPCONFIG_TYPE_IPV6;
+		default_config = gateway_data_config_get(default_gateway, type);
+
+		if (default_config &&
+			(updated6 ||
+			!is_gateway_config_state_active(default_config)))
+			PROMOTE_DEFAULT_GATEWAY(default_gateway, type);
+	}
+
+done:
+	return updated4 || updated6;
+}
+
+int __connman_gateway_get_vpn_index(int phy_index)
+{
+	GHashTableIter iter;
+	gpointer value, key;
+
+	g_hash_table_iter_init(&iter, gateway_hash);
+
+	while (g_hash_table_iter_next(&iter, &key, &value)) {
+		struct gateway_data *data = value;
+
+		if (data->ipv4_config &&
+				data->ipv4_config->vpn_phy_index == phy_index)
+			return data->index;
+
+		if (data->ipv6_config &&
+				data->ipv6_config->vpn_phy_index == phy_index)
+			return data->index;
+	}
+
+	return -1;
+}
+
+int __connman_gateway_get_vpn_phy_index(int vpn_index)
+{
+	GHashTableIter iter;
+	gpointer value, key;
+
+	g_hash_table_iter_init(&iter, gateway_hash);
+
+	while (g_hash_table_iter_next(&iter, &key, &value)) {
+		struct gateway_data *data = value;
+
+		if (data->index != vpn_index)
+			continue;
+
+		if (data->ipv4_config)
+			return data->ipv4_config->vpn_phy_index;
+
+		if (data->ipv6_config)
+			return data->ipv6_config->vpn_phy_index;
+	}
+
+	return -1;
+}
+
+int __connman_gateway_init(void)
+{
+	int err;
+
+	DBG("");
+
+	gateway_hash = g_hash_table_new_full(g_direct_hash, g_direct_equal,
+							NULL, remove_gateway);
+
+	err = connman_rtnl_register(&gateway_rtnl);
+	if (err < 0)
+		connman_error("Failed to setup RTNL gateway driver");
+
+	return err;
+}
+
+void __connman_gateway_cleanup(void)
+{
+	GHashTableIter iter;
+	gpointer value, key;
+
+	DBG("");
+
+	connman_rtnl_unregister(&gateway_rtnl);
+
+	g_hash_table_iter_init(&iter, gateway_hash);
+
+	while (g_hash_table_iter_next(&iter, &key, &value)) {
+		struct gateway_data *data = value;
+
+		del_gateway_routes_if_active(data, CONNMAN_IPCONFIG_TYPE_ALL);
+	}
+
+	g_hash_table_destroy(gateway_hash);
+	gateway_hash = NULL;
+}
diff --git a/src/inet.c b/src/inet.c
index 4039a73c..8a1e3423 100644
--- a/src/inet.c
+++ b/src/inet.c
@@ -32,6 +32,7 @@
 #include <string.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
+#include <sys/param.h>
 #include <sys/socket.h>
 #include <linux/sockios.h>
 #include <netdb.h>
@@ -256,6 +257,41 @@ out:
 	return ret;
 }
 
+/**
+ *  @brief
+ *    Return a string describing a Linux Routing Netlink (rtnl)
+ *    routing table identifier.
+ *
+ *  This returns a null-terminated C string describing a Linux Routing
+ *  Netlink (rtnl) routing table identifier.
+ *
+ *  @param[in]  table_id   The Linux Routing Netlink (rtnl) routing
+ *                         table identifier for which to return a
+ *                         descriptive string.
+ *
+ *  @returns
+ *    A pointer to a immutable null-terminated C string describing @a
+ *    table_id on success; otherwise, an empty string ("").
+ *
+ */
+const char *__connman_inet_table2string(uint32_t table_id)
+{
+	switch (table_id) {
+	case RT_TABLE_UNSPEC:
+		return "unspecified";
+	case RT_TABLE_COMPAT:
+		return "compat";
+	case RT_TABLE_DEFAULT:
+		return "default";
+	case RT_TABLE_MAIN:
+		return "main";
+	case RT_TABLE_LOCAL:
+		return "local";
+	}
+
+	return "";
+}
+
 int connman_inet_ifindex(const char *name)
 {
 	struct ifreq ifr;
@@ -549,14 +585,1061 @@ int connman_inet_clear_address(int index, struct connman_ipaddress *ipaddress)
 	return 0;
 }
 
-int connman_inet_add_host_route(int index, const char *host,
+static const char *rtnl_route_cmd2string(int cmd)
+{
+	switch (cmd) {
+	case RTM_NEWROUTE:
+		return "add";
+	case RTM_DELROUTE:
+		return "del";
+	}
+
+	return "";
+}
+
+/**
+ *  @brief
+ *    Convert the specified address from text to binary form.
+ *
+ *  This attempts to converts the specified address in text form into
+ *  binary form in network (that is, big endian) byte order, according
+ *  to the specified address family.
+ *
+ *  @param[in]      family       The address family describing the
+ *                               address pointed to by @a addr_string.
+ *  @param[in]      addr_string  A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               address, in text form, to convert to
+ *                               binary form.
+ *  @param[in,out]  addr_data    A pointer to storage sufficiently
+ *                               large to hold @a addr_string
+ *                               converted into binary form. This will
+ *                               point to the converted binary address
+ *                               data on success.
+ *
+ *  @retval  0              If successful.
+ *  @retval  -EINVAL        If @a addr_string or @a addr_data are
+ *                          null or @a addr_string does not contain a
+ *                          character string representing a valid
+ *                          network address in @a family.
+ *  @retval  -EAFNOSUPPORT  If @ family does not contain a valid
+ *                          address family.
+ *
+ *  @sa inet_pton
+ *
+ */
+static int inet_get_addr_data(int family,
+			const char *addr_string,
+			void *addr_data)
+{
+	int status = 0;
+
+	if (!addr_string || !addr_data)
+		return -EINVAL;
+
+	status = inet_pton(family, addr_string, addr_data);
+	switch (status) {
+	case -1:
+		return -errno;
+	default:
+	case 0:
+		return -EINVAL;
+	case 1:
+		break;
+	}
+
+	return 0;
+}
+
+/**
+ *  @brief
+ *    Apply the specified prefix length to the specified binary
+ *    address data.
+ *
+ *  This attempts to apply the specified prefix length as a network /
+ *  prefix mask to the specified address data, in network (that is,
+ *  big endian) byte order, to generate a network address / prefix.
+ *
+ *  @param[in]      addr_len   The length, in bytes of the address
+ *                             pointed to by @a addr_data.
+ *  @param[in,out]  addr_data  A pointer to the mutable address data
+ *                             in binary form in network (that is,
+ *                             big endian) byte order to mask with @a
+ *                             prefixlen.
+ *  @param[in]      prefixlen  The prefix length to apply to @a
+ *                             addr_data as a mask to generate a
+ *                             network address / prefix.
+ *
+ *  @retval  0              If successful.
+ *  @retval  -EINVAL        If @a addr_len or @a addr_data are null
+ *                          or if the specified prefix length exceeds
+ *                          the address length.
+ *
+ */
+static int inet_mask_addr_data(size_t addr_len,
+			void *addr_data,
+			uint8_t prefixlen)
+{
+	uint8_t *const addr_bytes = addr_data;
+	const size_t total_prefix_bytes = howmany(prefixlen, NBBY);
+	const size_t full_prefix_bytes	= prefixlen / NBBY;
+	const size_t full_clear_bytes	= addr_len - total_prefix_bytes;
+	const uint8_t remaining_bits	= prefixlen % NBBY;
+
+	if (!addr_len || !addr_data || full_prefix_bytes > addr_len)
+		return -EINVAL;
+
+	/* Clear whole non-prefix bytes */
+
+	memset(&addr_bytes[addr_len - full_clear_bytes],
+		0x00,
+		full_clear_bytes);
+
+	/* Mask remaining bits in the last partial prefix byte */
+
+	if (remaining_bits)
+		addr_bytes[full_prefix_bytes] &= ~(0xFF >> remaining_bits);
+
+	return 0;
+}
+
+/**
+ *  @brief
+ *    Add or remove a host or network route.
+ *
+ *  This attempts to add or remove a host or network route to or from
+ *  the kernel using a Linux Route Netlink (rtnl) socket and protocol
+ *  with the specified attributes.
+ *
+ *  @note
+ *    The caller may provide the IPv4 or IPv6 @a host_or_network
+ *    address in masked (that is, 169.254.0.0/16) or unmasked
+ *    (169.254.75.191/16) form. The function will mask the address,
+ *    based on the prefix length, before modifying the route with it.
+ *
+ *  @param[in]  cmd              The Linux Route Netlink command to
+ *                               send. This is expected to be either
+ *                               RTM_NEWROUTE (add new route) or
+ *                               RTM_DELROUTE (delete existing route).
+ *  @param[in]  family           The address family associated with @a
+ *                               host_or_network and @a gateway, if
+ *                               present.
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  host_or_network  A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv4 or IPv6 address, in text form,
+ *                               of the route host or network
+ *                               destination address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv4 or IPv6 address, in text
+ *                               form, of the route next hop gateway
+ *                               address.
+ *  @param[in]  prefixlen        The destination prefix length of the
+ *                               route.
+ *  @param[in]  table_id         The table to add/delete this route
+ *                               to/from.
+ *  @param[in]  metric           The routing priority metric for the
+ *                               route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a host_or_network is null; if @a index is
+ *                    invalid; if the address family of @a family was
+ *                    not AF_INET (IPv4) or AF_INET6 (IPv6); if @a
+ *                    host_or_network or @a gateway, if present, do
+ *                    not contain a character string representing a
+ *                    valid network address in either the AF_INET or
+ *                    AF_INET6 family; or if the routing information
+ *                    to be added or deleted was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    added or deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to add or delete
+ *                    routes.
+ *  @retval  -EEXIST  A request was made to add an existing routing
+ *                    entry.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ */
+static int inet_modify_host_or_network_route(int cmd,
+					int family,
+					int index,
+					const char *host_or_network,
+					const char *gateway,
+					uint8_t prefixlen,
+					uint32_t table_id,
+					uint32_t metric)
+{
+	g_autofree char *interface = NULL;
+	struct __connman_inet_rtnl_handle rth;
+	unsigned char host_or_network_buf[sizeof(struct in6_addr)];
+	unsigned char gateway_buf[sizeof(struct in6_addr)];
+	int ret;
+	size_t addr_len;
+
+	if (!host_or_network || index < 0)
+		return -EINVAL;
+
+	interface = connman_inet_ifname(index);
+
+	DBG("cmd %d (%s) family %d index %d (%s) destination %s/%u gateway %s "
+		"table %u <%s> metric %u",
+		cmd, rtnl_route_cmd2string(cmd),
+		family,
+		index, interface,
+		host_or_network, prefixlen,
+		gateway,
+		table_id, __connman_inet_table2string(table_id),
+		metric);
+
+	switch (family) {
+	case AF_INET:
+		addr_len = 4;
+		break;
+	case AF_INET6:
+		addr_len = 16;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Convert the host or network address from text to binary form */
+
+	ret = inet_get_addr_data(family, host_or_network, host_or_network_buf);
+	if (ret < 0)
+		return ret;
+
+	/* Apply the prefix length to the address data */
+
+	ret = inet_mask_addr_data(addr_len, host_or_network_buf, prefixlen);
+	if (ret < 0)
+		return ret;
+
+	/* If present, convert the gateway address from text to binary form */
+
+	if (gateway) {
+		ret = inet_get_addr_data(family, gateway, gateway_buf);
+		if (ret < 0)
+			return ret;
+	}
+
+	memset(&rth, 0, sizeof(rth));
+
+	rth.req.n.nlmsg_len   = NLMSG_LENGTH(sizeof(struct rtmsg));
+	rth.req.n.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL;
+	rth.req.n.nlmsg_type  = cmd;
+
+	rth.req.u.r.rt.rtm_family   = family;
+	rth.req.u.r.rt.rtm_table    = table_id;
+	rth.req.u.r.rt.rtm_protocol = RTPROT_BOOT;
+	rth.req.u.r.rt.rtm_scope    = gateway ?
+							RT_SCOPE_UNIVERSE :
+							RT_SCOPE_LINK;
+	rth.req.u.r.rt.rtm_type     = RTN_UNICAST;
+	rth.req.u.r.rt.rtm_dst_len  = prefixlen;
+
+	__connman_inet_rtnl_addattr_l(&rth.req.n, sizeof(rth.req),
+				RTA_DST, host_or_network_buf, addr_len);
+
+	if (gateway) {
+		__connman_inet_rtnl_addattr_l(&rth.req.n, sizeof(rth.req),
+					RTA_GATEWAY, gateway_buf, addr_len);
+	}
+
+	__connman_inet_rtnl_addattr32(&rth.req.n, sizeof(rth.req),
+				RTA_TABLE, table_id);
+
+	__connman_inet_rtnl_addattr32(&rth.req.n, sizeof(rth.req),
+				RTA_OIF, index);
+
+	__connman_inet_rtnl_addattr32(&rth.req.n, sizeof(rth.req),
+				RTA_PRIORITY, metric);
+
+	ret = __connman_inet_rtnl_open(&rth);
+	if (ret < 0)
+		goto done;
+
+	ret = __connman_inet_rtnl_send(&rth, &rth.req.n);
+	if (ret < 0)
+		goto done;
+
+	ret = __connman_inet_rtnl_recv(&rth, NULL);
+	if (ret < 0)
+		goto done;
+
+done:
+	__connman_inet_rtnl_close(&rth);
+
+	return ret;
+}
+
+/**
+ *  @brief
+ *    Add or remove a host route.
+ *
+ *  This attempts to add or remove a host route to or from the kernel
+ *  using a Linux Route Netlink (rtnl) socket and protocol with the
+ *  specified attributes.
+ *
+ *  @note
+ *    The caller may provide the IPv4 or IPv6 @a host address in
+ *    masked (that is, 169.254.0.0/16) or unmasked (169.254.75.191/16)
+ *    form. The function will mask the address, based on the prefix
+ *    length, before modifying the route with it.
+ *
+ *  @param[in]  cmd              The Linux Route Netlink command to
+ *                               send. This is expected to be either
+ *                               RTM_NEWROUTE (add new route) or
+ *                               RTM_DELROUTE (delete existing route).
+ *  @param[in]  family           The address family associated with @a
+ *                               host and @a gateway, if present.
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  host             A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv4 or IPv6 address, in text form,
+ *                               of the route host destination
+ *                               address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv4 or IPv6 address, in text
+ *                               form, of the route next hop gateway
+ *                               address.
+ *  @param[in]  prefixlen        The destination prefix length of the
+ *                               route.
+ *  @param[in]  table_id         The table to add/delete this route
+ *                               to/from.
+ *  @param[in]  metric           The routing priority metric for the
+ *                               route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a host is null; if @a index is invalid; if
+ *                    the address family of @a family was not AF_INET
+ *                    (IPv4) or AF_INET6 (IPv6); if @a host or @a
+ *                    gateway, if present, do not contain a character
+ *                    string representing a valid network address in
+ *                    either the AF_INET or AF_INET6 family; or if the
+ *                    routing information to be added or deleted was
+ *                    invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    added or deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to add or delete
+ *                    routes.
+ *  @retval  -EEXIST  A request was made to add an existing routing
+ *                    entry.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ *  @sa inet_modify_host_or_network_route
+ *
+ */
+static int inet_modify_host_route(int cmd,
+					int family,
+					int index,
+					const char *host,
+					const char *gateway,
+					uint8_t prefixlen,
+					uint32_t metric)
+{
+	static const uint32_t table_id = RT_TABLE_MAIN;
+
+	return inet_modify_host_or_network_route(cmd,
+				family,
+				index,
+				host,
+				gateway,
+				prefixlen,
+				table_id,
+				metric);
+}
+
+/**
+ *  @brief
+ *    Add or remove a network route.
+ *
+ *  This attempts to add or remove a network route to or from the
+ *  kernel using a Linux Route Netlink (rtnl) socket and protocol with
+ *  the specified attributes.
+ *
+ *  @note
+ *    The caller may provide the IPv4 or IPv6 @a network address in
+ *    masked (that is, 169.254.0.0/16) or unmasked (169.254.75.191/16)
+ *    form. The function will mask the address, based on the prefix
+ *    length, before modifying the route with it.
+ *
+ *  @param[in]  cmd              The Linux Route Netlink command to
+ *                               send. This is expected to be either
+ *                               RTM_NEWROUTE (add new route) or
+ *                               RTM_DELROUTE (delete existing route).
+ *  @param[in]  family           The address family associated with @a
+ *                               network and @a gateway, if present.
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  network          A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv4 or IPv6 address, in text form,
+ *                               of the route network destination
+ *                               address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv4 or IPv6 address, in text
+ *                               form, of the route next hop gateway
+ *                               address.
+ *  @param[in]  prefixlen        The destination prefix length of the
+ *                               route.
+ *  @param[in]  table_id         The table to add/delete this route
+ *                               to/from.
+ *  @param[in]  metric           The routing priority metric for the
+ *                               route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a network is null; if @a index is invalid;
+ *                    if the address family of @a family was not
+ *                    AF_INET (IPv4) or AF_INET6 (IPv6); if @a network
+ *                    or @a gateway, if present, do not contain a
+ *                    character string representing a valid network
+ *                    address in either the AF_INET or AF_INET6
+ *                    family; or if the routing information to be
+ *                    added or deleted was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    added or deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to add or delete
+ *                    routes.
+ *  @retval  -EEXIST  A request was made to add an existing routing
+ *                    entry.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ *  @sa inet_modify_host_or_network_route
+ *
+ */
+static int inet_modify_network_route(int cmd,
+					int family,
+					int index,
+					const char *network,
+					const char *gateway,
+					uint8_t prefixlen,
+					uint32_t metric)
+{
+	static const uint32_t table_id = RT_TABLE_MAIN;
+
+	return inet_modify_host_or_network_route(cmd,
+				family,
+				index,
+				network,
+				gateway,
+				prefixlen,
+				table_id,
+				metric);
+}
+
+/**
+ *  @brief
+ *    Add or remove an IPv4 network route.
+ *
+ *  This attempts to add or remove an IPv4 network route to or from
+ *  the kernel using a Linux Route Netlink (rtnl) socket and protocol
+ *  with the specified attributes.
+ *
+ *  @note
+ *    The caller may provide the IPv4 @a network address in masked
+ *    (that is, 169.254.0.0/16) or unmasked (169.254.75.191/16)
+ *    form. The function will mask the address, based on the prefix
+ *    length, before modifying the route with it.
+ *
+ *  @param[in]  cmd              The Linux Route Netlink command to
+ *                               send. This is expected to be either
+ *                               RTM_NEWROUTE (add new route) or
+ *                               RTM_DELROUTE (delete existing route).
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  network          A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv4 address, in text form, of the
+ *                               route network destination address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv4 address, in text form, of
+ *                               the route next hop gateway address.
+ *  @param[in]  metric           The routing priority metric for the
+ *                               route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a network is null; if @a index is invalid;
+ *                    if @a network or @a gateway, if present, do not
+ *                    contain a character string representing a valid
+ *                    network address in the AF_INET family; or if the
+ *                    routing information to be added or deleted was
+ *                    invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    added or deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to add or delete
+ *                    routes.
+ *  @retval  -EEXIST  A request was made to add an existing routing
+ *                    entry.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ *  @sa inet_modify_network_route
+ *
+ */
+static int inet_modify_ipv4_network_route(int cmd,
+					int index,
+					const char *network,
+					const char *gateway,
+					uint8_t prefixlen,
+					uint32_t metric)
+{
+	static const int family = AF_INET;
+
+	return inet_modify_network_route(cmd,
+				family,
+				index,
+				network,
+				gateway,
+				prefixlen,
+				metric);
+}
+
+/**
+ *  @brief
+ *    Add or remove an IPv6 network route.
+ *
+ *  This attempts to add or remove an IPv6 network route to or from
+ *  the kernel using a Linux Route Netlink (rtnl) socket and protocol
+ *  with the specified attributes.
+ *
+ *  @note
+ *    The caller may provide the IPv6 @a network address in masked
+ *    (that is, 2601:647:5a00:1500::/56) or unmasked
+ *    (2601:647:5a00:15c1:230d:b2c9:c388:f96b/56) form. The function
+ *    will mask the address, based on the prefix length, before
+ *    modifying the route with it.
+ *
+ *  @param[in]  cmd              The Linux Route Netlink command to
+ *                               send. This is expected to be either
+ *                               RTM_NEWROUTE (add new route) or
+ *                               RTM_DELROUTE (delete existing route).
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  network          A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv6 address, in text form, of the
+ *                               route network destination address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv6 address, in text form, of
+ *                               the route next hop gateway address.
+ *  @param[in]  metric           The routing priority metric for the
+ *                               route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a network is null; if @a index is invalid;
+ *                    if @a network or @a gateway, if present, do not
+ *                    contain a character string representing a valid
+ *                    network address in the AF_INET family; or if the
+ *                    routing information to be added or deleted was
+ *                    invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    added or deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to add or delete
+ *                    routes.
+ *  @retval  -EEXIST  A request was made to add an existing routing
+ *                    entry.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ *  @sa inet_modify_network_route
+ *
+ */
+static int inet_modify_ipv6_network_route(int cmd,
+					int index,
+					const char *network,
+					const char *gateway,
+					uint8_t prefixlen,
+					uint32_t metric)
+{
+	static const int family = AF_INET6;
+
+	return inet_modify_network_route(cmd,
+				family,
+				index,
+				network,
+				gateway,
+				prefixlen,
+				metric);
+}
+
+/**
+ *  @brief
+ *    Add or remove an IPv4 host route.
+ *
+ *  This attempts to add or remove an IPv4 host route to or from the
+ *  kernel using a Linux Route Netlink (rtnl) socket and protocol with
+ *  the specified attributes.
+ *
+ *  @param[in]  cmd              The Linux Route Netlink command to
+ *                               send. This is expected to be either
+ *                               RTM_NEWROUTE (add new route) or
+ *                               RTM_DELROUTE (delete existing route).
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  host             A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv4 address, in text form, of the
+ *                               route host destination address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv4 address, in text form, of
+ *                               the route next hop gateway address.
+ *  @param[in]  metric           The routing priority metric for the
+ *                               route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a host is null; if @a index is invalid; if
+ *                    @a host or @a gateway, if present, do not
+ *                    contain a character string representing a valid
+ *                    network address in the AF_INET family; or if the
+ *                    routing information to be added or deleted was
+ *                    invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    added or deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to add or delete
+ *                    routes.
+ *  @retval  -EEXIST  A request was made to add an existing routing
+ *                    entry.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ *  @sa inet_modify_host_route
+ *
+ */
+static int inet_modify_ipv4_host_route(int cmd,
+					int index,
+					const char *host,
+					const char *gateway,
+					uint32_t metric)
+{
+	static const int family = AF_INET;
+	static const uint8_t prefixlen = 32;
+
+	return inet_modify_host_route(cmd,
+				family,
+				index,
+				host,
+				gateway,
+				prefixlen,
+				metric);
+}
+
+/**
+ *  @brief
+ *    Add or remove an IPv6 host route.
+ *
+ *  This attempts to add or remove an IPv6 host route to or from the
+ *  kernel using a Linux Route Netlink (rtnl) socket and protocol with
+ *  the specified attributes.
+ *
+ *  @param[in]  cmd              The Linux Route Netlink command to
+ *                               send. This is expected to be either
+ *                               RTM_NEWROUTE (add new route) or
+ *                               RTM_DELROUTE (delete existing route).
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  host             A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv6 address, in text form, of the
+ *                               route host destination address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv6 address, in text form, of
+ *                               the route next hop gateway address.
+ *  @param[in]  metric           The routing priority metric for the
+ *                               route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a host is null; if @a index is invalid; if
+ *                    @a host or @a gateway, if present, do not
+ *                    contain a character string representing a valid
+ *                    network address in the AF_INET6 family; or if
+ *                    the routing information to be added or deleted
+ *                    was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    added or deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to add or delete
+ *                    routes.
+ *  @retval  -EEXIST  A request was made to add an existing routing
+ *                    entry.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ *  @sa inet_modify_host_route
+ *
+ */
+static int inet_modify_ipv6_host_route(int cmd,
+					int index,
+					const char *host,
+					const char *gateway,
+					uint32_t metric)
+{
+	static const int family = AF_INET6;
+	static const uint8_t prefixlen = 128;
+
+	return inet_modify_host_route(cmd,
+				family,
+				index,
+				host,
+				gateway,
+				prefixlen,
+				metric);
+}
+
+/**
+ *  @brief
+ *    Add an IPv4 host route with a route metric/priority.
+ *
+ *  This attempts to add an IPv4 host route to the kernel using a
+ *  Linux Route Netlink (rtnl) socket and protocol with the specified
+ *  attributes and route metric/priority.
+ *
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  host             A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv4 address, in text form, of the
+ *                               route host destination address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv4 address, in text form, of
+ *                               the route next hop gateway address.
+ *  @param[in]  metric           The routing priority metric for the
+ *                               route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a host is null; if @a index is invalid; if
+ *                    @a host or @a gateway, if present, do not
+ *                    contain a character string representing a valid
+ *                    network address in the AF_INET family; or if the
+ *                    routing information to be added was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    added was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to add routes.
+ *  @retval  -EEXIST  A request was made to add an existing routing
+ *                    entry.
+ *
+ *  @sa inet_modify_ipv4_host_route
+ *
+ */
+int connman_inet_add_host_route_with_metric(int index,
+				const char *host,
+				const char *gateway,
+				uint32_t metric)
+{
+	static const int cmd = RTM_NEWROUTE;
+
+	DBG("");
+
+	return inet_modify_ipv4_host_route(cmd,
+				index,
+				host,
+				gateway,
+				metric);
+}
+
+/**
+ *  @brief
+ *    Remove an IPv4 host route with a route metric/priority.
+ *
+ *  This attempts to remove an IPv4 host route from the kernel using a
+ *  Linux Route Netlink (rtnl) socket and protocol with the specified
+ *  attributes and route metric/priority.
+ *
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  host             A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv4 address, in text form, of the
+ *                               route host destination address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv4 address, in text form, of
+ *                               the route next hop gateway address.
+ *  @param[in]  metric           The routing priority metric for the
+ *                               route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a host is null; if @a index is invalid; if
+ *                    @a host or @a gateway, if present, do not
+ *                    contain a character string representing a valid
+ *                    network address in the AF_INET family; or if the
+ *                    routing information to be deleted was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to delete routes.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ *  @sa inet_modify_ipv4_host_route
+ *
+ */
+int connman_inet_del_host_route_with_metric(int index,
+				const char *host,
+				const char *gateway,
+				uint32_t metric)
+{
+	static const int cmd = RTM_DELROUTE;
+
+	DBG("");
+
+	return inet_modify_ipv4_host_route(cmd,
+				index,
+				host,
+				gateway,
+				metric);
+}
+
+/**
+ *  @brief
+ *    Add an IPv4 network route with a route metric/priority.
+ *
+ *  This attempts to add an IPv4 network route to the kernel using a
+ *  Linux Route Netlink (rtnl) socket and protocol with the specified
+ *  attributes and route metric/priority.
+ *
+ *  @note
+ *    The caller may provide the IPv4 @a network address in masked
+ *    (that is, 169.254.0.0/16) or unmasked (169.254.75.191/16)
+ *    form. The function will mask the address, based on the prefix
+ *    length, before modifying the route with it.
+ *
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  network          A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv4 address, in text form, of the
+ *                               route network destination address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv4 address, in text form, of
+ *                               the route next hop gateway address.
+ *  @param[in]  prefixlen        The destination prefix length of the
+ *                               route.
+ *  @param[in]  metric           The routing priority metric for the
+ *                               route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a network is null; if @a index is invalid;
+ *                    if @a network or @a gateway, if present, do not
+ *                    contain a character string representing a valid
+ *                    network address in the AF_INET family; or if the
+ *                    routing information to be added was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    added was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to add routes.
+ *  @retval  -EEXIST  A request was made to add an existing routing
+ *                    entry.
+ *
+ *  @sa inet_modify_ipv4_network_route
+ *
+ */
+int connman_inet_add_network_route_with_metric(int index,
+				const char *network,
+				const char *gateway,
+				uint8_t prefixlen,
+				uint32_t metric)
+{
+	static const int cmd = RTM_NEWROUTE;
+
+	DBG("");
+
+	return inet_modify_ipv4_network_route(cmd,
+				index,
+				network,
+				gateway,
+				prefixlen,
+				metric);
+}
+
+/**
+ *  @brief
+ *    Remove an IPv4 network route with a route metric/priority.
+ *
+ *  This attempts to add an IPv4 network route from the kernel using a
+ *  Linux Route Netlink (rtnl) socket and protocol with the specified
+ *  attributes and route metric/priority.
+ *
+ *  @note
+ *    The caller may provide the IPv4 @a network address in masked
+ *    (that is, 169.254.0.0/16) or unmasked (169.254.75.191/16)
+ *    form. The function will mask the address, based on the prefix
+ *    length, before modifying the route with it.
+ *
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  network          A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv4 address, in text form, of the
+ *                               route network destination address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv4 address, in text form, of
+ *                               the route next hop gateway address.
+ *  @param[in]  prefixlen        The destination prefix length of the
+ *                               route.
+ *  @param[in]  metric           The routing priority metric for the
+ *                               route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a network is null; if @a index is invalid;
+ *                    if @a network or @a gateway, if present, do not
+ *                    contain a character string representing a valid
+ *                    network address in the AF_INET family; or if the
+ *                    routing information to be deleted was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to add routes.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ *  @sa inet_modify_ipv4_network_route
+ *
+ */
+int connman_inet_del_network_route_with_metric(int index,
+				const char *network,
+				const char *gateway,
+				uint8_t prefixlen,
+				uint32_t metric)
+{
+	static const int cmd = RTM_DELROUTE;
+
+	DBG("");
+
+	return inet_modify_ipv4_network_route(cmd,
+				index,
+				network,
+				gateway,
+				prefixlen,
+				metric);
+}
+
+/**
+ *  @brief
+ *    Add an IPv4 host route.
+ *
+ *  This attempts to add an IPv4 host route to the kernel with the
+ *  specified attributes.
+ *
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  host             A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv4 address, in text form, of the
+ *                               route host destination address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv4 address, in text form, of
+ *                               the route next hop gateway address.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a host is null; if @a index is invalid; if
+ *                    @a host or @a gateway, if present, do not
+ *                    contain a character string representing a valid
+ *                    network address in the AF_INET family; or if the
+ *                    routing information to be added was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    added was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to add routes.
+ *  @retval  -EEXIST  A request was made to add an existing routing
+ *                    entry.
+ *
+ *  @sa connman_inet_del_host_route
+ *  @sa connman_inet_add_ipv6_host_route
+ *
+ */
+int connman_inet_add_host_route(int index,
+				const char *host,
 				const char *gateway)
 {
 	return connman_inet_add_network_route(index, host, gateway, NULL);
 }
 
-int connman_inet_del_host_route(int index, const char *host)
+/**
+ *  @brief
+ *    Delete an IPv4 host route.
+ *
+ *  This attempts to delete an IPv4 host route to the kernel with the
+ *  specified attributes.
+ *
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  host             A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv4 address, in text form, of the
+ *                               route host destination address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv4 address, in text form, of
+ *                               the route next hop gateway address.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a host is null; if @a index is invalid; if
+ *                    @a host or @a gateway, if present, do not
+ *                    contain a character string representing a valid
+ *                    network address in the AF_INET family; or if the
+ *                    routing information to be deleted was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to delete routes.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ *  @sa connman_inet_add_host_route
+ *  @sa connman_inet_del_ipv6_host_route
+ *
+ */
+int connman_inet_del_host_route(int index,
+				const char *host,
+				const char *gateway)
 {
+	/*
+	 * NOTE: The 'connman_inet_del_network_route' is deficient in that
+	 * it is missing the requisite 'gateway' parameter making it
+	 * symmetric with 'connman_inet_add_host_route' and
+	 * 'connman_inet_add_network_route'. Consequently, host route
+	 * deletion may fail.
+	 *
+	 * This, 'connman_inet_add_host_route', and
+	 * 'connman_inet_del_network_route' should probably be migrated to
+	 * the same RTNL-based call stack as
+	 * 'connman_inet_del_host_route_with_metric'.
+	 */
 	return connman_inet_del_network_route(index, host);
 }
 
@@ -611,6 +1694,16 @@ int connman_inet_add_network_route(int index, const char *host,
 	addr.sin_addr.s_addr = inet_addr(host);
 	memcpy(&rt.rt_dst, &addr, sizeof(rt.rt_dst));
 
+	/*
+	 * Don't add a routes for link-local or unspecified
+	 * destination address coupled with unspecified gateway.
+	 */
+	if ((!host || is_addr_ll(AF_INET, (struct sockaddr *)&addr) || __connman_inet_is_any_addr(host, AF_INET))
+			&& (!gateway || __connman_inet_is_any_addr(gateway, AF_INET))) {
+		close(sk);
+		return -EINVAL;
+	}
+
 	memset(&addr, 0, sizeof(addr));
 	addr.sin_family = AF_INET;
 	if (gateway)
@@ -692,52 +1785,339 @@ out:
 	return err;
 }
 
-int connman_inet_del_ipv6_network_route(int index, const char *host,
-						unsigned char prefix_len)
+/**
+ *  @brief
+ *    Add an IPv6 host route with a route metric/priority.
+ *
+ *  This attempts to add an IPv6 host route to the kernel using a
+ *  Linux Route Netlink (rtnl) socket and protocol with the specified
+ *  attributes and route metric/priority.
+ *
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  host             A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv6 address, in text form, of the
+ *                               route host destination address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv6 address, in text form, of
+ *                               the route next hop gateway address.
+ *  @param[in]  metric           The routing priority metric for the
+ *                               route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a host is null; if @a index is invalid; if
+ *                    @a host or @a gateway, if present, do not
+ *                    contain a character string representing a valid
+ *                    network address in the AF_INET family; or if the
+ *                    routing information to be added was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    added was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to add routes.
+ *  @retval  -EEXIST  A request was made to add an existing routing
+ *                    entry.
+ *
+ *  @sa inet_modify_ipv6_host_route
+ *
+ */
+int connman_inet_add_ipv6_host_route_with_metric(int index,
+				const char *host,
+				const char *gateway,
+				uint32_t metric)
 {
-	struct in6_rtmsg rt;
-	int sk, err = 0;
+	static const int cmd = RTM_NEWROUTE;
 
-	DBG("index %d host %s", index, host);
+	DBG("");
 
-	if (!host)
-		return -EINVAL;
+	return inet_modify_ipv6_host_route(cmd,
+				index,
+				host,
+				gateway,
+				metric);
+}
 
-	memset(&rt, 0, sizeof(rt));
+/**
+ *  @brief
+ *    Remove an IPv6 host route with a route metric/priority.
+ *
+ *  This attempts to remove an IPv6 host route from the kernel using a
+ *  Linux Route Netlink (rtnl) socket and protocol with the specified
+ *  attributes and route metric/priority.
+ *
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  host             A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv6 address, in text form, of the
+ *                               route host destination address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv6 address, in text form, of
+ *                               the route next hop gateway address.
+ *  @param[in]  metric           The routing priority metric for the
+ *                               route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a host is null; if @a index is invalid; if
+ *                    @a host or @a gateway, if present, do not
+ *                    contain a character string representing a valid
+ *                    network address in the AF_INET family; or if the
+ *                    routing information to be deleted was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to delete routes.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ *  @sa inet_modify_ipv6_host_route
+ *
+ */
+int connman_inet_del_ipv6_host_route_with_metric(int index,
+				const char *host,
+				const char *gateway,
+				uint32_t metric)
+{
+	static const int cmd = RTM_DELROUTE;
 
-	rt.rtmsg_dst_len = prefix_len;
+	DBG("");
 
-	if (inet_pton(AF_INET6, host, &rt.rtmsg_dst) != 1) {
-		err = -errno;
-		goto out;
-	}
+	return inet_modify_ipv6_host_route(cmd,
+				index,
+				host,
+				gateway,
+				metric);
+}
 
-	rt.rtmsg_flags = RTF_UP | RTF_HOST;
+/**
+ *  @brief
+ *    Add an IPv6 network route with a route metric/priority.
+ *
+ *  This attempts to add an IPv6 network route to the kernel using a
+ *  Linux Route Netlink (rtnl) socket and protocol with the specified
+ *  attributes and route metric/priority.
+ *
+ *  @note
+ *    The caller may provide the IPv6 @a network address in masked
+ *    (that is, 2601:647:5a00:1500::/56) or unmasked
+ *    (2601:647:5a00:15c1:230d:b2c9:c388:f96b/56) form. The function
+ *    will mask the address, based on the prefix length, before
+ *    modifying the route with it.
+ *
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  network          A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv6 address, in text form, of the
+ *                               route network destination address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv6 address, in text form, of
+ *                               the route next hop gateway address.
+ *  @param[in]  prefixlen        The destination prefix length of the
+ *                               route.
+ *  @param[in]  metric           The routing priority metric for the
+ *                               route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a network is null; if @a index is invalid;
+ *                    if @a network or @a gateway, if present, do not
+ *                    contain a character string representing a valid
+ *                    network address in the AF_INET family; or if the
+ *                    routing information to be added was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    added was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to add routes.
+ *  @retval  -EEXIST  A request was made to add an existing routing
+ *                    entry.
+ *
+ *  @sa inet_modify_ipv6_network_route
+ *
+ */
+int connman_inet_add_ipv6_network_route_with_metric(int index,
+				const char *network,
+				const char *gateway,
+				uint8_t prefixlen,
+				uint32_t metric)
+{
+	static const int cmd = RTM_NEWROUTE;
 
-	rt.rtmsg_metric = 1;
-	rt.rtmsg_ifindex = index;
+	DBG("");
 
-	sk = socket(AF_INET6, SOCK_DGRAM | SOCK_CLOEXEC, 0);
-	if (sk < 0) {
-		err = -errno;
-		goto out;
-	}
+	return inet_modify_ipv6_network_route(cmd,
+				index,
+				network,
+				gateway,
+				prefixlen,
+				metric);
+}
 
-	if (ioctl(sk, SIOCDELRT, &rt) < 0 && errno != ESRCH)
-		err = -errno;
+/**
+ *  @brief
+ *    Remove an IPv6 network route with a route metric/priority.
+ *
+ *  This attempts to add an IPv6 network route from the kernel using a
+ *  Linux Route Netlink (rtnl) socket and protocol with the specified
+ *  attributes and route metric/priority.
+ *
+ *  @note
+ *    The caller may provide the IPv6 @a network address in masked
+ *    (that is, 2601:647:5a00:1500::/56) or unmasked
+ *    (2601:647:5a00:15c1:230d:b2c9:c388:f96b/56) form. The function
+ *    will mask the address, based on the prefix length, before
+ *    modifying the route with it.
+ *
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  network          A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv6 address, in text form, of the
+ *                               route network destination address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv6 address, in text form, of
+ *                               the route next hop gateway address.
+ *  @param[in]  prefixlen        The destination prefix length of the
+ *                               route.
+ *  @param[in]  metric           The routing priority metric for the
+ *                               route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a network is null; if @a index is invalid;
+ *                    if @a network or @a gateway, if present, do not
+ *                    contain a character string representing a valid
+ *                    network address in the AF_INET family; or if the
+ *                    routing information to be deleted was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to add routes.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ *  @sa inet_modify_ipv4_network_route
+ *
+ */
+int connman_inet_del_ipv6_network_route_with_metric(int index,
+				const char *network,
+				const char *gateway,
+				uint8_t prefixlen,
+				uint32_t metric)
+{
+	static const int cmd = RTM_DELROUTE;
 
-	close(sk);
+	DBG("");
 
-out:
-	if (err < 0)
-		connman_error("Del IPv6 host route error (%s)",
-						strerror(-err));
+	return inet_modify_ipv6_network_route(cmd,
+				index,
+				network,
+				gateway,
+				prefixlen,
+				metric);
+}
 
-	return err;
+/**
+ *  @brief
+ *    Add an IPv6 host route.
+ *
+ *  This attempts to add an IPv6 host route to the kernel with the
+ *  specified attributes.
+ *
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  host             A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv6 address, in text form, of the
+ *                               route host destination address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv6 address, in text form, of
+ *                               the route next hop gateway address.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a host is null; if @a index is invalid; if
+ *                    @a host or @a gateway, if present, do not
+ *                    contain a character string representing a valid
+ *                    network address in the AF_INET family; or if the
+ *                    routing information to be added was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    added was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to add routes.
+ *  @retval  -EEXIST  A request was made to add an existing routing
+ *                    entry.
+ *
+ *  @sa connman_inet_add_host_route
+ *  @sa connman_inet_del_ipv6_host_route
+ *
+ */
+int connman_inet_add_ipv6_host_route(int index,
+				const char *host,
+				const char *gateway)
+{
+	return connman_inet_add_ipv6_network_route(index, host, gateway, 128);
 }
 
-int connman_inet_del_ipv6_host_route(int index, const char *host)
+/**
+ *  @brief
+ *    Delete an IPv6 host route.
+ *
+ *  This attempts to delete an IPv6 host route to the kernel with the
+ *  specified attributes.
+ *
+ *  @param[in]  index            The network interface index associated
+ *                               with the output network device for
+ *                               the route.
+ *  @param[in]  host             A pointer to an immutable null-
+ *                               terminated C string containing the
+ *                               IPv6 address, in text form, of the
+ *                               route host destination address.
+ *  @param[in]  gateway          An optional pointer to an immutable
+ *                               null-terminated C string containing
+ *                               the IPv6 address, in text form, of
+ *                               the route next hop gateway address.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a host is null; if @a index is invalid; if
+ *                    @a host or @a gateway, if present, do not
+ *                    contain a character string representing a valid
+ *                    network address in the AF_INET family; or if the
+ *                    routing information to be deleted was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to delete routes.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ *  @sa connman_inet_add_ipv6_host_route
+ *  @sa connman_inet_del_host_route
+ *
+ */
+int connman_inet_del_ipv6_host_route(int index,
+				const char *host,
+				const char *gateway)
 {
+	/*
+	 * NOTE: The 'connman_inet_del_ipv6_network_route' is deficient in
+	 * that it is missing the requisite 'gateway' parameter making it
+	 * symmetric with 'connman_inet_add_ipv6_host_route' and
+	 * 'connman_inet_add_ipv6_network_route'. Consequently, host route
+	 * deletion may fail.
+	 *
+	 * This, 'connman_inet_add_ipv6_host_route', and
+	 * 'connman_inet_del_ipv6_network_route' should probably be
+	 * migrated to the same RTNL-based call stack as
+	 * 'connman_inet_del_ipv6_host_route_with_metric'.
+	 */
 	return connman_inet_del_ipv6_network_route(index, host, 128);
 }
 
@@ -745,6 +2125,7 @@ int connman_inet_add_ipv6_network_route(int index, const char *host,
 					const char *gateway,
 					unsigned char prefix_len)
 {
+	struct sockaddr_in6 addr;
 	struct in6_rtmsg rt;
 	int sk, err = 0;
 
@@ -753,6 +2134,19 @@ int connman_inet_add_ipv6_network_route(int index, const char *host,
 	if (!host)
 		return -EINVAL;
 
+	if (inet_pton(AF_INET6, host, &addr.sin6_addr) != 1) {
+		err = -errno;
+		goto out;
+	}
+
+	/*
+	 * Don't add a route for link-local or unspecified
+	 * destination address coupled with unspecified gateway.
+	 */
+	if ((!host || is_addr_ll(AF_INET6, (struct sockaddr *)&addr) || __connman_inet_is_any_addr(host, AF_INET6))
+			&& (!gateway || __connman_inet_is_any_addr(gateway, AF_INET6)))
+		return -EINVAL;
+
 	memset(&rt, 0, sizeof(rt));
 
 	rt.rtmsg_dst_len = prefix_len;
@@ -798,10 +2192,48 @@ out:
 	return err;
 }
 
-int connman_inet_add_ipv6_host_route(int index, const char *host,
-					const char *gateway)
+int connman_inet_del_ipv6_network_route(int index, const char *host,
+						unsigned char prefix_len)
 {
-	return connman_inet_add_ipv6_network_route(index, host, gateway, 128);
+	struct in6_rtmsg rt;
+	int sk, err = 0;
+
+	DBG("index %d host %s", index, host);
+
+	if (!host)
+		return -EINVAL;
+
+	memset(&rt, 0, sizeof(rt));
+
+	rt.rtmsg_dst_len = prefix_len;
+
+	if (inet_pton(AF_INET6, host, &rt.rtmsg_dst) != 1) {
+		err = -errno;
+		goto out;
+	}
+
+	rt.rtmsg_flags = RTF_UP | RTF_HOST;
+
+	rt.rtmsg_metric = 1;
+	rt.rtmsg_ifindex = index;
+
+	sk = socket(AF_INET6, SOCK_DGRAM | SOCK_CLOEXEC, 0);
+	if (sk < 0) {
+		err = -errno;
+		goto out;
+	}
+
+	if (ioctl(sk, SIOCDELRT, &rt) < 0 && errno != ESRCH)
+		err = -errno;
+
+	close(sk);
+
+out:
+	if (err < 0)
+		connman_error("Del IPv6 host route error (%s)",
+						strerror(-err));
+
+	return err;
 }
 
 int connman_inet_clear_ipv6_gateway_address(int index, const char *gateway)
@@ -2515,33 +3947,68 @@ static gboolean inet_rtnl_timeout_cb(gpointer user_data)
 	return FALSE;
 }
 
-static int inet_rtnl_recv(GIOChannel *chan, struct inet_rtnl_cb_data *rtnl_data)
+/**
+ *  @brief
+ *    Receive and process a Linux Routing Netlink (rtnl) response
+ *    message.
+ *
+ *  This attempts to receive and process a Linux Routing Netlink
+ *  (rtnl) response message to a previous request send by
+ *  #__connman_inet_rtnl_send or #__connman_inet_rtnl_talk.
+ *
+ *  @param[in]      rtnl  A pointer to an immutable Connection
+ *                        Manager Routing Netlink (rtnl) session
+ *                        handle with which the response message will
+ *                        be received.
+ *  @param[in,out]  n     An optional pointer to storage for the
+ *                        Routing Netlink (rtnl) response message
+ *                        header which will be populated if a message
+ *                        is received and processed.
+ *
+ *  @retval  0            If successful.
+ *  @retval  -EINVAL      If @a rtnl is null.
+ *  @retval  -ECONNRESET  If zero bytes were read and/or the remote
+ *                        end of the Routing Netlink (rtnl) socket
+ *                        closed the connection.
+ *  @retval  -EBADMSG     If NLMSG_OK evaluates to false for the
+ *                        received Routing Netlink (rtnl) message or
+ *                        if the received message was of type
+ *                        NLMSG_NOOP or NLMSG_OVERRUN.
+ *
+ *  @sa __connman_inet_rtnl_open
+ *  @sa __connman_inet_rtnl_send
+ *  @sa __connman_inet_rtnl_talk
+ *  @sa __connman_inet_rtnl_close
+ *
+ */
+int __connman_inet_rtnl_recv(const struct __connman_inet_rtnl_handle *rtnl,
+	struct nlmsghdr **n)
 {
-	struct __connman_inet_rtnl_handle *rth = rtnl_data->rtnl;
 	struct nlmsghdr *h = NULL;
 	struct sockaddr_nl nladdr;
 	socklen_t addr_len = sizeof(nladdr);
 	unsigned char buf[4096];
 	void *ptr = buf;
 	gsize len;
-	int status, fd;
+	int status;
+
+	if (!rtnl)
+		return -EINVAL;
 
 	memset(buf, 0, sizeof(buf));
 	memset(&nladdr, 0, sizeof(nladdr));
 
-	fd = g_io_channel_unix_get_fd(chan);
-
-	status = recvfrom(fd, buf, sizeof(buf), 0,
+	status = recvfrom(rtnl->fd, buf, sizeof(buf), 0,
                        (struct sockaddr *) &nladdr, &addr_len);
 	if (status < 0) {
 		if (errno == EINTR || errno == EAGAIN)
 			return 0;
 
-		return -1;
+		return -errno;
 	}
 
 	if (status == 0)
-		return -1;
+		return -ECONNRESET;
 
 	if (nladdr.nl_pid != 0) { /* not sent by kernel, ignore */
 		DBG("Received msg from %u, ignoring it", nladdr.nl_pid);
@@ -2556,11 +4023,11 @@ static int inet_rtnl_recv(GIOChannel *chan, struct inet_rtnl_cb_data *rtnl_data)
 		h = ptr;
 
 		if (!NLMSG_OK(h, len))
-			return -1;
+			return -EBADMSG;
 
-		if (h->nlmsg_seq != rth->seq) {
+		if (h->nlmsg_seq != rtnl->seq) {
 			/* Skip this msg */
-			DBG("skip %d/%d len %d", rth->seq,
+			DBG("skip %d/%d len %d", rtnl->seq,
 				h->nlmsg_seq, h->nlmsg_len);
 
 			len -= h->nlmsg_len;
@@ -2571,18 +4038,42 @@ static int inet_rtnl_recv(GIOChannel *chan, struct inet_rtnl_cb_data *rtnl_data)
 		switch (h->nlmsg_type) {
 		case NLMSG_NOOP:
 		case NLMSG_OVERRUN:
-			return -1;
+			return -EBADMSG;
 
 		case NLMSG_ERROR:
 			err = (struct nlmsgerr *)NLMSG_DATA(h);
-			connman_error("RTNETLINK answers %s (%d)",
-				strerror(-err->error), -err->error);
+			if (err->error != 0)
+				DBG("RTNETLINK answers %s (%d)",
+					strerror(-err->error), -err->error);
 			return err->error;
 		}
 
 		break;
 	}
 
+	if (h && n)
+		*n = h;
+
+	return 0;
+}
+
+static int inet_rtnl_recv(GIOChannel *chan, struct inet_rtnl_cb_data *rtnl_data)
+{
+	struct __connman_inet_rtnl_handle *rth = rtnl_data->rtnl;
+	struct nlmsghdr *h = NULL;
+	int status;
+
+	/*
+	 * Both the chan and rth contain the socket descriptor and should
+	 * be identical. __connman_inet_rtnl_recv uses rth; consequently,
+	 * chan goes unused here.
+	 */
+	(void)chan;
+
+	status = __connman_inet_rtnl_recv(rth, &h);
+	if (status < 0)
+		return status;
+
 	if (h->nlmsg_seq == rth->seq) {
 		DBG("received %d seq %d", h->nlmsg_len, h->nlmsg_seq);
 
@@ -3020,7 +4511,7 @@ bool connman_inet_is_ipv6_supported()
  * connmand and vpnd use inet.c, getting the route is via ipconfig and ipconfig
  * is different for both. Gateway is left here for possible future use.
  *
- * Gateway can be NULL and connection.c then assigns 0.0.0.0 address or ::,
+ * Gateway can be NULL and gateway.c then assigns 0.0.0.0 address or ::,
  * depending on IP family.
  */
 bool connman_inet_is_default_route(int family, const char *host,
@@ -3137,16 +4628,64 @@ int __connman_inet_del_fwmark_rule(uint32_t table_id, int family, uint32_t fwmar
 	return iprule_modify(RTM_DELRULE, family, table_id, fwmark);
 }
 
-static int iproute_default_modify(int cmd, uint32_t table_id, int ifindex,
-			const char *gateway, unsigned char prefixlen)
+/**
+ *  @brief
+ *    Add or remove a gateway default route.
+ *
+ *  This attempts to add or remove a gateway default route to or from
+ *  the kernel using a Linux Route Netlink (rtnl) socket and protocol
+ *  with the specified attributes.
+ *
+ *  @param[in]  cmd        The Linux Route Netlink command to send. This
+ *                         is expected to be either RTM_NEWROUTE (add
+ *                         new route) or RTM_DELROUTE (delete existing
+ *                         route).
+ *  @param[in]  table_id   The table to add/delete this route to/from.
+ *  @param[in]  metric     The routing priority metric for the route.
+ *  @param[in]  ifindex    The network interface index associated with
+ *                         the output network device for the route.
+ *  @param[in]  gateway    A pointer to an immutable null-terminated C
+ *                         string containing the IPv4 or IPv6 address,
+ *                         in text form, of the route destination or
+ *                         next hop gateway address.
+ *  @param[in]  prefixlen  The destination prefix length of the route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If the address family of @a gateway was not AF_INET
+ *                    (IPv4) or AF_INET6 (IPv6), if @a gateway does not
+ *                    contain a character string representing a valid
+ *                    network address in either the AF_INET or
+ *                    AF_INET6 family, or if the routing information
+ *                    to be deleted was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to delete routes.
+ *  @retval  -EEXIST  A request was made to add an existing routing
+ *                    entry.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ */
+static int iproute_default_modify(int cmd, uint32_t table_id, uint32_t metric,
+			int ifindex, const char *gateway,
+			unsigned char prefixlen)
 {
 	struct __connman_inet_rtnl_handle rth;
 	unsigned char buf[sizeof(struct in6_addr)];
 	int ret, len;
 	int family = connman_inet_check_ipaddress(gateway);
 	char *dst = NULL;
+	g_autofree char *interface = NULL;
 
-	DBG("gateway %s/%u table %u", gateway, prefixlen, table_id);
+	interface = connman_inet_ifname(ifindex);
+
+	DBG("cmd %d (%s) ifindex %d (%s) gateway %s/%u table %u <%s> metric %u",
+		cmd, rtnl_route_cmd2string(cmd),
+		ifindex, interface,
+		gateway, prefixlen,
+		table_id, __connman_inet_table2string(table_id),
+		metric);
 
 	switch (family) {
 	case AF_INET:
@@ -3182,7 +4721,6 @@ static int iproute_default_modify(int cmd, uint32_t table_id, int ifindex,
 	rth.req.n.nlmsg_type = cmd;
 	rth.req.u.r.rt.rtm_family = family;
 	rth.req.u.r.rt.rtm_table = RT_TABLE_MAIN;
-	rth.req.u.r.rt.rtm_scope = RT_SCOPE_NOWHERE;
 	rth.req.u.r.rt.rtm_protocol = RTPROT_BOOT;
 	rth.req.u.r.rt.rtm_scope = RT_SCOPE_UNIVERSE;
 	rth.req.u.r.rt.rtm_type = RTN_UNICAST;
@@ -3202,11 +4740,20 @@ static int iproute_default_modify(int cmd, uint32_t table_id, int ifindex,
 	__connman_inet_rtnl_addattr32(&rth.req.n, sizeof(rth.req),
 							RTA_OIF, ifindex);
 
+	__connman_inet_rtnl_addattr32(&rth.req.n, sizeof(rth.req),
+							RTA_PRIORITY, metric);
+
 	ret = __connman_inet_rtnl_open(&rth);
 	if (ret < 0)
 		goto done;
 
 	ret = __connman_inet_rtnl_send(&rth, &rth.req.n);
+	if (ret < 0)
+		goto done;
+
+	ret = __connman_inet_rtnl_recv(&rth, NULL);
+	if (ret < 0)
+		goto done;
 
 done:
 	__connman_inet_rtnl_close(&rth);
@@ -3214,34 +4761,212 @@ done:
 	return ret;
 }
 
+/**
+ *  @brief
+ *    Add a gateway default route.
+ *
+ *  This attempts to add a gateway default route to the kernel routing
+ *  table, @a table_id, using a Linux Route Netlink (rtnl) socket and
+ *  protocol with the specified attributes, including an implicit
+ *  metric/prioity of zero (0), the highest priority.
+ *
+ *  @param[in]  table_id   The table to add this route to.
+ *  @param[in]  ifindex    The network interface index associated with
+ *                         the output network device for the route.
+ *  @param[in]  gateway    A pointer to an immutable null-terminated C
+ *                         string containing the IPv4 or IPv6 address,
+ *                         in text form, of the route destination or
+ *                         next hop gateway address.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If the address family of @a gateway was not AF_INET
+ *                    (IPv4) or AF_INET6 (IPv6), if @a gateway does not
+ *                    contain a character string representing a valid
+ *                    network address in either the AF_INET or
+ *                    AF_INET6 family, or if the routing information
+ *                    to be deleted was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to delete routes.
+ *  @retval  -EEXIST  A request was made to add an existing routing
+ *                    entry.
+ *
+ */
 int __connman_inet_add_default_to_table(uint32_t table_id, int ifindex,
 						const char *gateway)
 {
-	/* ip route add default via 1.2.3.4 dev wlan0 table 1234 */
+	static const uint32_t metric = 0;
+	static const unsigned char prefixlen = 0;
+
+	/*
+	 * ip route add default/0 via <gateway> dev wlan0 table <table_id>
+	 * metric 0
+	 */
+	return iproute_default_modify(RTM_NEWROUTE, table_id, metric, ifindex,
+		gateway, prefixlen);
+}
+
+/**
+ *  @brief
+ *    Add a gateway default route with metric/priority.
+ *
+ *  This attempts to add a gateway default route to the kernel routing
+ *  table, @a table_id, using a Linux Route Netlink (rtnl) socket and
+ *  protocol with the specified attributes, including an explicit
+ *  metric/prioity from the range [0, UINT32_MAX].
+ *
+ *  @param[in]  table_id   The table to add this route to.
+ *  @param[in]  ifindex    The network interface index associated with
+ *                         the output network device for the route.
+ *  @param[in]  gateway    A pointer to an immutable null-terminated C
+ *                         string containing the IPv4 or IPv6 address,
+ *                         in text form, of the route destination or
+ *                         next hop gateway address.
+ *  @param[in]  metric     The routing priority metric for the route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If the address family of @a gateway was not AF_INET
+ *                    (IPv4) or AF_INET6 (IPv6), if @a gateway does not
+ *                    contain a character string representing a valid
+ *                    network address in either the AF_INET or
+ *                    AF_INET6 family, or if the routing information
+ *                    to be deleted was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to delete routes.
+ *  @retval  -EEXIST  A request was made to add an existing routing
+ *                    entry.
+ *
+ */
+int __connman_inet_add_default_to_table_with_metric(uint32_t table_id,
+						int ifindex,
+						const char *gateway,
+						uint32_t metric)
+{
+	static const unsigned char prefixlen = 0;
 
-	return iproute_default_modify(RTM_NEWROUTE, table_id, ifindex, gateway, 0);
+	/*
+	 * ip route add default/0 via <gateway> dev wlan0 table <table_id>
+	 * metric <metric>
+	 */
+	return iproute_default_modify(RTM_NEWROUTE, table_id, metric, ifindex,
+		gateway, prefixlen);
 }
 
 int __connman_inet_add_subnet_to_table(uint32_t table_id, int ifindex,
 						const char *gateway, unsigned char prefixlen)
 {
-	/* ip route add 1.2.3.4/24 dev eth0 table 1234 */
-	return iproute_default_modify(RTM_NEWROUTE, table_id, ifindex, gateway, prefixlen);
+	static const uint32_t metric = 0;
+
+	/* ip route add 1.2.3.4/24 dev eth0 table 1234 metric 0 */
+	return iproute_default_modify(RTM_NEWROUTE, table_id, metric, ifindex,
+		gateway, prefixlen);
 }
 
+/**
+ *  @brief
+ *    Delete a gateway default route.
+ *
+ *  This attempts to delete a gateway default route from the kernel
+ *  routing table, @a table_id, using a Linux Route Netlink (rtnl)
+ *  socket and protocol with the specified attributes, including an
+ *  implicit metric/prioity of zero (0), the highest priority.
+ *
+ *  @param[in]  table_id   The table to delete this route from.
+ *  @param[in]  ifindex    The network interface index associated with
+ *                         the output network device for the route.
+ *  @param[in]  gateway    A pointer to an immutable null-terminated C
+ *                         string containing the IPv4 or IPv6 address,
+ *                         in text form, of the route destination or
+ *                         next hop gateway address.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If the address family of @a gateway was not AF_INET
+ *                    (IPv4) or AF_INET6 (IPv6), if @a gateway does not
+ *                    contain a character string representing a valid
+ *                    network address in either the AF_INET or
+ *                    AF_INET6 family, or if the routing information
+ *                    to be deleted was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to delete routes.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ */
 int __connman_inet_del_default_from_table(uint32_t table_id, int ifindex,
 						const char *gateway)
 {
-	/* ip route del default via 1.2.3.4 dev wlan0 table 1234 */
+	static const uint32_t metric = 0;
+	static const unsigned char prefixlen = 0;
 
-	return iproute_default_modify(RTM_DELROUTE, table_id, ifindex, gateway, 0);
+	/*
+	 * ip route del default/0 via <gateway> dev wlan0 table <table_id>
+	 * metric 0
+	 */
+	return iproute_default_modify(RTM_DELROUTE, table_id, metric, ifindex,
+		gateway, prefixlen);
+}
+
+/**
+ *  @brief
+ *    Delete a gateway default route with metric/priority.
+ *
+ *  This attempts to delete a gateway default route from the kernel
+ *  routing table, @a table_id, using a Linux Route Netlink (rtnl)
+ *  socket and protocol with the specified attributes, including an
+ *  explicit metric/prioity from the range [0, UINT32_MAX].
+ *
+ *  @param[in]  table_id   The table to delete this route from.
+ *  @param[in]  ifindex    The network interface index associated with
+ *                         the output network device for the route.
+ *  @param[in]  gateway    A pointer to an immutable null-terminated C
+ *                         string containing the IPv4 or IPv6 address,
+ *                         in text form, of the route destination or
+ *                         next hop gateway address.
+ *  @param[in]  metric     The routing priority metric for the route.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If the address family of @a gateway was not AF_INET
+ *                    (IPv4) or AF_INET6 (IPv6), if @a gateway does not
+ *                    contain a character string representing a valid
+ *                    network address in either the AF_INET or
+ *                    AF_INET6 family, or if the routing information
+ *                    to be deleted was invalid.
+ *  @retval  -EFAULT  If the address to the routing information to be
+ *                    deleted was invalid.
+ *  @retval  -EPERM   If the current process does not have the
+ *                    credentials or capabilities to delete routes.
+ *  @retval  -ESRCH   A request was made to delete a non-existing
+ *                    routing entry.
+ *
+ */
+int __connman_inet_del_default_from_table_with_metric(uint32_t table_id,
+						int ifindex,
+						const char *gateway,
+						uint32_t metric)
+{
+	static const unsigned char prefixlen = 0;
+
+	/*
+	 * ip route del default/0 via <gateway> dev wlan0 table <table_id>
+	 * metric <metric>
+	 */
+	return iproute_default_modify(RTM_DELROUTE, table_id, metric, ifindex,
+		gateway, prefixlen);
 }
 
 int __connman_inet_del_subnet_from_table(uint32_t table_id, int ifindex,
 						const char *gateway, unsigned char prefixlen)
 {
-	/* ip route del 1.2.3.4/24 dev eth0 table 1234 */
-	return iproute_default_modify(RTM_DELROUTE, table_id, ifindex, gateway, prefixlen);
+	static const uint32_t metric = 0;
+
+	/* ip route del 1.2.3.4/24 dev eth0 table 1234 metric 0 */
+	return iproute_default_modify(RTM_DELROUTE, table_id, metric, ifindex,
+		gateway, prefixlen);
 }
 
 int __connman_inet_get_interface_ll_address(int index, int family,
diff --git a/src/ipconfig.c b/src/ipconfig.c
index 34b1724a..c2d7d2bc 100644
--- a/src/ipconfig.c
+++ b/src/ipconfig.c
@@ -40,6 +40,14 @@
 
 #include "connman.h"
 
+/* Linux reverse path filtering (rp_filter) validation setting values.
+ */
+enum {
+	__CONNMAN_LINUX_RP_FILTER_SETTING_NO_VALIDATION          = 0,
+	__CONNMAN_LINUX_RP_FILTER_SETTING_STRICT_MODE_VALIDATION = 1,
+	__CONNMAN_LINUX_RP_FILTER_SETTING_LOOSE_MODE_VALIDATION  = 2,
+};
+
 struct connman_ipconfig {
 	int refcount;
 	int index;
@@ -95,6 +103,11 @@ static GHashTable *ipdevice_hash = NULL;
 static GList *ipconfig_list = NULL;
 static bool is_ipv6_supported = false;
 
+static const char *maybe_null(const void *pointer)
+{
+	return pointer ? pointer : "<null>";
+}
+
 static void store_set_str(struct ipconfig_store *store,
 			const char *key, const char *val)
 
@@ -217,12 +230,13 @@ const char *__connman_ipconfig_type2string(enum connman_ipconfig_type type)
 {
 	switch (type) {
 	case CONNMAN_IPCONFIG_TYPE_UNKNOWN:
-	case CONNMAN_IPCONFIG_TYPE_ALL:
 		return "unknown";
 	case CONNMAN_IPCONFIG_TYPE_IPV4:
 		return "IPv4";
 	case CONNMAN_IPCONFIG_TYPE_IPV6:
 		return "IPv6";
+	case CONNMAN_IPCONFIG_TYPE_ALL:
+		return "IPv4 + IPv6";
 	}
 
 	return NULL;
@@ -249,9 +263,9 @@ static const char *type2str(unsigned short type)
 static const char *scope2str(unsigned char scope)
 {
 	switch (scope) {
-	case 0:
+	case RT_SCOPE_UNIVERSE:
 		return "UNIVERSE";
-	case 253:
+	case RT_SCOPE_LINK:
 		return "LINK";
 	}
 
@@ -261,6 +275,45 @@ static const char *scope2str(unsigned char scope)
 #define PROC_IPV4_CONF_PREFIX "/proc/sys/net/ipv4/conf"
 #define PROC_IPV6_CONF_PREFIX "/proc/sys/net/ipv6/conf"
 
+/**
+ *  @brief
+ *    Get the file system configuration value associated with the
+ *    composed prefix, optional network interface name, and suffix
+ *    path components.
+ *
+ *  This attempts to read and return the file system (ostensibly from
+ *  the Linux proc file system) configuration value associated with
+ *  the composed combination of the specified prefix, optional network
+ *  interface name, and suffix path components. If the network
+ *  interface name is null, then "all" is used. The composed path name
+ *  will look like "prefix/<ifname|all>/suffix".
+ *
+ *  @param[in]   prefix  A pointer to the immutable null-terminated C
+ *                       string containing the prefix component(s) of
+ *                       the file system path for which to get the
+ *                       configuration value.
+ *  @param[in]   ifname  An optional pointer to the immutable null-
+ *                       terminated C string containing the network
+ *                       interface name to use as the path component
+ *                       between @a prefix and @a suffix. If null,
+ *                       "all" will be used.
+ *  @param[in]   suffix  A pointer to the immutable null-terminated C
+ *                       string containing the suffix component(s) of
+ *                       the file system path for which to get the
+ *                       configuration value.
+ *  @param[out]  value   A pointer to storage to be populated with the
+ *                       read configuration value, if successful.
+ *
+ *  @retval  1         If successful.
+ *  @retval  0         If no configuration value was successfully read.
+ *  @retval  -ENOMEM   If memory could not be allocated for the
+ *                     configuration path name to be read.
+ *  @retval  -ENOENT   The composed configuration path name does not
+ *                     exist.
+ *  @retval  -EACCESS  The current process does not have permission
+ *                     to access the composed configuration path name.
+ *
+ */
 static int read_conf_value(const char *prefix, const char *ifname,
 					const char *suffix, int *value)
 {
@@ -268,11 +321,14 @@ static int read_conf_value(const char *prefix, const char *ifname,
 	FILE *f;
 	int err;
 
+	// Build the file system path name from the specified,
+	// null-terminated variable argument component list.
+
 	path = g_build_filename(prefix, ifname ? ifname : "all", suffix, NULL);
 	if (!path)
 		return -ENOMEM;
 
-	errno = 0;
+	errno = 0; /* Avoid stale errno values with fopen */
 	f = fopen(path, "r");
 	if (!f) {
 		err = -errno;
@@ -294,12 +350,84 @@ static int read_conf_value(const char *prefix, const char *ifname,
 	return err;
 }
 
+/**
+ *  @brief
+ *    Get the Linux proc file system configuration value associated
+ *    with the composed /proc/sys/net/ipv4/conf prefix, optional
+ *    network interface name, and suffix path components.
+ *
+ *  This attempts to read and return the file system (ostensibly from
+ *  the Linux proc file system) configuration value associated with
+ *  the composed combination of the /proc/sys/net/ipv4/conf prefix,
+ *  optional network interface name, and suffix path components. If
+ *  the network interface name is null, then "all" is used. The
+ *  composed path name will look like "/proc/sys/net/ipv4/conf/
+ *  <ifname|all>/suffix".
+ *
+ *  @param[in]   ifname  An optional pointer to the immutable null-
+ *                       terminated C string containing the network
+ *                       interface name to use as the path component
+ *                       between @a prefix and @a suffix. If null,
+ *                       "all" will be used.
+ *  @param[in]   suffix  A pointer to the immutable null-terminated C
+ *                       string containing the suffix component(s) of
+ *                       the file system path for which to get the
+ *                       configuration value.
+ *  @param[out]  value   A pointer to storage to be populated with the
+ *                       read configuration value, if successful.
+ *
+ *  @retval  1         If successful.
+ *  @retval  0         If no configuration value was successfully read.
+ *  @retval  -ENOMEM   If memory could not be allocated for the
+ *                     configuration path name to be read.
+ *  @retval  -ENOENT   The composed configuration path name does not
+ *                     exist.
+ *  @retval  -EACCESS  The current process does not have permission
+ *                     to access the composed configuration path name.
+ *
+ */
 static int read_ipv4_conf_value(const char *ifname, const char *suffix,
 								int *value)
 {
 	return read_conf_value(PROC_IPV4_CONF_PREFIX, ifname, suffix, value);
 }
 
+/**
+ *  @brief
+ *    Get the Linux proc file system configuration value associated
+ *    with the composed /proc/sys/net/ipv6/conf prefix, optional
+ *    network interface name, and suffix path components.
+ *
+ *  This attempts to read and return the file system (ostensibly from
+ *  the Linux proc file system) configuration value associated with
+ *  the composed combination of the /proc/sys/net/ipv6/conf prefix,
+ *  optional network interface name, and suffix path components. If
+ *  the network interface name is null, then "all" is used. The
+ *  composed path name will look like "/proc/sys/net/ipv6/conf/
+ *  <ifname|all>/suffix".
+ *
+ *  @param[in]   ifname  An optional pointer to the immutable null-
+ *                       terminated C string containing the network
+ *                       interface name to use as the path component
+ *                       between @a prefix and @a suffix. If null,
+ *                       "all" will be used.
+ *  @param[in]   suffix  A pointer to the immutable null-terminated C
+ *                       string containing the suffix component(s) of
+ *                       the file system path for which to get the
+ *                       configuration value.
+ *  @param[out]  value   A pointer to storage to be populated with the
+ *                       read configuration value, if successful.
+ *
+ *  @retval  1         If successful.
+ *  @retval  0         If no configuration value was successfully read.
+ *  @retval  -ENOMEM   If memory could not be allocated for the
+ *                     configuration path name to be read.
+ *  @retval  -ENOENT   The composed configuration path name does not
+ *                     exist.
+ *  @retval  -EACCESS  The current process does not have permission
+ *                     to access the composed configuration path name.
+ *
+ */
 static int read_ipv6_conf_value(const char *ifname, const char *suffix,
 								int *value)
 {
@@ -344,9 +472,9 @@ static int write_ipv6_conf_value(const char *ifname, const char *suffix,
 	return write_conf_value(PROC_IPV6_CONF_PREFIX, ifname, suffix, value);
 }
 
-static bool get_ipv6_state(gchar *ifname)
+static bool get_ipv6_state(const gchar *ifname)
 {
-	int disabled;
+	int disabled = 1;
 	bool enabled = false;
 
 	if (read_ipv6_conf_value(ifname, "disable_ipv6", &disabled) > 0)
@@ -355,7 +483,7 @@ static bool get_ipv6_state(gchar *ifname)
 	return enabled;
 }
 
-static int set_ipv6_state(gchar *ifname, bool enable)
+static int set_ipv6_state(const gchar *ifname, bool enable)
 {
 	int disabled = enable ? 0 : 1;
 
@@ -364,15 +492,32 @@ static int set_ipv6_state(gchar *ifname, bool enable)
 	return write_ipv6_conf_value(ifname, "disable_ipv6", disabled);
 }
 
-static int get_ipv6_privacy(gchar *ifname)
+/**
+ *  @brief
+ *    Return the IPv6 address privacy setting from the Linux kernel
+ *    proc file system for the specified network interface name.
+ *
+ *  This attempts to read and return the IPv6 address privacy setting
+ *  (that is, "use_tempaddr") from the Linux kernel proc file system
+ *  for the specified network interface name.
+ *
+ *  @param[in]  ifname  A pointer to the immutable null-terminated C
+ *                      string of the network interface name for which
+ *                      to return the IPv6 privacy setting.
+ *
+ *  @retval  <= 0  IPv6 address privacy is disabled.
+ *  @retval     1  IPv6 address privacy is enabled.
+ *  @retval     2  IPv6 address privacy is preferred.
+ *
+ */
+static int get_ipv6_privacy(const gchar *ifname)
 {
-	int value;
+	int value = 0;
 
 	if (!ifname)
-		return 0;
+		return value;
 
-	if (read_ipv6_conf_value(ifname, "use_tempaddr", &value) < 0)
-		value = 0;
+	read_ipv6_conf_value(ifname, "use_tempaddr", &value);
 
 	return value;
 }
@@ -380,7 +525,7 @@ static int get_ipv6_privacy(gchar *ifname)
 /* Enable the IPv6 privacy extension for stateless address autoconfiguration.
  * The privacy extension is described in RFC 3041 and RFC 4941
  */
-static int set_ipv6_privacy(gchar *ifname, int value)
+static int set_ipv6_privacy(const gchar *ifname, int value)
 {
 	if (!ifname)
 		return -EINVAL;
@@ -391,12 +536,27 @@ static int set_ipv6_privacy(gchar *ifname, int value)
 	return write_ipv6_conf_value(ifname, "use_tempaddr", value);
 }
 
+/**
+ *  @brief
+ *    Return the IPv4 reverse path routing validation setting from the
+ *    Linux kernel proc file system.
+ *
+ *  This attempts to read and return the IPv6 address privacy setting
+ *  (that is, "rp_filter") from the Linux kernel proc file system.
+ *
+ *  @retval  -EINVAL  The setting could not be read.
+ *  @retval  0        No reverse path routing validation is in effect.
+ *  @retval  1        Strict mode reverse path routing validation is
+ *                    in effect.
+ *  @retval  2        Loose mode reverse path routing validation is
+ *                    in effect.
+ *
+ */
 static int get_rp_filter(void)
 {
-	int value;
+	int value = -EINVAL;
 
-	if (read_ipv4_conf_value(NULL, "rp_filter", &value) < 0)
-		value = -EINVAL;
+	read_ipv4_conf_value(NULL, "rp_filter", &value);
 
 	return value;
 }
@@ -406,11 +566,11 @@ static int set_rp_filter(int value)
 	/* 0 = no validation, 1 = strict mode, 2 = loose mode */
 	switch (value) {
 	case -1:
-		value = 0;
+		value = __CONNMAN_LINUX_RP_FILTER_SETTING_NO_VALIDATION;
 		/* fall through */
-	case 0:
-	case 1:
-	case 2:
+	case __CONNMAN_LINUX_RP_FILTER_SETTING_NO_VALIDATION:
+	case __CONNMAN_LINUX_RP_FILTER_SETTING_STRICT_MODE_VALIDATION:
+	case __CONNMAN_LINUX_RP_FILTER_SETTING_LOOSE_MODE_VALIDATION:
 		break;
 	default:
 		return -EINVAL;
@@ -421,6 +581,7 @@ static int set_rp_filter(int value)
 
 int __connman_ipconfig_set_rp_filter()
 {
+	const int default_value = __CONNMAN_LINUX_RP_FILTER_SETTING_LOOSE_MODE_VALIDATION;
 	int value;
 
 	value = get_rp_filter();
@@ -428,10 +589,10 @@ int __connman_ipconfig_set_rp_filter()
 	if (value < 0)
 		return value;
 
-	set_rp_filter(2);
+	set_rp_filter(default_value);
 
-	connman_info("rp_filter set to 2 (loose mode routing), "
-			"old value was %d", value);
+	connman_info("rp_filter set to %d (loose mode routing), "
+			"old value was %d", default_value, value);
 
 	return value;
 }
@@ -877,7 +1038,10 @@ out:
 }
 
 void __connman_ipconfig_newroute(int index, int family, unsigned char scope,
-					const char *dst, const char *gateway)
+					const char *dst,
+					unsigned char dst_prefixlen,
+					const char *gateway,
+					uint32_t table_id, uint32_t metric)
 {
 	struct connman_ipdevice *ipdevice;
 	char *ifname;
@@ -938,15 +1102,20 @@ void __connman_ipconfig_newroute(int index, int family, unsigned char scope,
 		}
 	}
 
-	connman_info("%s {add} route %s gw %s scope %u <%s>",
-		ifname, dst, gateway, scope, scope2str(scope));
+	DBG("%s {add} route %s/%u gw %s scope %u <%s> table %u <%s> "
+		"metric %u",
+		ifname, dst, dst_prefixlen, gateway, scope, scope2str(scope),
+		table_id, __connman_inet_table2string(table_id), metric);
 
 out:
 	g_free(ifname);
 }
 
 void __connman_ipconfig_delroute(int index, int family, unsigned char scope,
-					const char *dst, const char *gateway)
+					const char *dst,
+					unsigned char dst_prefixlen,
+					const char *gateway,
+					uint32_t table_id, uint32_t metric)
 {
 	struct connman_ipdevice *ipdevice;
 	char *ifname;
@@ -1005,8 +1174,10 @@ void __connman_ipconfig_delroute(int index, int family, unsigned char scope,
 		}
 	}
 
-	connman_info("%s {del} route %s gw %s scope %u <%s>",
-		ifname, dst, gateway, scope, scope2str(scope));
+	DBG("%s {del} route %s/%u gw %s scope %u <%s> table %u <%s> "
+		"metric %u",
+		ifname, dst, dst_prefixlen, gateway, scope, scope2str(scope),
+		table_id, __connman_inet_table2string(table_id), metric);
 
 out:
 	g_free(ifname);
@@ -1147,7 +1318,7 @@ void __connman_ipconfig_set_broadcast(struct connman_ipconfig *ipconfig,
 	ipconfig->address->broadcast = g_strdup(broadcast);
 }
 
-const char *__connman_ipconfig_get_gateway(struct connman_ipconfig *ipconfig)
+const char *__connman_ipconfig_get_gateway(const struct connman_ipconfig *ipconfig)
 {
 	if (!ipconfig->address)
 		return NULL;
@@ -1166,11 +1337,41 @@ void __connman_ipconfig_set_gateway(struct connman_ipconfig *ipconfig,
 	ipconfig->address->gateway = g_strdup(gateway);
 }
 
-int __connman_ipconfig_gateway_add(struct connman_ipconfig *ipconfig)
+/**
+ *  @brief
+ *    Add, or set, the gateway, or default router, for a network
+ *    service.
+ *
+ *  This attempts to add, or set, the gateway, or default router, for
+ *  a network service using the specified IP configuration.
+ *
+ *  @param[in]  ipconfig  A pointer to the immutable IP configuration
+ *                        containing the network interface index @a
+ *                        index as the lookup key for the network
+ *                        service for which to add, or set, the
+ *                        gateway.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If the @a address field of @a ipconfig is null,
+ *                    if a cooresponding service cannot be found for
+ *                    the network interface index @a index of @a
+ *                    ipconfig, or if the network interface index
+ *                    associated with @a service is invalid.
+ *
+ *  @sa __connman_ipconfig_gateway_remove
+ *  @sa __connman_gateway_add
+ *
+ */
+int __connman_ipconfig_gateway_add(const struct connman_ipconfig *ipconfig)
 {
 	struct connman_service *service;
+	g_autofree char *interface = NULL;
 
-	DBG("");
+	interface = connman_inet_ifname(ipconfig->index);
+
+	DBG("ipconfig %p type %d (%s) index %d (%s)", ipconfig,
+		ipconfig->type, __connman_ipconfig_type2string(ipconfig->type),
+		ipconfig->index, maybe_null(interface));
 
 	if (!ipconfig->address)
 		return -EINVAL;
@@ -1179,12 +1380,12 @@ int __connman_ipconfig_gateway_add(struct connman_ipconfig *ipconfig)
 	if (!service)
 		return -EINVAL;
 
-	DBG("type %d gw %s peer %s", ipconfig->type,
+	DBG("gw %s peer %s",
 		ipconfig->address->gateway, ipconfig->address->peer);
 
 	if (ipconfig->type == CONNMAN_IPCONFIG_TYPE_IPV6 ||
 				ipconfig->type == CONNMAN_IPCONFIG_TYPE_IPV4)
-		return __connman_connection_gateway_add(service,
+		return __connman_gateway_add(service,
 						ipconfig->address->gateway,
 						ipconfig->type,
 						ipconfig->address->peer);
@@ -1192,15 +1393,38 @@ int __connman_ipconfig_gateway_add(struct connman_ipconfig *ipconfig)
 	return 0;
 }
 
-void __connman_ipconfig_gateway_remove(struct connman_ipconfig *ipconfig)
+/**
+ *  @brief
+ *    Remove, or clear, the gateway, or default router, for a network
+ *    service.
+ *
+ *  This attempts to remove, or clear, the gateway, or default router, for
+ *  a network service using the specified IP configuration.
+ *
+ *  @param[in]  ipconfig  A pointer to the immutable IP configuration
+ *                        containing the network interface index @a
+ *                        index as the lookup key for the network
+ *                        service for which to remove, or clear, the
+ *                        gateway.
+ *
+ *  @sa __connman_ipconfig_gateway_add
+ *  @sa __connman_gateway_remove
+ *
+ */
+void __connman_ipconfig_gateway_remove(const struct connman_ipconfig *ipconfig)
 {
 	struct connman_service *service;
+	g_autofree char *interface = NULL;
 
-	DBG("");
+	interface = connman_inet_ifname(ipconfig->index);
+
+	DBG("ipconfig %p type %d (%s) index %d (%s)", ipconfig,
+		ipconfig->type, __connman_ipconfig_type2string(ipconfig->type),
+		ipconfig->index, maybe_null(interface));
 
 	service = __connman_service_lookup_from_index(ipconfig->index);
 	if (service)
-		__connman_connection_gateway_remove(service, ipconfig->type);
+		__connman_gateway_remove(service, ipconfig->type);
 }
 
 unsigned char __connman_ipconfig_get_prefixlen(struct connman_ipconfig *ipconfig)
@@ -1388,7 +1612,7 @@ void __connman_ipconfig_set_data(struct connman_ipconfig *ipconfig, void *data)
  *
  * Get interface index
  */
-int __connman_ipconfig_get_index(struct connman_ipconfig *ipconfig)
+int __connman_ipconfig_get_index(const struct connman_ipconfig *ipconfig)
 {
 	if (!ipconfig)
 		return -1;
diff --git a/src/iptables.c b/src/iptables.c
index 664b27f1..a81a0779 100644
--- a/src/iptables.c
+++ b/src/iptables.c
@@ -1259,6 +1259,14 @@ static void update_hooks(struct connman_iptables *table, GList *chain_head,
 	}
 }
 
+static bool connman_iptables_entry_is_valid(
+				const struct connman_iptables_entry *new_entry)
+{
+	return (new_entry &&
+			(((new_entry->type == AF_INET)  && new_entry->entry) ||
+			 ((new_entry->type == AF_INET6) && new_entry->entry6)));
+}
+
 static struct connman_iptables_entry *prepare_rule_inclusion(
 				struct connman_iptables *table,
 				struct iptables_ip *ip,
@@ -1283,16 +1291,8 @@ static struct connman_iptables_entry *prepare_rule_inclusion(
 
 	new_entry = new_rule(ip, target_name, xt_t, xt_rm);
 
-	switch (new_entry->type) {
-	case AF_INET:
-		if (new_entry->entry)
-			break;
-	case AF_INET6:
-		if (new_entry->entry6)
-			break;
-	default:
+	if (!connman_iptables_entry_is_valid(new_entry))
 		goto err;
-	}
 
 	update_hooks(table, chain_head, new_entry);
 
@@ -1337,17 +1337,7 @@ static int iptables_append_rule(struct connman_iptables *table,
 	new_entry = prepare_rule_inclusion(table, ip, chain_name, target_name,
 					xt_t, &builtin, xt_rm, false);
 
-	if (!new_entry)
-		return -EINVAL;
-
-	switch (new_entry->type) {
-	case AF_INET:
-		if (new_entry->entry)
-			break;
-	case AF_INET6:
-		if (new_entry->entry6)
-			break;
-	default:
+	if (!connman_iptables_entry_is_valid(new_entry)) {
 		ret = -EINVAL;
 		goto err;
 	}
@@ -1391,17 +1381,7 @@ static int iptables_insert_rule(struct connman_iptables *table,
 	new_entry = prepare_rule_inclusion(table, ip, chain_name, target_name,
 					xt_t, &builtin, xt_rm, true);
 
-	if (!new_entry)
-		return -EINVAL;
-
-	switch (new_entry->type) {
-	case AF_INET:
-		if (new_entry->entry)
-			break;
-	case AF_INET6:
-		if (new_entry->entry6)
-			break;
-	default:
+	if (!connman_iptables_entry_is_valid(new_entry)) {
 		ret = -EINVAL;
 		goto err;
 	}
diff --git a/src/log.c b/src/log.c
index 554b046b..f7483194 100644
--- a/src/log.c
+++ b/src/log.c
@@ -38,7 +38,7 @@ static const char *program_exec;
 static const char *program_path;
 
 /* This makes sure we always have a __debug section. */
-CONNMAN_DEBUG_DEFINE(dummy);
+CONNMAN_DEBUG_ALIAS(dummy);
 
 /**
  * connman_info:
diff --git a/src/main.c b/src/main.c
index ae4a450d..f5da979b 100644
--- a/src/main.c
+++ b/src/main.c
@@ -47,6 +47,7 @@
 #define DEFAULT_ONLINE_CHECK_IPV4_URL "http://ipv4.connman.net/online/status.html"
 #define DEFAULT_ONLINE_CHECK_IPV6_URL "http://ipv6.connman.net/online/status.html"
 
+#define DEFAULT_ONLINE_CHECK_CONNECT_TIMEOUT (0 * 1000)
 /*
  * We set the integer to 1 sec so that we have a chance to get
  * necessary IPv6 router advertisement messages that might have
@@ -54,11 +55,22 @@
  */
 #define DEFAULT_ONLINE_CHECK_INITIAL_INTERVAL 1
 #define DEFAULT_ONLINE_CHECK_MAX_INTERVAL 12
+
+#define DEFAULT_ONLINE_CHECK_FAILURES_THRESHOLD 6
+#define DEFAULT_ONLINE_CHECK_SUCCESSES_THRESHOLD 6
+
+#define ONLINE_CHECK_INTERVAL_STYLE_FIBONACCI "fibonacci"
+#define ONLINE_CHECK_INTERVAL_STYLE_GEOMETRIC "geometric"
+
+#define DEFAULT_ONLINE_CHECK_INTERVAL_STYLE ONLINE_CHECK_INTERVAL_STYLE_GEOMETRIC
+
 #define DEFAULT_LOCALTIME "/etc/localtime"
 
 #define MAINFILE "main.conf"
 #define CONFIGMAINFILE CONFIGDIR "/" MAINFILE
 
+#define GENERAL_GROUP "General"
+
 static char *default_auto_connect[] = {
 	"wifi",
 	"ethernet",
@@ -102,10 +114,15 @@ static struct {
 	char *vendor_class_id;
 	bool enable_online_check;
 	bool enable_online_to_ready_transition;
+	enum service_online_check_mode online_check_mode;
 	char *online_check_ipv4_url;
 	char *online_check_ipv6_url;
+	unsigned int online_check_connect_timeout_ms;
 	unsigned int online_check_initial_interval;
 	unsigned int online_check_max_interval;
+	unsigned int online_check_failures_threshold;
+	unsigned int online_check_successes_threshold;
+	char *online_check_interval_style;
 	bool auto_connect_roaming_services;
 	bool acd;
 	bool use_gateways_as_timeservers;
@@ -132,10 +149,17 @@ static struct {
 	.vendor_class_id = NULL,
 	.enable_online_check = true,
 	.enable_online_to_ready_transition = false,
+	.online_check_mode = CONNMAN_SERVICE_ONLINE_CHECK_MODE_UNKNOWN,
 	.online_check_ipv4_url = NULL,
 	.online_check_ipv6_url = NULL,
+	.online_check_connect_timeout_ms = DEFAULT_ONLINE_CHECK_CONNECT_TIMEOUT,
 	.online_check_initial_interval = DEFAULT_ONLINE_CHECK_INITIAL_INTERVAL,
 	.online_check_max_interval = DEFAULT_ONLINE_CHECK_MAX_INTERVAL,
+	.online_check_failures_threshold =
+		DEFAULT_ONLINE_CHECK_FAILURES_THRESHOLD,
+	.online_check_successes_threshold =
+		DEFAULT_ONLINE_CHECK_SUCCESSES_THRESHOLD,
+	.online_check_interval_style = NULL,
 	.auto_connect_roaming_services = false,
 	.acd = false,
 	.use_gateways_as_timeservers = false,
@@ -162,10 +186,15 @@ static struct {
 #define CONF_VENDOR_CLASS_ID            "VendorClassID"
 #define CONF_ENABLE_ONLINE_CHECK        "EnableOnlineCheck"
 #define CONF_ENABLE_ONLINE_TO_READY_TRANSITION "EnableOnlineToReadyTransition"
+#define CONF_ONLINE_CHECK_MODE          "OnlineCheckMode"
 #define CONF_ONLINE_CHECK_IPV4_URL      "OnlineCheckIPv4URL"
 #define CONF_ONLINE_CHECK_IPV6_URL      "OnlineCheckIPv6URL"
+#define CONF_ONLINE_CHECK_CONNECT_TIMEOUT "OnlineCheckConnectTimeout"
 #define CONF_ONLINE_CHECK_INITIAL_INTERVAL "OnlineCheckInitialInterval"
 #define CONF_ONLINE_CHECK_MAX_INTERVAL     "OnlineCheckMaxInterval"
+#define CONF_ONLINE_CHECK_FAILURES_THRESHOLD "OnlineCheckFailuresThreshold"
+#define CONF_ONLINE_CHECK_SUCCESSES_THRESHOLD "OnlineCheckSuccessesThreshold"
+#define CONF_ONLINE_CHECK_INTERVAL_STYLE "OnlineCheckIntervalStyle"
 #define CONF_AUTO_CONNECT_ROAMING_SERVICES "AutoConnectRoamingServices"
 #define CONF_ACD                        "AddressConflictDetection"
 #define CONF_USE_GATEWAYS_AS_TIMESERVERS "UseGatewaysAsTimeservers"
@@ -193,10 +222,15 @@ static const char *supported_options[] = {
 	CONF_VENDOR_CLASS_ID,
 	CONF_ENABLE_ONLINE_CHECK,
 	CONF_ENABLE_ONLINE_TO_READY_TRANSITION,
+	CONF_ONLINE_CHECK_MODE,
 	CONF_ONLINE_CHECK_IPV4_URL,
 	CONF_ONLINE_CHECK_IPV6_URL,
+	CONF_ONLINE_CHECK_CONNECT_TIMEOUT,
 	CONF_ONLINE_CHECK_INITIAL_INTERVAL,
 	CONF_ONLINE_CHECK_MAX_INTERVAL,
+	CONF_ONLINE_CHECK_FAILURES_THRESHOLD,
+	CONF_ONLINE_CHECK_SUCCESSES_THRESHOLD,
+	CONF_ONLINE_CHECK_INTERVAL_STYLE,
 	CONF_AUTO_CONNECT_ROAMING_SERVICES,
 	CONF_ACD,
 	CONF_USE_GATEWAYS_AS_TIMESERVERS,
@@ -289,14 +323,14 @@ static void check_config(GKeyFile *config)
 	keys = g_key_file_get_groups(config, NULL);
 
 	for (j = 0; keys && keys[j]; j++) {
-		if (g_strcmp0(keys[j], "General") != 0)
+		if (g_strcmp0(keys[j], GENERAL_GROUP) != 0)
 			connman_warn("Unknown group %s in %s",
 						keys[j], MAINFILE);
 	}
 
 	g_strfreev(keys);
 
-	keys = g_key_file_get_keys(config, "General", NULL, NULL);
+	keys = g_key_file_get_keys(config, GENERAL_GROUP, NULL, NULL);
 
 	for (j = 0; keys && keys[j]; j++) {
 		bool found;
@@ -317,6 +351,74 @@ static void check_config(GKeyFile *config)
 	g_strfreev(keys);
 }
 
+static void online_check_mode_set_from_deprecated(void)
+{
+	connman_settings.online_check_mode =
+		connman_settings.enable_online_check ?
+		connman_settings.enable_online_to_ready_transition ?
+			CONNMAN_SERVICE_ONLINE_CHECK_MODE_CONTINUOUS :
+			CONNMAN_SERVICE_ONLINE_CHECK_MODE_ONE_SHOT :
+		CONNMAN_SERVICE_ONLINE_CHECK_MODE_NONE;
+}
+
+static void online_check_mode_set_to_deprecated(void)
+{
+	switch (connman_settings.online_check_mode) {
+	case CONNMAN_SERVICE_ONLINE_CHECK_MODE_NONE:
+		connman_settings.enable_online_check = false;
+		connman_settings.enable_online_to_ready_transition = false;
+		break;
+	case CONNMAN_SERVICE_ONLINE_CHECK_MODE_ONE_SHOT:
+		connman_settings.enable_online_check = true;
+		connman_settings.enable_online_to_ready_transition = false;
+		break;
+	case CONNMAN_SERVICE_ONLINE_CHECK_MODE_CONTINUOUS:
+		connman_settings.enable_online_check = true;
+		connman_settings.enable_online_to_ready_transition = true;
+		break;
+	default:
+		break;
+	}
+}
+
+static void online_check_settings_log(void)
+{
+	connman_info("Online check mode \"%s\"",
+				 __connman_service_online_check_mode2string(
+					connman_settings.online_check_mode));
+
+	if (connman_settings.online_check_mode ==
+			CONNMAN_SERVICE_ONLINE_CHECK_MODE_NONE)
+		return;
+
+	connman_info("Online check IPv4 URL \"%s\"",
+		connman_settings.online_check_ipv4_url);
+
+	connman_info("Online check IPv6 URL \"%s\"",
+		connman_settings.online_check_ipv6_url);
+
+	connman_info("Online check interval style \"%s\"",
+		connman_settings.online_check_interval_style);
+
+	connman_info("Online check interval range [%u, %u]",
+		connman_settings.online_check_initial_interval,
+		connman_settings.online_check_max_interval);
+
+	if (connman_settings.online_check_connect_timeout_ms)
+		connman_info("Online check connect timeout %u ms",
+			connman_settings.online_check_connect_timeout_ms);
+
+	if (connman_settings.online_check_mode !=
+			CONNMAN_SERVICE_ONLINE_CHECK_MODE_CONTINUOUS)
+		return;
+
+	connman_info("Online check continuous mode failures threshold %d",
+		connman_settings.online_check_failures_threshold);
+
+	connman_info("Online check continuous mode successes threshold %d",
+		connman_settings.online_check_successes_threshold);
+}
+
 static void parse_config(GKeyFile *config)
 {
 	GError *error = NULL;
@@ -328,6 +430,7 @@ static void parse_config(GKeyFile *config)
 	char *string;
 	gsize len;
 	int integer;
+	double real;
 
 	if (!config) {
 		connman_settings.auto_connect =
@@ -342,26 +445,28 @@ static void parse_config(GKeyFile *config)
 			g_strdup(DEFAULT_ONLINE_CHECK_IPV4_URL);
 		connman_settings.online_check_ipv6_url =
 			g_strdup(DEFAULT_ONLINE_CHECK_IPV6_URL);
+		connman_settings.online_check_interval_style =
+			g_strdup(DEFAULT_ONLINE_CHECK_INTERVAL_STYLE);
 		return;
 	}
 
 	DBG("parsing %s", MAINFILE);
 
-	boolean = g_key_file_get_boolean(config, "General",
+	boolean = g_key_file_get_boolean(config, GENERAL_GROUP,
 						CONF_BG_SCAN, &error);
 	if (!error)
 		connman_settings.bg_scan = boolean;
 
 	g_clear_error(&error);
 
-	timeservers = __connman_config_get_string_list(config, "General",
+	timeservers = __connman_config_get_string_list(config, GENERAL_GROUP,
 					CONF_PREF_TIMESERVERS, NULL, &error);
 	if (!error)
 		connman_settings.pref_timeservers = timeservers;
 
 	g_clear_error(&error);
 
-	str_list = __connman_config_get_string_list(config, "General",
+	str_list = __connman_config_get_string_list(config, GENERAL_GROUP,
 			CONF_AUTO_CONNECT_TECHS, &len, &error);
 
 	if (!error)
@@ -375,7 +480,7 @@ static void parse_config(GKeyFile *config)
 
 	g_clear_error(&error);
 
-	str_list = __connman_config_get_string_list(config, "General",
+	str_list = __connman_config_get_string_list(config, GENERAL_GROUP,
 			CONF_FAVORITE_TECHS, &len, &error);
 
 	if (!error)
@@ -389,7 +494,7 @@ static void parse_config(GKeyFile *config)
 
 	g_clear_error(&error);
 
-	str_list = __connman_config_get_string_list(config, "General",
+	str_list = __connman_config_get_string_list(config, GENERAL_GROUP,
 			CONF_PREFERRED_TECHS, &len, &error);
 
 	if (!error)
@@ -400,7 +505,7 @@ static void parse_config(GKeyFile *config)
 
 	g_clear_error(&error);
 
-	str_list = __connman_config_get_string_list(config, "General",
+	str_list = __connman_config_get_string_list(config, GENERAL_GROUP,
 			CONF_ALWAYS_CONNECTED_TECHS, &len, &error);
 
 	if (!error)
@@ -411,7 +516,7 @@ static void parse_config(GKeyFile *config)
 
 	g_clear_error(&error);
 
-	str_list = __connman_config_get_string_list(config, "General",
+	str_list = __connman_config_get_string_list(config, GENERAL_GROUP,
 			CONF_FALLBACK_NAMESERVERS, &len, &error);
 
 	if (!error)
@@ -422,21 +527,21 @@ static void parse_config(GKeyFile *config)
 
 	g_clear_error(&error);
 
-	integer = g_key_file_get_integer(config, "General",
+	integer = g_key_file_get_integer(config, GENERAL_GROUP,
 			CONF_TIMEOUT_INPUTREQ, &error);
 	if (!error && integer >= 0)
 		connman_settings.timeout_inputreq = integer * 1000;
 
 	g_clear_error(&error);
 
-	integer = g_key_file_get_integer(config, "General",
+	integer = g_key_file_get_integer(config, GENERAL_GROUP,
 			CONF_TIMEOUT_BROWSERLAUNCH, &error);
 	if (!error && integer >= 0)
 		connman_settings.timeout_browserlaunch = integer * 1000;
 
 	g_clear_error(&error);
 
-	interfaces = __connman_config_get_string_list(config, "General",
+	interfaces = __connman_config_get_string_list(config, GENERAL_GROUP,
 			CONF_BLACKLISTED_INTERFACES, &len, &error);
 
 	if (!error)
@@ -447,7 +552,7 @@ static void parse_config(GKeyFile *config)
 
 	g_clear_error(&error);
 
-	boolean = __connman_config_get_bool(config, "General",
+	boolean = __connman_config_get_bool(config, GENERAL_GROUP,
 					CONF_ALLOW_HOSTNAME_UPDATES,
 					&error);
 	if (!error)
@@ -455,7 +560,7 @@ static void parse_config(GKeyFile *config)
 
 	g_clear_error(&error);
 
-	boolean = __connman_config_get_bool(config, "General",
+	boolean = __connman_config_get_bool(config, GENERAL_GROUP,
 					CONF_ALLOW_DOMAINNAME_UPDATES,
 					&error);
 	if (!error)
@@ -463,14 +568,14 @@ static void parse_config(GKeyFile *config)
 
 	g_clear_error(&error);
 
-	boolean = __connman_config_get_bool(config, "General",
+	boolean = __connman_config_get_bool(config, GENERAL_GROUP,
 			CONF_SINGLE_TECH, &error);
 	if (!error)
 		connman_settings.single_tech = boolean;
 
 	g_clear_error(&error);
 
-	tethering = __connman_config_get_string_list(config, "General",
+	tethering = __connman_config_get_string_list(config, GENERAL_GROUP,
 			CONF_TETHERING_TECHNOLOGIES, &len, &error);
 
 	if (!error)
@@ -478,7 +583,7 @@ static void parse_config(GKeyFile *config)
 
 	g_clear_error(&error);
 
-	boolean = __connman_config_get_bool(config, "General",
+	boolean = __connman_config_get_bool(config, GENERAL_GROUP,
 					CONF_PERSISTENT_TETHERING_MODE,
 					&error);
 	if (!error)
@@ -486,39 +591,88 @@ static void parse_config(GKeyFile *config)
 
 	g_clear_error(&error);
 
-	boolean = __connman_config_get_bool(config, "General",
+	boolean = __connman_config_get_bool(config, GENERAL_GROUP,
 					CONF_ENABLE_6TO4, &error);
 	if (!error)
 		connman_settings.enable_6to4 = boolean;
 
 	g_clear_error(&error);
 
-	string = __connman_config_get_string(config, "General",
+	string = __connman_config_get_string(config, GENERAL_GROUP,
 					CONF_VENDOR_CLASS_ID, &error);
 	if (!error)
 		connman_settings.vendor_class_id = string;
 
 	g_clear_error(&error);
 
-	boolean = __connman_config_get_bool(config, "General",
+	/* EnableOnlineCheck */
+
+	boolean = __connman_config_get_bool(config, GENERAL_GROUP,
 					CONF_ENABLE_ONLINE_CHECK, &error);
 	if (!error) {
+		connman_warn("\"%s\" is deprecated; use \"%s\" instead.",
+			CONF_ENABLE_ONLINE_CHECK,
+			CONF_ONLINE_CHECK_MODE);
+
 		connman_settings.enable_online_check = boolean;
-		if (!boolean)
-			connman_info("Online check disabled by main config.");
 	}
 
 	g_clear_error(&error);
 
-	boolean = __connman_config_get_bool(config, "General",
+	/* EnableOnlineToReadyTransition */
+
+	boolean = __connman_config_get_bool(config, GENERAL_GROUP,
 			CONF_ENABLE_ONLINE_TO_READY_TRANSITION, &error);
 	if (!error) {
+		connman_warn("\"%s\" is deprecated; use \"%s\" instead.",
+			CONF_ENABLE_ONLINE_TO_READY_TRANSITION,
+			CONF_ONLINE_CHECK_MODE);
+
 		connman_settings.enable_online_to_ready_transition = boolean;
 	}
 
 	g_clear_error(&error);
 
-	string = __connman_config_get_string(config, "General",
+	/* OnlineCheckMode */
+
+	string = __connman_config_get_string(config, GENERAL_GROUP,
+				CONF_ONLINE_CHECK_MODE, &error);
+	if (!error) {
+		connman_settings.online_check_mode =
+			__connman_service_online_check_string2mode(string);
+		if (connman_settings.online_check_mode ==
+			CONNMAN_SERVICE_ONLINE_CHECK_MODE_UNKNOWN) {
+			connman_error("Invalid online check mode \"%s\"",
+				string);
+
+			online_check_mode_set_from_deprecated();
+		} else
+			online_check_mode_set_to_deprecated();
+	} else
+		online_check_mode_set_from_deprecated();
+
+	g_clear_error(&error);
+
+	/* OnlineCheckConnectTimeout */
+
+	real = g_key_file_get_double(config, GENERAL_GROUP,
+			CONF_ONLINE_CHECK_CONNECT_TIMEOUT, &error);
+	if (!error) {
+		if (real < 0) {
+			connman_warn("Incorrect online check connect timeout %f",
+				real);
+			connman_settings.online_check_connect_timeout_ms =
+				DEFAULT_ONLINE_CHECK_CONNECT_TIMEOUT;
+		} else
+			connman_settings.online_check_connect_timeout_ms =
+				real * 1000;
+	}
+
+	g_clear_error(&error);
+
+	/* OnlineCheckIPv4URL */
+
+	string = __connman_config_get_string(config, GENERAL_GROUP,
 					CONF_ONLINE_CHECK_IPV4_URL, &error);
 	if (!error)
 		connman_settings.online_check_ipv4_url = string;
@@ -528,7 +682,9 @@ static void parse_config(GKeyFile *config)
 
 	g_clear_error(&error);
 
-	string = __connman_config_get_string(config, "General",
+	/* OnlineCheckIPv6URL */
+
+	string = __connman_config_get_string(config, GENERAL_GROUP,
 					CONF_ONLINE_CHECK_IPV6_URL, &error);
 	if (!error)
 		connman_settings.online_check_ipv6_url = string;
@@ -536,17 +692,18 @@ static void parse_config(GKeyFile *config)
 		connman_settings.online_check_ipv6_url =
 			g_strdup(DEFAULT_ONLINE_CHECK_IPV6_URL);
 
-
 	g_clear_error(&error);
 
-	integer = g_key_file_get_integer(config, "General",
+	/* OnlineCheck{Initial,Max}Interval */
+
+	integer = g_key_file_get_integer(config, GENERAL_GROUP,
 			CONF_ONLINE_CHECK_INITIAL_INTERVAL, &error);
 	if (!error && integer >= 0)
 		connman_settings.online_check_initial_interval = integer;
 
 	g_clear_error(&error);
 
-	integer = g_key_file_get_integer(config, "General",
+	integer = g_key_file_get_integer(config, GENERAL_GROUP,
 			CONF_ONLINE_CHECK_MAX_INTERVAL, &error);
 	if (!error && integer >= 0)
 		connman_settings.online_check_max_interval = integer;
@@ -565,27 +722,80 @@ static void parse_config(GKeyFile *config)
 			DEFAULT_ONLINE_CHECK_MAX_INTERVAL;
 	}
 
-	boolean = __connman_config_get_bool(config, "General",
+	/* OnlineCheckFailuresThreshold */
+
+	integer = g_key_file_get_integer(config, GENERAL_GROUP,
+			CONF_ONLINE_CHECK_FAILURES_THRESHOLD, &error);
+	if (!error && integer >= 0)
+		connman_settings.online_check_failures_threshold = integer;
+
+	if (connman_settings.online_check_failures_threshold < 1) {
+		connman_warn("Incorrect online check failures threshold [%d]",
+			connman_settings.online_check_failures_threshold);
+		connman_settings.online_check_failures_threshold =
+			DEFAULT_ONLINE_CHECK_FAILURES_THRESHOLD;
+	}
+
+	g_clear_error(&error);
+
+	/* OnlineCheckSuccessesThreshold */
+
+	integer = g_key_file_get_integer(config, GENERAL_GROUP,
+			CONF_ONLINE_CHECK_SUCCESSES_THRESHOLD, &error);
+	if (!error && integer >= 0)
+		connman_settings.online_check_successes_threshold = integer;
+
+	if (connman_settings.online_check_successes_threshold < 1) {
+		connman_warn("Incorrect online check successes threshold [%d]",
+			connman_settings.online_check_successes_threshold);
+		connman_settings.online_check_successes_threshold =
+			DEFAULT_ONLINE_CHECK_SUCCESSES_THRESHOLD;
+	}
+
+	g_clear_error(&error);
+
+	/* OnlineCheckIntervalStyle */
+
+	string = __connman_config_get_string(config, GENERAL_GROUP,
+					CONF_ONLINE_CHECK_INTERVAL_STYLE, &error);
+	if (!error) {
+		if ((g_strcmp0(string, ONLINE_CHECK_INTERVAL_STYLE_FIBONACCI) == 0) ||
+			(g_strcmp0(string, ONLINE_CHECK_INTERVAL_STYLE_GEOMETRIC) == 0)) {
+			connman_settings.online_check_interval_style = string;
+		} else {
+			connman_warn("Incorrect online check interval style [%s]",
+				string);
+			connman_settings.online_check_interval_style =
+				g_strdup(DEFAULT_ONLINE_CHECK_INTERVAL_STYLE);
+		}
+	} else
+		connman_settings.online_check_interval_style =
+			g_strdup(DEFAULT_ONLINE_CHECK_INTERVAL_STYLE);
+
+	g_clear_error(&error);
+
+	boolean = __connman_config_get_bool(config, GENERAL_GROUP,
 				CONF_AUTO_CONNECT_ROAMING_SERVICES, &error);
 	if (!error)
 		connman_settings.auto_connect_roaming_services = boolean;
 
 	g_clear_error(&error);
 
-	boolean = __connman_config_get_bool(config, "General", CONF_ACD, &error);
+	boolean = __connman_config_get_bool(config, GENERAL_GROUP,
+				CONF_ACD, &error);
 	if (!error)
 		connman_settings.acd = boolean;
 
 	g_clear_error(&error);
 
-	boolean = __connman_config_get_bool(config, "General",
+	boolean = __connman_config_get_bool(config, GENERAL_GROUP,
 				CONF_USE_GATEWAYS_AS_TIMESERVERS, &error);
 	if (!error)
 		connman_settings.use_gateways_as_timeservers = boolean;
 
 	g_clear_error(&error);
 
-	string = __connman_config_get_string(config, "General",
+	string = __connman_config_get_string(config, GENERAL_GROUP,
 				CONF_LOCALTIME, &error);
 	if (!error)
 		connman_settings.localtime = string;
@@ -594,12 +804,14 @@ static void parse_config(GKeyFile *config)
 
 	g_clear_error(&error);
 
-	boolean = __connman_config_get_bool(config, "General",
+	boolean = __connman_config_get_bool(config, GENERAL_GROUP,
 				CONF_REGDOM_FOLLOWS_TIMEZONE, &error);
 	if (!error)
 		connman_settings.regdom_follows_timezone = boolean;
 
-	string = __connman_config_get_string(config, "General",
+	g_clear_error(&error);
+
+	string = __connman_config_get_string(config, GENERAL_GROUP,
 				CONF_RESOLV_CONF, &error);
 	if (!error)
 		connman_settings.resolv_conf = string;
@@ -607,6 +819,8 @@ static void parse_config(GKeyFile *config)
 		g_free(string);
 
 	g_clear_error(&error);
+
+	online_check_settings_log();
 }
 
 static int config_init(const char *file)
@@ -801,6 +1015,12 @@ char *connman_setting_get_string(const char *key)
 		return connman_settings.localtime ?
 			connman_settings.localtime : DEFAULT_LOCALTIME;
 
+	if (g_str_equal(key, CONF_RESOLV_CONF))
+		return connman_settings.resolv_conf;
+
+	if (g_str_equal(key, CONF_ONLINE_CHECK_INTERVAL_STYLE))
+		return connman_settings.online_check_interval_style;
+
 	return NULL;
 }
 
@@ -842,20 +1062,29 @@ bool connman_setting_get_bool(const char *key)
 	if (g_str_equal(key, CONF_REGDOM_FOLLOWS_TIMEZONE))
 		return connman_settings.regdom_follows_timezone;
 
-	if (g_str_equal(key, CONF_RESOLV_CONF))
-		return connman_settings.resolv_conf;
-
 	return false;
 }
 
 unsigned int connman_setting_get_uint(const char *key)
 {
+	if (g_str_equal(key, CONF_ONLINE_CHECK_CONNECT_TIMEOUT))
+		return connman_settings.online_check_connect_timeout_ms;
+
 	if (g_str_equal(key, CONF_ONLINE_CHECK_INITIAL_INTERVAL))
 		return connman_settings.online_check_initial_interval;
 
 	if (g_str_equal(key, CONF_ONLINE_CHECK_MAX_INTERVAL))
 		return connman_settings.online_check_max_interval;
 
+	if (g_str_equal(key, CONF_ONLINE_CHECK_MODE))
+		return connman_settings.online_check_mode;
+
+	if (g_str_equal(key, CONF_ONLINE_CHECK_FAILURES_THRESHOLD))
+		return connman_settings.online_check_failures_threshold;
+
+	if (g_str_equal(key, CONF_ONLINE_CHECK_SUCCESSES_THRESHOLD))
+		return connman_settings.online_check_successes_threshold;
+
 	return 0;
 }
 
@@ -1002,7 +1231,7 @@ int main(int argc, char *argv[])
 	__connman_detect_init();
 	__connman_session_init();
 	__connman_timeserver_init();
-	__connman_connection_init();
+	__connman_gateway_init();
 
 	__connman_plugin_init(option_plugin, option_noplugin);
 
@@ -1033,7 +1262,7 @@ int main(int argc, char *argv[])
 	__connman_session_cleanup();
 	__connman_plugin_cleanup();
 	__connman_provider_cleanup();
-	__connman_connection_cleanup();
+	__connman_gateway_cleanup();
 	__connman_timeserver_cleanup();
 	__connman_detect_cleanup();
 	__connman_proxy_cleanup();
diff --git a/src/main.conf b/src/main.conf
index ddd57996..5357edb8 100644
--- a/src/main.conf
+++ b/src/main.conf
@@ -116,11 +116,51 @@
 # section 4.1).
 # Enable6to4 = false
 
-# Enable use of http get as on online status check.
-# When a service is in a READY state, and is selected as default,
-# ConnMan will issue an HTTP GET request to verify that end-to-end
-# connectivity is successful. Only then the service will be
-# transitioned to ONLINE state.
+# This indicates the "online" HTTP-based Internet reachability check
+# mode. Possible values are "none", "one-shot", "continuous".
+#
+# In "none" mode, there are no "online" HTTP-based Internet
+# reachability checks. Any connected service and the manager state
+# will terminate at the "ready" state and will not progress to
+# "online".
+#
+# In "one-shot" mode, there is a single, one-shot "online" HTTP-based
+# Internet reachability check for the default service. When the check
+# succeeds, the associated service and the manager state will
+# terminate at the "online" state. When the check fails, subsequent
+# checks will be rescheduled according to "OnlineCheckIntervalStyle",
+# "OnlineCheckInitialInterval", and "OnlineCheckMaxInterval" and will
+# continue indefinitely until one succeeds or until the service is
+# disconnected.
+#
+# In "continuous" mode, there are ongoing "online" HTTP-based Internet
+# reachability check for the default service. As with "one-shot" mode,
+# when the first check succeeds, the associated service and the
+# manager state will terminate at the "online" state. Thereafter,
+# subsequent checks will be scheduled according to
+# "OnlineCheckIntervalStyle" and "OnlineCheckMaxInterval". When the
+# check fails, subsequent checks will be rescheduled according to
+# "OnlineCheckIntervalStyle", "OnlineCheckInitialInterval", and
+# "OnlineCheckMaxInterval". When and if "OnlineCheckFailuresThreshold"
+# is met, the service and manager state will be demoted to "ready" and
+# the service will have its "Error" property set to
+# "online-check-failed" while subsequent checks will continue. In the
+# interim, if available, another service may be promoted to the
+# default service and online checks will be initiated for it. When and
+# if, for the demoted service, "OnlineCheckSuccessesThreshold" is met,
+# the service "Error" property will be cleared and the service state
+# promoted to "online", potentially causing it to become the default
+# service again.
+# Default value is "one-shot".
+# OnlineCheckMode = one-shot
+
+# NOTE: This setting is deprecated; use "OnlineCheckMode" instead with
+# a value of "one-shot" or "none".
+# Enable the use of "online" HTTP-baesd Internet reachability check as
+# an online status check.  When a service is in a READY state, and is
+# selected as default, ConnMan will issue an HTTP GET request to
+# verify that end-to-end connectivity is successful. Only then the
+# service will be transitioned to ONLINE state.
 # If this setting is false, the default service will remain in READY state.
 # Default value is true.
 # EnableOnlineCheck = false
@@ -132,24 +172,100 @@
 # OnlineCheckIPv4URL= http://ipv4.connman.net/online/status.html
 # OnlineCheckIPv6URL= http://ipv6.connman.net/online/status.html
 
+# The time, in decimal seconds (for example, 12.3), to wait for a
+# successful TCP connection to the host associated with
+# "OnlineCheckIPv4URL" or "OnlineCheckIPv6URL". Connections that take
+# longer than "OnlineCheckConnectTimeout" will be aborted. The default
+# value is zero ('0') which indicates that no explicit connection
+# timeout will be used, leaving the timeout to the underlying operating
+# system and network stack.
+# OnlineCheckConnectTimeout=0
+
 # Range of intervals between two online check requests.
 # Please refer to the README for more detailed information.
 # Default values are 1 and 12 respectively.
 # OnlineCheckInitialInterval = 1
 # OnlineCheckMaxInterval = 12
 
-# WARNING: Experimental feature!!!
-# In addition to EnableOnlineCheck setting, enable or disable use of HTTP GET
-# to detect the loss of end-to-end connectivity.
-# If this setting is false, when the default service transitions to ONLINE
-# state, the HTTP GET request is no more called until next cycle, initiated
-# by a transition of the default service to DISCONNECT state.
-# If this setting is true, the HTTP GET request keeps beeing called to guarantee
-# that end-to-end connectivity is still successful. If not, the default service
-# will transition to READY state, enabling another service to become the
-# default one, in replacement.
+# NOTE: This setting is deprecated; use "OnlineCheckMode" instead with
+# a value of "continuous" or "none".
+# In addition to the "EnableOnlineCheck" setting, enable or disable
+# continuous use of "online" HTTP-based Internet reachability checks
+# to detect the loss of end-to-end connectivity.
+# If this setting is false, when the default service transitions to
+# ONLINE state, the "online" HTTP-based Internet reachability check is
+# terminated until a transition of the default service to DISCONNECT
+# state.
+# If this setting is true, the "online" HTTP-based Internet
+# reachability checks continue to be rescheduled to guarantee that
+# end-to-end connectivity is still successful. If not, the default
+# service will transition to READY state, enabling another service to
+# become the default one, in replacement.
 # EnableOnlineToReadyTransition = false
 
+# When both "EnableOnlineCheck" and "EnableOnlineToReadyTransition"
+# are asserted or "OnlineCheckMode" is "continuous", this is the
+# number of failed back-to-back "ready" to "online" HTTP-based
+# Internet reachability checks that will be allowed before marking a
+# service as "failed" from a reachability perspective, sorting it at a
+# lower priority than other services not so marked.
+#
+# Lower values may result in higher-frequency network service cycling
+# while higher values may result in a longer period of time before
+# failing from a non-Internet reachable service to one that might be.
+#
+# See "OnlineCheckIntervalStyle", "OnlineCheckInitialInterval", and
+# "OnlineCheckMaxInterval" for other values that influence network
+# service failure/recovery transition time.
+#
+# Default value is 6.
+# OnlineCheckFailuresThreshold=6
+
+# When both "EnableOnlineCheck" and "EnableOnlineToReadyTransition"
+# are asserted or "OnlineCheckMode" is "continuous", this is the
+# number of successful back-to-back "ready" to "online" HTTP-based
+# Internet reachability checks that must be met before clearing a
+# service as "failed" from a reachability perspective and allowing it
+# to transition to the "online" state again, allowing it to sort back
+# to a higher priority relative to other network services.
+#
+# Lower values may result in higher-frequency network service cycling
+# while higher values may result in a longer period of time before
+# transitioning back to more a preferred, Internet reachable network
+# service.
+#
+# See "OnlineCheckIntervalStyle", "OnlineCheckInitialInterval", and
+# "OnlineCheckMaxInterval" for other values that influence network
+# service failure/recovery transition time.
+#
+# Default value is 6.
+# OnlineCheckSuccessesThreshold=6
+
+# The style or mathematical series function used to compute the actual
+# time, in seconds, between two "ready" to "online" HTTP-based Internet
+# reachability checks. The value of which may be either "geometric" or
+# "fibonacci".
+#
+# The "geometric" style or function simply takes the square of the
+# online check interval. For example, at a check interval of 6, the
+# time, in seconds, is 36 (6^2) seconds.
+#
+# The "fibonacci" style or function takes the value of the Fibonacci
+# sequence at the online check interval. For example, at a check
+# interval of 6, the time, in seconds, is 8 seconds.
+#
+# "fibonacci" is more aggressive in check rate up to 12 steps (its
+# equivalence point with "geometric" at 144 seconds) than "geometric"
+# and yields quicker recovery for transient failures. For example, for
+# an "OnlineCheckSuccessesThreshold" of six (6), "fibonacci" gets the
+# failing service back to "online" in 20 seconds versus 91 seconds for
+# "geometric". By comparison, past 12 steps, "fibonacci" backs off far
+# more aggressively, which is less wasteful, particularly for a
+# metered interface like Cellular, when the failures are more enduring.
+#
+# Default value is "geometric".
+# OnlineCheckIntervalStyle=geometric
+
 # List of technologies with AutoConnect = true which are always connected
 # regardless of PreferredTechnologies setting. Default value is empty and
 # will connect a technology only if it is at a higher preference than any
diff --git a/src/network.c b/src/network.c
index e3e02d16..416a7e74 100644
--- a/src/network.c
+++ b/src/network.c
@@ -87,7 +87,6 @@ struct connman_network {
 		void *ssid;
 		int ssid_len;
 		char *mode;
-		unsigned short channel;
 		char *security;
 		char *passphrase;
 		char *eap;
@@ -1023,7 +1022,7 @@ static void set_disconnected(struct connman_network *network)
 					CONNMAN_IPCONFIG_TYPE_IPV6);
 
 	if (network->connected) {
-		__connman_connection_gateway_remove(service,
+		__connman_gateway_remove(service,
 						CONNMAN_IPCONFIG_TYPE_ALL);
 
 		__connman_ipconfig_address_unset(ipconfig_ipv4);
@@ -1334,7 +1333,7 @@ void connman_network_unref_debug(struct connman_network *network,
 	network_destruct(network);
 }
 
-const char *__connman_network_get_type(struct connman_network *network)
+const char *__connman_network_get_type(const struct connman_network *network)
 {
 	return type2string(network->type);
 }
@@ -1346,7 +1345,7 @@ const char *__connman_network_get_type(struct connman_network *network)
  * Get type of network
  */
 enum connman_network_type connman_network_get_type(
-				struct connman_network *network)
+				const struct connman_network *network)
 {
 	return network->type;
 }
@@ -1357,7 +1356,7 @@ enum connman_network_type connman_network_get_type(
  *
  * Get identifier of network
  */
-const char *connman_network_get_identifier(struct connman_network *network)
+const char *connman_network_get_identifier(const struct connman_network *network)
 {
 	return network->identifier;
 }
@@ -1404,7 +1403,7 @@ done:
  *
  * Get index number of network
  */
-int connman_network_get_index(struct connman_network *network)
+int connman_network_get_index(const struct connman_network *network)
 {
 	return network->index;
 }
@@ -2119,14 +2118,6 @@ uint16_t connman_network_get_frequency(struct connman_network *network)
 	return network->frequency;
 }
 
-int connman_network_set_wifi_channel(struct connman_network *network,
-						uint16_t channel)
-{
-	network->wifi.channel = channel;
-
-	return 0;
-}
-
 int connman_network_set_autoconnect(struct connman_network *network,
 				bool autoconnect)
 {
@@ -2142,11 +2133,6 @@ bool __connman_network_native_autoconnect(struct connman_network *network)
 	return true;
 }
 
-uint16_t connman_network_get_wifi_channel(struct connman_network *network)
-{
-	return network->wifi.channel;
-}
-
 /**
  * connman_network_set_string:
  * @network: network structure
diff --git a/src/provider.c b/src/provider.c
index e2091846..1f0ce10d 100644
--- a/src/provider.c
+++ b/src/provider.c
@@ -535,7 +535,7 @@ done:
 	provider->index = index;
 }
 
-int connman_provider_get_index(struct connman_provider *provider)
+int connman_provider_get_index(const struct connman_provider *provider)
 {
 	return provider->index;
 }
@@ -666,7 +666,7 @@ int connman_provider_set_split_routing(struct connman_provider *provider,
 	}
 
 	vpn_index = __connman_service_get_index(provider->vpn_service);
-	service_index = __connman_connection_get_vpn_phy_index(vpn_index);
+	service_index = __connman_gateway_get_vpn_phy_index(vpn_index);
 	service = __connman_service_lookup_from_index(service_index);
 	if (!service)
 		goto save;
@@ -857,7 +857,7 @@ static void provider_service_changed(struct connman_service *service,
 
 	service_index = __connman_service_get_index(service);
 
-	vpn_index = __connman_connection_get_vpn_index(service_index);
+	vpn_index = __connman_gateway_get_vpn_index(service_index);
 
 	DBG("service %p %s state %d index %d/%d", service,
 		connman_service_get_identifier(service),
diff --git a/src/proxy.c b/src/proxy.c
index e1bc420a..9e00469e 100644
--- a/src/proxy.c
+++ b/src/proxy.c
@@ -107,7 +107,9 @@ unsigned int connman_proxy_lookup(const char *interface, const char *url,
 {
 	struct proxy_lookup *lookup;
 
-	DBG("interface %s url %s", interface, url);
+	DBG("interface %s url %s service %p (%s)",
+		interface, url,
+		service, connman_service_get_identifier(service));
 
 	if (!interface)
 		return 0;
diff --git a/src/rtnl.c b/src/rtnl.c
index e8a8325e..a28370ae 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -670,7 +670,9 @@ static void process_deladdr(unsigned char family, unsigned char prefixlen,
 
 static void extract_ipv4_route(struct rtmsg *msg, int bytes, int *index,
 						struct in_addr *dst,
-						struct in_addr *gateway)
+						struct in_addr *gateway,
+						uint32_t *table_id,
+						uint32_t *metric)
 {
 	struct rtattr *attr;
 
@@ -689,13 +691,23 @@ static void extract_ipv4_route(struct rtmsg *msg, int bytes, int *index,
 			if (index)
 				*index = *((int *) RTA_DATA(attr));
 			break;
+		case RTA_TABLE:
+			if (table_id)
+				*table_id = *((uint32_t *) RTA_DATA(attr));
+			break;
+		case RTA_PRIORITY:
+			if (metric)
+				*metric = *((uint32_t *) RTA_DATA(attr));
+			break;
 		}
 	}
 }
 
 static void extract_ipv6_route(struct rtmsg *msg, int bytes, int *index,
 						struct in6_addr *dst,
-						struct in6_addr *gateway)
+						struct in6_addr *gateway,
+						uint32_t *table_id,
+						uint32_t *metric)
 {
 	struct rtattr *attr;
 
@@ -715,6 +727,14 @@ static void extract_ipv6_route(struct rtmsg *msg, int bytes, int *index,
 			if (index)
 				*index = *((int *) RTA_DATA(attr));
 			break;
+		case RTA_TABLE:
+			if (table_id)
+				*table_id = *((uint32_t *) RTA_DATA(attr));
+			break;
+		case RTA_PRIORITY:
+			if (metric)
+				*metric = *((uint32_t *) RTA_DATA(attr));
+			break;
 		}
 	}
 }
@@ -725,17 +745,23 @@ static void process_newroute(unsigned char family, unsigned char scope,
 	GSList *list;
 	char dststr[INET6_ADDRSTRLEN], gatewaystr[INET6_ADDRSTRLEN];
 	int index = -1;
+	uint32_t table_id = RT_TABLE_UNSPEC;
+	uint32_t metric = 0;
 
 	if (family == AF_INET) {
 		struct in_addr dst = { INADDR_ANY }, gateway = { INADDR_ANY };
 
-		extract_ipv4_route(msg, bytes, &index, &dst, &gateway);
+		extract_ipv4_route(msg, bytes, &index, &dst, &gateway,
+			&table_id, &metric);
 
 		inet_ntop(family, &dst, dststr, sizeof(dststr));
 		inet_ntop(family, &gateway, gatewaystr, sizeof(gatewaystr));
 
 		__connman_ipconfig_newroute(index, family, scope, dststr,
-								gatewaystr);
+							msg->rtm_dst_len,
+							gatewaystr,
+							table_id,
+							metric);
 
 		/* skip host specific routes */
 		if (scope != RT_SCOPE_UNIVERSE &&
@@ -749,13 +775,17 @@ static void process_newroute(unsigned char family, unsigned char scope,
 		struct in6_addr dst = IN6ADDR_ANY_INIT,
 				gateway = IN6ADDR_ANY_INIT;
 
-		extract_ipv6_route(msg, bytes, &index, &dst, &gateway);
+		extract_ipv6_route(msg, bytes, &index, &dst, &gateway,
+			&table_id, &metric);
 
 		inet_ntop(family, &dst, dststr, sizeof(dststr));
 		inet_ntop(family, &gateway, gatewaystr, sizeof(gatewaystr));
 
 		__connman_ipconfig_newroute(index, family, scope, dststr,
-								gatewaystr);
+							msg->rtm_dst_len,
+							gatewaystr,
+							table_id,
+							metric);
 
 		/* skip host specific routes */
 		if (scope != RT_SCOPE_UNIVERSE &&
@@ -782,17 +812,23 @@ static void process_delroute(unsigned char family, unsigned char scope,
 	GSList *list;
 	char dststr[INET6_ADDRSTRLEN], gatewaystr[INET6_ADDRSTRLEN];
 	int index = -1;
+	uint32_t table_id = RT_TABLE_UNSPEC;
+	uint32_t metric = 0;
 
 	if (family == AF_INET) {
 		struct in_addr dst = { INADDR_ANY }, gateway = { INADDR_ANY };
 
-		extract_ipv4_route(msg, bytes, &index, &dst, &gateway);
+		extract_ipv4_route(msg, bytes, &index, &dst, &gateway,
+			&table_id, &metric);
 
 		inet_ntop(family, &dst, dststr, sizeof(dststr));
 		inet_ntop(family, &gateway, gatewaystr, sizeof(gatewaystr));
 
 		__connman_ipconfig_delroute(index, family, scope, dststr,
-								gatewaystr);
+							msg->rtm_dst_len,
+							gatewaystr,
+							table_id,
+							metric);
 
 		/* skip host specific routes */
 		if (scope != RT_SCOPE_UNIVERSE &&
@@ -806,13 +842,17 @@ static void process_delroute(unsigned char family, unsigned char scope,
 		struct in6_addr dst = IN6ADDR_ANY_INIT,
 				gateway = IN6ADDR_ANY_INIT;
 
-		extract_ipv6_route(msg, bytes, &index, &dst, &gateway);
+		extract_ipv6_route(msg, bytes, &index, &dst, &gateway,
+			&table_id, &metric);
 
 		inet_ntop(family, &dst, dststr, sizeof(dststr));
 		inet_ntop(family, &gateway, gatewaystr, sizeof(gatewaystr));
 
 		__connman_ipconfig_delroute(index, family, scope, dststr,
-						gatewaystr);
+							msg->rtm_dst_len,
+							gatewaystr,
+							table_id,
+							metric);
 
 		/* skip host specific routes */
 		if (scope != RT_SCOPE_UNIVERSE &&
diff --git a/src/service.c b/src/service.c
index 06d02322..f3e022c9 100644
--- a/src/service.c
+++ b/src/service.c
@@ -45,6 +45,24 @@
 #define VPN_AUTOCONNECT_TIMEOUT_STEP 30
 #define VPN_AUTOCONNECT_TIMEOUT_ATTEMPTS_THRESHOLD 270
 
+/*
+ * There are many call sites throughout this module for these
+ * functions. These are macros to help, during debugging, to acertain
+ * where they were called from.
+ */
+
+#define DEFAULT_CHANGED() \
+	default_changed(__func__)
+
+#define SERVICE_LIST_SORT() \
+	service_list_sort(__func__)
+
+typedef guint (*online_check_timeout_compute_t)(unsigned int interval);
+typedef bool (*is_counter_threshold_met_predicate_t)(
+	const struct connman_service *service,
+	const char *counter_description,
+	unsigned int counter_threshold);
+
 static DBusConnection *connection = NULL;
 
 static GList *service_list = NULL;
@@ -53,11 +71,23 @@ static GHashTable *passphrase_requested = NULL;
 static GSList *counter_list = NULL;
 static unsigned int autoconnect_id = 0;
 static unsigned int vpn_autoconnect_id = 0;
+/**
+ *  A weak reference to the current default service (that is, has the
+ *  default route) used to compare against another service when the
+ *  default service has potentially changed.
+ *
+ *  @sa connman_service_get_default
+ *  @sa connman_service_is_default
+ *  @sa default_changed
+ *
+ */
 static struct connman_service *current_default = NULL;
 static bool services_dirty = false;
-static bool enable_online_to_ready_transition = false;
+static unsigned int online_check_connect_timeout_ms = 0;
 static unsigned int online_check_initial_interval = 0;
 static unsigned int online_check_max_interval = 0;
+static const char *online_check_timeout_interval_style = NULL;
+static online_check_timeout_compute_t online_check_timeout_compute_func = NULL;
 
 struct connman_stats {
 	bool valid;
@@ -73,6 +103,42 @@ struct connman_stats_counter {
 	struct connman_stats stats_roaming;
 };
 
+/**
+ *  IP configuration type-specific "online" HTTP-based Internet
+ *  reachability check state.
+ *
+ */
+struct online_check_state {
+	/**
+	 *  Indicates whether an online check is active and in-flight.
+	 */
+	bool active;
+
+	/**
+	 *  The current GLib main loop timer identifier.
+	 *
+	 */
+	guint timeout;
+
+	/**
+	 *  The current "online" reachability check sequence interval.
+	 *
+	 */
+	unsigned int interval;
+
+	/**
+	 *	The number of sustained, back-to-back "online" reachability
+	 *	check successes for "continuous" online check mode.
+	 */
+	unsigned int successes;
+
+	/**
+	 *	The number of sustained, back-to-back "online" reachability
+	 *	check failures for "continuous" online check mode.
+	 */
+	unsigned int failures;
+};
+
 struct connman_service {
 	int refcount;
 	char *identifier;
@@ -125,7 +191,6 @@ struct connman_service {
 	char *private_key_passphrase;
 	char *phase2;
 	DBusMessage *pending;
-	DBusMessage *provider_pending;
 	guint timeout;
 	struct connman_stats stats;
 	struct connman_stats stats_roaming;
@@ -137,10 +202,23 @@ struct connman_service {
 	char *pac;
 	bool wps;
 	bool wps_advertizing;
-	guint online_timeout_ipv4;
-	guint online_timeout_ipv6;
-	unsigned int online_check_interval_ipv4;
-	unsigned int online_check_interval_ipv6;
+
+    /**
+     *  IPv4-specific "online" reachability check state.
+     */
+	struct online_check_state online_check_state_ipv4;
+
+    /**
+     *  IPv6-specific "online" reachability check state.
+     */
+	struct online_check_state online_check_state_ipv6;
+
+    /**
+     *  Tracks whether the service has met the number of sustained,
+     *  back-to-back "online" reachability check failures for
+     *  "continuous" online check mode.
+     */
+	bool online_check_failures_met_threshold;
 	bool do_split_routing;
 	bool new_service;
 	bool hidden_service;
@@ -157,6 +235,17 @@ static struct connman_ipconfig *create_ip6config(struct connman_service *service
 static void dns_changed(struct connman_service *service);
 static void vpn_auto_connect(void);
 static void trigger_autoconnect(struct connman_service *service);
+static void service_list_sort(const char *function);
+static void complete_online_check(struct connman_service *service,
+					enum connman_ipconfig_type type,
+					bool success,
+					int err);
+static bool service_downgrade_online_state(struct connman_service *service);
+static bool connman_service_is_default(const struct connman_service *service);
+static int start_online_check_if_connected(struct connman_service *service);
+static void set_error(struct connman_service *service,
+					enum connman_service_error error);
+static void clear_error(struct connman_service *service);
 
 struct find_data {
 	const char *path;
@@ -342,6 +431,8 @@ static const char *error2string(enum connman_service_error error)
 		return "invalid-key";
 	case CONNMAN_SERVICE_ERROR_BLOCKED:
 		return "blocked";
+	case CONNMAN_SERVICE_ERROR_ONLINE_CHECK_FAILED:
+		return "online-check-failed";
 	}
 
 	return NULL;
@@ -663,7 +754,9 @@ static int service_save(struct connman_service *service)
 	const char *cst_str = NULL;
 	int err = 0;
 
-	DBG("service %p new %d", service, service->new_service);
+	DBG("service %p (%s) new %d",
+		service, connman_service_get_identifier(service),
+		service->new_service);
 
 	if (service->new_service)
 		return -ESRCH;
@@ -965,6 +1058,11 @@ static bool is_connected(enum connman_service_state state)
 	return false;
 }
 
+static bool is_online(enum connman_service_state state)
+{
+	return state == CONNMAN_SERVICE_STATE_ONLINE;
+}
+
 static bool is_idle(enum connman_service_state state)
 {
 	switch (state) {
@@ -1184,7 +1282,9 @@ int __connman_service_nameserver_append(struct connman_service *service,
 	char **nameservers;
 	int len, i;
 
-	DBG("service %p nameserver %s auto %d",	service, nameserver, is_auto);
+	DBG("service %p (%s) nameserver %s auto %d",
+		service, connman_service_get_identifier(service),
+		nameserver, is_auto);
 
 	if (!nameserver)
 		return -EINVAL;
@@ -1303,9 +1403,38 @@ void __connman_service_nameserver_clear(struct connman_service *service)
 	nameserver_add_all(service, CONNMAN_IPCONFIG_TYPE_ALL);
 }
 
-static void add_nameserver_route(int family, int index, char *nameserver,
+/**
+ *  @brief
+ *    Add an IPv4 or IPv6 host route for the specified domain name
+ *    service (DNS) server.
+ *
+ *  This attempts to add an IPv4 or IPv6 host route for the specified
+ *  domain name service (DNS) server with the specified attributes.
+ *
+ *  @param[in]  family      The address family describing the
+ *                          address pointed to by @a nameserver.
+ *  @param[in]  index       The network interface index associated
+ *                          with the output network device for
+ *                          the route.
+ *  @param[in]  nameserver  A pointer to an immutable null-terminated
+ *                          C string containing the IPv4 or IPv6
+ *                          address, in text form, of the route
+ *                          DNS server destination address.
+ *  @param[in]  gw          A pointer to an immutable null-terminated
+ *                          C string containing the IPv4 or IPv6
+ *                          address, in text form, of the route next
+ *                          hop gateway address.
+ *
+ *  @sa del_nameserver_route
+ *  @sa nameserver_add_routes
+ *
+ */
+static void add_nameserver_route(int family, int index, const char *nameserver,
 				const char *gw)
 {
+	DBG("family %d index %d nameserver %s gw %s",
+		family, index, nameserver, gw);
+
 	switch (family) {
 	case AF_INET:
 		if (connman_inet_compare_subnet(index, nameserver))
@@ -1325,6 +1454,92 @@ static void add_nameserver_route(int family, int index, char *nameserver,
 	}
 }
 
+/**
+ *  @brief
+ *    Delete an IPv4 or IPv6 host route for the specified domain name
+ *    service (DNS) server.
+ *
+ *  This attempts to delete an IPv4 or IPv6 host route for the
+ *  specified domain name service (DNS) server with the specified
+ *  attributes.
+ *
+ *  @param[in]  family      The address family describing the
+ *                          address pointed to by @a nameserver.
+ *  @param[in]  index       The network interface index associated
+ *                          with the output network device for
+ *                          the route.
+ *  @param[in]  nameserver  A pointer to an immutable null-terminated
+ *                          C string containing the IPv4 or IPv6
+ *                          address, in text form, of the route
+ *                          DNS server destination address.
+ *  @param[in]  gw          A pointer to an immutable null-terminated
+ *                          C string containing the IPv4 or IPv6
+ *                          address, in text form, of the route next
+ *                          hop gateway address.
+ *
+ *  @sa add_nameserver_route
+ *  @sa nameserver_del_routes
+ *
+ */
+static void del_nameserver_route(int family, int index, const char *nameserver,
+				const char *gw,
+				enum connman_ipconfig_type type)
+{
+	DBG("family %d index %d nameserver %s gw %s",
+		family, index, nameserver, gw);
+
+	switch (family) {
+	case AF_INET:
+		if (type != CONNMAN_IPCONFIG_TYPE_IPV4 &&
+			type != CONNMAN_IPCONFIG_TYPE_ALL)
+			break;
+
+		if (connman_inet_compare_subnet(index, nameserver))
+			break;
+
+		if (connman_inet_del_host_route(index, nameserver, gw) < 0)
+			/* For P-t-P link the above route del will fail */
+			connman_inet_del_host_route(index, nameserver, NULL);
+		break;
+
+	case AF_INET6:
+		if (type != CONNMAN_IPCONFIG_TYPE_IPV6 &&
+			type != CONNMAN_IPCONFIG_TYPE_ALL)
+			break;
+
+		if (connman_inet_del_ipv6_host_route(index, nameserver,
+								gw) < 0)
+			connman_inet_del_ipv6_host_route(index, nameserver,
+							NULL);
+		break;
+	}
+}
+
+/**
+ *  @brief
+ *    Add IPv4 or IPv6 host routes for the specified domain name
+ *    service (DNS) servers.
+ *
+ *  This attempts to add IPv4 or IPv6 host routes for the specified
+ *  domain name service (DNS) servers with the specified attributes.
+ *
+ *  @param[in]  index        The network interface index associated
+ *                           with the output network device for
+ *                           the route.
+ *  @param[in]  nameservers  A pointer to a null-terminated array of
+ *                           mutable null-terminated C strings
+ *                           containing the IPv4 or IPv6 addresses, in
+ *                           text form, of the route DNS server
+ *                           destination addresses.
+ *  @param[in]  gw           A pointer to an immutable null-terminated
+ *                           C string containing the IPv4 or IPv6
+ *                           address, in text form, of the route next
+ *                           hop gateway address.
+ *
+ *  @sa add_nameserver_route
+ *  @sa nameserver_del_routes
+ *
+ */
 static void nameserver_add_routes(int index, char **nameservers,
 					const char *gw)
 {
@@ -1343,141 +1558,2451 @@ static void nameserver_add_routes(int index, char **nameservers,
 	}
 }
 
+/**
+ *  @brief
+ *    Delete IPv4 or IPv6 host routes for the specified domain name
+ *    service (DNS) servers.
+ *
+ *  This attempts to delete IPv4 or IPv6 host routes for the specified
+ *  domain name service (DNS) servers with the specified attributes.
+ *
+ *  @param[in]  index        The network interface index associated
+ *                           with the output network device for
+ *                           the route.
+ *  @param[in]  nameservers  A pointer to a null-terminated array of
+ *                           mutable null-terminated C strings
+ *                           containing the IPv4 or IPv6 addresses, in
+ *                           text form, of the route DNS server
+ *                           destination addresses.
+ *  @param[in]  gw           A pointer to an immutable null-terminated
+ *                           C string containing the IPv4 or IPv6
+ *                           address, in text form, of the route next
+ *                           hop gateway address.
+ *
+ *  @sa del_nameserver_route
+ *  @sa nameserver_add_routes
+ *
+ */
 static void nameserver_del_routes(int index, char **nameservers,
+				const char *gw,
 				enum connman_ipconfig_type type)
 {
-	int i, family;
+	int i, ns_family, gw_family;
+
+	gw_family = connman_inet_check_ipaddress(gw);
+	if (gw_family < 0)
+		return;
 
 	for (i = 0; nameservers[i]; i++) {
-		family = connman_inet_check_ipaddress(nameservers[i]);
-		if (family < 0)
+		ns_family = connman_inet_check_ipaddress(nameservers[i]);
+		if (ns_family < 0 || ns_family != gw_family)
 			continue;
 
-		switch (family) {
-		case AF_INET:
-			if (type != CONNMAN_IPCONFIG_TYPE_IPV6)
-				connman_inet_del_host_route(index,
-							nameservers[i]);
-			break;
-		case AF_INET6:
-			if (type != CONNMAN_IPCONFIG_TYPE_IPV4)
-				connman_inet_del_ipv6_host_route(index,
-							nameservers[i]);
-			break;
-		}
+		del_nameserver_route(ns_family, index, nameservers[i],
+			gw, type);
+	}
+}
+
+/**
+ *  @brief
+ *    Add IPv4 or IPv6 host routes for the domain name service (DNS)
+ *    servers associated with the specified service.
+ *
+ *  This attempts to add IPv4 or IPv6 host routes for both the
+ *  automatic and configured domain name service (DNS) servers
+ *  associated with the specified network service.
+ *
+ *  @param[in]  service      A pointer to the immutable network
+ *                           service for which to add DNS server host
+ *                           routes.
+ *  @param[in]  gw           A pointer to an immutable null-terminated
+ *                           C string containing the IPv4 or IPv6
+ *                           address, in text form, of the route next
+ *                           hop gateway address.
+ *
+ *  @sa __connman_service_nameserver_del_routes
+ *  @sa nameserver_add_routes
+ *
+ */
+void __connman_service_nameserver_add_routes(
+					const struct connman_service *service,
+					const char *gw)
+{
+	int index;
+
+	if (!service)
+		return;
+
+	index = __connman_service_get_index(service);
+
+	if (service->nameservers_config) {
+		/*
+		 * Configured nameserver takes preference over the
+		 * discoverd nameserver gathered from DHCP, VPN, etc.
+		 */
+		nameserver_add_routes(index, service->nameservers_config, gw);
+	} else if (service->nameservers) {
+		/*
+		 * We add nameservers host routes for nameservers that
+		 * are not on our subnet. For those who are, the subnet
+		 * route will be installed by the time the dns proxy code
+		 * tries to reach them. The subnet route is installed
+		 * when setting the interface IP address.
+		 */
+		nameserver_add_routes(index, service->nameservers, gw);
+	}
+}
+
+/**
+ *  @brief
+ *    Delete IPv4 or IPv6 host routes for the domain name service (DNS)
+ *    servers associated with the specified service.
+ *
+ *  This attempts to delete IPv4 or IPv6 host routes for both the
+ *  automatic and configured domain name service (DNS) servers
+ *  associated with the specified network service.
+ *
+ *  @param[in]  service      A pointer to the immutable network
+ *                           service for which to delete DNS server
+ *                           host routes.
+ *  @param[in]  gw           A pointer to an immutable null-terminated
+ *                           C string containing the IPv4 or IPv6
+ *                           address, in text form, of the route next
+ *                           hop gateway address.
+ *  @param[in]  type         The IP configuration type for which to
+ *                           delete DNS server host routes.
+ *
+ *  @sa __connman_service_nameserver_del_routes
+ *  @sa nameserver_add_routes
+ *
+ */
+void __connman_service_nameserver_del_routes(
+					const struct connman_service *service,
+					const char *gw,
+					enum connman_ipconfig_type type)
+{
+	int index;
+
+	if (!service)
+		return;
+
+	index = __connman_service_get_index(service);
+
+	if (service->nameservers_config)
+		nameserver_del_routes(index, service->nameservers_config,
+					gw, type);
+	else if (service->nameservers)
+		nameserver_del_routes(index, service->nameservers, gw, type);
+}
+
+/**
+ *  @brief
+ *    Check the proxy setup of the specified network service.
+ *
+ *  This checks the proxy configuration of the specified network
+ *  service. The network service, @a service, may be set to
+ *  #CONNMAN_SERVICE_PROXY_METHOD_DIRECT if the current internal
+ *  method is empty or if there is no Proxy Auto-configuration (PAC)
+ *  URL received from DHCP or if the user proxy configuration is empty
+ *  or automatic and the Web Proxy Auto-discovery (WPAD) protocol
+ *  fails.
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           for which the proxy setup is to be
+ *                           checked and for which the method may be
+ *                           updated to
+ *                           #CONNMAN_SERVICE_PROXY_METHOD_DIRECT.
+ *
+ *  @returns
+ *    True if the proxy method has been established for the specified
+ *    service; otherwise, false.
+ *
+ *  @sa connman_service_set_proxy_method
+ *  @sa __connman_wpad_start
+ *
+ */
+static bool check_proxy_setup(struct connman_service *service)
+{
+	DBG("service %p (%s)", service, connman_service_get_identifier(service));
+
+	/*
+	 * We start WPAD if we haven't got a PAC URL from DHCP and
+	 * if our proxy manual configuration is either empty or set
+	 * to AUTO with an empty URL.
+	 */
+
+	if (service->proxy != CONNMAN_SERVICE_PROXY_METHOD_UNKNOWN)
+		return true;
+
+	if (service->proxy_config != CONNMAN_SERVICE_PROXY_METHOD_UNKNOWN &&
+		(service->proxy_config != CONNMAN_SERVICE_PROXY_METHOD_AUTO ||
+			service->pac))
+		return true;
+
+	if (__connman_wpad_start(service) < 0) {
+		connman_service_set_proxy_method(service,
+			CONNMAN_SERVICE_PROXY_METHOD_DIRECT);
+		return true;
+	}
+
+	return false;
+}
+
+const char *__connman_service_online_check_mode2string(
+				enum service_online_check_mode mode)
+{
+	switch (mode) {
+	case CONNMAN_SERVICE_ONLINE_CHECK_MODE_UNKNOWN:
+		break;
+	case CONNMAN_SERVICE_ONLINE_CHECK_MODE_NONE:
+		return "none";
+	case CONNMAN_SERVICE_ONLINE_CHECK_MODE_ONE_SHOT:
+		return "one-shot";
+	case CONNMAN_SERVICE_ONLINE_CHECK_MODE_CONTINUOUS:
+		return "continuous";
+	default:
+		break;
 	}
+
+	return NULL;
+}
+
+enum service_online_check_mode __connman_service_online_check_string2mode(
+				const char *mode)
+{
+	if (!mode)
+		return CONNMAN_SERVICE_ONLINE_CHECK_MODE_UNKNOWN;
+
+	if (g_strcmp0(mode, "none") == 0)
+		return CONNMAN_SERVICE_ONLINE_CHECK_MODE_NONE;
+	else if (g_strcmp0(mode, "one-shot") == 0)
+		return CONNMAN_SERVICE_ONLINE_CHECK_MODE_ONE_SHOT;
+	else if (g_strcmp0(mode, "continuous") == 0)
+		return CONNMAN_SERVICE_ONLINE_CHECK_MODE_CONTINUOUS;
+
+	return CONNMAN_SERVICE_ONLINE_CHECK_MODE_UNKNOWN;
+}
+
+/**
+ *  @brief
+ *    Return the "online" HTTP-based Internet reachability check mode.
+ *
+ *  @returns
+ *    The "online" HTTP-based Internet reachability check mode.
+ *
+ */
+enum service_online_check_mode __connman_service_get_online_check_mode(void)
+{
+	return connman_setting_get_uint("OnlineCheckMode");
+}
+
+/**
+ *  @brief
+ *    Return whether the "online" HTTP-based Internet reachability
+ *    checks are enabled.
+ *
+ *  @returns
+ *    True if "online" HTTP-based Internet reachability checks are
+ *    enabled; otherwise, false.
+ *
+ *  @sa __connman_service_get_online_check_mode
+ *
+ */
+bool __connman_service_is_online_check_enabled(void)
+{
+	const enum service_online_check_mode mode =
+		__connman_service_get_online_check_mode();
+
+	return mode != CONNMAN_SERVICE_ONLINE_CHECK_MODE_UNKNOWN &&
+		mode != CONNMAN_SERVICE_ONLINE_CHECK_MODE_NONE;
+}
+
+/**
+ *  @brief
+ *    Determines whether the "online" HTTP-based Internet reachability
+ *    check mode is the specified mode.
+ *
+ *  @param[in]  mode  The "online" HTTP-based Internet reachability
+ *                    check mode to confirm.
+ *
+ *  @returns
+ *    True if the current "online" HTTP-based Internet reachability
+ *    check mode is @a mode; otherwise, false.
+ *
+ *  @sa __connman_service_get_online_check_mode
+ *
+ */
+bool __connman_service_is_online_check_mode(
+		enum service_online_check_mode mode)
+{
+	return __connman_service_get_online_check_mode() == mode;
+}
+
+/**
+ *  @brief
+ *    Determine whether an "online" HTTP-based Internet reachability
+ *    check is active.
+ *
+ *  This determines whether an "online" HTTP-based Internet
+ *  reachability check is active for the specified network service IP
+ *  configuration type.
+ *
+ *  @param[in]  service  A pointer to the immutable network service
+ *                       for which to determine whether an "online"
+ *                       HTTP-based Internet reachability is active.
+ *  @param[in]  type     The IP configuration type for which to
+ *                       determine whether an "online" HTTP-based
+ *                       Internet reachability is active.
+ *
+ *  @returns
+ *    True if an "online" HTTP-based Internet reachability check is
+ *    active for the specified network service IP configuration type;
+ *    otherwise, false.
+ *
+ */
+static bool online_check_is_active(const struct connman_service *service,
+		enum connman_ipconfig_type type)
+{
+	bool do_ipv4 = false, do_ipv6 = false;
+	bool active = false;
+
+	DBG("service %p (%s) type %d (%s)",
+		service, connman_service_get_identifier(service),
+		type, __connman_ipconfig_type2string(type));
+
+	if (!service)
+		goto done;
+
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
+		do_ipv4 = true;
+	else if (type == CONNMAN_IPCONFIG_TYPE_IPV6)
+		do_ipv6 = true;
+	else if (type == CONNMAN_IPCONFIG_TYPE_ALL)
+		do_ipv4 = do_ipv6 = true;
+	else
+		goto done;
+
+	active = (do_ipv4 && service->online_check_state_ipv4.active) ||
+			 (do_ipv6 && service->online_check_state_ipv6.active);
+
+	DBG("active? %u", active);
+
+ done:
+	return active;
+}
+
+/**
+ *  @brief
+ *    Assign the "online" HTTP-based Internet reachability check
+ *    active state.
+ *
+ *  This assigns the "online" HTTP-based Internet reachability check
+ *  active state for the specified network service IP configuration
+ *  type.
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           for which to assign the "online" HTTP-
+ *                           based Internet reachability active
+ *                           state.
+ *  @param[in]      type     The IP configuration type for which to
+ *                           assign the "online" HTTP-based Internet
+ *                           reachability active state.
+ *  @param[in]      active   The "online" HTTP-based Internet
+ *                           reachability active state to assign.
+ *
+ *  @sa online_check_is_active
+ *
+ */
+static void online_check_active_set_value(struct connman_service *service,
+		enum connman_ipconfig_type type,
+		bool active)
+{
+	bool do_ipv4 = false, do_ipv6 = false;
+
+	DBG("service %p (%s) type %d (%s) active? %u",
+		service, connman_service_get_identifier(service),
+		type, __connman_ipconfig_type2string(type),
+		active);
+
+	if (!service)
+		return;
+
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
+		do_ipv4 = true;
+	else if (type == CONNMAN_IPCONFIG_TYPE_IPV6)
+		do_ipv6 = true;
+	else if (type == CONNMAN_IPCONFIG_TYPE_ALL)
+		do_ipv4 = do_ipv6 = true;
+	else
+		return;
+
+	if (do_ipv4)
+		service->online_check_state_ipv4.active = active;
+
+	if (do_ipv6)
+		service->online_check_state_ipv6.active = active;
 }
 
-void __connman_service_nameserver_add_routes(struct connman_service *service,
-						const char *gw)
+/**
+ *  @brief
+ *    Set, or assert, the "online" HTTP-based Internet reachability
+ *    check active state.
+ *
+ *  This sets, or asserts, the "online" HTTP-based Internet
+ *  reachability check active state for the specified network service
+ *  IP configuration type.
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           for which to set the "online" HTTP-
+ *                           based Internet reachability active
+ *                           state.
+ *  @param[in]      type     The IP configuration type for which to
+ *                           set the "online" HTTP-based Internet
+ *                           reachability active state.
+ *
+ *  @sa online_check_active_set_value
+ *  @sa online_check_is_active
+ *
+ */
+static void online_check_active_set(struct connman_service *service,
+		enum connman_ipconfig_type type)
+{
+	online_check_active_set_value(service, type, true);
+}
+
+/**
+ *  @brief
+ *    Clear, or deassert, the "online" HTTP-based Internet
+ *    reachability check active state.
+ *
+ *  This clears, or deasserts, the "online" HTTP-based Internet
+ *  reachability check active state for the specified network service
+ *  IP configuration type.
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           for which to clear the "online" HTTP-
+ *                           based Internet reachability active
+ *                           state.
+ *  @param[in]      type     The IP configuration type for which to
+ *                           clear the "online" HTTP-based Internet
+ *                           reachability active state.
+ *
+ *  @sa online_check_active_set_value
+ *  @sa online_check_is_active
+ *
+ */
+static void online_check_active_clear(struct connman_service *service,
+		enum connman_ipconfig_type type)
+{
+	online_check_active_set_value(service, type, false);
+}
+
+/**
+ *  @brief
+ *    Compute a Fibonacci online check timeout based on the specified
+ *    interval.
+ *
+ *  This computes the Fibonacci online check timeout, in seconds,
+ *  based on the specified interval in a Fibonacci series. For
+ *  example, an interval of 9 yields a timeout of 34 seconds.
+ *
+ *  @note
+ *    As compared to a geometric series, the Fibonacci series is
+ *    slightly less aggressive in backing off up to the equivalence
+ *    point at interval 12, but far more aggressive past that point,
+ *    climbing to past an hour at interval 19 whereas the geometric
+ *    series does not reach that point until interval 60.
+ *
+ *  @param[in]  interval  The interval in the geometric series for
+ *                        which to compute the online check timeout.
+ *
+ *  @returns
+ *    The timeout, in seconds, for the online check.
+ *
+ *  @sa online_check_timeout_compute_fibonacci
+ *
+ */
+static guint online_check_timeout_compute_fibonacci(unsigned int interval)
+{
+	unsigned int i;
+	guint first = 0;
+	guint second = 1;
+	guint timeout_seconds;
+
+	for (i = 0; i <= interval; i++) {
+		timeout_seconds = first;
+
+		first = second;
+
+		second = second + timeout_seconds;
+	}
+
+	return timeout_seconds;
+}
+
+/**
+ *  @brief
+ *    Compute a geometric online check timeout based on the specified
+ *    interval.
+ *
+ *  This computes the geometric online check timeout, in seconds,
+ *  based on the specified interval in a geometric series, where the
+ *  resulting value is interval^2. For example, an interval of 9
+ *  yields a timeout of 81 seconds.
+ *
+ *  @note
+ *    As compared to a Fibonacci series, the geometric series is
+ *    slightly more aggressive in backing off up to the equivalence
+ *    point at interval 12, but far less aggressive past that point,
+ *    only reaching an hour at interval 90 compared to interval 19 for
+ *    Fibonacci for a similar timeout.
+ *
+ *  @param[in]  interval  The interval in the geometric series for
+ *                        which to compute the online check timeout.
+ *
+ *  @returns
+ *    The timeout, in seconds, for the online check.
+ *
+ *  @sa online_check_timeout_compute_fibonacci
+ *
+ */
+static guint online_check_timeout_compute_geometric(unsigned int interval)
+{
+	const guint timeout_seconds = interval * interval;
+
+	return timeout_seconds;
+}
+
+/**
+ *  @brief
+ *    Cancel any "online" HTTP-based Internet reachability checks for
+ *    the specified network service IP configuration type.
+ *
+ *  This cancels any current or pending IPv4 and/or IPv6 "online"
+ *  HTTP-based Internet reachability checks for the specified network
+ *  service IP configuration type.
+ *
+ *  @note
+ *    Any lingering WISPr portal reachability context will be lazily
+ *    released at the start of the next online check for the service
+ *    and replaced with new context.
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           for which any current or pending IPv4 or
+ *                           IPv6 "online" reachability checks should
+ *                           be canceled.
+ *  @param[in]      type     The IP configuration type for which the
+ *                           "online" reachability check is to be
+ *                           canceled.
+ *
+ *  @sa start_online_check
+ *  @sa complete_online_check
+ *  @sa __connman_wispr_start
+ *  @sa __connman_wispr_stop
+ *
+ */
+static void cancel_online_check(struct connman_service *service,
+				enum connman_ipconfig_type type)
+{
+	bool do_ipv4 = false, do_ipv6 = false;
+
+	DBG("service %p (%s) type %d (%s) "
+		"online_timeout_ipv4 %d online_timeout_ipv6 %d",
+		service, connman_service_get_identifier(service),
+		type, __connman_ipconfig_type2string(type),
+		service->online_check_state_ipv4.timeout,
+		service->online_check_state_ipv6.timeout);
+
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
+		do_ipv4 = true;
+	else if (type == CONNMAN_IPCONFIG_TYPE_IPV6)
+		do_ipv6 = true;
+	else if (type == CONNMAN_IPCONFIG_TYPE_ALL)
+		do_ipv4 = do_ipv6 = true;
+	else
+		return;
+
+	/*
+	 * First, ensure that the reachability check(s) is/are cancelled
+	 * in the WISPr module. This may fail, however, we ignore any such
+	 * failures as we still want to cancel any outstanding check(s)
+	 * from this module as well.
+	 */
+
+	if (do_ipv4)
+		__connman_wispr_cancel(service, CONNMAN_IPCONFIG_TYPE_IPV4);
+
+	if (do_ipv6)
+		__connman_wispr_cancel(service, CONNMAN_IPCONFIG_TYPE_IPV6);
+
+	/*
+	 * Now that the reachability check(s) has/have been cancelled in
+	 * the WISPr module, cancel any outstanding check(s) that may be
+	 * scheduled in this module.
+	 */
+	if (do_ipv4 &&
+		service->online_check_state_ipv4.timeout) {
+		g_source_remove(service->online_check_state_ipv4.timeout);
+		service->online_check_state_ipv4.timeout = 0;
+
+		/*
+		 * This balances the retained referece made when
+		 * g_timeout_add_seconds was called to schedule this
+		 * now-cancelled scheduled online check.
+		 */
+		connman_service_unref(service);
+	}
+
+	if (do_ipv6 &&
+		service->online_check_state_ipv6.timeout) {
+		g_source_remove(service->online_check_state_ipv6.timeout);
+		service->online_check_state_ipv6.timeout = 0;
+
+		/*
+		 * This balances the retained referece made when
+		 * g_timeout_add_seconds was called to schedule this
+		 * now-cancelled scheduled online check.
+		 */
+		connman_service_unref(service);
+	}
+
+    /* Mark the online check state as inactive. */
+
+	online_check_active_clear(service, type);
+}
+
+/**
+ *  @brief
+ *    Check whether an online check is enabled for the specified
+ *    service.
+ *
+ *  This determines whether "online" HTTP-based Internet reachability
+ *  checks are enabled for the specified network service. If not, an
+ *  information-level message is logged.
+ *
+ *  @param[in]  service  A pointer to the immutable service for which
+ *                       to determine whether "online" HTTP-based
+ *                       Internet reachability checks are enabled.
+ *
+ *  @returns
+ *    True if "online" HTTP-based Internet reachability * checks are
+ *    enabled for the specified network service; otherwise, false.
+ *
+ *  @sa start_online_check
+ *  @sa start_online_check_if_connected
+ *
+ */
+static bool online_check_is_enabled_check(
+		const struct connman_service *service)
+{
+	g_autofree char *interface = NULL;
+
+	if (!__connman_service_is_online_check_enabled()) {
+		interface = connman_service_get_interface(service);
+
+		connman_info("Online check disabled; "
+			"interface %s [ %s ] remains in %s state.",
+			interface,
+			__connman_service_type2string(service->type),
+			state2string(CONNMAN_SERVICE_STATE_READY));
+
+		return false;
+	}
+
+	return true;
+}
+
+/**
+ *  @brief
+ *    Start an "online" HTTP-based Internet reachability check for the
+ *    specified network service IP configuration type.
+ *
+ *  This attempts to start an "online" HTTP-based Internet
+ *  reachability check for the specified network service IP
+ *  configuration type.
+ *
+ *  @note
+ *    Any check is skipped, with an informational log message, if @a
+ *    OnlineCheckMode is "none".
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           for which to start the "online"
+ *                           reachability check.
+ *  @param[in]      type     The IP configuration type for which the
+ *                           "online" reachability check is to be
+ *                           started.
+ *
+ *  @retval  0          If successful.
+ *  @retval  -EINVAL    If @a service is null or @a type is invalid.
+ *  @retval  -EPERM     If online checks are disabled via
+ *                      configuration.
+ *  @retval  -EALREADY  If online checks are already active for @a
+ *                      service.
+ *
+ *  @sa cancel_online_check
+ *  @sa complete_online_check
+ *  @sa start_online_check_if_connected
+ *  @sa __connman_service_wispr_start
+ *
+ */
+static int start_online_check(struct connman_service *service,
+				enum connman_ipconfig_type type)
+{
+	int status = 0;
+
+	DBG("service %p (%s) type %d (%s) maybe start WISPr",
+		service,
+		connman_service_get_identifier(service),
+		type,
+		__connman_ipconfig_type2string(type));
+
+	if (!service) {
+		status = -EINVAL;
+		goto done;
+	}
+
+	if (!online_check_is_enabled_check(service)) {
+		status = -EPERM;
+		goto done;
+	}
+
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV6 || check_proxy_setup(service)) {
+		cancel_online_check(service, type);
+
+		status = __connman_service_wispr_start(service, type);
+	}
+
+done:
+	DBG("status %d (%s)", status, strerror(-status));
+
+	return status;
+}
+
+/**
+ *  @brief
+ *    Return the online check failures threshold state.
+ *
+ *  @param[in]  service  A pointer to the immutable service for which
+ *                       to return the online check failures threshold
+ *                       state.
+ *
+ *  @returns
+ *    True if the online check failures threshold was met; otherwise,
+ *    false.
+ *
+ *  @sa online_check_failures_threshold_was_met_set_value
+ *  @sa online_check_failures_threshold_was_met_set
+ *  @sa online_check_failures_threshold_was_met_clear
+ *
+ */
+static bool online_check_failures_threshold_was_met(
+			const struct connman_service *service)
+{
+	return service->online_check_failures_met_threshold;
+}
+
+/**
+ *  @brief
+ *    Set the online check failures threshold state to the specified
+ *    value.
+ *
+ *  @param[in,out]  service  A pointer to the mutable service for which
+ *                           to set the failures threshold state.
+ *  @param[in]      value    The value to set the @a service failures
+ *                           threshold state to.
+ *
+ *  @sa online_check_failures_threshold_was_met_set
+ *  @sa online_check_failures_threshold_was_met_clear
+ *
+ */
+static void online_check_failures_threshold_was_met_set_value(
+			struct connman_service *service, bool value)
+{
+	DBG("service %p (%s) failures met threshold %u",
+		service, connman_service_get_identifier(service),
+		value);
+
+	service->online_check_failures_met_threshold = value;
+}
+
+/**
+ *  @brief
+ *    Set (that is, assert) the online check failures threshold state.
+ *
+ *  @param[in,out]  service  A pointer to the mutable service for which
+ *                           to set the failures threshold state.
+ *
+ *  @sa online_check_failures_threshold_was_met_set_value
+ *  @sa online_check_failures_threshold_was_met_clear
+ *
+ */
+static void online_check_failures_threshold_was_met_set(
+			struct connman_service *service)
+{
+	online_check_failures_threshold_was_met_set_value(service, true);
+}
+
+/**
+ *  @brief
+ *    Clear (that is, deassert) the online check failures threshold
+ *    state.
+ *
+ *  @param[in,out]  service  A pointer to the mutable service for which
+ *                           to clear the failures threshold state.
+ *
+ *  @sa online_check_failures_threshold_was_met_set_value
+ *  @sa online_check_failures_threshold_was_met_set
+ *
+ */
+static void online_check_failures_threshold_was_met_clear(
+			struct connman_service *service)
+{
+	online_check_failures_threshold_was_met_set_value(service, false);
+}
+
+/**
+ *  Reset the specified counter to zero (0).
+ *
+ *  @param[in,out]  counter  A pointer to the counter to reset by
+ *                           setting it to zero (0).
+ *
+ */
+static inline void online_check_counter_reset(
+			unsigned int *counter)
+{
+	if (!counter)
+		return;
+
+	*counter = 0;
+}
+
+/**
+ *  @brief
+ *    Reset to zero (0) the IPv4 and IPv6 online check failure
+ *    counters for the specified service.
+ *
+ *  @param[in]   service   A pointer to the mutable service for which
+ *                         to reset the IPv4 and IPv6 online check
+ *                         failure counters.
+ *
+ *  @sa online_check_successes_reset
+ *
+ */
+static void online_check_failures_reset(struct connman_service *service)
+{
+	DBG("service %p (%s)",
+		service, connman_service_get_identifier(service));
+
+	online_check_counter_reset(&service->online_check_state_ipv4.failures);
+	online_check_counter_reset(&service->online_check_state_ipv6.failures);
+}
+
+/**
+ *  @brief
+ *    Reset to zero (0) the IPv4 and IPv6 online check success
+ *    counters for the specified service.
+ *
+ *  @param[in]   service   A pointer to the mutable service for which
+ *                         to reset the IPv4 and IPv6 online check
+ *                         success counters.
+ *
+ *  @sa online_check_failures_reset
+ *
+ */
+static void online_check_successes_reset(struct connman_service *service)
+{
+	DBG("service %p (%s)",
+		service, connman_service_get_identifier(service));
+
+	online_check_counter_reset(&service->online_check_state_ipv4.successes);
+	online_check_counter_reset(&service->online_check_state_ipv6.successes);
+}
+
+/**
+ *  @brief
+ *    Reset the online check state for the specified service.
+ *
+ *  This resets the online check state for the specified service,
+ *  including its failure threshold state, failure counters, and
+ *  success counters.
+ *
+ *  @param[in]   service   A pointer to the mutable service for which
+ *                         to reset the online check state.
+ *
+ *  @sa online_check_failures_reset
+ *  @sa online_check_successes_reset
+ *  @sa online_check_failures_threshold_was_met_clear
+ *
+ */
+static void online_check_state_reset(struct connman_service *service)
+{
+	online_check_failures_reset(service);
+
+	online_check_successes_reset(service);
+
+	online_check_failures_threshold_was_met_clear(service);
+
+	clear_error(service);
+}
+
+/**
+ *  @brief
+ *    Log the specified IPv4 and IPv6 online check counters for the
+ *    specified service.
+ *
+ *  This logs the specified IPv4 and IPv6 online check counters
+ *  described by the provided description for the specified network
+ *  service.
+ *
+ *  @param[in]  service              A pointer to the immutable network
+ *                                   service associated with @a
+ *                                   ipv4_counter and @a ipv6_counter.
+ *  @param[in]  counter_description  A pointer to a null-terminated C
+ *                                   string describing @a ipv4_counter
+ *                                   and @a ipv6_counter. For example,
+ *                                   "failure".
+ *  @param[in]  ipv4_counter         The IPv4-specific counter to log.
+ *  @param[in]  ipv6_counter         The IPv6-specific counter to log.
+ *
+ */
+static void online_check_counters_log(
+			const struct connman_service *service,
+			const char *counter_description,
+			unsigned int ipv4_counter,
+			unsigned int ipv6_counter)
+{
+	DBG("service %p (%s) "
+		"ipv4 state %d (%s) %s(s/es) %u "
+		"ipv6 state %d (%s) %s(s/es) %u ",
+		service, connman_service_get_identifier(service),
+		service->state_ipv4, state2string(service->state_ipv4),
+		counter_description,
+		ipv4_counter,
+		service->state_ipv6, state2string(service->state_ipv6),
+		counter_description,
+		ipv6_counter);
+}
+
+/**
+ *  @brief
+ *    Determine whether an online check counter has met its threshold.
+ *
+ *  This determines whether an online check counter associated with
+ *  the specified network service has met its threshold, where the
+ *  threshold is accessed from the configuration store with the
+ *  specified key.
+ *
+ *  @param[in]  service                A pointer to the immutable
+ *                                     network service associated with
+ *                                     the counter to check.
+ *  @param[in]  counter_threshold_key  A pointer to a null-terminated
+ *                                     C string containing the key to
+ *                                     use with the configuration
+ *                                     store to access the threshold
+ *                                     value to check the counter
+ *                                     against.
+ *  @param[in]  counter_description    A pointer to a null-terminated
+ *                                     C string describing the counter
+ *                                     to check. For example, "failure".
+ *  @param[in]  predicate              A pointer to the predicate
+ *                                     function to invoke to make the
+ *                                     actual determination of whether
+ *                                     the counter has met the
+ *                                     threshold accessed by @a
+ *                                     counter_threshold_key.
+ *
+ *  @returns
+ *    True if the counter has met the threshold; otherwise, false.
+ *
+ */
+static bool online_check_counter_threshold_is_met(
+			const struct connman_service *service,
+			const char *counter_threshold_key,
+			const char *counter_description,
+			is_counter_threshold_met_predicate_t predicate)
+{
+	unsigned int counter_threshold;
+	bool threshold_met = false;
+
+	if (!service ||
+		!counter_threshold_key ||
+		!counter_description ||
+		!predicate)
+		goto done;
+
+	counter_threshold = connman_setting_get_uint(counter_threshold_key);
+
+	threshold_met = predicate(service,
+						counter_description,
+						counter_threshold);
+
+	DBG("service %p (%s) %s threshold %u %s(s) met %u",
+		service, connman_service_get_identifier(service),
+		counter_description,
+		counter_threshold,
+		counter_description,
+		threshold_met);
+
+done:
+	return threshold_met;
+}
+
+/**
+ *  @brief
+ *    Determine whether the service has met the online check failure
+ *    threshold.
+ *
+ *  This predicate determines whether the online check failure
+ *  threshold has been met by the specified network service.
+ *
+ *  @param[in]  service                A pointer to the immutable
+ *                                     network service for which to
+ *                                     check whether its has met the
+ *                                     online check failure threshold.
+ *  @param[in]  counter_description    A pointer to a null-terminated
+ *                                     C string describing the failure
+ *                                     counter. For example,
+ *                                     "failure".
+ *  @param[in]  counter_threshold      The threshold value to check the
+ *                                     failure counter against.
+ *
+ *  @returns
+ *    True if the online check failure counter has met the failure
+ *    threshold; otherwise, false.
+ *
+ *  @sa online_check_failures_threshold_is_met
+ *
+ */
+static bool is_online_check_failure_threshold_met_predicate(
+			const struct connman_service *service,
+			const char *counter_description,
+			unsigned int counter_threshold)
+{
+	bool ipv4_is_connected;
+	bool ipv6_is_connected;
+	bool threshold_met = false;
+
+	online_check_counters_log(service,
+		counter_description,
+		service->online_check_state_ipv4.failures,
+		service->online_check_state_ipv6.failures);
+
+	ipv4_is_connected = is_connected(service->state_ipv4);
+	ipv6_is_connected = is_connected(service->state_ipv6);
+
+	/*
+	 * It is entirely possible that IPv4 reachability is fine and that
+	 * IPv6 reachablity is not due to the premises ISP, premises
+	 * Internet access equipment (that is, CPE), availability of the
+	 * reachability endpoint infrastructure, etc.
+	 *
+	 * Consequently, we want to see bilateral failures of BOTH IPv4
+	 * AND IPv6 in excess of the threshold, to the extent either is
+	 * connected (based on the #is_connected predicate).
+	 */
+	if ((!ipv6_is_connected &&
+		 ipv4_is_connected &&
+		 service->online_check_state_ipv4.failures >=
+		 counter_threshold) ||
+
+		(!ipv4_is_connected &&
+		ipv6_is_connected &&
+		service->online_check_state_ipv6.failures >=
+		counter_threshold) ||
+
+		(ipv4_is_connected &&
+		service->online_check_state_ipv4.failures >=
+		counter_threshold &&
+		ipv6_is_connected &&
+		service->online_check_state_ipv6.failures >=
+		counter_threshold)) {
+		threshold_met = true;
+	}
+
+	return threshold_met;
+}
+
+/**
+ *  @brief
+ *    Determine whether the online check failures threshold is met.
+ *
+ *  This attempts to determine whether the online check failures
+ *  threshold is met, comparing the current IPv4 and IPv6 online check
+ *  failure counts against the "OnlineCheckFailuresThreshold" settings
+ *  value and returning @a true if @b both the IPv4 and IPv6 counts
+ *  meet or exceed the threshold.
+ *
+ *  @param[in]  service  A pointer to the immutable service for which
+ *                       to determine whether the online check failure
+ *                       threshold is met.
+ *
+ *  @returns
+ *    True if the failure threshold is met; otherwise, false.
+ *
+ *  @sa online_check_successes_threshold_is_met
+ *
+ */
+static bool online_check_failures_threshold_is_met(
+			const struct connman_service *service)
+{
+	const char * const counter_threshold_key =
+		"OnlineCheckFailuresThreshold";
+	const char * const counter_description =
+		"failure";
+
+	return online_check_counter_threshold_is_met(service,
+			counter_threshold_key,
+			counter_description,
+			is_online_check_failure_threshold_met_predicate);
+}
+
+/**
+ *  @brief
+ *    Determine whether the service has met the online check success
+ *    threshold.
+ *
+ *  This predicate determines whether the online check success
+ *  threshold has been met by the specified network service.
+ *
+ *  @param[in]  service                A pointer to the immutable
+ *                                     network service for which to
+ *                                     check whether its has met the
+ *                                     online check success threshold.
+ *  @param[in]  counter_description    A pointer to a null-terminated
+ *                                     C string describing the success
+ *                                     counter. For example,
+ *                                     "success".
+ *  @param[in]  counter_threshold      The threshold value to check the
+ *                                     success counter against.
+ *
+ *  @returns
+ *    True if the online check success counter has met the success
+ *    threshold; otherwise, false.
+ *
+ *  @sa online_check_successes_threshold_is_met
+ *
+ */
+static bool is_online_check_success_threshold_met_predicate(
+			const struct connman_service *service,
+			const char *counter_description,
+			unsigned int counter_threshold)
+{
+	bool threshold_met = false;
+
+	online_check_counters_log(service,
+		counter_description,
+		service->online_check_state_ipv4.successes,
+		service->online_check_state_ipv6.successes);
+
+	/*
+	 * It is entirely possible that IPv4 reachability is fine and that
+	 * IPv6 reachablity is not due to the premises ISP, premises
+	 * Internet access equipment (that is, CPE), availability of the
+	 * reachability endpoint infrastructure, etc.
+	 *
+	 * Consequently, we want to see bilateral successes of EITHER IPv4
+	 * OR IPv6 (as with #combine_state) in excess of the threshold, to
+	 * the extent either is connected (based on the #is_connected
+	 * predicate).
+	 */
+
+	if ((is_connected(service->state_ipv4) &&
+		service->online_check_state_ipv4.successes >=
+		counter_threshold) ||
+		(is_connected(service->state_ipv6) &&
+		service->online_check_state_ipv6.successes >=
+		counter_threshold)) {
+		threshold_met = true;
+	}
+
+	return threshold_met;
+}
+
+/**
+ *  @brief
+ *    Determine whether the online check successes threshold is met.
+ *
+ *  This attempts to determine whether the online check successes
+ *  threshold is met, comparing the current IPv4 and IPv6 online check
+ *  success counts against the "OnlineCheckSuccessesThreshold" settings
+ *  value and returning @a true if @b either the IPv4 @b or IPv6 counts
+ *  meet or exceed the threshold.
+ *
+ *  @param[in]  service  A pointer to the immutable service for which
+ *                       to determine whether the online check success
+ *                       threshold is met.
+ *
+ *  @returns
+ *    True if the success threshold is met; otherwise, false.
+ *
+ *  @sa online_check_failures_threshold_is_met
+ *
+ */
+static bool online_check_successes_threshold_is_met(
+			const struct connman_service *service)
+{
+	const char * const counter_threshold_key =
+		"OnlineCheckSuccessesThreshold";
+	const char * const counter_description =
+		"success";
+
+	return online_check_counter_threshold_is_met(service,
+			counter_threshold_key,
+			counter_description,
+			is_online_check_success_threshold_met_predicate);
+}
+
+/**
+ *  @brief
+ *    Retry an "online" HTTP-based Internet reachability check.
+ *
+ *  This retries an "online" HTTP-based Internet reachability check
+ *  for the specified network service IP configuration type.
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           for which an "online" reachability check
+ *                           should be retried.
+ *  @param[in]      type     The IP configuration type for which an
+ *                           "online" reachability check should be
+ *                           retried.
+ *
+ *  @sa complete_online_check
+ *  @sa redo_wispr_ipv4
+ *  @sa redo_wispr_ipv6
+ *
+ */
+static void redo_wispr(struct connman_service *service,
+					enum connman_ipconfig_type type)
+{
+	DBG("Retrying service %p (%s) type %d (%s) WISPr",
+		service, connman_service_get_identifier(service),
+		type, __connman_ipconfig_type2string(type));
+
+	__connman_wispr_start(service, type,
+			online_check_connect_timeout_ms, complete_online_check);
+
+	// Release the reference to the service taken when
+	// g_timeout_add_seconds was invoked with the callback
+	// that, in turn, invoked this function.
+
+	connman_service_unref(service);
+}
+
+/**
+ *  @brief
+ *    Retry an "online" HTTP-based Internet reachability check
+ *    callback.
+ *
+ *  This callback retries an IPv4 "online" HTTP-based Internet
+ *  reachability check for the specified network service.
+ *
+ *  @param[in,out]  user_data  A pointer to the mutable network
+ *                             service for which an IPv4 "online"
+ *                             reachability check should be retried.
+ *
+ *  @returns
+ *    FALSE (that is, G_SOURCE_REMOVE) unconditionally, indicating
+ *    that the timeout source that triggered this callback should be
+ *    removed on callback completion.
+ *
+ *  @sa complete_online_check
+ *  @sa redo_wispr
+ *  @sa redo_wispr_ipv6
+ *
+ */
+static gboolean redo_wispr_ipv4(gpointer user_data)
+{
+	struct connman_service *service = user_data;
+
+	service->online_check_state_ipv4.timeout = 0;
+
+	redo_wispr(service, CONNMAN_IPCONFIG_TYPE_IPV4);
+
+	return FALSE;
+}
+
+/**
+ *  @brief
+ *    Retry an "online" HTTP-based Internet reachability check
+ *    callback.
+ *
+ *  This callback retries an IPv6 "online" HTTP-based Internet
+ *  reachability check for the specified network service.
+ *
+ *  @param[in,out]  user_data  A pointer to the mutable network
+ *                             service for which an IPv6 "online"
+ *                             reachability check should be retried.
+ *
+ *  @returns
+ *    FALSE (that is, G_SOURCE_REMOVE) unconditionally, indicating
+ *    that the timeout source that triggered this callback should be
+ *    removed on callback completion.
+ *
+ *  @sa complete_online_check
+ *  @sa redo_wispr
+ *  @sa redo_wispr_ipv4
+ *
+ */
+static gboolean redo_wispr_ipv6(gpointer user_data)
+{
+	struct connman_service *service = user_data;
+
+	service->online_check_state_ipv6.timeout = 0;
+
+	redo_wispr(service, CONNMAN_IPCONFIG_TYPE_IPV6);
+
+	return FALSE;
+}
+
+/**
+ *  @brief
+ *    Reschedule an "online" HTTP-based Internet reachability check
+ *    for the specified network service IP configuration type.
+ *
+ *  This attempts to eschedule an "online" HTTP-based Internet
+ *  reachability check for the specified network service IP
+ *  configuration type with the provided interval and timeout
+ *  identifier.
+ *
+ *  @param[in,out]  service             A pointer to the mutable
+ *                                      network service for which to
+ *                                      reschedule the "online"
+ *                                      reachability check. On
+ *                                      success, the service will have
+ *                                      a reference retained that must
+ *                                      be elsewhere released.
+ *  @param[in]      type                The IP configuration type for
+ *                                      which the "online"
+ *                                      reachability check is to be
+ *                                      rescheduled.
+ *  @param[in,out]  online_check_state  A pointer to the mutable IP
+ *                                      configuration type-specific
+ *                                      "online" reachability check
+ *                                      state associated with @a
+ *                                      service and @a type. On
+ *                                      success, the 'interval' field
+ *                                      will be incremented by one (1)
+ *                                      if it is less than the value
+ *                                      of the @a
+ *                                      OnlineCheckMaxInterval
+ *                                      configuration setting and the
+ *                                      'timeout' field this will be
+ *                                      updated with the GLib main
+ *                                      loop timer identifier
+ *                                      associated with the
+ *                                      rescheduled "online"
+ *                                      HTTP-based Internet
+ *                                      reachability check request.
+ *
+ *  @sa redo_wispr_ipv4
+ *  @sa redo_wispr_ipv6
+ *
+ */
+static void reschedule_online_check(struct connman_service *service,
+			enum connman_ipconfig_type type,
+			struct online_check_state *online_check_state)
+{
+	GSourceFunc redo_func;
+	guint seconds;
+
+	if (!service || !online_check_state)
+		return;
+
+	DBG("service %p (%s) type %d (%s) interval %u timeout %u",
+		service,
+		connman_service_get_identifier(service),
+		type,
+		__connman_ipconfig_type2string(type),
+		online_check_state->interval,
+		online_check_state->timeout);
+
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
+		redo_func = redo_wispr_ipv4;
+	else if (type == CONNMAN_IPCONFIG_TYPE_IPV6)
+		redo_func = redo_wispr_ipv6;
+	else
+		return;
+
+	DBG("updating online checkout timeout period");
+
+	seconds = online_check_timeout_compute_func(
+				online_check_state->interval);
+
+	DBG("service %p (%s) type %d (%s) interval %u style \"%s\" seconds %u",
+		service,
+		connman_service_get_identifier(service),
+		type, __connman_ipconfig_type2string(type),
+		online_check_state->interval,
+		online_check_timeout_interval_style,
+		seconds);
+
+	online_check_state->timeout = g_timeout_add_seconds(seconds,
+				redo_func, connman_service_ref(service));
+
+	/* Increment the interval for the next time, limiting to a maximum
+	 * interval of @a online_check_max_interval.
+	 */
+	if (online_check_state->interval < online_check_max_interval)
+		online_check_state->interval++;
+}
+
+/**
+ *  @brief
+ *    Increment and log the specified online check counter.
+ *
+ *  This increments by one (1) and logs the post-increment value of
+ *  the specified online check counter associated with the specified
+ *  network service.
+ *
+ *  @param[in]  service              A pointer to the immutable network
+ *                                   service associated with @a
+ *                                   counter.
+ *  @param[in]  type                 The IP configuration type associated
+ *                                   with @a counter.
+ *  @param[in]  counter_description  A pointer to a null-terminated C
+ *                                   string describing @a counter. For
+ *                                   example, "failure".
+ *
+ */
+static void online_check_counter_increment_and_log(
+			const struct connman_service *service,
+			enum connman_ipconfig_type type,
+			const char *counter_description,
+			unsigned int *counter)
+{
+	if (!service || !counter_description || !counter)
+		return;
+
+	(*counter)++;
+
+	DBG("service %p (%s) type %d (%s) %s %u",
+		service, connman_service_get_identifier(service),
+		type, __connman_ipconfig_type2string(type),
+		counter_description, *counter);
+}
+
+/**
+ *  @brief
+ *    Log an online check success.
+ *
+ *  This logs an online check success for the specified network
+ *  service IP configuration type.
+ *
+ *  @param[in]  service  A pointer to the immutable network
+ *                       service for which to log an online
+ *                       check success.
+ *  @param[in]  type     The IP configuration type for which
+ *                       the online check was successful.
+ *
+ */
+static void online_check_log_success(const struct connman_service *service,
+			enum connman_ipconfig_type type)
+{
+	g_autofree char *interface = NULL;
+
+	interface = connman_service_get_interface(service);
+
+	connman_info("Interface %s [ %s ] %s online check to %s succeeded",
+		interface,
+		__connman_service_type2string(service->type),
+		__connman_ipconfig_type2string(type),
+		type == CONNMAN_IPCONFIG_TYPE_IPV4 ?
+			connman_setting_get_string("OnlineCheckIPv4URL") :
+			connman_setting_get_string("OnlineCheckIPv6URL"));
+}
+
+/**
+ *  @brief
+ *    Log that an online check counter has met its threshold.
+ *
+ *  This logs that an online check counter associated with the
+ *  specified network service has met its threshold.
+ *
+ *  @param[in]  service                A pointer to the immutable
+ *                                     network service for which to
+ *                                     log that one of its online
+ *                                     check counters has met its
+ *                                     threshold.
+ *  @param[in]  counter_threshold_key  A pointer to a null-terminated
+ *                                     C string containing the key to
+ *                                     use with the configuration
+ *                                     store to access the threshold
+ *                                     value for the counter.
+ *  @param[in]  counter_description    A pointer to a null-terminated
+ *                                     C string describing the counter
+ *                                     to check. For example,
+ *                                     "failure(s)".
+ *
+ */
+static void continuous_online_check_log_counter_threshold_met(
+			const struct connman_service *service,
+			const char *counter_threshold_key,
+			const char *counter_description)
+{
+	g_autofree char *interface = NULL;
+
+	interface = connman_service_get_interface(service);
+
+	connman_warn("Interface %s [ %s ] online check had %u back-to-back "
+		"%s; %s threshold met",
+		interface,
+		__connman_service_type2string(service->type),
+		connman_setting_get_uint(counter_threshold_key),
+				 counter_description,
+				 counter_description);
+}
+
+/**
+ *  @brief
+ *    Log that an online check success counter has met its threshold.
+ *
+ *  This logs that an online check success counter associated with the
+ *  specified network service has met its threshold.
+ *
+ *  @param[in]  service                A pointer to the immutable
+ *                                     network service for which to
+ *                                     log that its online check
+ *                                     success counter has met its
+ *                                     threshold.
+ *
+ */
+static void continuous_online_check_log_successes_threshold_met(
+			const struct connman_service *service
+)
+{
+	static const char *const counter_threshold_key =
+		"OnlineCheckSuccessesThreshold";
+	static const char *const counter_description =
+		"success(es)";
+
+	continuous_online_check_log_counter_threshold_met(service,
+		counter_threshold_key,
+		counter_description);
+}
+
+/**
+ *  @brief
+ *    Log that an online check failure counter has met its threshold.
+ *
+ *  This logs that an online check failure counter associated with the
+ *  specified network service has met its threshold.
+ *
+ *  @param[in]  service                A pointer to the immutable
+ *                                     network service for which to
+ *                                     log that its online check
+ *                                     failure counter has met its
+ *                                     threshold.
+ *
+ */
+static void continuous_online_check_log_failures_threshold_met(
+			const struct connman_service *service
+)
+{
+	static const char *const counter_threshold_key =
+		"OnlineCheckFailuresThreshold";
+	static const char *const counter_description =
+		"failure(s)";
+
+	continuous_online_check_log_counter_threshold_met(service,
+		counter_threshold_key,
+		counter_description);
+}
+
+/**
+ *  @brief
+ *    Handle the successful completion of an "online" HTTP-based
+ *    Internet reachability check for the specified network service
+ *    and IP configuration type for the "one-shot" online check mode.
+ *
+ *  This handles the completion of a successful "online" HTTP-based
+ *  Internet reachability check for the specified network service and
+ *  IP configuration type for the "one-shot" online check mode. This
+ *  effectively "bookends" an earlier #__connman_service_wispr_start.
+ *
+ *  @param[in,out]  service             A pointer to the mutable service
+ *                                      for which to handle a
+ *                                      successful previously-requested
+ *                                      online check.
+ *  @param[in]      type                The IP configuration type for
+ *                                      which to handle a successful
+ *                                      previously-requested online
+ *                                      check.
+ *  @param[in,out]  online_check_state  A pointer to the online check
+ *                                      state for @a service
+ *                                      associated with @a type.
+ *
+ *  @returns
+ *    False, unconditionally.
+ *
+ *  @sa handle_oneshot_online_check_failure
+ *  @sa handle_online_check_success
+ *
+ */
+static bool handle_oneshot_online_check_success(
+			struct connman_service *service,
+			enum connman_ipconfig_type type,
+			struct online_check_state *online_check_state)
+{
+	const bool reschedule = true;
+
+	/*
+	 * Simply log the success, mark the service IP configuration state
+	 * as ONLINE, and return.
+	 */
+	online_check_log_success(service, type);
+
+	__connman_service_ipconfig_indicate_state(service,
+		CONNMAN_SERVICE_STATE_ONLINE,
+		type);
+
+	return !reschedule;
+}
+
+/**
+ *  @brief
+ *    Handle the successful completion of an "online" HTTP-based
+ *    Internet reachability check for the specified network service
+ *    and IP configuration type for the "continuous" online check mode.
+ *
+ *  This handles the completion of a successful "online" HTTP-based
+ *  Internet reachability check for the specified network service and
+ *  IP configuration type for the "continuous" online check mode. This
+ *  effectively "bookends" an earlier #__connman_service_wispr_start.
+ *
+ *  @param[in,out]  service             A pointer to the mutable service
+ *                                      for which to handle a
+ *                                      successful previously-requested
+ *                                      online check.
+ *  @param[in]      type                The IP configuration type for
+ *                                      which to handle a successful
+ *                                      previously-requested online
+ *                                      check.
+ *  @param[in,out]  online_check_state  A pointer to the online check
+ *                                      state for @a service
+ *                                      associated with @a type.
+ *
+ *  @returns
+ *    True if another online check should be scheduled; otherwise,
+ *    false.
+ *
+ *  @sa handle_continuous_online_check_failure
+ *  @sa handle_online_check_success
+ *
+ */
+static bool handle_continuous_online_check_success(
+			struct connman_service *service,
+			enum connman_ipconfig_type type,
+			struct online_check_state *online_check_state)
+{
+	bool failures_threshold_was_met;
+	bool successes_threshold_is_met;
+	const bool reschedule = true;
+
+	/* Unconditionally increment and log the success counter. */
+
+	online_check_counter_increment_and_log(service, type,
+		"successes", &online_check_state->successes);
+
+	/*
+	 * Ultimately, for failures, we are looking for a STRING of
+	 * SUSTAINED, BACK-TO-BACK failures to meet the failures
+	 * threshold. Consequently, any success should reset the
+	 * corresponding failure count back to zero (0).
+	 */
+	online_check_counter_reset(&online_check_state->failures);
+
+	failures_threshold_was_met =
+		online_check_failures_threshold_was_met(service);
+	successes_threshold_is_met =
+		online_check_successes_threshold_is_met(service);
+
+	DBG("failures threshold was met %u, "
+		"successes threshold is met %u, "
+		"default %u",
+		failures_threshold_was_met,
+		successes_threshold_is_met,
+		connman_service_is_default(service));
+
+	/*
+	 * If the service HAD previously-exceeded the failure threshold
+	 * AND if this is the first success, then reset the online check
+	 * interval to the initial, minimum value since we want to recover
+	 * as quickly as possible with a STRING of SUSTAINED, BACK-TO-BACK
+	 * successes, where the length of that string is dictated by the
+	 * "OnlineCheckSuccessesThreshold" settings value.
+	 *
+	 * Otherwise, if the service HAD NOT previously-exceeded the
+	 * failure threshold OR if it HAD previously-exceeded the failure
+	 * threshold AND the successes threshold was met, then reset the
+	 * online check interval to the maximum value.
+	 */
+	if (failures_threshold_was_met &&
+		online_check_state->successes == 1)
+		online_check_state->interval = online_check_initial_interval;
+	else if (!failures_threshold_was_met ||
+		(failures_threshold_was_met && successes_threshold_is_met))
+		online_check_state->interval = online_check_max_interval;
+
+	/*
+	 * If the service HAD NOT previously-exceeded the failure
+	 * threshold, then simply mark the service IP configuration state
+	 * as ONLINE.
+	 *
+	 * Otherwise, if the service HAD previously exceeded the failure
+	 * threshold AND successes meet or exceed the configured success
+	 * threshold, then re-sort the network services and update the
+	 * gateways accordingly.
+	 *
+	 * The succeeding service will be promoted until such time as it
+	 * has a configured number of failures, at which time, we will
+	 * resort again.
+	 *
+	 */
+	if (!failures_threshold_was_met) {
+		if (online_check_state->successes == 1)
+			online_check_log_success(service, type);
+
+		if (connman_service_is_default(service))
+			__connman_service_ipconfig_indicate_state(service,
+				CONNMAN_SERVICE_STATE_ONLINE,
+				type);
+	} else if (failures_threshold_was_met &&
+			   successes_threshold_is_met) {
+		online_check_log_success(service, type);
+
+		continuous_online_check_log_successes_threshold_met(service);
+
+		online_check_state_reset(service);
+
+		/*
+		 * The ordering here is considered and intentional. FIRST, now
+		 * that this service has cleared / reset the online check
+		 * state, re-sort the service list. This may promote this
+		 * service back to the default. SECOND, make the READY to
+		 * ONLINE promotion, since that promotion is qualified with
+		 * this service being the default (that is, has the default
+		 * route) service.
+		 */
+		SERVICE_LIST_SORT();
+
+		if (connman_service_is_default(service)) {
+			__connman_service_ipconfig_indicate_state(
+				service,
+				CONNMAN_SERVICE_STATE_ONLINE,
+				type);
+		}
+
+		__connman_gateway_update();
+	}
+
+	return reschedule;
+}
+
+/**
+ *  @brief
+ *    Handle the successful completion of an "online" HTTP-based
+ *    Internet reachability check for the specified network service
+ *    and IP configuration type.
+ *
+ *  This handles the completion of a successful "online" HTTP-based
+ *  Internet reachability check for the specified network service and
+ *  IP configuration type. This effectively "bookends" an earlier
+ *  #__connman_service_wispr_start.
+ *
+ *  @param[in,out]  service             A pointer to the mutable service
+ *                                      for which to handle a
+ *                                      successful previously-requested
+ *                                      online check.
+ *  @param[in]      type                The IP configuration type for
+ *                                      which to handle a successful
+ *                                      previously-requested online
+ *                                      check.
+ *  @param[in,out]  online_check_state  A pointer to the online check
+ *                                      state for @a service
+ *                                      associated with @a type.
+ *  @param[in]      oneshot             A Boolean indicating whether the
+ *                                      online check mode is
+ *                                      "one-shot" (true) or
+ *                                      "continuous" (false).
+ *
+ *  @returns
+ *    True if another online check should be scheduled; otherwise,
+ *    false.
+ *
+ *  @sa handle_online_check_failure
+ *  @sa handle_oneshot_online_check_success
+ *  @sa handle_continuous_online_check_success
+ *
+ */
+static bool handle_online_check_success(struct connman_service *service,
+				enum connman_ipconfig_type type,
+				struct online_check_state *online_check_state,
+				bool oneshot)
+{
+	bool reschedule;
+
+	DBG("service %p (%s) type %d (%s) "
+		"one-shot %u\n",
+		service,
+		connman_service_get_identifier(service),
+		type, __connman_ipconfig_type2string(type),
+		oneshot);
+
+	if (oneshot)
+		reschedule = handle_oneshot_online_check_success(service,
+						type,
+						online_check_state);
+	else
+		reschedule = handle_continuous_online_check_success(service,
+						type,
+						online_check_state);
+
+	return reschedule;
+}
+
+/**
+ *  @brief
+ *    Log an online check failure.
+ *
+ *  This logs an online check failure for the specified network
+ *  service IP configuration type.
+ *
+ *  @param[in]  service  A pointer to the immutable network
+ *                       service for which to log an online
+ *                       check failure.
+ *  @param[in]  type     The IP configuration type for which
+ *                       the online check failed.
+ *  @param[in]  err      The error status, in the POSIX domain,
+ *                       associated with the online check failure.
+ *
+ */
+static void online_check_log_failure(const struct connman_service *service,
+			enum connman_ipconfig_type type,
+			int err)
+{
+	g_autofree char *interface = NULL;
+
+	interface = connman_service_get_interface(service);
+
+	connman_warn("Interface %s [ %s ] %s online check to %s failed: %d: %s",
+		interface,
+		__connman_service_type2string(service->type),
+		__connman_ipconfig_type2string(type),
+		type == CONNMAN_IPCONFIG_TYPE_IPV4 ?
+			connman_setting_get_string("OnlineCheckIPv4URL") :
+			connman_setting_get_string("OnlineCheckIPv6URL"),
+		err,
+		strerror(-err));
+}
+
+/**
+ *  @brief
+ *    Handle the failed completion of an one-shot mode "online"
+ *    HTTP-based Internet reachability check for the specified network
+ *    service and IP configuration type for the "one-shot" online
+ *    check mode.
+ *
+ *  This handles the completion of a failed one-shot mode "online"
+ *  HTTP-based Internet reachability check for the specified network
+ *  service and IP configuration type for the "one-shot" online check
+ *  mode. This effectively "bookends" an earlier
+ *  #__connman_service_wispr_start.
+ *
+ *  This simply indicates that rescheduling another check is desired.
+ *
+ *  @param[in,out]  service             A pointer to the mutable service
+ *                                      for which to handle a
+ *                                      failed previously-requested
+ *                                      online check.
+ *  @param[in]      type                The IP configuration type for
+ *                                      which to handle a failed
+ *                                      previously-requested online
+ *                                      check.
+ *  @param[in]      ipconfig_state      The current @a type IP
+ *                                      configuration state for @a
+ *                                      service.
+ *  @param[in,out]  online_check_state  A pointer to the online check
+ *                                      state for @a service
+ *                                      associated with @a type.
+ *  @param[in]      err                 The error status associated with
+ *                                      the failed previously-requested
+ *                                      online check. This is expected
+ *                                      to be less than zero ('< 0').
+ *
+ *  @returns
+ *    True, unconditionally.
+ *
+ *  @sa handle_online_check_failure
+ *  @sa handle_oneshot_online_check_failure
+ *
+ */
+static bool handle_oneshot_online_check_failure(
+			struct connman_service *service,
+			enum connman_ipconfig_type type,
+			enum connman_service_state ipconfig_state,
+			struct online_check_state *online_check_state,
+			int err)
+{
+	const bool reschedule = true;
+
+	/* Simply indicate rescheduling another check is desired. */
+
+	DBG("online check mode is one-shot; requesting another check");
+
+	return reschedule;
+}
+
+/**
+ *  @brief
+ *    Handle the failed completion of an one-shot mode "online"
+ *    HTTP-based Internet reachability check for the specified network
+ *    service and IP configuration type for the "continuous" online
+ *    check mode.
+ *
+ *  This handles the completion of a failed continuous mode "online"
+ *  HTTP-based Internet reachability check for the specified network
+ *  service and IP configuration type for the "continuous" online check
+ *  mode. This effectively "bookends" an earlier
+ *  #__connman_service_wispr_start.
+ *
+ *  @param[in,out]  service             A pointer to the mutable service
+ *                                      for which to handle a
+ *                                      failed previously-requested
+ *                                      online check.
+ *  @param[in]      type                The IP configuration type for
+ *                                      which to handle a failed
+ *                                      previously-requested online
+ *                                      check.
+ *  @param[in]      ipconfig_state      The current @a type IP
+ *                                      configuration state for @a
+ *                                      service.
+ *  @param[in,out]  online_check_state  A pointer to the online check
+ *                                      state for @a service
+ *                                      associated with @a type.
+ *  @param[in]      err                 The error status associated with
+ *                                      the failed previously-requested
+ *                                      online check. This is expected
+ *                                      to be less than zero ('< 0').
+ *
+ *  @returns
+ *    True if another online check should be scheduled; otherwise,
+ *    false.
+ *
+ *  @sa handle_online_check_failure
+ *  @sa handle_continuous_online_check_failure
+ *
+ */
+static bool handle_continuous_online_check_failure(
+			struct connman_service *service,
+			enum connman_ipconfig_type type,
+			enum connman_service_state ipconfig_state,
+			struct online_check_state *online_check_state,
+			int err)
+{
+	bool reschedule = false;
+
+	/* Unconditionally increment and log the failure counter. */
+
+	online_check_counter_increment_and_log(service, type,
+		"failures", &online_check_state->failures);
+
+	/*
+	 * Ultimately, for successes, we are looking for a STRING of
+	 * SUSTAINED, BACK-TO-BACK successes to meet the successes
+	 * threshold. Consequently, any failure should reset the
+	 * corresponding success count back to zero (0).
+	 */
+	online_check_counter_reset(&online_check_state->successes);
+
+	/*
+	 * If this is the first failure, then reset the online check
+	 * interval to the initial, minimum value. Subsequent failures
+	 * will increment the interval on reschedule from here until the
+	 * maximum interval is hit.
+	 */
+	if (online_check_state->failures == 1)
+		online_check_state->interval = online_check_initial_interval;
+
+	DBG("failures threshold was met %u failures threshold is met %u "
+		"default %u",
+		online_check_failures_threshold_was_met(service),
+		online_check_failures_threshold_is_met(service),
+		connman_service_is_default(service));
+
+	/*
+	 * If the service HAD NOT previously-exceeded the failure
+	 * threshold AND failures meet or exceed the configured failure
+	 * threshold, then:
+	 *
+	 *	  1. Assert the failure threshold state.
+	 *	  2. Reset the success counters.
+	 *	  3. Attempt to downgrade the service IP configuration state
+	 *		 from ONLINE to READY.
+	 *	  4. Re-sort the network services.
+	 *	  5. Update the gateways accordingly.
+	 *
+	 * The failing service will be demoted until such time as it has a
+	 * configured number of successes, at which time, we will resort
+	 * again.
+	 *
+	 */
+	if (!online_check_failures_threshold_was_met(service) &&
+		online_check_failures_threshold_is_met(service)) {
+		online_check_failures_threshold_was_met_set(service);
+
+		continuous_online_check_log_failures_threshold_met(service);
+
+		online_check_successes_reset(service);
+
+		/*
+		 * Attempt to downgrade the service state from ONLINE to
+		 * READY.
+		 *
+		 * We attempt BOTH IPv4 and IPv6 IP configuration states since
+		 * the #online_check_failures_threshold_is_met predicate tells
+		 * us that both IP configurations have met the failures
+		 * threshold.
+		 */
+		service_downgrade_online_state(service);
+
+		set_error(service, CONNMAN_SERVICE_ERROR_ONLINE_CHECK_FAILED);
+
+		SERVICE_LIST_SORT();
+
+		__connman_gateway_update();
+	}
+
+	DBG("failures threshold was met %u, default %u",
+		online_check_failures_threshold_was_met(service),
+		connman_service_is_default(service));
+
+	/*
+	 * We only want to reschedule future online checks for
+	 * the default service or those that are in failure.
+	 */
+	if (connman_service_is_default(service) ||
+		online_check_failures_threshold_was_met(service))
+		reschedule = true;
+
+	return reschedule;
+}
+
+/**
+ *  @brief
+ *    Handle the failed completion of an "online" HTTP-based
+ *    Internet reachability check for the specified network service
+ *    and IP configuration type.
+ *
+ *  This handles the completion of a failed "online" HTTP-based
+ *  Internet reachability check for the specified network service and
+ *  IP configuration type. This effectively "bookends" an earlier
+ *  #__connman_service_wispr_start.
+ *
+ *  @param[in,out]  service             A pointer to the mutable service
+ *                                      for which to handle a
+ *                                      failed previously-requested
+ *                                      online check.
+ *  @param[in]      type                The IP configuration type for
+ *                                      which to handle a failed
+ *                                      previously-requested online
+ *                                      check.
+ *  @param[in]      ipconfig_state      The current @a type IP
+ *                                      configuration state for @a
+ *                                      service.
+ *  @param[in,out]  online_check_state  A pointer to the online check
+ *                                      state for @a service
+ *                                      associated with @a type.
+ *  @param[in]      oneshot             A Boolean indicating whether the
+ *                                      online check mode is
+ *                                      "one-shot" (true) or
+ *                                      "continuous" (false).
+ *  @param[in]      err                 The error status associated with
+ *                                      the failed previously-requested
+ *                                      online check. This is expected
+ *                                      to be less than zero ('< 0').
+ *
+ *  @returns
+ *    True if another online check should be scheduled; otherwise,
+ *    false.
+ *
+ *  @sa handle_online_check_success
+ *  @sa handle_oneshot_online_check_failure
+ *  @sa handle_continuous_online_check_failure
+ *
+ */
+static bool handle_online_check_failure(struct connman_service *service,
+				enum connman_ipconfig_type type,
+				enum connman_service_state ipconfig_state,
+				struct online_check_state *online_check_state,
+				bool oneshot,
+				int err)
+{
+	bool reschedule = false;
+
+	DBG("service %p (%s) type %d (%s) state %d (%s) "
+		"one-shot %u err %d (%s)\n",
+		service,
+		connman_service_get_identifier(service),
+		type, __connman_ipconfig_type2string(type),
+		ipconfig_state, state2string(ipconfig_state),
+		oneshot, err, strerror(-err));
+
+	/*
+	 * Regardless of online check mode, if this completion closure
+	 * was a failure with error status -ECANCELED, then it was canceled
+	 * by #__connman_wispr_cancel. Simply ignore it and DO NOT indicate
+	 * rescheduling another check is desired.
+	 */
+	if (err == -ECANCELED) {
+		DBG("online check was canceled; no action taken");
+
+		goto done;
+	}
+
+	/* Unconditionally log the failure, regardless of online check mode. */
+
+	online_check_log_failure(service, type, err);
+
+	/* Handle the failure according to the online check mode. */
+
+	if (oneshot)
+		reschedule = handle_oneshot_online_check_failure(
+						service,
+						type,
+						ipconfig_state,
+						online_check_state,
+						err);
+	else
+		reschedule = handle_continuous_online_check_failure(
+						service,
+						type,
+						ipconfig_state,
+						online_check_state,
+						err);
+
+done:
+	return reschedule;
+}
+
+/**
+ *  @brief
+ *    This completes an "online" HTTP-based Internet reachability
+ *    check for the specified network service and IP configuration
+ *    type.
+ *
+ *  This completes a failed or successful "online" HTTP-based Internet
+ *  reachability check for the specified network service and IP
+ *  configuration type. This effectively "bookends" an earlier
+ *  #__connman_service_wispr_start.
+ *
+ *  If "OnlineCheckMode" is "one-shot" and if @a success is asserted,
+ *  then the state for the specified IP configuration type is
+ *  transitioned to "online" and a future online check is scheduled
+ *  based on the current interval and the "OnlineCheckIntervalStyle"
+ *  setting.
+ *
+ *  Otherwise, if "OnlineCheckMode" is "continuous", then counters are
+ *  managed for the success or failure and state is managed and
+ *  tracked resulting in the potential demotion of the service,
+ *  placing it into a temporary failure state until such time as a
+ *  series of back-to-back online checks successfully complete. If the
+ *  service is a non-default after demotion and it is in failure state
+ *  or if it is the default service, then a future online check is
+ *  scheduled based on the current interval and the
+ *  "OnlineCheckIntervalStyle" setting.
+ *
+ *  @param[in,out]  service  A pointer to the mutable service for which
+ *                           to complete a previously-requested online
+ *                           check.
+ *  @param[in]      type     The IP configuration type for which to
+ *                           complete a previously-requested online
+ *                           check.
+ *  @param[in]      success  A Boolean indicating whether the previously-
+ *                           requested online check was successful.
+ *  @param[in]      err      The error status associated with previously-
+ *                           requested online check. This is expected
+ *                           to be zero ('0') if @a success is @a true
+ *                           and less than zero ('< 0') if @a success
+ *                           is @a false.
+ *
+ *  @sa cancel_online_check
+ *  @sa start_online_check
+ *  @sa start_online_check_if_connected
+ *  @sa __connman_service_wispr_start
+ *  @sa handle_online_check_success
+ *  @sa handle_online_check_failure
+ *  @sa reschedule_online_check
+ *
+ */
+static void complete_online_check(struct connman_service *service,
+					enum connman_ipconfig_type type,
+					bool success,
+					int err)
+{
+	const bool oneshot = __connman_service_is_online_check_mode(
+		CONNMAN_SERVICE_ONLINE_CHECK_MODE_ONE_SHOT);
+	struct online_check_state *online_check_state;
+	enum connman_service_state ipconfig_state;
+	bool reschedule = false;
+
+	DBG("service %p (%s) type %d (%s) "
+		"success %u err %d (%s)\n",
+		service,
+		connman_service_get_identifier(service),
+		type, __connman_ipconfig_type2string(type),
+		success, err, strerror(-err));
+
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV4) {
+		online_check_state = &service->online_check_state_ipv4;
+		ipconfig_state = service->state_ipv4;
+	} else if (type == CONNMAN_IPCONFIG_TYPE_IPV6) {
+		online_check_state = &service->online_check_state_ipv6;
+		ipconfig_state = service->state_ipv6;
+	} else
+		return;
+
+	if (success)
+		reschedule = handle_online_check_success(service,
+					 type,
+					 online_check_state,
+					 oneshot);
+	else
+		reschedule = handle_online_check_failure(service,
+					 type,
+					 ipconfig_state,
+					 online_check_state,
+					 oneshot,
+					 err);
+
+	DBG("reschedule online check %u", reschedule);
+
+	if (reschedule)
+		reschedule_online_check(service, type, online_check_state);
+	else
+		online_check_active_clear(service, type);
+}
+
+/**
+ *  @brief
+ *    Start HTTP-based Internet reachability probes if the specified
+ *    service is connected.
+ *
+ *  This attempts to start IPv4 or IPv6 HTTP-based Internet
+ *  reachability probes if the IPv4 state or IPv6 state is connected
+ *  (that is, "ready" or "online") and if the online check state is
+ *  not already active for the specified network service IP
+ *  configuration type.
+ *
+ *  @param[in,out]  service  A pointer to a mutable service on which
+ *                           to start "online" HTTP-based Internet
+ *                           reachability checks if the IP
+ *                           configuration state associated with @a
+ *                           type is "connected" (that is, "ready" or
+ *                           "online").
+ *  @param[in]      type     The IP configuration type for which to
+ *                           start the "online" HTTP-based Internet
+ *                           reachability checks.
+ *
+ *  @retval  0          If successful.
+ *  @retval  -EINVAL    If @a service is null or @a type is invalid.
+ *  @retval  -EPERM     If online checks are disabled via
+ *                      configuration.
+ *  @retval  -ENOTCONN  If @a service is not "connected" (that is,
+ *                      "ready" or "online").
+ *  @retval  -EALREADY  If online checks are already active for @a
+ *                      service.
+ *
+ *  @sa start_online_check
+ *  @sa start_online_check_if_connected_with_type
+ *
+ */
+static int start_online_check_if_connected_with_type(
+					struct connman_service *service,
+					enum connman_ipconfig_type type)
+{
+	int status = 0;
+
+	switch (type) {
+	case CONNMAN_IPCONFIG_TYPE_IPV4:
+	case CONNMAN_IPCONFIG_TYPE_IPV6:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (!__connman_service_is_connected_state(service, type))
+		status = -ENOTCONN;
+	else
+		status = __connman_service_wispr_start(service, type);
+
+	return status;
+}
+
+/**
+ *  @brief
+ *    Start HTTP-based Internet reachability probes if the specified
+ *    service is connected.
+ *
+ *  This attempts to start IPv4 and/or IPv6 HTTP-based Internet
+ *  reachability probes if the IPv4 state or IPv6 state is connected
+ *  (that is, "ready" or "online").
+ *
+ *  @param[in,out]  service  A pointer to a mutable service on which
+ *                           to start "online" HTTP-based Internet
+ *                           reachability checks if the IPv4 or IPv6
+ *                           state is "connected" (that is, "ready" or
+ *                           "online").
+ *
+ *  @retval  0          If successful.
+ *  @retval  -EINVAL    If @a service is null or @a type is invalid.
+ *  @retval  -EPERM     If online checks are disabled via
+ *                      configuration.
+ *  @retval  -ENOTCONN  If @a service is not "connected" (that is,
+ *                      "ready" or "online").
+ *  @retval  -EALEADY   If online checks are already active for @a
+ *                      service.
+ *
+ *  @sa start_online_check
+ *  @sa start_online_check_if_connected_with_type
+ *
+ */
+static int start_online_check_if_connected(struct connman_service *service)
 {
-	int index;
+	int status4 = 0, status6 = 0;
+
+	DBG("service %p (%s) state4 %d (%s) state6 %d (%s) maybe start WISPr",
+		service,
+		connman_service_get_identifier(service),
+		service->state_ipv4, state2string(service->state_ipv4),
+		service->state_ipv6, state2string(service->state_ipv6));
 
 	if (!service)
-		return;
+		return -EINVAL;
 
-	index = __connman_service_get_index(service);
+	if (!online_check_is_enabled_check(service))
+		return -EPERM;
 
-	if (service->nameservers_config) {
-		/*
-		 * Configured nameserver takes preference over the
-		 * discoverd nameserver gathered from DHCP, VPN, etc.
-		 */
-		nameserver_add_routes(index, service->nameservers_config, gw);
-	} else if (service->nameservers) {
-		/*
-		 * We add nameservers host routes for nameservers that
-		 * are not on our subnet. For those who are, the subnet
-		 * route will be installed by the time the dns proxy code
-		 * tries to reach them. The subnet route is installed
-		 * when setting the interface IP address.
-		 */
-		nameserver_add_routes(index, service->nameservers, gw);
-	}
+	status4 = start_online_check_if_connected_with_type(service,
+			CONNMAN_IPCONFIG_TYPE_IPV4);
+
+	status6 = start_online_check_if_connected_with_type(service,
+			CONNMAN_IPCONFIG_TYPE_IPV6);
+
+	DBG("status4 %d (%s) status6 %d (%s)",
+		status4, strerror(-status4),
+		status6, strerror(-status6));
+
+	return (status4 < 0 ? status4 : status6);
 }
 
-void __connman_service_nameserver_del_routes(struct connman_service *service,
+/**
+ *  @brief
+ *    Start an "online" HTTP-based Internet reachability check for the
+ *    specified network service IP configuration type.
+ *
+ *  This attempts to start an "online" HTTP-based Internet
+ *  reachability check for the specified network service IP
+ *  configuration type.
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           for which to start the "online"
+ *                           reachability check.
+ *  @param[in]      type     The IP configuration type for which the
+ *                           "online" reachability check is to be
+ *                           started.
+ *
+ *  @retval  0          If successful.
+ *  @retval  -EINVAL    If @a service is null or @a type is invalid.
+ *  @retval  -EALREADY  If online checks are already active for @a
+ *                      service.
+ *
+ *  @sa cancel_online_check
+ *  @sa start_online_check
+ *  @sa complete_online_check
+ *  @sa start_online_check_if_connected
+ *
+ */
+int __connman_service_wispr_start(struct connman_service *service,
 					enum connman_ipconfig_type type)
 {
-	int index;
+	DBG("service %p (%s) type %d (%s)",
+		service,
+		connman_service_get_identifier(service),
+		type, __connman_ipconfig_type2string(type));
 
 	if (!service)
-		return;
+		return -EINVAL;
 
-	index = __connman_service_get_index(service);
+	switch (type) {
+	case CONNMAN_IPCONFIG_TYPE_IPV4:
+	case CONNMAN_IPCONFIG_TYPE_IPV6:
+		break;
+	default:
+		return -EINVAL;
+	}
 
-	if (service->nameservers_config)
-		nameserver_del_routes(index, service->nameservers_config,
-					type);
-	else if (service->nameservers)
-		nameserver_del_routes(index, service->nameservers, type);
-}
+	if (online_check_is_active(service, type))
+		return -EALREADY;
 
-static bool check_proxy_setup(struct connman_service *service)
-{
 	/*
-	 * We start WPAD if we haven't got a PAC URL from DHCP and
-	 * if our proxy manual configuration is either empty or set
-	 * to AUTO with an empty URL.
+	 * At this particular entry point, we assume to be starting an
+	 * "online" HTTP-based Internet reachability check
+	 * afresh. Consequently, set the check interval to initial.
 	 */
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
+		service->online_check_state_ipv4.interval =
+					online_check_initial_interval;
+	else if (type == CONNMAN_IPCONFIG_TYPE_IPV6)
+		service->online_check_state_ipv6.interval =
+					online_check_initial_interval;
 
-	if (service->proxy != CONNMAN_SERVICE_PROXY_METHOD_UNKNOWN)
-		return true;
-
-	if (service->proxy_config != CONNMAN_SERVICE_PROXY_METHOD_UNKNOWN &&
-		(service->proxy_config != CONNMAN_SERVICE_PROXY_METHOD_AUTO ||
-			service->pac))
-		return true;
-
-	if (__connman_wpad_start(service) < 0) {
-		service->proxy = CONNMAN_SERVICE_PROXY_METHOD_DIRECT;
-		__connman_notifier_proxy_changed(service);
-		return true;
-	}
-
-	return false;
-}
+	__connman_wispr_start(service, type,
+			online_check_connect_timeout_ms, complete_online_check);
 
-static void cancel_online_check(struct connman_service *service)
-{
-	if (service->online_timeout_ipv4) {
-		g_source_remove(service->online_timeout_ipv4);
-		service->online_timeout_ipv4 = 0;
-		connman_service_unref(service);
-	}
-	if (service->online_timeout_ipv6) {
-		g_source_remove(service->online_timeout_ipv6);
-		service->online_timeout_ipv6 = 0;
-		connman_service_unref(service);
-	}
-}
+	/* Mark the online check state as active. */
 
-static void start_online_check(struct connman_service *service,
-				enum connman_ipconfig_type type)
-{
-	if (!connman_setting_get_bool("EnableOnlineCheck")) {
-		connman_info("Online check disabled. "
-			"Default service remains in READY state.");
-		return;
-	}
-	enable_online_to_ready_transition =
-		connman_setting_get_bool("EnableOnlineToReadyTransition");
-	online_check_initial_interval =
-		connman_setting_get_uint("OnlineCheckInitialInterval");
-	online_check_max_interval =
-		connman_setting_get_uint("OnlineCheckMaxInterval");
+	online_check_active_set(service, type);
 
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV6 || check_proxy_setup(service)) {
-		cancel_online_check(service);
-		__connman_service_wispr_start(service, type);
-	}
+	return 0;
 }
 
+/**
+ *  @brief
+ *    Handle an update to the address(es) for the specified network
+ *    service and IP configuration type.
+ *
+ *  This attempts to handle an address change or update for the
+ *  specified network service and IP configuration type if and only if
+ *  it is connected (that is, #is_connected returns true) and it is
+ *  the default service (that is, has the default route).
+ *
+ *  If the service meets those criteria, then nameservers are
+ *  refreshed, an "online" HTTP-based Internet reachability check is
+ *  initiated, and a time-of-day synchronization is requested.
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           for which there was an address change or
+ *                           update.
+ *  @param[in]      type     The IP configuration type for @a service
+ *                           for which there was an address change or
+ *                           update.
+ *
+ *  @sa nameserver_remove_all
+ *  @sa nameserver_add_all
+ *  @sa start_online_check
+ *  @sa __connman_timeserver_sync
+ *
+ */
 static void address_updated(struct connman_service *service,
 			enum connman_ipconfig_type type)
 {
+	DBG("service %p (%s) type %d (%s)",
+		service,
+		connman_service_get_identifier(service),
+		type, __connman_ipconfig_type2string(type));
+
 	if (is_connected(service->state) &&
-			service == connman_service_get_default()) {
+			connman_service_is_default(service)) {
 		nameserver_remove_all(service, type);
 		nameserver_add_all(service, type);
 		start_online_check(service, type);
@@ -1575,6 +4100,18 @@ static void reset_stats(struct connman_service *service)
 	g_timer_reset(service->stats_roaming.timer);
 }
 
+/**
+ *  @brief
+ *    Return the default service, if any.
+ *
+ *  This attempts to return a pointer to the default service (that is,
+ *  the service with the default route), if any.
+ *
+ *  @returns
+ *    A pointer to the mutable default service, if one exists;
+ *    otherwise, null.
+ *
+ */
 struct connman_service *connman_service_get_default(void)
 {
 	struct connman_service *service;
@@ -1582,6 +4119,9 @@ struct connman_service *connman_service_get_default(void)
 	if (!service_list)
 		return NULL;
 
+	// Sorting is such that the default service is ALWAYS at the
+	// head of the service list, if one exists.
+
 	service = service_list->data;
 
 	if (!is_connected(service->state))
@@ -1590,6 +4130,51 @@ struct connman_service *connman_service_get_default(void)
 	return service;
 }
 
+/**
+ *  @brief
+ *    Determine whether the specified service is the default service.
+ *
+ *  This determines whether the specified service is the default
+ *  service (that is, the service with the default route).
+ *
+ *  @param[in]  service  A pointer to the immutable service for which
+ *                       to determine whether it is the default
+ *                       network service.
+ *  @returns
+ *    True if the specified service is the default network service;
+ *    otherwise, false.
+ *
+ *  @sa connman_service_get_default
+ *
+ */
+static bool connman_service_is_default(const struct connman_service *service)
+{
+	if (!service)
+		return false;
+
+	return connman_service_get_default() == service;
+}
+
+/**
+ *  @brief
+ *    Determine whether the specified network interface index belongs
+ *    to the default service.
+ *
+ *  This determines whether or not the specified network interface
+ *  index belongs to the default service (that is, the service with
+ *  the default route).
+ *
+ *  @param[in]  index  The network interface to determine whether it
+ *                     belongs to the default service.
+ *
+ *  @returns
+ *    True if the specified index belongs to the default service;
+ *    otherwise, false.
+ *
+ *  @sa connman_service_get_default
+ *  @sa __connman_service_get_index
+ *
+ */
 bool __connman_service_index_is_default(int index)
 {
 	struct connman_service *service;
@@ -1602,41 +4187,65 @@ bool __connman_service_index_is_default(int index)
 	return __connman_service_get_index(service) == index;
 }
 
-static void start_wispr_when_connected(struct connman_service *service)
+static void service_log_default(const struct connman_service *service)
 {
-	if (!connman_setting_get_bool("EnableOnlineCheck")) {
-		connman_info("Online check disabled. "
-			"Default service remains in READY state.");
-		return;
-	}
+	g_autofree char *interface = NULL;
 
-	if (__connman_service_is_connected_state(service,
-			CONNMAN_IPCONFIG_TYPE_IPV4))
-		__connman_service_wispr_start(service,
-					CONNMAN_IPCONFIG_TYPE_IPV4);
+	interface = connman_service_get_interface(service);
 
-	if (__connman_service_is_connected_state(service,
-			CONNMAN_IPCONFIG_TYPE_IPV6))
-		__connman_service_wispr_start(service,
-					CONNMAN_IPCONFIG_TYPE_IPV6);
+	connman_info("Interface %s [ %s ] is the default",
+		interface,
+		__connman_service_type2string(service->type));
 }
 
-static void default_changed(void)
+static void default_changed(const char *function)
 {
 	struct connman_service *service = connman_service_get_default();
 
+	DBG("from %s()", function);
+
 	if (service == current_default)
 		return;
 
-	DBG("current default %p %s", current_default,
-		current_default ? current_default->identifier : "");
-	DBG("new default %p %s", service, service ? service->identifier : "");
+	DBG("current default %p (%s)", current_default,
+		connman_service_get_identifier(current_default));
+	DBG("new default %p (%s)", service, connman_service_get_identifier(service));
 
 	__connman_service_timeserver_changed(current_default, NULL);
 
+	/*
+	 * If there is a current default service, then it may either have
+	 * been temporarily:
+	 *
+	 *	 1. promoted as a failover from another senior service that
+	 *		was temporarily demoted
+	 *	 2. demoted as a failover to another junior service that is
+	 *		being temporarily promoted
+	 *
+	 * due to a continuous mode online check failure.
+	 *
+	 * Regardless, only services in online check failure or the default
+	 * service should be running online checks and only the default
+	 * service should be online. Consequently, make the appropriate
+	 * calls on the current default to ensure that is the case BEFORE
+	 * assigning the proposed new default as the current default.
+	 */
+	if (current_default) {
+		if (!online_check_failures_threshold_was_met(current_default) &&
+			current_default->error !=
+				CONNMAN_SERVICE_ERROR_ONLINE_CHECK_FAILED) {
+			cancel_online_check(current_default,
+				CONNMAN_IPCONFIG_TYPE_ALL);
+
+			service_downgrade_online_state(current_default);
+		}
+	}
+
 	current_default = service;
 
 	if (service) {
+		service_log_default(service);
+
 		if (service->hostname &&
 				connman_setting_get_bool("AllowHostnameUpdates"))
 			__connman_utsname_set_hostname(service->hostname);
@@ -1645,7 +4254,7 @@ static void default_changed(void)
 				connman_setting_get_bool("AllowDomainnameUpdates"))
 			__connman_utsname_set_domainname(service->domainname);
 
-		start_wispr_when_connected(service);
+		start_online_check_if_connected(service);
 
 		/*
 		 * Connect VPN automatically when new default service
@@ -1661,10 +4270,24 @@ static void default_changed(void)
 	__connman_notifier_default_changed(service);
 }
 
+static void service_log_state(const struct connman_service *service)
+{
+	g_autofree char *interface = NULL;
+
+	interface = connman_service_get_interface(service);
+
+	connman_info("Interface %s [ %s ] state is %s",
+		interface,
+		__connman_service_type2string(service->type),
+		state2string(service->state));
+}
+
 static void state_changed(struct connman_service *service)
 {
 	const char *str;
 
+	service_log_state(service);
+
 	__connman_notifier_service_state_changed(service, service->state);
 
 	str = state2string(service->state);
@@ -2635,8 +5258,7 @@ static void append_properties(DBusMessageIter *dict, dbus_bool_t limited,
 	connman_dbus_dict_append_array(dict, "Nameservers.Configuration",
 				DBUS_TYPE_STRING, append_dnsconfig, service);
 
-	if (service->state == CONNMAN_SERVICE_STATE_READY ||
-			service->state == CONNMAN_SERVICE_STATE_ONLINE)
+	if (is_connected(service->state))
 		list = __connman_timeserver_get_all(service);
 	else
 		list = NULL;
@@ -2717,13 +5339,13 @@ void __connman_service_list_struct(DBusMessageIter *iter)
 	g_list_foreach(service_list, append_struct, iter);
 }
 
-bool __connman_service_is_hidden(struct connman_service *service)
+bool __connman_service_is_hidden(const struct connman_service *service)
 {
 	return service->hidden;
 }
 
 bool
-__connman_service_is_split_routing(struct connman_service *service)
+__connman_service_is_split_routing(const struct connman_service *service)
 {
 	return service->do_split_routing;
 }
@@ -2742,7 +5364,7 @@ bool __connman_service_index_is_split_routing(int index)
 	return __connman_service_is_split_routing(service);
 }
 
-int __connman_service_get_index(struct connman_service *service)
+int __connman_service_get_index(const struct connman_service *service)
 {
 	if (!service)
 		return -1;
@@ -2776,7 +5398,7 @@ void __connman_service_set_hostname(struct connman_service *service,
 		service->hostname = g_strdup(hostname);
 }
 
-const char *__connman_service_get_hostname(struct connman_service *service)
+const char *__connman_service_get_hostname(const struct connman_service *service)
 {
 	if (!service)
 		return NULL;
@@ -2799,7 +5421,7 @@ void __connman_service_set_domainname(struct connman_service *service,
 	domain_changed(service);
 }
 
-const char *connman_service_get_domainname(struct connman_service *service)
+const char *connman_service_get_domainname(const struct connman_service *service)
 {
 	if (!service)
 		return NULL;
@@ -2810,7 +5432,7 @@ const char *connman_service_get_domainname(struct connman_service *service)
 		return service->domainname;
 }
 
-const char *connman_service_get_dbuspath(struct connman_service *service)
+const char *connman_service_get_dbuspath(const struct connman_service *service)
 {
 	if (!service)
 		return NULL;
@@ -2818,7 +5440,7 @@ const char *connman_service_get_dbuspath(struct connman_service *service)
 	return service->path;
 }
 
-char **connman_service_get_nameservers(struct connman_service *service)
+char **connman_service_get_nameservers(const struct connman_service *service)
 {
 	if (!service)
 		return NULL;
@@ -2852,25 +5474,44 @@ char **connman_service_get_nameservers(struct connman_service *service)
 	return g_strdupv(connman_setting_get_string_list("FallbackNameservers"));
 }
 
-char **connman_service_get_timeservers_config(struct connman_service *service)
+const char * const *connman_service_get_timeservers_config(const struct connman_service *service)
 {
 	if (!service)
 		return NULL;
 
-	return service->timeservers_config;
+	return (const char * const *)service->timeservers_config;
 }
 
-char **connman_service_get_timeservers(struct connman_service *service)
+const char * const *connman_service_get_timeservers(const struct connman_service *service)
 {
 	if (!service)
 		return NULL;
 
-	return service->timeservers;
+	return (const char * const *)service->timeservers;
 }
 
+/**
+ *  @brief
+ *    Set the web proxy method of the specified service.
+ *
+ *  This attempts to set the web proxy method of the specified service
+ *  but will fail to do so if @a service is null or is hidden.
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           for which to set the web proxy method.
+ *  @param[in]      method   The web proxy method to set.
+ *
+ *  @sa proxy_changed
+ *  @sa __connman_notifier_proxy_changed
+ *
+ */
 void connman_service_set_proxy_method(struct connman_service *service,
 					enum connman_service_proxy_method method)
 {
+	DBG("service %p (%s) method %d (%s)",
+		service, connman_service_get_identifier(service),
+		method, proxymethod2string(method));
+
 	if (!service || service->hidden)
 		return;
 
@@ -2883,7 +5524,7 @@ void connman_service_set_proxy_method(struct connman_service *service,
 }
 
 enum connman_service_proxy_method connman_service_get_proxy_method(
-					struct connman_service *service)
+					const struct connman_service *service)
 {
 	if (!service)
 		return CONNMAN_SERVICE_PROXY_METHOD_UNKNOWN;
@@ -2909,7 +5550,7 @@ char **connman_service_get_proxy_excludes(struct connman_service *service)
 	return g_strdupv(service->excludes);
 }
 
-const char *connman_service_get_proxy_url(struct connman_service *service)
+const char *connman_service_get_proxy_url(const struct connman_service *service)
 {
 	if (!service)
 		return NULL;
@@ -3044,8 +5685,10 @@ int __connman_service_timeserver_remove(struct connman_service *service,
 	for (i = 0, j = 0; i < len; i++) {
 		if (g_strcmp0(service->timeservers[i], timeserver) != 0) {
 			servers[j] = g_strdup(service->timeservers[i]);
-			if (!servers[j])
+			if (!servers[j]) {
+				g_strfreev(servers);
 				return -ENOMEM;
+			}
 			j++;
 		}
 	}
@@ -3082,96 +5725,6 @@ void __connman_service_set_pac(struct connman_service *service,
 	proxy_changed(service);
 }
 
-void __connman_service_set_identity(struct connman_service *service,
-					const char *identity)
-{
-	if (service->immutable || service->hidden)
-		return;
-
-	g_free(service->identity);
-	service->identity = g_strdup(identity);
-
-	if (service->network)
-		connman_network_set_string(service->network,
-					"WiFi.Identity",
-					service->identity);
-}
-
-void __connman_service_set_anonymous_identity(struct connman_service *service,
-						const char *anonymous_identity)
-{
-	if (service->immutable || service->hidden)
-		return;
-
-	g_free(service->anonymous_identity);
-	service->anonymous_identity = g_strdup(anonymous_identity);
-
-	if (service->network)
-		connman_network_set_string(service->network,
-					"WiFi.AnonymousIdentity",
-					service->anonymous_identity);
-}
-
-void __connman_service_set_subject_match(struct connman_service *service,
-						const char *subject_match)
-{
-	if (service->immutable || service->hidden)
-		return;
-
-	g_free(service->subject_match);
-	service->subject_match = g_strdup(subject_match);
-
-	if (service->network)
-		connman_network_set_string(service->network,
-					"WiFi.SubjectMatch",
-					service->subject_match);
-}
-
-void __connman_service_set_altsubject_match(struct connman_service *service,
-						const char *altsubject_match)
-{
-	if (service->immutable || service->hidden)
-		return;
-
-	g_free(service->altsubject_match);
-	service->altsubject_match = g_strdup(altsubject_match);
-
-	if (service->network)
-		connman_network_set_string(service->network,
-					"WiFi.AltSubjectMatch",
-					service->altsubject_match);
-}
-
-void __connman_service_set_domain_suffix_match(struct connman_service *service,
-						const char *domain_suffix_match)
-{
-	if (service->immutable || service->hidden)
-		return;
-
-	g_free(service->domain_suffix_match);
-	service->domain_suffix_match = g_strdup(domain_suffix_match);
-
-	if (service->network)
-		connman_network_set_string(service->network,
-					"WiFi.DomainSuffixMatch",
-					service->domain_suffix_match);
-}
-
-void __connman_service_set_domain_match(struct connman_service *service,
-						const char *domain_match)
-{
-	if (service->immutable || service->hidden)
-		return;
-
-	g_free(service->domain_match);
-	service->domain_match = g_strdup(domain_match);
-
-	if (service->network)
-		connman_network_set_string(service->network,
-					"WiFi.DomainMatch",
-					service->domain_match);
-}
-
 void __connman_service_set_agent_identity(struct connman_service *service,
 						const char *agent_identity)
 {
@@ -3241,9 +5794,6 @@ int __connman_service_check_passphrase(enum connman_service_security security,
 	return 0;
 }
 
-static void set_error(struct connman_service *service,
-					enum connman_service_error error);
-
 int __connman_service_set_passphrase(struct connman_service *service,
 					const char *passphrase)
 {
@@ -3270,12 +5820,12 @@ int __connman_service_set_passphrase(struct connman_service *service,
 
 	if (service->hidden_service &&
 			service->error == CONNMAN_SERVICE_ERROR_INVALID_KEY)
-		set_error(service, CONNMAN_SERVICE_ERROR_UNKNOWN);
+		clear_error(service);
 
 	return 0;
 }
 
-const char *__connman_service_get_passphrase(struct connman_service *service)
+const char *__connman_service_get_passphrase(const struct connman_service *service)
 {
 	if (!service)
 		return NULL;
@@ -3609,21 +6159,6 @@ int __connman_service_reset_ipconfig(struct connman_service *service,
 	return err;
 }
 
-void __connman_service_wispr_start(struct connman_service *service,
-					enum connman_ipconfig_type type)
-{
-	DBG("service %p type %s", service, __connman_ipconfig_type2string(type));
-
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
-		service->online_check_interval_ipv4 =
-					online_check_initial_interval;
-	else
-		service->online_check_interval_ipv6 =
-					online_check_initial_interval;
-
-	__connman_wispr_start(service, type);
-}
-
 static DBusMessage *set_property(DBusConnection *conn,
 					DBusMessage *msg, void *user_data)
 {
@@ -3667,7 +6202,7 @@ static DBusMessage *set_property(DBusConnection *conn,
 			 * have the same effect as user connecting the VPN =
 			 * clear previous error and change state to idle.
 			 */
-			set_error(service, CONNMAN_SERVICE_ERROR_UNKNOWN);
+			clear_error(service);
 
 			if (service->state == CONNMAN_SERVICE_STATE_FAILURE) {
 				service->state = CONNMAN_SERVICE_STATE_IDLE;
@@ -3704,6 +6239,7 @@ static DBusMessage *set_property(DBusConnection *conn,
 
 		if (gw && strlen(gw))
 			__connman_service_nameserver_del_routes(service,
+						gw,
 						CONNMAN_IPCONFIG_TYPE_ALL);
 
 		dbus_message_iter_recurse(&value, &entry);
@@ -3748,7 +6284,7 @@ static DBusMessage *set_property(DBusConnection *conn,
 		nameserver_add_all(service, CONNMAN_IPCONFIG_TYPE_ALL);
 		dns_configuration_changed(service);
 
-		start_wispr_when_connected(service);
+		start_online_check_if_connected(service);
 
 		service_save(service);
 	} else if (g_str_equal(name, "Timeservers.Configuration")) {
@@ -3941,10 +6477,48 @@ static DBusMessage *set_property(DBusConnection *conn,
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
+static void service_log_error(const struct connman_service *service,
+					enum connman_service_error error)
+{
+	g_autofree char *interface = NULL;
+
+	interface = connman_service_get_interface(service);
+
+	connman_warn("Interface %s [ %s ] error \"%s\"",
+		interface,
+		__connman_service_type2string(service->type),
+		error2string(error));
+}
+
+/**
+ *  @brief
+ *    Set the specified network service "Error" property.
+ *
+ *  This sets the specified network service "Error" property to the
+ *  provided value.
+ *
+ *  @note
+ *    This function results in a D-Bus property changed signal for the
+ *    network service "Error" property.
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           for which to set the "Error" property.
+ *  @param[in]      error    The error value to set.
+ *
+ *  @sa clear_error
+ *
+ */
 static void set_error(struct connman_service *service,
 					enum connman_service_error error)
 {
-	const char *str;
+	const char *str = error2string(error);
+
+	if (!str)
+		str = "";
+
+	DBG("service %p (%s) error %d (%s)",
+		service, connman_service_get_identifier(service),
+		error, str);
 
 	if (service->error == error)
 		return;
@@ -3954,19 +6528,41 @@ static void set_error(struct connman_service *service,
 	if (!service->path)
 		return;
 
+	if (error != CONNMAN_SERVICE_ERROR_UNKNOWN)
+		service_log_error(service, error);
+
 	if (!allow_property_changed(service))
 		return;
 
-	str = error2string(service->error);
-
-	if (!str)
-		str = "";
-
 	connman_dbus_property_changed_basic(service->path,
 				CONNMAN_SERVICE_INTERFACE, "Error",
 				DBUS_TYPE_STRING, &str);
 }
 
+/**
+ *  @brief
+ *    Clear or reset the specified network service "Error" property.
+ *
+ *  This sets the specified network service "Error" property to the
+ *  initialization value of #CONNMAN_SERVICE_ERROR_UNKNOWN,
+ *  effectively clearing or resetting the property.
+ *
+ *  @note
+ *    This function results in a D-Bus property changed signal for the
+ *    network service "Error" property.
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           for which to clear or reset the "Error"
+ *                           property.
+ *
+ *  @sa set_error
+ *
+ */
+static void clear_error(struct connman_service *service)
+{
+	set_error(service, CONNMAN_SERVICE_ERROR_UNKNOWN);
+}
+
 static void remove_timeout(struct connman_service *service)
 {
 	if (service->timeout > 0) {
@@ -3983,12 +6579,6 @@ static void reply_pending(struct connman_service *service, int error)
 		connman_dbus_reply_pending(service->pending, error, NULL);
 		service->pending = NULL;
 	}
-
-	if (service->provider_pending) {
-		connman_dbus_reply_pending(service->provider_pending,
-				error, service->path);
-		service->provider_pending = NULL;
-	}
 }
 
 static void service_complete(struct connman_service *service)
@@ -4014,7 +6604,7 @@ static DBusMessage *clear_property(DBusConnection *conn,
 							DBUS_TYPE_INVALID);
 
 	if (g_str_equal(name, "Error")) {
-		set_error(service, CONNMAN_SERVICE_ERROR_UNKNOWN);
+		clear_error(service);
 
 		__connman_service_clear_error(service);
 		service_complete(service);
@@ -4358,7 +6948,7 @@ static gboolean run_vpn_auto_connect(gpointer data) {
 		is_connected(def_service->state))) {
 
 		DBG("stopped, default service %s connected %d",
-			def_service ? def_service->identifier : "NULL",
+			connman_service_get_identifier(def_service),
 			def_service ? is_connected(def_service->state) : -1);
 		goto out;
 	}
@@ -4462,30 +7052,6 @@ static void vpn_auto_connect(void)
 		g_idle_add(run_vpn_auto_connect, NULL);
 }
 
-bool
-__connman_service_is_provider_pending(struct connman_service *service)
-{
-	if (!service)
-		return false;
-
-	if (service->provider_pending)
-		return true;
-
-	return false;
-}
-
-void __connman_service_set_provider_pending(struct connman_service *service,
-							DBusMessage *msg)
-{
-	if (service->provider_pending) {
-		DBG("service %p provider pending msg %p already exists",
-			service, service->provider_pending);
-		return;
-	}
-
-	service->provider_pending = msg;
-}
-
 static void check_pending_msg(struct connman_service *service)
 {
 	if (!service->pending)
@@ -4715,46 +7281,186 @@ static bool check_suitable_state(enum connman_service_state a,
 	return a == b;
 }
 
-static void downgrade_state(struct connman_service *service)
+/**
+ *  @brief
+ *    Downgrade the service IP configuration state from "online" to
+ *    "ready".
+ *
+ *  This attempts to downgrade the specified IP configuration state of
+ *  the specified service to "ready" if it is "online".
+ *
+ *  @param[in,out]  service  A pointer to the mutable service whose IP
+ *                           configuration state, if
+ *                           #CONNMAN_SERVICE_STATE_ONLINE, is to be
+ *                           downgraded to
+ *                           #CONNMAN_SERVICE_STATE_READY.
+ *  @param[in]      state    The current IP configuration state of @a
+ *                           service.
+ *  @param[in]      type     The IP configuration type of @a service to
+ *                           try to downgrade.
+ *
+ *  @returns
+ *    True if the service state was downgraded for the specified IP
+ *    configuration type; otherwise, false.
+ *
+ *  @sa service_downgrade_online_state
+ *  @sa service_downgrade_online_state_if_default
+ *
+ */
+static bool service_ipconfig_downgrade_online_state(
+					struct connman_service *service,
+					enum connman_service_state state,
+					enum connman_ipconfig_type type)
 {
 	if (!service)
-		return;
+		return false;
 
-	DBG("service %p state4 %d state6 %d", service, service->state_ipv4,
-						service->state_ipv6);
+	DBG("service %p (%s) type %d (%s) state %d (%s)",
+		service,
+		connman_service_get_identifier(service),
+		type, __connman_ipconfig_type2string(type),
+		state, state2string(state));
 
-	if (service->state_ipv4 == CONNMAN_SERVICE_STATE_ONLINE)
+	if (is_online(state)) {
 		__connman_service_ipconfig_indicate_state(service,
 						CONNMAN_SERVICE_STATE_READY,
-						CONNMAN_IPCONFIG_TYPE_IPV4);
+						type);
 
-	if (service->state_ipv6 == CONNMAN_SERVICE_STATE_ONLINE)
-		__connman_service_ipconfig_indicate_state(service,
-						CONNMAN_SERVICE_STATE_READY,
-						CONNMAN_IPCONFIG_TYPE_IPV6);
+		return true;
+	}
+
+	return false;
+}
+
+/**
+ *  @brief
+ *    Downgrade the service IPv4 and IPv6 states from "online" to
+ *    "ready".
+ *
+ *  This attempts to downgrade the IPv4 and IPv6 states of the
+ *  specified service to "ready" if they are "online".
+ *
+ *  @param[in,out]  service  A pointer to the mutable service whose IPv4
+ *                           and IPv6 states, if
+ *                           #CONNMAN_SERVICE_STATE_ONLINE, are to be
+ *                           downgraded to
+ *                           #CONNMAN_SERVICE_STATE_READY.
+ *
+ *  @returns
+ *    True if either IPv4 or IPv6 service state was downgraded;
+ *    otherwise, false.
+ *
+ *  @sa service_ipconfig_downgrade_online_state
+ *  @sa service_downgrade_online_state_if_default
+ *
+ */
+static bool service_downgrade_online_state(struct connman_service *service)
+{
+	bool ipv4_downgraded = false;
+	bool ipv6_downgraded = false;
+
+	if (!service)
+		return false;
+
+	DBG("service %p (%s) state4 %d (%s) state6 %d (%s)",
+		service,
+		connman_service_get_identifier(service),
+		service->state_ipv4, state2string(service->state_ipv4),
+		service->state_ipv6, state2string(service->state_ipv6));
+
+	ipv4_downgraded = service_ipconfig_downgrade_online_state(service,
+								 service->state_ipv4,
+								 CONNMAN_IPCONFIG_TYPE_IPV4);
+
+	ipv6_downgraded = service_ipconfig_downgrade_online_state(service,
+								 service->state_ipv6,
+								 CONNMAN_IPCONFIG_TYPE_IPV6);
+
+	return ipv4_downgraded || ipv6_downgraded;
 }
 
-static void apply_relevant_default_downgrade(struct connman_service *service)
+/**
+ *  @brief
+ *    Downgrade the service IPv4 and IPv6 states from "online" to
+ *    "ready" if and only if the service is the default service and it
+ *    is "online".
+ *
+ *  This attempts to downgrade the IPv4 and IPv6 states of the
+ *  specified service to "ready" if and only if the service is the
+ *  default service and its combined service state is "online".
+ *
+ *  @param[in,out]  service  A pointer to the mutable service whose IPv4
+ *                           and IPv6 states, if it is the default
+ *                           service and its combined service state is
+ *                           #CONNMAN_SERVICE_STATE_ONLINE, are to be
+ *                           downgraded to
+ *                           #CONNMAN_SERVICE_STATE_READY.
+ *
+ *  @returns
+ *    True if either IPv4 or IPv6 service state was downgraded;
+ *    otherwise, false.
+ *
+ *  @sa service_ipconfig_downgrade_online_state
+ *  @sa service_downgrade_online_state
+ *
+ */
+static bool service_downgrade_online_state_if_default(struct connman_service *service)
 {
 	struct connman_service *def_service;
 
 	def_service = connman_service_get_default();
 	if (!def_service || def_service != service ||
-		def_service->state != CONNMAN_SERVICE_STATE_ONLINE)
-		return;
+		!is_online(def_service->state))
+		return false;
 
-	downgrade_state(def_service);
+	return service_downgrade_online_state(def_service);
 }
 
-static void switch_default_service(struct connman_service *default_service,
-		struct connman_service *downgrade_service)
+/**
+ *  @brief
+ *    Switch the order of the two specified services in the network
+ *    service list.
+ *
+ *  This attempts to switch the order of the two specified services in
+ *  the ntework service list. This has the side-effect of potentially
+ *  downgrading the state of @a demoted_service from "online" to
+ *  "ready" if it is "online" and is the default service and
+ *  downgrading the state of @a promoted_service from "online" to
+ *  "ready".
+ *
+ *  @note
+ *    If the two services have pointer equivalence or are already in
+ *    the specified order, there is no state downgrade of @a
+ *    promoted_service.
+ *
+ *  @param[in,out]  demoted_service   A pointer to the mutable service
+ *                                    to demote in the network service
+ *                                    list to @b after @a
+ *                                    promoted_service.
+ *  @param[in,out]  promoted_service  A pointer to the mutable service
+ *                                    to promote in the network service
+ *                                    list to @b before @a
+ *                                    demoted_service.
+ *
+ */
+static void switch_service_order(struct connman_service *demoted_service,
+		struct connman_service *promoted_service)
 {
 	struct connman_service *service;
 	GList *src, *dst;
 
-	apply_relevant_default_downgrade(default_service);
-	src = g_list_find(service_list, downgrade_service);
-	dst = g_list_find(service_list, default_service);
+	DBG("demoted_service %p (%s) default %u promoted_sevice %p (%s) default %u",
+		demoted_service,
+		connman_service_get_identifier(demoted_service),
+		connman_service_is_default(demoted_service),
+		promoted_service,
+		connman_service_get_identifier(promoted_service),
+		connman_service_is_default(promoted_service));
+
+	service_downgrade_online_state_if_default(demoted_service);
+
+	src = g_list_find(service_list, promoted_service);
+	dst = g_list_find(service_list, demoted_service);
 
 	/* Nothing to do */
 	if (src == dst || src->next == dst)
@@ -4764,7 +7470,7 @@ static void switch_default_service(struct connman_service *default_service,
 	service_list = g_list_delete_link(service_list, src);
 	service_list = g_list_insert_before(service_list, dst, service);
 
-	downgrade_state(downgrade_service);
+	service_downgrade_online_state(promoted_service);
 }
 
 static struct _services_notify {
@@ -4842,6 +7548,15 @@ static gboolean service_send_changed(gpointer data)
 	return FALSE;
 }
 
+/**
+ *  @brief
+ *    Schedule a D-Bus "ServicesChanged" signal at 100 milliseconds
+ *    from now.
+ *
+ *  @sa service_send_changed
+ *  @sa service_list_sort
+ *
+ */
 static void service_schedule_changed(void)
 {
 	if (services_notify->id != 0)
@@ -4945,11 +7660,11 @@ int __connman_service_move(struct connman_service *service,
 	 * is triggered via downgrading it - if relevant - to state ready.
 	 */
 	if (before)
-		switch_default_service(target, service);
+		switch_service_order(target, service);
 	else
-		switch_default_service(service, target);
+		switch_service_order(service, target);
 
-	__connman_connection_update_gateway();
+	__connman_gateway_update();
 
 	service_schedule_changed();
 
@@ -5013,7 +7728,8 @@ static DBusMessage *reset_counters(DBusConnection *conn,
 
 static void service_schedule_added(struct connman_service *service)
 {
-	DBG("service %p", service);
+	DBG("service %p (%s)",
+		service, connman_service_get_identifier(service));
 
 	g_hash_table_remove(services_notify->remove, service->path);
 	g_hash_table_replace(services_notify->add, service->path, service);
@@ -5082,7 +7798,7 @@ static void service_free(gpointer user_data)
 	struct connman_service *service = user_data;
 	char *path = service->path;
 
-	DBG("service %p", service);
+	DBG("service %p (%s)", service, connman_service_get_identifier(service));
 
 	reply_pending(service, ENOENT);
 
@@ -5094,13 +7810,16 @@ static void service_free(gpointer user_data)
 	__connman_notifier_service_remove(service);
 	service_schedule_removed(service);
 
+	cancel_online_check(service, CONNMAN_IPCONFIG_TYPE_ALL);
+
 	__connman_wispr_stop(service);
+
 	stats_stop(service);
 
 	service->path = NULL;
 
 	if (path) {
-		__connman_connection_update_gateway();
+		__connman_gateway_update();
 
 		g_dbus_unregister_interface(connection, path,
 						CONNMAN_SERVICE_INTERFACE);
@@ -5308,11 +8027,11 @@ void connman_service_unref_debug(struct connman_service *service,
 
 static gint service_compare(gconstpointer a, gconstpointer b);
 
-static gint service_compare_vpn(struct connman_service *a,
-						struct connman_service *b)
+static gint service_compare_vpn(const struct connman_service *a,
+						const struct connman_service *b)
 {
 	struct connman_provider *provider;
-	struct connman_service *service;
+	const struct connman_service *service;
 	struct connman_service *transport;
 	const char *ident;
 	bool reverse;
@@ -5340,8 +8059,35 @@ static gint service_compare_vpn(struct connman_service *a,
 	return service_compare(transport, service);
 }
 
-static gint service_compare_preferred(struct connman_service *service_a,
-					struct connman_service *service_b)
+/**
+ *  @brief
+ *    Compare two network services against the @a
+ *    PreferredTechnologies priority list.
+ *
+ *  This compares the two specified network services, by their
+ *  technology type, against the @a PreferredTechnologies priority
+ *  list.
+ *
+ *  @param[in]  service_a  A pointer to the first immutable service
+ *                         to compare by its technology type with the
+ *                         @a PreferredTechnologies priority list.
+ *  @param[in]  service_b  A pointer to the second immutable service
+ *                         to compare by its technology type with the
+ *                         @a PreferredTechnologies priority list.
+ *
+ *  @retval   0  If the @a PreferredTechnologies configuration is empty
+ *               or if neither service type matches a technology type
+ *               in the @a PreferredTechnologies list.
+ *  @retval  -1  If @a service_a type matches a technology type
+ *               in the @a PreferredTechnologies list and should sort
+ *               @b before @a service_b.
+ *  @retval   1  If @a service_b type matches a technology type
+ *               in the @a PreferredTechnologies list and should sort
+ *               @b before @a service_a.
+ *
+ */
+static gint service_compare_preferred(const struct connman_service *service_a,
+					const struct connman_service *service_b)
 {
 	unsigned int *tech_array;
 	int i;
@@ -5359,10 +8105,37 @@ static gint service_compare_preferred(struct connman_service *service_a,
 	return 0;
 }
 
+/**
+ *  @brief
+ *    Compare two network services against one another.
+ *
+ *  This compares the two specified network services.
+ *
+ *  Services are compared with the following sort criteria:
+ *
+ *    1. State
+ *    2. Favorite status
+ *    3. Type
+ *    4. Strength
+ *    5. Name
+ *
+ *  @param[in]  a  A pointer to the first immutable service
+ *                 to compare.
+ *  @param[in]  b  A pointer to the second immutable service
+ *                 to compare.
+ *
+ *  @retval    0  If service @a a and @a b are equivalent.
+ *  @retval  < 0  If service @a a should sort @b before service @a b.
+ *  @retval  > 0  If service @a b should sort @b before service @a a.
+ *
+ *  @sa service_compare_preferred
+ *  @sa __connman_service_compare
+ *
+ */
 static gint service_compare(gconstpointer a, gconstpointer b)
 {
-	struct connman_service *service_a = (void *) a;
-	struct connman_service *service_b = (void *) b;
+	const struct connman_service *service_a = (const void *) a;
+	const struct connman_service *service_b = (const void *) b;
 	enum connman_service_state state_a, state_b;
 	bool a_connected, b_connected;
 	gint strength;
@@ -5372,9 +8145,31 @@ static gint service_compare(gconstpointer a, gconstpointer b)
 	a_connected = is_connected(state_a);
 	b_connected = is_connected(state_b);
 
+	/*
+	 * If both services are connected (that is, "ready" or "online"),
+	 * then further sort by whether the services are VPN type, then
+	 * service order if there is VPN equivalence, and then by their
+	 * preferred technology status.
+	 */
 	if (a_connected && b_connected) {
 		int rval;
 
+		/*
+		 * If at this point the services are still comparing as
+		 * equivalent, then use online check failure status, giving
+		 * priority to the service that has not met the failure
+		 * threshold.
+		 */
+		if (!online_check_failures_threshold_was_met(service_a) &&
+			online_check_failures_threshold_was_met(service_b)) {
+			return -1;
+		}
+
+		if (online_check_failures_threshold_was_met(service_a) &&
+			!online_check_failures_threshold_was_met(service_b)) {
+			return 1;
+		}
+
 		/* Compare the VPN transport and the service */
 		if ((service_a->type == CONNMAN_SERVICE_TYPE_VPN ||
 				service_b->type == CONNMAN_SERVICE_TYPE_VPN) &&
@@ -5395,13 +8190,22 @@ static gint service_compare(gconstpointer a, gconstpointer b)
 			return rval;
 	}
 
+	/*
+	 * If at this point the services are still comparing as
+	 * equilvalent, then check whether their combined states are
+	 * different. If they are, then prefer the service that is
+	 * "online" to that which is only "ready", then prefer @a a being
+	 * connected versus @a b being connected, and, finally, then
+	 * prefer @a a being in the process of connecting to @a b being in
+	 * the process of connecting.
+	 */
 	if (state_a != state_b) {
 		if (a_connected && b_connected) {
 			/* We prefer online over ready state */
-			if (state_a == CONNMAN_SERVICE_STATE_ONLINE)
+			if (is_online(state_a))
 				return -1;
 
-			if (state_b == CONNMAN_SERVICE_STATE_ONLINE)
+			if (is_online(state_b))
 				return 1;
 		}
 
@@ -5416,12 +8220,26 @@ static gint service_compare(gconstpointer a, gconstpointer b)
 			return 1;
 	}
 
+	/*
+	 * If at this point the services are still comparing as
+	 * equivalent, then use favorite status, giving priority to @a a
+	 * as a favorite versus @a b as a favorite.
+	 */
 	if (service_a->favorite && !service_b->favorite)
 		return -1;
 
 	if (!service_a->favorite && service_b->favorite)
 		return 1;
 
+	/*
+	 * If at this point the services are still comparing as
+	 * equivalent, then check whether their types are different. If
+	 * they are, then compare their types. First, against the
+	 * PreferredTechnologies priority list and then by an internal
+	 * prioritization favoring Ethernet over Wi-Fi, Wi-Fi over
+	 * Cellular, Cellular over Bluetooth, Bluetooth over VPN, and VPN
+	 * over Gadget (that is, USB Ethernet).
+	 */
 	if (service_a->type != service_b->type) {
 		int rval;
 
@@ -5460,21 +8278,70 @@ static gint service_compare(gconstpointer a, gconstpointer b)
 			return 1;
 	}
 
+	/*
+	 * If at this point the services are still comparing as
+	 * equivalent, then check their strengths.
+	 */
 	strength = (gint) service_b->strength - (gint) service_a->strength;
 	if (strength)
 		return strength;
 
+	/*
+	 * Finally, if at this point the services are still comparing as
+	 * equivalent, then check their names.
+	 */
 	return g_strcmp0(service_a->name, service_b->name);
 }
 
-static void service_list_sort(void)
+/**
+ *  @brief
+ *    Sort the network services list and schedule a "ServicesChanged"
+ *    D-Bus signal.
+ *
+ *  This attempts to sort, if non-null and has more than one element,
+ *  the network services list. On completion of the sort, a D-Bus
+ *  "ServicesChanged" signal is scheduled.
+ *
+ *  @param[in]  function  A pointer to an immutable null-terminated
+ *                        C string containing the function name to
+ *                        which the call to this function should be
+ *                        attributed.
+ *
+ *  @sa service_compare
+ *  @sa service_compare_preferred
+ *  @sa service_schedule_changed
+ *
+ */
+static void service_list_sort(const char *function)
 {
+	DBG("from %s()", function);
+
 	if (service_list && service_list->next) {
 		service_list = g_list_sort(service_list, service_compare);
 		service_schedule_changed();
 	}
 }
 
+/**
+ *  @brief
+ *    Compare two network services against one another.
+ *
+ *  This compares the two specified network services.
+ *
+ *  @param[in]  a  A pointer to the first immutable service
+ *                 to compare.
+ *  @param[in]  b  A pointer to the second immutable service
+ *                 to compare.
+ *
+ *  @retval    0  If service @a a and @a b are equivalent.
+ *  @retval  < 0  If service @a a should sort @b before service @a b.
+ *  @retval  > 0  If service @a b should sort @b before service @a a.
+ *
+ *  @sa service_compare
+ *  @sa service_compare_preferred
+ *  @sa service_list_sort
+ *
+ */
 int __connman_service_compare(const struct connman_service *a,
 					const struct connman_service *b)
 {
@@ -5487,7 +8354,7 @@ int __connman_service_compare(const struct connman_service *a,
  *
  * Get the type of service
  */
-enum connman_service_type connman_service_get_type(struct connman_service *service)
+enum connman_service_type connman_service_get_type(const struct connman_service *service)
 {
 	if (!service)
 		return CONNMAN_SERVICE_TYPE_UNKNOWN;
@@ -5501,7 +8368,7 @@ enum connman_service_type connman_service_get_type(struct connman_service *servi
  *
  * Get network interface of service
  */
-char *connman_service_get_interface(struct connman_service *service)
+char *connman_service_get_interface(const struct connman_service *service)
 {
 	int index;
 
@@ -5528,6 +8395,104 @@ __connman_service_get_network(struct connman_service *service)
 	return service->network;
 }
 
+/**
+ *  @brief
+ *    Return the current service count.
+ *
+ *  @returns
+ *    The current service count.
+ *
+ */
+static size_t service_get_count(void)
+{
+	return service_list ? g_list_length(service_list) : 0;
+}
+
+/**
+ *  @brief
+ *    Get the route metric/priority for the specified service.
+ *
+ *  This attempts to get the route metric/priority for the specified
+ *  service based on the current service and services state.
+ *
+ *  If the service is the default or if it is the only service, then
+ *  the metric is zero (0). Otherwise, a low-priority metric (metric >
+ *  0) unique to @a service and its underlying network interface is
+ *  computed and returned.
+ *
+ *  @param[in]      service  A pointer to the immutable service for
+ *                           which to get the route metric/priority.
+ *  @param[in,out]  metric   A pointer to storage for the route
+ *                           metric/priority, populated with the route
+ *                           metric/priority on success.
+ *
+ *  @retval  0        If successful.
+ *  @retval  -EINVAL  If @a service or @a metric are null.
+ *  @retval  -ENXIO   If the network interface index associated with
+ *                    @a service is invalid.
+ *
+ *  @sa connman_service_is_default
+ *
+ */
+int __connman_service_get_route_metric(const struct connman_service *service,
+				uint32_t *metric)
+{
+	static const uint32_t metric_base = UINT32_MAX;
+	static const uint32_t metric_ceiling = (1 << 20);
+	static const uint32_t metric_index_step = (1 << 10);
+	int index;
+
+	DBG("");
+
+	if (!service || !metric)
+		return -EINVAL;
+
+	DBG("service %p (%s) metric %p",
+		service, connman_service_get_identifier(service),
+		metric);
+
+	index = __connman_service_get_index(service);
+	if (index < 0)
+		return -ENXIO;
+
+	/*
+	 * The algorithm uses the network interface index since it is
+	 * assumed to be stable for the uptime of the network interface
+	 * and, consequently, the potential maximum lifetime of the route.
+	 *
+	 * The algorithm establishes UINT32_MAX as the metric base (the
+	 * lowest possible priority) and a somewhat-arbitrary 2^20 as the
+	 * ceiling (to keep metrics out of a range that might be used by
+	 * other applications). The metric is then adjusted in increments
+	 * of 1,024 (2^10) from the base, but less than the ceiling, by
+	 * multiplying the increment by the network interface index. This
+	 * is easy and simple to compute and is invariant on service
+	 * order.
+	 *
+	 * In the fullness of time, the "rule of least astonishment" for
+	 * Connection Manager might be that low priority metrics follow
+	 * the service order with the default service always having metric
+	 * zero (0) and lowest priority metric assigned to the lowest
+	 * priority service, etc. Achieving this would require having
+	 * access to APIs (such as '__connman_service_get_count()' and
+	 * '__connman_service_get_order(service)') that expose a
+	 * strictly-in/decreasing service order with no duplicates. Today,
+	 * there is no such API nor is there such a durable service order
+	 * meeting that mathematical requirement.
+	 */
+
+	if (service_get_count() <= 1 || connman_service_is_default(service))
+		*metric = 0;
+	else
+		*metric = MAX(metric_ceiling,
+					metric_base -
+					(index * metric_index_step));
+
+	DBG("metric %u", *metric);
+
+	return 0;
+}
+
 struct connman_ipconfig *
 __connman_service_get_ip4config(struct connman_service *service)
 {
@@ -5558,7 +8523,7 @@ __connman_service_get_ipconfig(struct connman_service *service, int family)
 
 }
 
-bool __connman_service_is_connected_state(struct connman_service *service,
+bool __connman_service_is_connected_state(const struct connman_service *service,
 					enum connman_ipconfig_type type)
 {
 	if (!service)
@@ -5579,7 +8544,7 @@ bool __connman_service_is_connected_state(struct connman_service *service,
 	return false;
 }
 enum connman_service_security __connman_service_get_security(
-				struct connman_service *service)
+				const struct connman_service *service)
 {
 	if (!service)
 		return CONNMAN_SERVICE_SECURITY_UNKNOWN;
@@ -5587,7 +8552,7 @@ enum connman_service_security __connman_service_get_security(
 	return service->security;
 }
 
-const char *__connman_service_get_phase2(struct connman_service *service)
+const char *__connman_service_get_phase2(const struct connman_service *service)
 {
 	if (!service)
 		return NULL;
@@ -5595,7 +8560,7 @@ const char *__connman_service_get_phase2(struct connman_service *service)
 	return service->phase2;
 }
 
-bool __connman_service_wps_enabled(struct connman_service *service)
+bool __connman_service_wps_enabled(const struct connman_service *service)
 {
 	if (!service)
 		return false;
@@ -5635,9 +8600,9 @@ int __connman_service_set_favorite_delayed(struct connman_service *service,
 
 	if (!delay_ordering) {
 
-		service_list_sort();
+		SERVICE_LIST_SORT();
 
-		__connman_connection_update_gateway();
+		__connman_gateway_update();
 	}
 
 	return 0;
@@ -5657,12 +8622,12 @@ int __connman_service_set_favorite(struct connman_service *service,
 							false);
 }
 
-bool connman_service_get_favorite(struct connman_service *service)
+bool connman_service_get_favorite(const struct connman_service *service)
 {
 	return service->favorite;
 }
 
-bool connman_service_get_autoconnect(struct connman_service *service)
+bool connman_service_get_autoconnect(const struct connman_service *service)
 {
 	return service->autoconnect;
 }
@@ -5774,8 +8739,8 @@ static void report_error_cb(void *user_context, bool retry,
 		__connman_service_clear_error(service);
 
 		service_complete(service);
-		service_list_sort();
-		__connman_connection_update_gateway();
+		SERVICE_LIST_SORT();
+		__connman_gateway_update();
 	}
 }
 
@@ -5890,7 +8855,7 @@ static void request_input_cb(struct connman_service *service,
 
 	if (err >= 0) {
 		/* We forget any previous error. */
-		set_error(service, CONNMAN_SERVICE_ERROR_UNKNOWN);
+		clear_error(service);
 
 		__connman_service_connect(service,
 					CONNMAN_SERVICE_CONNECT_REASON_USER);
@@ -5915,39 +8880,89 @@ static void request_input_cb(struct connman_service *service,
 		}
 
 		service_complete(service);
-		__connman_connection_update_gateway();
+		__connman_gateway_update();
 	}
 }
 
+/**
+ *  @brief
+ *    Downgrade the service IPv4 and IPv6 states from "online" to
+ *    "ready" of all connected services.
+ *
+ *  This attempts to downgrade the IPv4 and IPv6 states of all
+ *  @a is_connected services to "ready" if they are "online".
+ *
+ *  @sa service_ipconfig_downgrade_online_state
+ *  @sa service_downgrade_online_state
+ *  @sa service_downgrade_online_state_if_default
+ *
+ */
 static void downgrade_connected_services(void)
 {
 	struct connman_service *up_service;
 	GList *list;
 
+	DBG("");
+
 	for (list = service_list; list; list = list->next) {
 		up_service = list->data;
 
 		if (!is_connected(up_service->state))
 			continue;
 
-		if (up_service->state == CONNMAN_SERVICE_STATE_ONLINE)
+		if (is_online(up_service->state))
 			return;
 
-		downgrade_state(up_service);
+		service_downgrade_online_state(up_service);
 	}
 }
 
+/**
+ *  @brief
+ *    Potentially change the network service list order of the default
+ *    network service and the specified network service.
+ *
+ *  This attempts to switch the order of the specified services in the
+ *  network service list if and only if a) the services are non-null,
+ *  b) do not have pointer equivalence, and c) if @a new_service
+ *  should sort before @a default_service according to the @a
+ *  PreferredTechnologies list.
+ *
+ *  @param[in,out]  default_service  A pointer to the mutable, default
+ *                                   network service to potentially
+ *                                   demote in the network service
+ *                                   list to @b after @a new_service.
+ *  @param[in,out]  new_service      A pointer to the mutable service
+ *                                   to potentially promote in the
+ *                                   network service list to @b before
+ *                                   @a default_service.
+ *  @param[in]      new_state        The pending network service state
+ *                                   of @a new_service that is
+ *                                   precipitating the order update.
+ *
+ *  @retval  0          If the preferred order was successfully
+ *                      changed which includes @a default_service
+ *                      being null or @a default_service and @a
+ *                      new_service having pointer equivalence.
+ *  @retval  -EALREADY  If the preferred order was unchanged.
+ *
+ */
 static int service_update_preferred_order(struct connman_service *default_service,
 		struct connman_service *new_service,
 		enum connman_service_state new_state)
 {
+	DBG("default_service %p (%s) new_service %p (%s) new_state %d (%s)",
+		default_service, connman_service_get_identifier(default_service),
+		new_service, connman_service_get_identifier(new_service),
+		new_state, state2string(new_state));
+
 	if (!default_service || default_service == new_service)
 		return 0;
 
 	if (service_compare_preferred(default_service, new_service) > 0) {
-		switch_default_service(default_service,
+		switch_service_order(default_service,
 				new_service);
-		__connman_connection_update_gateway();
+		__connman_gateway_update();
 		return 0;
 	}
 
@@ -6005,8 +9020,9 @@ static int service_indicate_state(struct connman_service *service)
 	old_state = service->state;
 	new_state = combine_state(service->state_ipv4, service->state_ipv6);
 
-	DBG("service %p old %s - new %s/%s => %s",
+	DBG("service %p (%s) old %s - new %s/%s => %s",
 					service,
+					connman_service_get_identifier(service),
 					state2string(old_state),
 					state2string(service->state_ipv4),
 					state2string(service->state_ipv6),
@@ -6017,14 +9033,14 @@ static int service_indicate_state(struct connman_service *service)
 
 	def_service = connman_service_get_default();
 
-	if (new_state == CONNMAN_SERVICE_STATE_ONLINE) {
+	if (is_online(new_state)) {
 		result = service_update_preferred_order(def_service,
 				service, new_state);
 		if (result == -EALREADY)
 			return result;
 	}
 
-	if (old_state == CONNMAN_SERVICE_STATE_ONLINE)
+	if (is_online(old_state))
 		__connman_notifier_leave_online(service->type);
 
 	if (is_connected(old_state) && !is_connected(new_state))
@@ -6076,7 +9092,7 @@ static int service_indicate_state(struct connman_service *service)
 		break;
 
 	case CONNMAN_SERVICE_STATE_READY:
-		set_error(service, CONNMAN_SERVICE_ERROR_UNKNOWN);
+		clear_error(service);
 
 		if (service->new_service &&
 				__connman_stats_service_register(service) == 0) {
@@ -6097,7 +9113,7 @@ static int service_indicate_state(struct connman_service *service)
 
 		service_update_preferred_order(def_service, service, new_state);
 
-		default_changed();
+		DEFAULT_CHANGED();
 
 		__connman_service_set_favorite(service, true);
 
@@ -6123,7 +9139,7 @@ static int service_indicate_state(struct connman_service *service)
 		domain_changed(service);
 		proxy_changed(service);
 
-		if (old_state != CONNMAN_SERVICE_STATE_ONLINE)
+		if (!is_online(old_state))
 			__connman_notifier_connect(service->type);
 
 		method = __connman_ipconfig_get_method(service->ipconfig_ipv6);
@@ -6143,14 +9159,18 @@ static int service_indicate_state(struct connman_service *service)
 		break;
 
 	case CONNMAN_SERVICE_STATE_DISCONNECT:
-		set_error(service, CONNMAN_SERVICE_ERROR_UNKNOWN);
+		clear_error(service);
 
 		reply_pending(service, ECONNABORTED);
 
-		default_changed();
+		DEFAULT_CHANGED();
+
+		cancel_online_check(service, CONNMAN_IPCONFIG_TYPE_ALL);
 
 		__connman_wispr_stop(service);
 
+		online_check_state_reset(service);
+
 		__connman_wpad_stop(service);
 
 		domain_changed(service);
@@ -6180,9 +9200,9 @@ static int service_indicate_state(struct connman_service *service)
 		break;
 	}
 
-	service_list_sort();
+	SERVICE_LIST_SORT();
 
-	__connman_connection_update_gateway();
+	__connman_gateway_update();
 
 notifier:
 	if ((old_state == CONNMAN_SERVICE_STATE_ONLINE &&
@@ -6192,9 +9212,9 @@ notifier:
 		__connman_notifier_disconnect(service->type);
 	}
 
-	if (new_state == CONNMAN_SERVICE_STATE_ONLINE) {
+	if (is_online(new_state)) {
 		__connman_notifier_enter_online(service->type);
-		default_changed();
+		DEFAULT_CHANGED();
 	}
 
 	return 0;
@@ -6224,7 +9244,7 @@ int __connman_service_indicate_error(struct connman_service *service,
 
 int __connman_service_clear_error(struct connman_service *service)
 {
-	DBusMessage *pending, *provider_pending;
+	DBusMessage *pending;
 
 	DBG("service %p", service);
 
@@ -6236,8 +9256,6 @@ int __connman_service_clear_error(struct connman_service *service)
 
 	pending = service->pending;
 	service->pending = NULL;
-	provider_pending = service->provider_pending;
-	service->provider_pending = NULL;
 
 	__connman_service_ipconfig_indicate_state(service,
 						CONNMAN_SERVICE_STATE_IDLE,
@@ -6248,14 +9266,15 @@ int __connman_service_clear_error(struct connman_service *service)
 						CONNMAN_IPCONFIG_TYPE_IPV4);
 
 	service->pending = pending;
-	service->provider_pending = provider_pending;
 
 	return 0;
 }
 
 int __connman_service_indicate_default(struct connman_service *service)
 {
-	DBG("service %p state %s", service, state2string(service->state));
+	DBG("service %p (%s) state %d (%s)",
+		service, connman_service_get_identifier(service),
+		service->state, state2string(service->state));
 
 	if (!is_connected(service->state)) {
 		/*
@@ -6266,7 +9285,7 @@ int __connman_service_indicate_default(struct connman_service *service)
 		return -EINPROGRESS;
 	}
 
-	default_changed();
+	DEFAULT_CHANGED();
 
 	return 0;
 }
@@ -6340,92 +9359,6 @@ static void service_rp_filter(struct connman_service *service,
 		connected_networks_count, original_rp_filter);
 }
 
-static void redo_wispr(struct connman_service *service,
-					enum connman_ipconfig_type type)
-{
-	DBG("Retrying %s WISPr for %p %s",
-		__connman_ipconfig_type2string(type),
-		service, service->name);
-
-	__connman_wispr_start(service, type);
-	connman_service_unref(service);
-}
-
-static gboolean redo_wispr_ipv4(gpointer user_data)
-{
-	struct connman_service *service = user_data;
-
-	service->online_timeout_ipv4 = 0;
-
-	redo_wispr(service, CONNMAN_IPCONFIG_TYPE_IPV4);
-
-	return FALSE;
-}
-
-static gboolean redo_wispr_ipv6(gpointer user_data)
-{
-	struct connman_service *service = user_data;
-
-	service->online_timeout_ipv6 = 0;
-
-	redo_wispr(service, CONNMAN_IPCONFIG_TYPE_IPV6);
-
-	return FALSE;
-}
-
-void __connman_service_online_check(struct connman_service *service,
-					enum connman_ipconfig_type type,
-					bool success)
-{
-	GSourceFunc redo_func;
-	unsigned int *interval;
-	enum connman_service_state current_state;
-	int timeout;
-
-	DBG("service %p type %s success %d\n",
-		service, __connman_ipconfig_type2string(type), success);
-
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV4) {
-		interval = &service->online_check_interval_ipv4;
-		redo_func = redo_wispr_ipv4;
-	} else {
-		interval = &service->online_check_interval_ipv6;
-		redo_func = redo_wispr_ipv6;
-	}
-
-	if(!enable_online_to_ready_transition)
-		goto redo_func;
-
-	if (success) {
-		*interval = online_check_max_interval;
-	} else {
-		current_state = service->state;
-		downgrade_state(service);
-		if (current_state != service->state)
-			*interval = online_check_initial_interval;
-		if (service != connman_service_get_default()) {
-			return;
-		}
-	}
-
-redo_func:
-	DBG("service %p type %s interval %d", service,
-		__connman_ipconfig_type2string(type), *interval);
-
-	timeout = g_timeout_add_seconds(*interval * *interval,
-				redo_func, connman_service_ref(service));
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
-		service->online_timeout_ipv4 = timeout;
-	else
-		service->online_timeout_ipv6 = timeout;
-
-	/* Increment the interval for the next time, set a maximum timeout of
-	 * online_check_max_interval seconds * online_check_max_interval seconds.
-	 */
-	if (*interval < online_check_max_interval)
-		(*interval)++;
-}
-
 int __connman_service_ipconfig_indicate_state(struct connman_service *service,
 					enum connman_service_state new_state,
 					enum connman_ipconfig_type type)
@@ -6482,11 +9415,11 @@ int __connman_service_ipconfig_indicate_state(struct connman_service *service,
 	if (old_state == new_state)
 		return -EALREADY;
 
-	DBG("service %p (%s) old state %d (%s) new state %d (%s) type %d (%s)",
-		service, service ? service->identifier : NULL,
+	DBG("service %p (%s) type %d (%s) old state %d (%s) new state %d (%s)",
+		service, connman_service_get_identifier(service),
+		type, __connman_ipconfig_type2string(type),
 		old_state, state2string(old_state),
-		new_state, state2string(new_state),
-		type, __connman_ipconfig_type2string(type));
+		new_state, state2string(new_state));
 
 	switch (new_state) {
 	case CONNMAN_SERVICE_STATE_UNKNOWN:
@@ -6519,7 +9452,7 @@ int __connman_service_ipconfig_indicate_state(struct connman_service *service,
 
 	if (is_connected(old_state) && !is_connected(new_state)) {
 		nameserver_remove_all(service, type);
-		cancel_online_check(service);
+		cancel_online_check(service, type);
 	}
 
 	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
@@ -6527,11 +9460,29 @@ int __connman_service_ipconfig_indicate_state(struct connman_service *service,
 	else
 		service->state_ipv6 = new_state;
 
-	if (!is_connected(old_state) && is_connected(new_state))
+	if (!is_connected(old_state) && is_connected(new_state)) {
 		nameserver_add_all(service, type);
 
-	__connman_timeserver_sync(service,
+		/*
+		 * Care must be taken here in a multi-technology and -service
+		 * environment. In such an environment, there may be a senior,
+		 * default service that is providing the network service for
+		 * time-of-day synchronization.
+		 *
+		 * Without an appropriate qualifier here, a junior,
+		 * non-default service may come in and usurp the senior,
+		 * default service and start trying to provide time-of-day
+		 * synchronization which is NOT what is desired.
+		 *
+		 * However, this qualifier should NOT be moved to the next
+		 * most outer block. Otherwise, name servers will not be added
+		 * to junior, non-default services and they will be unusable
+		 * from a DNS perspective.
+		 */
+		if (connman_service_is_default(service))
+			__connman_timeserver_sync(service,
 				CONNMAN_TIMESERVER_SYNC_REASON_STATE_UPDATE);
+	}
 
 	return service_indicate_state(service);
 }
@@ -6951,9 +9902,9 @@ int __connman_service_provision_changed(const char *ident)
 	if (services_dirty) {
 		services_dirty = false;
 
-		service_list_sort();
+		SERVICE_LIST_SORT();
 
-		__connman_connection_update_gateway();
+		__connman_gateway_update();
 	}
 
 	return data.ret;
@@ -7024,9 +9975,9 @@ static int service_register(struct connman_service *service)
 	if (__connman_config_provision_service(service) < 0)
 		service_load(service);
 
-	service_list_sort();
+	SERVICE_LIST_SORT();
 
-	__connman_connection_update_gateway();
+	__connman_gateway_update();
 
 	return 0;
 }
@@ -7083,8 +10034,10 @@ static void service_ip_bound(struct connman_ipconfig *ipconfig,
 	type = __connman_ipconfig_get_config_type(ipconfig);
 	method = __connman_ipconfig_get_method(ipconfig);
 
-	DBG("service %p ipconfig %p type %d method %d", service, ipconfig,
-							type, method);
+	DBG("service %p (%s) type %d (%s) ipconfig %p method %d (%s)",
+		service, connman_service_get_identifier(service),
+		type, __connman_ipconfig_type2string(type),
+		ipconfig, method, __connman_ipconfig_method2string(method));
 
 	if (type == CONNMAN_IPCONFIG_TYPE_IPV6 &&
 			method == CONNMAN_IPCONFIG_METHOD_AUTO)
@@ -7126,12 +10079,34 @@ static void service_ip_release(struct connman_ipconfig *ipconfig,
 	settings_changed(service, ipconfig);
 }
 
+/**
+ *  @brief
+ *    Handler for IP configuration routes changes.
+ *
+ *  This is the IP configuration handler for route set (add) and unset
+ *  (delete) operations for the specified IP configuration and its
+ *  associated network interface name.
+ *
+ *  @param[in]  ipconfig  A pointer to the IP configuration associated
+ *                        with the network service route change.
+ *  @param[in]  ifname    A pointer to an immutable null-terminated
+ *                        C string containing the network interface
+ *                        name associated with the route change.
+ *
+ *  @sa __connman_ipconfig_set_data
+ *  @sa __connman_ipconfig_set_ops
+ *  @sa settings_changed
+ *
+ */
 static void service_route_changed(struct connman_ipconfig *ipconfig,
 				const char *ifname)
 {
 	struct connman_service *service = __connman_ipconfig_get_data(ipconfig);
 
-	DBG("%s route changed", ifname);
+	DBG("service %p (%s) ipconfig %p ifname %s route changed",
+		service, connman_service_get_identifier(service),
+		ipconfig,
+		ifname);
 
 	settings_changed(service, ipconfig);
 }
@@ -7294,22 +10269,22 @@ struct connman_service *__connman_service_lookup_from_index(int index)
 	return NULL;
 }
 
-const char *connman_service_get_identifier(struct connman_service *service)
+const char *connman_service_get_identifier(const struct connman_service *service)
 {
-	return service ? service->identifier : NULL;
+	return service ? service->identifier : "<null>";
 }
 
-const char *__connman_service_get_path(struct connman_service *service)
+const char *__connman_service_get_path(const struct connman_service *service)
 {
 	return service->path;
 }
 
-const char *__connman_service_get_name(struct connman_service *service)
+const char *__connman_service_get_name(const struct connman_service *service)
 {
 	return service->name;
 }
 
-enum connman_service_state connman_service_get_state(struct connman_service *service)
+enum connman_service_state connman_service_get_state(const struct connman_service *service)
 {
 	return service ? service->state : CONNMAN_SERVICE_STATE_UNKNOWN;
 }
@@ -7425,7 +10400,7 @@ static void update_from_network(struct connman_service *service,
 	if (!service->network)
 		service->network = connman_network_ref(network);
 
-	service_list_sort();
+	SERVICE_LIST_SORT();
 }
 
 static void trigger_autoconnect(struct connman_service *service)
@@ -7523,7 +10498,7 @@ struct connman_service * __connman_service_create_from_network(struct connman_ne
 			__connman_ipconfig_set_index(service->ipconfig_ipv6,
 									index);
 
-		__connman_connection_update_gateway();
+		__connman_gateway_update();
 		return service;
 	}
 
@@ -7632,7 +10607,7 @@ roaming:
 
 sorting:
 	if (need_sort) {
-		service_list_sort();
+		SERVICE_LIST_SORT();
 	}
 }
 
@@ -7649,7 +10624,7 @@ void __connman_service_remove_from_network(struct connman_network *network)
 
 	service->ignore = true;
 
-	__connman_connection_gateway_remove(service,
+	__connman_gateway_remove(service,
 					CONNMAN_IPCONFIG_TYPE_ALL);
 
 	connman_service_unref(service);
@@ -7842,6 +10817,21 @@ int __connman_service_init(void)
 
 	remove_unprovisioned_services();
 
+	online_check_timeout_interval_style =
+		connman_setting_get_string("OnlineCheckIntervalStyle");
+	if (g_strcmp0(online_check_timeout_interval_style, "fibonacci") == 0)
+		online_check_timeout_compute_func = online_check_timeout_compute_fibonacci;
+	else
+		online_check_timeout_compute_func = online_check_timeout_compute_geometric;
+
+	online_check_connect_timeout_ms =
+		connman_setting_get_uint("OnlineCheckConnectTimeout");
+
+	online_check_initial_interval =
+		connman_setting_get_uint("OnlineCheckInitialInterval");
+	online_check_max_interval =
+		connman_setting_get_uint("OnlineCheckMaxInterval");
+
 	return 0;
 }
 
diff --git a/src/session.c b/src/session.c
index eeefe3f2..bef4b833 100644
--- a/src/session.c
+++ b/src/session.c
@@ -1937,7 +1937,9 @@ static void service_state_changed(struct connman_service *service,
 {
 	struct connman_service_info *info;
 
-	DBG("service %p state %d", service, state);
+	DBG("service %p (%s) state %d",
+		service, connman_service_get_identifier(service),
+		state);
 
 	info = g_hash_table_lookup(service_hash, service);
 
diff --git a/src/technology.c b/src/technology.c
index 5c469111..65fb9854 100644
--- a/src/technology.c
+++ b/src/technology.c
@@ -43,6 +43,8 @@ static GHashTable *rfkill_list;
 
 static bool global_offlinemode;
 
+static char *global_regdom = NULL;
+
 struct connman_rfkill {
 	unsigned int index;
 	enum connman_service_type type;
@@ -333,8 +335,14 @@ int connman_technology_set_regdom(const char *alpha2)
 					driver->set_regdom(technology, alpha2);
 			}
 		}
+
+		/* Save regdom for this technology */
+		connman_technology_regdom_notify(technology, alpha2);
 	}
 
+	g_free(global_regdom);
+	global_regdom = g_strdup(alpha2);
+
 	return 0;
 }
 
@@ -354,6 +362,22 @@ static struct connman_technology *technology_find(enum connman_service_type type
 	return NULL;
 }
 
+const char *__connman_technology_get_regdom(enum connman_service_type type)
+{
+	struct connman_technology *technology;
+
+	DBG("type %d/%s", type, get_name(type));
+
+	technology = technology_find(type);
+	if (!technology)
+		return NULL;
+
+	if (technology->regdom)
+		return technology->regdom;
+
+	return global_regdom;
+}
+
 enum connman_service_type connman_technology_get_type
 				(struct connman_technology *technology)
 {
@@ -1283,6 +1307,7 @@ static struct connman_technology *technology_get(enum connman_service_type type)
 	technology_load(technology);
 	technology_list = g_slist_prepend(technology_list, technology);
 	technology->driver_list = tech_drivers;
+	technology->regdom = g_strdup(global_regdom);
 
 	for (list = tech_drivers; list; list = list->next) {
 		driver = list->data;
@@ -1905,4 +1930,6 @@ void __connman_technology_cleanup(void)
 	g_hash_table_destroy(rfkill_list);
 
 	dbus_connection_unref(connection);
+
+	g_free(global_regdom);
 }
diff --git a/src/timeserver.c b/src/timeserver.c
index d23776fa..d364f728 100644
--- a/src/timeserver.c
+++ b/src/timeserver.c
@@ -35,6 +35,11 @@
 
 #define TS_RECHECK_INTERVAL     7200
 
+/**
+ *  A strong (that is, uses #connman_service_{ref,unref}) reference to
+ *  the network service currently used for time of day synchronization.
+ *
+ */
 static struct connman_service *ts_service;
 static GSList *timeservers_list = NULL;
 static GSList *ts_list = NULL;
@@ -47,7 +52,7 @@ static GResolv *resolv = NULL;
 static int resolv_id = 0;
 
 static void sync_next(void);
-static void ts_set_nameservers(struct connman_service *service);
+static void ts_set_nameservers(const struct connman_service *service);
 
 static void resolv_debug(const char *str, void *data)
 {
@@ -229,13 +234,13 @@ GSList *__connman_timeserver_add_list(GSList *server_list,
  * list which will be used to determine NTP server for time corrections.
  * The service settings take priority over the global timeservers.
  */
-GSList *__connman_timeserver_get_all(struct connman_service *service)
+GSList *__connman_timeserver_get_all(const struct connman_service *service)
 {
 	GSList *list = NULL;
-	struct connman_network *network;
+	const struct connman_network *network;
 	char **timeservers;
-	char **service_ts;
-	char **service_ts_config;
+	const char * const *service_ts;
+	const char * const *service_ts_config;
 	const char *service_gw;
 	char **fallback_ts;
 	int index, i;
@@ -262,7 +267,7 @@ GSList *__connman_timeserver_get_all(struct connman_service *service)
 	 * configuration option is set to true.
 	 */
 	if (connman_setting_get_bool("UseGatewaysAsTimeservers")) {
-		network = __connman_service_get_network(service);
+		network = __connman_service_get_network((struct connman_service *)service);
 		if (network) {
 			index = connman_network_get_index(network);
 			service_gw = __connman_ipconfig_get_gateway_from_index(index,
@@ -374,7 +379,7 @@ static int ts_setup_resolv(struct connman_service *service)
 }
 
 
-static void ts_set_nameservers(struct connman_service *service)
+static void ts_set_nameservers(const struct connman_service *service)
 {
 	char **nameservers;
 	int i;
@@ -393,8 +398,28 @@ static void ts_set_nameservers(struct connman_service *service)
 	}
 }
 
+/**
+ *  @brief
+ *    Reset internal time of day synchronization state and initiate
+ *    time of day synchronization with the specified network service.
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           object for which a time of day
+ *                           synchronization with time services should
+ *                           be initiated. Name and time servers from
+ *                           this service will be used for time of day
+ *                           synchronization.
+ *
+ *  @sa __connman_timeserver_sync
+ *  @sa __connman_timeserver_conf_update
+ *  @sa __connman_timeserver_system_set
+ *
+ */
 static void ts_reset(struct connman_service *service)
 {
+	DBG("service %p (%s)",
+		service, connman_service_get_identifier(service));
+
 	if (!resolv)
 		return;
 
@@ -427,13 +452,58 @@ static void ts_reset(struct connman_service *service)
 
 	ts_recheck_enable();
 
-	ts_service = service;
+	if (ts_service) {
+		connman_service_unref(ts_service);
+		ts_service = NULL;
+	}
+
+	if (service) {
+		connman_service_ref(service);
+		ts_service = service;
+	}
+
 	timeserver_sync_start();
 }
 
+static const char *timeserver_sync_reason2string(
+			enum connman_timeserver_sync_reason reason)
+{
+	switch (reason) {
+	case CONNMAN_TIMESERVER_SYNC_REASON_START:
+		return "start";
+	case CONNMAN_TIMESERVER_SYNC_REASON_ADDRESS_UPDATE:
+		return "address update";
+	case CONNMAN_TIMESERVER_SYNC_REASON_STATE_UPDATE:
+		return "state update";
+	case CONNMAN_TIMESERVER_SYNC_REASON_TS_CHANGE:
+		return "timeserver change";
+	}
+
+	return "unknown";
+}
+
+/**
+ *  @brief
+ *    Initiate a time of day synchronization with time services.
+ *
+ *  This initiates a time of day synchronization with time services
+ *  for the specified network service for the provided reason.
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           object for which a time of day
+ *                           synchronization with time services should
+ *                           be initiated.
+ *  @param[in]      reason   The reason for the time of day
+ *                           synchronizization request.
+ *
+ */
 void __connman_timeserver_sync(struct connman_service *service,
 			enum connman_timeserver_sync_reason reason)
 {
+	DBG("service %p (%s) reason %d (%s)",
+		service, connman_service_get_identifier(service),
+		reason, timeserver_sync_reason2string(reason));
+
 	if (!service)
 		return;
 
@@ -506,7 +576,10 @@ static void timeserver_stop(void)
 {
 	DBG(" ");
 
-	ts_service = NULL;
+	if (ts_service) {
+		connman_service_unref(ts_service);
+		ts_service = NULL;
+	}
 
 	if (resolv) {
 		g_resolv_unref(resolv);
diff --git a/src/timezone.c b/src/timezone.c
index f8d192df..89c44895 100644
--- a/src/timezone.c
+++ b/src/timezone.c
@@ -38,9 +38,10 @@
 
 #include "connman.h"
 
-#define ETC_SYSCONFIG_CLOCK	"/etc/sysconfig/clock"
-#define USR_SHARE_ZONEINFO	"/usr/share/zoneinfo"
-#define USR_SHARE_ZONEINFO_MAP	USR_SHARE_ZONEINFO "/zone1970.tab"
+#define ETC_SYSCONFIG_CLOCK		"/etc/sysconfig/clock"
+#define USR_SHARE_ZONEINFO		"/usr/share/zoneinfo"
+#define USR_SHARE_ZONEINFO_MAP		USR_SHARE_ZONEINFO "/zone1970.tab"
+#define USR_SHARE_ZONEINFO_MAP_OLD	USR_SHARE_ZONEINFO "/zone.tab"
 
 static char *read_key_file(const char *pathname, const char *key)
 {
@@ -115,12 +116,17 @@ static char *read_key_file(const char *pathname, const char *key)
 }
 
 static int compare_file(void *src_map, struct stat *src_st,
-						const char *pathname)
+				const char *real_path, const char *pathname)
 {
 	struct stat dst_st;
 	void *dst_map;
 	int fd, result;
 
+	DBG("real path %s path name %s", real_path, pathname);
+
+	if (real_path && g_strcmp0(real_path, pathname))
+		return -1;
+
 	fd = open(pathname, O_RDONLY | O_CLOEXEC);
 	if (fd < 0)
 		return -1;
@@ -151,7 +157,8 @@ static int compare_file(void *src_map, struct stat *src_st,
 }
 
 static char *find_origin(void *src_map, struct stat *src_st,
-				const char *basepath, const char *subpath)
+				const char* real_path, const char *basepath,
+				const char *subpath)
 {
 	DIR *dir;
 	struct dirent *d;
@@ -186,7 +193,8 @@ static char *find_origin(void *src_map, struct stat *src_st,
 						"%s/%s/%s", basepath,
 							subpath, d->d_name);
 
-			if (compare_file(src_map, src_st, pathname) == 0) {
+			if (compare_file(src_map, src_st, real_path, pathname)
+									== 0) {
 				if (!subpath)
 					str = g_strdup(d->d_name);
 				else
@@ -214,7 +222,8 @@ static char *find_origin(void *src_map, struct stat *src_st,
 				snprintf(pathname, sizeof(pathname),
 						"%s/%s", subpath, d->d_name);
 
-			str = find_origin(src_map, src_st, basepath, pathname);
+			str = find_origin(src_map, src_st, real_path, basepath,
+						pathname);
 			if (str) {
 				closedir(dir);
 				return str;
@@ -228,7 +237,52 @@ static char *find_origin(void *src_map, struct stat *src_st,
 	return NULL;
 }
 
-static char *get_timezone_alpha2(const char *zone)
+/* TZ map file format: Countrycodes Coordinates TZ Comments */
+enum tz_map_item {
+	TZ_MAP_ITEM_ISO3166 = 0,
+	TZ_MAP_ITEM_COORDINATE = 1,
+	TZ_MAP_ITEM_TIMEZONE = 2,
+	TZ_MAP_ITEM_COMMENT = 3,
+};
+
+static bool iso3166_matches(const char *codes, const char *iso3166)
+{
+	gchar **tokens;
+	guint len;
+	guint i;
+	bool ret = false;
+
+	if (!codes || !iso3166)
+		return false;
+
+	tokens = g_strsplit(codes, ",", -1);
+	if (!tokens)
+		return false;
+
+	len = g_strv_length(tokens);
+	if (len < 2) {
+		g_strfreev(tokens);
+		return false;
+	}
+
+	DBG("search %s from %s", iso3166, codes);
+
+	for (i = 0; i < len; i++) {
+		DBG("#%d %s", i, tokens[i]);
+
+		if (!g_strcmp0(tokens[i], iso3166)) {
+			ret = true;
+			break;
+		}
+	}
+
+	g_strfreev(tokens);
+
+	return ret;
+}
+
+static char *get_timezone_alpha2(const char *zone, const char *mapfile,
+						enum tz_map_item map_item)
 {
 	GIOChannel *channel;
 	struct stat st;
@@ -236,15 +290,15 @@ static char *get_timezone_alpha2(const char *zone)
 	char *line;
 	char *alpha2 = NULL;
 	gsize len;
+	bool found = false;
 	int fd;
 
 	if (!zone)
 		return NULL;
 
-	fd = open(USR_SHARE_ZONEINFO_MAP, O_RDONLY | O_CLOEXEC);
+	fd = open(mapfile, O_RDONLY | O_CLOEXEC);
 	if (fd < 0) {
-		connman_warn("failed to open zoneinfo map %s",
-							USR_SHARE_ZONEINFO_MAP);
+		connman_warn("failed to open zoneinfo map %s", mapfile);
 		return NULL;
 	}
 
@@ -256,23 +310,23 @@ static char *get_timezone_alpha2(const char *zone)
 
 	channel = g_io_channel_unix_new(fd);
 	if (!channel) {
-		connman_warn("failed to create io channel for %s",
-							USR_SHARE_ZONEINFO_MAP);
+		connman_warn("failed to create io channel for %s", mapfile);
 		close(fd);
 		return NULL;
 	}
 
-	DBG("read %s for %s", USR_SHARE_ZONEINFO_MAP, zone);
+	DBG("read %s for %s", mapfile, zone);
 	g_io_channel_set_encoding(channel, "UTF-8", NULL);
 
 	while (g_io_channel_read_line(channel, &line, &len, NULL, NULL) ==
 							G_IO_STATUS_NORMAL) {
+		found = false;
+
 		if (!line || !*line || *line == '#' || *line == '\n') {
 			g_free(line);
 			continue;
 		}
 
-		/* File format: Countrycodes Coordinates TZ Comments */
 		tokens = g_strsplit_set(line, " \t", 4);
 		if (!tokens) {
 			connman_warn("line %s failed to parse", line);
@@ -280,13 +334,35 @@ static char *get_timezone_alpha2(const char *zone)
 			continue;
 		}
 
-		if (g_strv_length(tokens) >= 3 && !g_strcmp0(
-						g_strstrip(tokens[2]), zone)) {
+		if (g_strv_length(tokens) >= 3) {
+			switch (map_item) {
+			case TZ_MAP_ITEM_ISO3166:
+
+				if (!g_strcmp0(tokens[0], zone)) {
+					found = true;
+					break;
+				}
+
+				if (iso3166_matches(tokens[0], zone))
+					found = true;
+				break;
+			case TZ_MAP_ITEM_COORDINATE:
+				break;
+			case TZ_MAP_ITEM_TIMEZONE:
+				if (!g_strcmp0(g_strstrip(tokens[2]), zone))
+					found = true;
+				break;
+			case TZ_MAP_ITEM_COMMENT:
+				break;
+			}
+
 			/*
 			 * Multiple country codes can be listed, use the first
-			 * 2 chars.
+			 * 2 chars as backends such as gsupplicant support only
+			 * the main country code.
 			 */
-			alpha2 = g_strndup(g_strstrip(tokens[0]), 2);
+			if (found)
+				alpha2 = g_strndup(g_strstrip(tokens[0]), 2);
 		}
 
 		g_strfreev(tokens);
@@ -300,9 +376,8 @@ static char *get_timezone_alpha2(const char *zone)
 			} else {
 				DBG("Zone %s ISO3166 country code %s", zone,
 									alpha2);
+				break;
 			}
-
-			break;
 		}
 	}
 
@@ -312,6 +387,44 @@ static char *get_timezone_alpha2(const char *zone)
 	return alpha2;
 }
 
+static char *try_get_timezone_alpha2(const char *zone)
+{
+	char *alpha2;
+	char *alpha2_old;
+
+	/* First try the official map */
+	alpha2 = get_timezone_alpha2(zone, USR_SHARE_ZONEINFO_MAP,
+							TZ_MAP_ITEM_TIMEZONE);
+	if (alpha2)
+		return alpha2;
+
+	DBG("%s not found in %s", zone, USR_SHARE_ZONEINFO_MAP);
+
+	/* The zone was not found in official map, try with deprecated */
+	alpha2_old = get_timezone_alpha2(zone, USR_SHARE_ZONEINFO_MAP_OLD,
+							TZ_MAP_ITEM_TIMEZONE);
+	if (!alpha2_old) {
+		DBG("%s not found in %s", zone, USR_SHARE_ZONEINFO_MAP_OLD);
+		return NULL;
+	}
+
+	/*
+	 * Found from deprecated, try to get main region code from official new
+	 * map using the iso3166 search. This is because some of the codes
+	 * defined in the deprecated are not supported by the backends, e.g.,
+	 * gsupplicant and the main code should be used.
+	 */
+	alpha2 = get_timezone_alpha2(alpha2_old, USR_SHARE_ZONEINFO_MAP,
+							TZ_MAP_ITEM_ISO3166);
+
+	DBG("%s -> ISO3166 %s found in %s as %s", zone, alpha2_old,
+						USR_SHARE_ZONEINFO_MAP, alpha2);
+
+	g_free(alpha2_old);
+
+	return alpha2;
+}
+
 char *__connman_timezone_lookup(void)
 {
 	struct stat st;
@@ -319,13 +432,16 @@ char *__connman_timezone_lookup(void)
 	int fd;
 	char *zone;
 	char *alpha2;
+	const char *local_time;
+	char real_path[PATH_MAX];
 
 	zone = read_key_file(ETC_SYSCONFIG_CLOCK, "ZONE");
 
 	DBG("sysconfig zone %s", zone);
 
-	fd = open(connman_setting_get_string("Localtime"),
-							O_RDONLY | O_CLOEXEC);
+	local_time = connman_setting_get_string("Localtime");
+
+	fd = open(local_time, O_RDONLY | O_CLOEXEC);
 	if (fd < 0) {
 		g_free(zone);
 		return NULL;
@@ -334,6 +450,15 @@ char *__connman_timezone_lookup(void)
 	if (fstat(fd, &st) < 0)
 		goto done;
 
+	if (!realpath(local_time, real_path)) {
+		connman_error("Failed to get real path of %s: %d/%s",
+					local_time, errno, strerror(errno));
+		g_free(zone);
+		close(fd);
+
+		return NULL;
+	}
+
 	if (S_ISREG(st.st_mode)) {
 		map = mmap(0, st.st_size, PROT_READ, MAP_SHARED, fd, 0);
 		if (!map || map == MAP_FAILED) {
@@ -349,14 +474,15 @@ char *__connman_timezone_lookup(void)
 			snprintf(pathname, PATH_MAX, "%s/%s",
 						USR_SHARE_ZONEINFO, zone);
 
-			if (compare_file(map, &st, pathname) != 0) {
+			if (compare_file(map, &st, NULL, pathname) != 0) {
 				g_free(zone);
 				zone = NULL;
 			}
 		}
 
 		if (!zone)
-			zone = find_origin(map, &st, USR_SHARE_ZONEINFO, NULL);
+			zone = find_origin(map, &st, real_path,
+						USR_SHARE_ZONEINFO, NULL);
 
 		munmap(map, st.st_size);
 	} else {
@@ -370,7 +496,7 @@ done:
 	DBG("localtime zone %s", zone);
 
 	if (connman_setting_get_bool("RegdomFollowsTimezone")) {
-		alpha2 = get_timezone_alpha2(zone);
+		alpha2 = try_get_timezone_alpha2(zone);
 		if (alpha2) {
 			DBG("change regdom to %s", alpha2);
 			connman_technology_set_regdom(alpha2);
diff --git a/src/wispr.c b/src/wispr.c
index a4372018..b1b0f337 100644
--- a/src/wispr.c
+++ b/src/wispr.c
@@ -50,20 +50,63 @@ enum connman_wispr_result {
 	CONNMAN_WISPR_RESULT_FAILED  = 3,
 };
 
+/**
+ *  State for host routes used for a WISPr request.
+ */
 struct wispr_route {
+	/**
+	 *	A pointer to a mutable, dynamically-allocated null-terminated
+	 *	C string containing the text-formatted address of the WISPr
+	 *	host.
+	 */
 	char *address;
+
+	/**
+	 *	The network interface index associated with the underlying
+	 *	network interface over which the WISPr request will sent and
+	 *	the reply received.
+	 */
 	int if_index;
+
+	/**
+	 *	The route metric/priority used for the host route created for
+	 *	the WISPr host.
+	 */
+	uint32_t metric;
+};
+
+/**
+ *  Gateway configuration function pointers for IP configuration
+ *  type-specific route set/clear/add/delete operations.
+ */
+struct wispr_portal_context_route_ops {
+	int (*add_host_route_with_metric)(int index,
+		const char *host,
+		const char *gateway,
+		uint32_t metric);
+	int (*del_host_route_with_metric)(int index,
+		const char *host,
+		const char *gateway,
+		uint32_t metric);
 };
 
 struct connman_wispr_portal_context {
 	int refcount;
 	struct connman_service *service;
 	enum connman_ipconfig_type type;
+
+	/**
+	 *	A pointer to immutable function pointers for route
+	 *	set/clear/add/delete operations.
+	 */
+	const struct wispr_portal_context_route_ops *ops;
+
+	__connman_wispr_cb_t cb;
 	struct connman_wispr_portal *wispr_portal;
 
 	/* Portal/WISPr common */
 	GWeb *web;
-	unsigned int token;
+	unsigned int proxy_token;
 	guint request_id;
 
 	const char *status_url;
@@ -82,7 +125,7 @@ struct connman_wispr_portal_context {
 
 	GSList *route_list;
 
-	guint timeout;
+	guint proxy_timeout;
 };
 
 struct connman_wispr_portal {
@@ -92,11 +135,31 @@ struct connman_wispr_portal {
 
 static bool wispr_portal_web_result(GWebResult *result, gpointer user_data);
 
+/**
+ *  A dictionary / hash table of network interface indices to
+ *  active / outstanding WISPr / portal request contexts.
+ *
+ */
 static GHashTable *wispr_portal_hash = NULL;
 
 static char *online_check_ipv4_url = NULL;
 static char *online_check_ipv6_url = NULL;
-static bool enable_online_to_ready_transition = false;
+
+static const struct wispr_portal_context_route_ops
+	ipv4_wispr_portal_context_route_ops = {
+	.add_host_route_with_metric    =
+		connman_inet_add_host_route_with_metric,
+	.del_host_route_with_metric    =
+		connman_inet_del_host_route_with_metric
+};
+
+static const struct wispr_portal_context_route_ops
+	ipv6_wispr_portal_context_route_ops = {
+	.add_host_route_with_metric    =
+		connman_inet_add_ipv6_host_route_with_metric,
+	.del_host_route_with_metric    =
+		connman_inet_del_ipv6_host_route_with_metric
+};
 
 #define wispr_portal_context_ref(wp_context) \
 	wispr_portal_context_ref_debug(wp_context, __FILE__, __LINE__, __func__)
@@ -130,30 +193,90 @@ static void connman_wispr_message_init(struct connman_wispr_message *msg)
 	msg->location_name = NULL;
 }
 
+/**
+ *  @brief
+ *    Deallocate resources associated with the specified WISPr host
+ *    route.
+ *
+ *  This attempts to deallocate resources, including host routes,
+ *  associated with the specified WISPr host route belonging to the
+ *  specified WISPr portal context.
+ *
+ *  @param[in]      wp_context  A pointer to the immutable WISPr
+ *                              portal context associated with @a
+ *                              route.
+ *  @param[in,out]  route       A pointer to the mutable WISPr host
+ *                              route structure for which to delete an
+ *                              associated host route and to
+ *                              deallocate any dynamically-allocated
+ *                              resources associated with it.
+ *
+ *  @sa wispr_route_request
+ *
+ */
+static void free_wispr_route(
+		const struct connman_wispr_portal_context *wp_context,
+		struct wispr_route *route)
+{
+	g_autofree char *interface = NULL;
+	const char *gateway;
+
+	gateway = __connman_ipconfig_get_gateway_from_index(route->if_index,
+		wp_context->type);
+
+	/*
+	 * If gateway was null, as with wispr_route_request, there was no
+	 * host route created. Consequently, there is no host route to
+	 * delete. Simply free the address.
+	 */
+	if (!gateway)
+		goto free;
+
+	interface = connman_inet_ifname(route->if_index);
+
+	DBG("delete route to %s via %s dev %d (%s) metric %u type %d (%s) "
+		"ops %p",
+		route->address,
+		gateway,
+		route->if_index, interface,
+		route->metric,
+		wp_context->type,
+		__connman_ipconfig_type2string(wp_context->type),
+		wp_context->ops);
+
+	wp_context->ops->del_host_route_with_metric(
+				route->if_index,
+				route->address,
+				gateway,
+				route->metric);
+
+free:
+	g_free(route->address);
+	route->address = NULL;
+}
+
+/**
+ *  @brief
+ *    Deallocate host route resources associated with the specified
+ *    WISPr portal context.
+ *
+ *  This attempts to deallocate host route resources associated with
+ *  the specified WISPr specified WISPr portal context.
+ *
+ *  @param[in]      wp_context  A pointer to the mutable WISPr
+ *                              portal context for which to deallocate
+ *                              resources associated with host routes.
+ *
+ */
 static void free_wispr_routes(struct connman_wispr_portal_context *wp_context)
 {
 	while (wp_context->route_list) {
 		struct wispr_route *route = wp_context->route_list->data;
 
-		DBG("free route to %s if %d type %d", route->address,
-				route->if_index, wp_context->type);
+		free_wispr_route(wp_context, route);
 
-		switch (wp_context->type) {
-		case CONNMAN_IPCONFIG_TYPE_IPV4:
-			connman_inet_del_host_route(route->if_index,
-					route->address);
-			break;
-		case CONNMAN_IPCONFIG_TYPE_IPV6:
-			connman_inet_del_ipv6_host_route(route->if_index,
-					route->address);
-			break;
-		case CONNMAN_IPCONFIG_TYPE_UNKNOWN:
-		case CONNMAN_IPCONFIG_TYPE_ALL:
-			break;
-		}
-
-		g_free(route->address);
 		g_free(route);
+		wp_context->route_list->data = NULL;
 
 		wp_context->route_list =
 			g_slist_delete_link(wp_context->route_list,
@@ -161,41 +284,98 @@ static void free_wispr_routes(struct connman_wispr_portal_context *wp_context)
 	}
 }
 
-static void free_connman_wispr_portal_context(
+/**
+ *  @brief
+ *    Cancel a WISPr/portal request.
+ *
+ *  This attempts to cancel any outstanding request associated with
+ *  the specified WISPr/portal context. This deallocates any resources
+ *  associated with the context, except for the context itself which
+ *  requires invoking #free_connman_wispr_portal_context.
+ *
+ *  @param[in,out]  wp_context  A pointer to the mutable WISPr/portal
+ *                              context for which to cancel an outstanding
+ *                              request, whether a reachability check
+ *                              or otherwise.
+ *
+ *  @sa create_connman_wispr_portal_context
+ *  @sa free_connman_wispr_portal_context
+ *
+ */
+static void cancel_connman_wispr_portal_context(
 		struct connman_wispr_portal_context *wp_context)
 {
-	if (wp_context->wispr_portal) {
-		if (wp_context->wispr_portal->ipv4_context == wp_context)
-			wp_context->wispr_portal->ipv4_context = NULL;
+	if (!wp_context)
+		return;
 
-		if (wp_context->wispr_portal->ipv6_context == wp_context)
-			wp_context->wispr_portal->ipv6_context = NULL;
-	}
+	DBG("wispr/portal context %p service %p (%s) type %d (%s)",
+		wp_context,
+		wp_context->service,
+		connman_service_get_identifier(wp_context->service),
+		wp_context->type,
+		__connman_ipconfig_type2string(wp_context->type));
 
-	if (wp_context->token > 0)
-		connman_proxy_lookup_cancel(wp_context->token);
+	if (wp_context->proxy_token > 0) {
+		connman_proxy_lookup_cancel(wp_context->proxy_token);
+		wp_context->proxy_token = 0;
+	}
 
-	if (wp_context->request_id > 0)
+	if (wp_context->request_id > 0) {
 		g_web_cancel_request(wp_context->web, wp_context->request_id);
+		wp_context->request_id = 0;
+	}
 
-	if (wp_context->timeout > 0)
-		g_source_remove(wp_context->timeout);
+	if (wp_context->proxy_timeout > 0) {
+		g_source_remove(wp_context->proxy_timeout);
+		wp_context->proxy_timeout = 0;
+	}
 
-	if (wp_context->web)
+	if (wp_context->web) {
 		g_web_unref(wp_context->web);
+		wp_context->web = NULL;
+	}
 
 	g_free(wp_context->redirect_url);
+	wp_context->redirect_url = NULL;
 
-	if (wp_context->wispr_parser)
+	if (wp_context->wispr_parser) {
 		g_web_parser_unref(wp_context->wispr_parser);
+		wp_context->wispr_parser = NULL;
+	}
 
 	connman_wispr_message_init(&wp_context->wispr_msg);
 
 	g_free(wp_context->wispr_username);
+	wp_context->wispr_username = NULL;
+
 	g_free(wp_context->wispr_password);
+	wp_context->wispr_password = NULL;
+
 	g_free(wp_context->wispr_formdata);
+	wp_context->wispr_formdata = NULL;
 
 	free_wispr_routes(wp_context);
+}
+
+static void free_connman_wispr_portal_context(
+		struct connman_wispr_portal_context *wp_context)
+{
+	DBG("wispr/portal context %p service %p (%s) type %d (%s)",
+		wp_context,
+		wp_context->service,
+		connman_service_get_identifier(wp_context->service),
+		wp_context->type,
+		__connman_ipconfig_type2string(wp_context->type));
+
+	if (wp_context->wispr_portal) {
+		if (wp_context->wispr_portal->ipv4_context == wp_context)
+			wp_context->wispr_portal->ipv4_context = NULL;
+
+		if (wp_context->wispr_portal->ipv6_context == wp_context)
+			wp_context->wispr_portal->ipv6_context = NULL;
+	}
+
+	cancel_connman_wispr_portal_context(wp_context);
 
 	g_free(wp_context);
 }
@@ -453,7 +633,30 @@ static void wispr_portal_error(struct connman_wispr_portal_context *wp_context)
 	wp_context->wispr_result = CONNMAN_WISPR_RESULT_FAILED;
 }
 
-static void portal_manage_status(GWebResult *result,
+/**
+ *  @brief
+ *    Handle a successful "online" HTTP-based Internet reachability
+ *    check.
+ *
+ *  This handles a successful (that is, completed with a HTTP 200 "OK"
+ *  status code) "online" HTTP-based Internet reachability check
+ *  previously-initiated with #__connman_wispr_start.
+ *
+ *  @param[in]      result      A pointer to the mutable HTTP result
+ *                              for the successful "online" HTTP-based
+ *                              Internet reachability check this is
+ *                              handling.
+ *  @param[in,out]  wp_context  A pointer to the mutable WISPr portal
+ *                              detection context associated the
+ *                              successful "online" HTTP-based
+ *                              Internet reachability check this is
+ *                              handling.
+ *
+ *  @sa __connman_wispr_start
+ *  @sa wispr_portal_web_result
+ *
+ */
+static void portal_manage_success_status(GWebResult *result,
 			struct connman_wispr_portal_context *wp_context)
 {
 	struct connman_service *service = wp_context->service;
@@ -479,11 +682,7 @@ static void portal_manage_status(GWebResult *result,
 				&str))
 		connman_info("Client-Timezone: %s", str);
 
-	__connman_service_ipconfig_indicate_state(service,
-					CONNMAN_SERVICE_STATE_ONLINE, type);
-
-	if (enable_online_to_ready_transition)
-		__connman_service_online_check(service, type, true);
+	wp_context->cb(service, type, true, 0);
 }
 
 static bool wispr_route_request(const char *address, int ai_family,
@@ -491,37 +690,51 @@ static bool wispr_route_request(const char *address, int ai_family,
 {
 	int result = -1;
 	struct connman_wispr_portal_context *wp_context = user_data;
+	g_autofree char *interface = NULL;
 	const char *gateway;
 	struct wispr_route *route;
+	uint32_t metric = 0;
+
+	interface = connman_inet_ifname(if_index);
 
 	gateway = __connman_ipconfig_get_gateway_from_index(if_index,
 		wp_context->type);
 
-	DBG("address %s if %d gw %s", address, if_index, gateway);
-
 	if (!gateway)
 		return false;
 
+	result = __connman_service_get_route_metric(wp_context->service,
+				&metric);
+	if (result < 0) {
+		DBG("failed to get metric for service %p (%s): %s (%d)",
+			wp_context->service,
+			connman_service_get_identifier(wp_context->service),
+			strerror(-result), result);
+
+		return false;
+	}
+
+	DBG("add route to %s via %s dev %d (%s) metric %u type %d (%s) "
+		"ops %p",
+		address,
+		gateway,
+		if_index, interface,
+		metric,
+		wp_context->type,
+		__connman_ipconfig_type2string(wp_context->type),
+		wp_context->ops);
+
 	route = g_try_new0(struct wispr_route, 1);
 	if (route == 0) {
 		DBG("could not create struct");
 		return false;
 	}
 
-	switch (wp_context->type) {
-	case CONNMAN_IPCONFIG_TYPE_IPV4:
-		result = connman_inet_add_host_route(if_index, address,
-				gateway);
-		break;
-	case CONNMAN_IPCONFIG_TYPE_IPV6:
-		result = connman_inet_add_ipv6_host_route(if_index, address,
-				gateway);
-		break;
-	case CONNMAN_IPCONFIG_TYPE_UNKNOWN:
-	case CONNMAN_IPCONFIG_TYPE_ALL:
-		break;
-	}
-
+	result = wp_context->ops->add_host_route_with_metric(
+					if_index,
+					address,
+					gateway,
+					metric);
 	if (result < 0) {
 		g_free(route);
 		return false;
@@ -529,6 +742,8 @@ static bool wispr_route_request(const char *address, int ai_family,
 
 	route->address = g_strdup(address);
 	route->if_index = if_index;
+	route->metric = metric;
+
 	wp_context->route_list = g_slist_prepend(wp_context->route_list, route);
 
 	return true;
@@ -537,17 +752,31 @@ static bool wispr_route_request(const char *address, int ai_family,
 static void wispr_portal_request_portal(
 		struct connman_wispr_portal_context *wp_context)
 {
-	DBG("wp_context %p %s", wp_context,
-		__connman_ipconfig_type2string(wp_context->type));
+	int err = 0;
+
+	DBG("wispr/portal context %p service %p (%s) type %d (%s)",
+		wp_context,
+		wp_context->service,
+		connman_service_get_identifier(wp_context->service),
+		wp_context->type, __connman_ipconfig_type2string(wp_context->type));
 
+	/*
+	 * Retain a reference to the WISPr/portal context to account for
+	 * 'g_web_request_get' maintaining a weak reference to it. This will
+	 * be released in the 'wispr_portal_web_result' callback.
+	 */
 	wispr_portal_context_ref(wp_context);
 	wp_context->request_id = g_web_request_get(wp_context->web,
 					wp_context->status_url,
 					wispr_portal_web_result,
 					wispr_route_request,
-					wp_context);
+					wp_context, &err);
 
 	if (wp_context->request_id == 0) {
+		wp_context->cb(wp_context->service,
+						wp_context->type,
+						false,
+						err);
 		wispr_portal_error(wp_context);
 		wispr_portal_context_unref(wp_context);
 	}
@@ -661,7 +890,7 @@ static void wispr_portal_request_wispr_login(struct connman_service *service,
 					wp_context->wispr_msg.login_url,
 					"application/x-www-form-urlencoded",
 					wispr_input, wispr_portal_web_result,
-					wp_context);
+					wp_context, NULL);
 
 	connman_wispr_message_init(&wp_context->wispr_msg);
 }
@@ -771,19 +1000,19 @@ static bool wispr_portal_web_result(GWebResult *result, gpointer user_data)
 	DBG("status: %03u", status);
 
 	switch (status) {
-	case 000:
+	case GWEB_HTTP_STATUS_CODE_UNKNOWN:
 		wispr_portal_context_ref(wp_context);
 		__connman_agent_request_browser(wp_context->service,
 				wispr_portal_browser_reply_cb,
 				wp_context->status_url, wp_context);
 		break;
-	case 200:
+	case GWEB_HTTP_STATUS_CODE_OK:
 		if (wp_context->wispr_msg.message_type >= 0)
 			break;
 
 		if (g_web_result_get_header(result, "X-ConnMan-Status",
 						&str)) {
-			portal_manage_status(result, wp_context);
+			portal_manage_success_status(result, wp_context);
 		} else {
 			wispr_portal_context_ref(wp_context);
 			__connman_agent_request_browser(wp_context->service,
@@ -792,12 +1021,12 @@ static bool wispr_portal_web_result(GWebResult *result, gpointer user_data)
 		}
 
 		break;
-	case 300:
-	case 301:
-	case 302:
-	case 303:
-	case 307:
-	case 308:
+	case GWEB_HTTP_STATUS_CODE_MULTIPLE_CHOICES:
+	case GWEB_HTTP_STATUS_CODE_MOVED_PERMANENTLY:
+	case GWEB_HTTP_STATUS_CODE_FOUND:
+	case GWEB_HTTP_STATUS_CODE_SEE_OTHER:
+	case GWEB_HTTP_STATUS_CODE_TEMPORARY_REDIRECT:
+	case GWEB_HTTP_STATUS_CODE_PERMANENT_REDIRECT:
 		if (!g_web_supports_tls() ||
 			!g_web_result_get_header(result, "Location",
 							&redirect)) {
@@ -816,16 +1045,31 @@ static bool wispr_portal_web_result(GWebResult *result, gpointer user_data)
 		wispr_portal_context_ref(wp_context);
 		wp_context->request_id = g_web_request_get(wp_context->web,
 				redirect, wispr_portal_web_result,
-				wispr_route_request, wp_context);
+				wispr_route_request, wp_context, NULL);
 
 		goto done;
-	case 400:
-	case 404:
-		__connman_service_online_check(wp_context->service,
-						wp_context->type, false);
+	case GWEB_HTTP_STATUS_CODE_BAD_REQUEST:
+		wp_context->cb(wp_context->service,
+				wp_context->type,
+				false,
+				-EINVAL);
+		break;
 
+	case GWEB_HTTP_STATUS_CODE_NOT_FOUND:
+		wp_context->cb(wp_context->service,
+				wp_context->type,
+				false,
+				-ENOENT);
 		break;
-	case 505:
+
+	case GWEB_HTTP_STATUS_CODE_REQUEST_TIMEOUT:
+		wp_context->cb(wp_context->service,
+				wp_context->type,
+				false,
+				-ETIMEDOUT);
+		break;
+
+	case GWEB_HTTP_STATUS_CODE_HTTP_VERSION_NOT_SUPPORTED:
 		wispr_portal_context_ref(wp_context);
 		__connman_agent_request_browser(wp_context->service,
 				wispr_portal_browser_reply_cb,
@@ -839,6 +1083,12 @@ static bool wispr_portal_web_result(GWebResult *result, gpointer user_data)
 	wp_context->request_id = 0;
 done:
 	wp_context->wispr_msg.message_type = -1;
+
+	/*
+	 * Release a reference to the WISPr/portal context to balance the
+	 * earlier reference retained to account for 'g_web_request_get'
+	 * maintaining a weak reference to it.
+	 */
 	wispr_portal_context_unref(wp_context);
 	return false;
 }
@@ -873,12 +1123,25 @@ static void proxy_callback(const char *proxy, void *user_data)
 	struct connman_wispr_portal_context *wp_context = user_data;
 	char *proxy_server;
 
-	DBG("proxy %s", proxy);
+	DBG("wp_context %p proxy %p", wp_context, proxy);
 
-	if (!wp_context || !proxy)
+	if (!wp_context)
 		return;
 
-	wp_context->token = 0;
+	if (!proxy) {
+		DBG("no valid proxy");
+
+		wp_context->cb(wp_context->service,
+				wp_context->type,
+				false,
+				-EINVAL);
+
+		return;
+	}
+
+	DBG("proxy %s", proxy);
+
+	wp_context->proxy_token = 0;
 
 	proxy_server = parse_proxy(proxy);
 	if (proxy_server) {
@@ -905,14 +1168,55 @@ static gboolean no_proxy_callback(gpointer user_data)
 {
 	struct connman_wispr_portal_context *wp_context = user_data;
 
-	wp_context->timeout = 0;
+	wp_context->proxy_timeout = 0;
 
 	proxy_callback("DIRECT", wp_context);
 
 	return FALSE;
 }
 
-static int wispr_portal_detect(struct connman_wispr_portal_context *wp_context)
+/**
+ *  @brief
+ *    Start a WISPr / portal detection request / HTTP-based Internet
+ *    reachability check for the specified WISPr / portal context.
+ *
+ *  This attempts to start a WISPr / portal detection request /
+ *  HTTP-based Internet reachability check for the network service IP
+ *  configuration type associated with the provided WISPr / portal
+ *  context with the provided connection timeout.
+ *
+ *  @param[in,out]  wp_context          A pointer to the mutable WISPr
+ *                                      / portal context to supporting
+ *                                      running the WISPr request /
+ *                                      HTTP-based Internet
+ *                                      reachability check.
+ *  param[in]       connect_timeout_ms  The time, in milliseconds, for
+ *                                      the TCP connection timeout.
+ *                                      Connections that take longer
+ *                                      than this will be aborted. A
+ *                                      value of zero ('0') indicates
+ *                                      that no explicit connection
+ *                                      timeout will be used, leaving
+ *                                      the timeout to the underlying
+ *                                      operating system and its
+ *                                      network stack.
+ *
+ *  @retval  0        If the WISPr request / HTTP-based Internet
+ *                    reachability check was successfully queued.
+ *  @retval  -EINVAL  If the network interface or network interface
+ *                    index associated with @a wp_context->service is
+ *                    invalid, if @a wp_context->service has no name
+ *                    servers, or if a proxy could not be successfully
+ *                    associated with @a wp_context->service.
+ *  @retval  -ENOMEM  If a GWeb instance could not be allocated for
+ *                    the WISPr request / HTTP-based Internet
+ *                    reachability check.
+ *
+ *  @sa __connman_wispr_start
+ *
+ */
+static int wispr_portal_detect(struct connman_wispr_portal_context *wp_context,
+						guint connect_timeout_ms)
 {
 	enum connman_service_proxy_method proxy_method;
 	char *interface = NULL;
@@ -921,15 +1225,16 @@ static int wispr_portal_detect(struct connman_wispr_portal_context *wp_context)
 	int err = 0;
 	int i;
 
-	DBG("wispr/portal context %p service %p", wp_context,
-		wp_context->service);
+	DBG("wispr/portal context %p service %p (%s) type %d (%s)",
+		wp_context,
+		wp_context->service,
+		connman_service_get_identifier(wp_context->service),
+		wp_context->type, __connman_ipconfig_type2string(wp_context->type));
 
 	interface = connman_service_get_interface(wp_context->service);
 	if (!interface)
 		return -EINVAL;
 
-	DBG("interface %s", interface);
-
 	if_index = connman_inet_ifindex(interface);
 	if (if_index < 0) {
 		DBG("Could not get ifindex");
@@ -937,6 +1242,8 @@ static int wispr_portal_detect(struct connman_wispr_portal_context *wp_context)
 		goto done;
 	}
 
+	DBG("index %d (%s)", if_index, interface);
+
 	nameservers = connman_service_get_nameservers(wp_context->service);
 	if (!nameservers) {
 		DBG("Could not get nameservers");
@@ -954,6 +1261,8 @@ static int wispr_portal_detect(struct connman_wispr_portal_context *wp_context)
 	if (getenv("CONNMAN_WEB_DEBUG"))
 		g_web_set_debug(wp_context->web, web_debug, "WEB");
 
+	g_web_set_connect_timeout(wp_context->web, connect_timeout_ms);
+
 	if (wp_context->type == CONNMAN_IPCONFIG_TYPE_IPV4) {
 		g_web_set_address_family(wp_context->web, AF_INET);
 		wp_context->status_url = online_check_ipv4_url;
@@ -967,18 +1276,40 @@ static int wispr_portal_detect(struct connman_wispr_portal_context *wp_context)
 
 	proxy_method = connman_service_get_proxy_method(wp_context->service);
 
-	if (proxy_method != CONNMAN_SERVICE_PROXY_METHOD_DIRECT) {
-		wp_context->token = connman_proxy_lookup(interface,
+	DBG("proxy_method %d", proxy_method);
+
+	/*
+	 * Include both CONNMAN_SERVICE_PROXY_METHOD_UNKNOWN and
+	 * CONNMAN_SERVICE_PROXY_METHOD_DIRECT in avoiding a call to
+	 * connman_proxy_lookup, since the former will always result in
+	 * a WISPr request "falling down a hole" that will only ever
+	 * result in a failure completion.
+	 *
+	 * Whether following the connman_proxy_lookup / proxy_callback
+	 * path or the g_idle_add / no_proxy_callback path, both funnel to
+	 * proxy_callback. Retain a reference to the WISPr/portal context
+	 * here and release it there (that is, in proxy_callback) such
+	 * that the context is retained while the lookup or the idle
+	 * timeout are in flight.
+	 */
+	if (proxy_method != CONNMAN_SERVICE_PROXY_METHOD_DIRECT &&
+			proxy_method != CONNMAN_SERVICE_PROXY_METHOD_UNKNOWN) {
+		wispr_portal_context_ref(wp_context);
+
+		wp_context->proxy_token = connman_proxy_lookup(interface,
 						wp_context->status_url,
 						wp_context->service,
 						proxy_callback, wp_context);
 
-		if (wp_context->token == 0) {
+		if (wp_context->proxy_token == 0) {
 			err = -EINVAL;
 			wispr_portal_context_unref(wp_context);
 		}
-	} else if (wp_context->timeout == 0) {
-		wp_context->timeout = g_idle_add(no_proxy_callback, wp_context);
+	} else if (wp_context->proxy_timeout == 0) {
+		wispr_portal_context_ref(wp_context);
+
+		wp_context->proxy_timeout = g_idle_add(no_proxy_callback,
+						wp_context);
 	}
 
 done:
@@ -988,18 +1319,29 @@ done:
 	return err;
 }
 
-int __connman_wispr_start(struct connman_service *service,
-					enum connman_ipconfig_type type)
+/**
+ *  @brief
+ *    Return whether WISPr requests / HTTP-based Internet reachability
+ *    checks are supported.
+ *
+ *  This determines whether WISPr requests / HTTP-based Internet
+ *  reachability check are supported for the specified network service
+ *  based on its associated technology type.
+ *
+ *  @param[in]  service  A pointer to the immutable network service
+ *                       for which to check WISPr requests / HTTP-based
+ *                       Internet reachability check support.
+ *
+ *  @returns
+ *    True if the network service technology type supports WISPr
+ *    requests / HTTP-based Internet reachability checks; otherwise,
+ *    false.
+ *
+ */
+static bool is_wispr_supported(const struct connman_service *service)
 {
-	struct connman_wispr_portal_context *wp_context = NULL;
-	struct connman_wispr_portal *wispr_portal = NULL;
-	int index, err;
-
-	DBG("service %p %s", service,
-		__connman_ipconfig_type2string(type));
-
-	if (!wispr_portal_hash)
-		return -EINVAL;
+	if (!service)
+		return false;
 
 	switch (connman_service_get_type(service)) {
 	case CONNMAN_SERVICE_TYPE_ETHERNET:
@@ -1007,14 +1349,79 @@ int __connman_wispr_start(struct connman_service *service,
 	case CONNMAN_SERVICE_TYPE_BLUETOOTH:
 	case CONNMAN_SERVICE_TYPE_CELLULAR:
 	case CONNMAN_SERVICE_TYPE_GADGET:
-		break;
+		return true;
 	case CONNMAN_SERVICE_TYPE_UNKNOWN:
 	case CONNMAN_SERVICE_TYPE_SYSTEM:
 	case CONNMAN_SERVICE_TYPE_GPS:
 	case CONNMAN_SERVICE_TYPE_VPN:
 	case CONNMAN_SERVICE_TYPE_P2P:
-		return -EOPNOTSUPP;
+	default:
+		return false;
 	}
+}
+
+/**
+ *  @brief
+ *    Start a HTTP-based Internet reachability check for the specified
+ *    network service IP configuration type.
+ *
+ *  This attempts to start a HTTP-based Internet reachability check
+ *  for the specified network service IP configuration type with the
+ *  provided connection timeout and completion callback.
+ *
+ *  @param[in,out]  service             A pointer to the mutable network
+ *                                      service for which to start the
+ *                                      reachability check.
+ *  @param[in]      type                The IP configuration type for
+ *                                      which the reachability check
+ *                                      is to be started.
+ *  param[in]       connect_timeout_ms  The time, in milliseconds, for
+ *                                      the TCP connection timeout.
+ *                                      Connections that take longer
+ *                                      than this will be aborted. A
+ *                                      value of zero ('0') indicates
+ *                                      that no explicit connection
+ *                                      timeout will be used, leaving
+ *                                      the timeout to the underlying
+ *                                      operating system and its
+ *                                      network stack.
+ *  @param[in]      callback            The callback to be invoked when
+ *                                      the reachability check
+ *                                      terminates, either on failure
+ *                                      or success.
+ *
+ *  @retval  0            If successful.
+ *  @retval  -EINVAL      If the reachability check subsystem is not
+ *                        properly initialized, @a callback is null,
+ *                        or if the network interface index associated
+ *                        with @a service is invalid.
+ *  @retval  -EOPNOTSUPP  If a reachability check is not supported for
+ *                        the network service technology type.
+ *  @retval  -ENOMEM      If resources could not be allocated for the
+ *                        reachability check.
+ *
+ *  @sa __connman_wispr_stop
+ *
+ */
+int __connman_wispr_start(struct connman_service *service,
+					enum connman_ipconfig_type type,
+					guint connect_timeout_ms,
+					__connman_wispr_cb_t callback)
+{
+	struct connman_wispr_portal_context *wp_context = NULL;
+	struct connman_wispr_portal *wispr_portal = NULL;
+	int index, err;
+
+	DBG("service %p (%s) type %d (%s) connect_timeout %u ms callback %p",
+		service, connman_service_get_identifier(service),
+		type, __connman_ipconfig_type2string(type),
+		connect_timeout_ms, callback);
+
+	if (!wispr_portal_hash || !callback)
+		return -EINVAL;
+
+	if (!is_wispr_supported(service))
+		return -EOPNOTSUPP;
 
 	index = __connman_service_get_index(service);
 	if (index < 0)
@@ -1048,29 +1455,148 @@ int __connman_wispr_start(struct connman_service *service,
 
 	wp_context->service = service;
 	wp_context->type = type;
+	wp_context->cb = callback;
 	wp_context->wispr_portal = wispr_portal;
 
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV4) {
 		wispr_portal->ipv4_context = wp_context;
-	else
+		wispr_portal->ipv4_context->ops =
+			&ipv4_wispr_portal_context_route_ops;
+	} else if (type == CONNMAN_IPCONFIG_TYPE_IPV6) {
 		wispr_portal->ipv6_context = wp_context;
+		wispr_portal->ipv6_context->ops =
+			&ipv6_wispr_portal_context_route_ops;
+	} else {
+		err = -EINVAL;
+		goto free_wp;
+	}
 
-	err = wispr_portal_detect(wp_context);
+	err = wispr_portal_detect(wp_context, connect_timeout_ms);
 	if (err)
 		goto free_wp;
 	return 0;
 
 free_wp:
+	DBG("err %d wp_context %p", err, wp_context);
+
+	wp_context->cb(wp_context->service, wp_context->type, false, err);
+
 	g_hash_table_remove(wispr_portal_hash, GINT_TO_POINTER(index));
 	return err;
 }
 
+/**
+ *  @brief
+ *    Cancel a HTTP-based Internet reachability check for the specified
+ *    network service IP configuration type.
+ *
+ *  This attempts to cancel a HTTP-based Internet reachability check
+ *  for the specified network service IP configuration type.
+ *
+ *  If a matching HTTP-based Internet reachability check is found, the
+ *  original callback specified with #__connman_wispr_start will be
+ *  invoked with a success value of zero ('0') or false and an error
+ *  value of -ECANCELED.
+ *
+ *  @param[in,out]  service             A pointer to the mutable network
+ *                                      service for which to cancel the
+ *                                      reachability check.
+ *  @param[in]      type                The IP configuration type for
+ *                                      which the reachability check
+ *                                      is to be cancelled.
+ *
+ *  @retval  0            If a matching HTTP-based Internet reachability
+ *                        check was successfully cancelled.
+ *  @retval  -EINVAL      If the IP configuration type is not X or Y or
+ *                        if the network interface index associated
+ *                        with @a service is invalid.
+ *  @retval  -ENOENT      If a matching HTTP-based Internet reachability
+ *                        check could not be found.
+ *  @retval  -EOPNOTSUPP  If HTTP-based Internet reachability checks are
+ *                        not supported for the technology type
+ *                        associated with @a service.
+ *
+ *  @sa __connman_wispr_start
+ *  @sa __connman_wispr_stop
+ *
+ */
+int __connman_wispr_cancel(struct connman_service *service,
+					enum connman_ipconfig_type type)
+{
+	struct connman_wispr_portal_context *wp_context = NULL;
+	struct connman_wispr_portal *wispr_portal = NULL;
+	int index;
+
+	DBG("service %p (%s) type %d (%s)",
+		service, connman_service_get_identifier(service),
+		type, __connman_ipconfig_type2string(type));
+
+	if (!is_wispr_supported(service))
+		return -EOPNOTSUPP;
+
+	index = __connman_service_get_index(service);
+	if (index < 0)
+		return -EINVAL;
+
+	DBG("index %d", index);
+
+	if (!wispr_portal_hash)
+		return -ENOENT;
+
+	wispr_portal = g_hash_table_lookup(wispr_portal_hash,
+					GINT_TO_POINTER(index));
+
+	DBG("wispr_portal %p", wispr_portal);
+
+	if (!wispr_portal)
+		return -ENOENT;
+
+	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
+		wp_context = wispr_portal->ipv4_context;
+	else if (type == CONNMAN_IPCONFIG_TYPE_IPV6)
+		wp_context = wispr_portal->ipv6_context;
+	else
+		return -EINVAL;
+
+	DBG("wp_context %p", wp_context);
+
+	if (!wp_context)
+		return -ENOENT;
+
+	cancel_connman_wispr_portal_context(wp_context);
+
+	wp_context->cb(wp_context->service,
+			wp_context->type,
+			false,
+			-ECANCELED);
+
+	wispr_portal_context_unref(wp_context);
+
+	return 0;
+}
+
+/**
+ *  @brief
+ *    Stop all HTTP-based Internet reachability checks for the specified
+ *    network service.
+ *
+ *  This attempts to stop all HTTP-based Internet reachability checks
+ *  for the specified network service.
+ *
+ *  @param[in,out]  service  A pointer to the mutable network service
+ *                           for which to stop all reachability
+ *                           checks.
+ *
+ *  @sa __connman_wispr_start
+ *  @sa __connman_wispr_cancel
+ *
+ */
 void __connman_wispr_stop(struct connman_service *service)
 {
 	struct connman_wispr_portal *wispr_portal;
 	int index;
 
-	DBG("service %p", service);
+	DBG("service %p (%s)", service, connman_service_get_identifier(service));
 
 	if (!wispr_portal_hash)
 		return;
@@ -1104,9 +1630,6 @@ int __connman_wispr_init(void)
 	online_check_ipv6_url =
 		connman_setting_get_string("OnlineCheckIPv6URL");
 
-	enable_online_to_ready_transition =
-		connman_setting_get_bool("EnableOnlineToReadyTransition");
-
 	return 0;
 }
 
diff --git a/src/wpad.c b/src/wpad.c
index 54084ee8..e1886d2b 100644
--- a/src/wpad.c
+++ b/src/wpad.c
@@ -131,7 +131,7 @@ int __connman_wpad_start(struct connman_service *service)
 	int index;
 	int i;
 
-	DBG("service %p", service);
+	DBG("service %p (%s)", service, connman_service_get_identifier(service));
 
 	if (!wpad_list)
 		return -EINVAL;
diff --git a/tools/iptables-unit.c b/tools/iptables-unit.c
index b91591f2..d490b87d 100644
--- a/tools/iptables-unit.c
+++ b/tools/iptables-unit.c
@@ -624,7 +624,7 @@ struct connman_service {
 	char *dummy;
 };
 
-char *connman_service_get_interface(struct connman_service *service)
+char *connman_service_get_interface(const struct connman_service *service)
 {
 	return "eth0";
 }
diff --git a/tools/web-test.c b/tools/web-test.c
index 55c58af5..a65e6c11 100644
--- a/tools/web-test.c
+++ b/tools/web-test.c
@@ -150,7 +150,8 @@ int main(int argc, char *argv[])
 
 	timer = g_timer_new();
 
-	if (g_web_request_get(web, argv[1], web_result, NULL,  NULL) == 0) {
+	if (g_web_request_get(web, argv[1], web_result,
+			NULL, NULL, NULL) == 0) {
 		fprintf(stderr, "Failed to start request\n");
 		return 1;
 	}
diff --git a/tools/wispr.c b/tools/wispr.c
index e56dfc16..ef7b60d3 100644
--- a/tools/wispr.c
+++ b/tools/wispr.c
@@ -531,7 +531,7 @@ static bool wispr_result(GWebResult *result, gpointer user_data)
 		printf("\n");
 
 		wispr->request = g_web_request_get(wispr->web, redirect,
-				wispr_result, wispr_route, wispr);
+				wispr_result, wispr_route, wispr, NULL);
 
 		return false;
 	}
@@ -591,7 +591,7 @@ static bool wispr_result(GWebResult *result, gpointer user_data)
 		printf("\n");
 
 		wispr->request = g_web_request_get(wispr->web, redirect,
-				wispr_result, NULL, wispr);
+				wispr_result, NULL, wispr, NULL);
 
 		return false;
 	}
@@ -608,7 +608,7 @@ static gboolean execute_login(gpointer user_data)
 
 	wispr->request = g_web_request_post(wispr->web, wispr->msg.login_url,
 					"application/x-www-form-urlencoded",
-					wispr_input, wispr_result, wispr);
+					wispr_input, wispr_result, wispr, NULL);
 
 	wispr_msg_init(&wispr->msg);
 
@@ -694,7 +694,7 @@ int main(int argc, char *argv[])
 						parser_callback, &wispr);
 
 	wispr.request = g_web_request_get(wispr.web, option_url,
-			wispr_result, wispr_route, &wispr);
+			wispr_result, wispr_route, &wispr, NULL);
 
 	if (wispr.request == 0) {
 		fprintf(stderr, "Failed to start request\n");
diff --git a/unit/test-iptables.c b/unit/test-iptables.c
index f08736ea..a96d8679 100644
--- a/unit/test-iptables.c
+++ b/unit/test-iptables.c
@@ -69,13 +69,13 @@ static void set_test_config(enum configtype type)
 #define IP6T_SO_GET_INFO		(IP6T_BASE_CTL)
 #define IP6T_SO_GET_ENTRIES		(IP6T_BASE_CTL + 1)
 
-int static xt_match_parse(int c, char **argv, int invert, unsigned int *flags,
+static int xt_match_parse(int c, char **argv, int invert, unsigned int *flags,
 			const void *entry, struct xt_entry_match **match)
 {
 	return 0;
 }
 
-int static xt_target_parse(int c, char **argv, int invert, unsigned int *flags,
+static int xt_target_parse(int c, char **argv, int invert, unsigned int *flags,
 			const void *entry, struct xt_entry_target **targetinfo)
 {
 	return 0;
@@ -210,8 +210,6 @@ void xtables_option_mfcall(struct xtables_match *m)
 	if (test_config_type & TEST_CONFIG_MFCALL_FAIL)
 		call_error("xtables_option_mfcall");
 
-	m = &xt_match;
-
 	return;
 }
 
@@ -222,8 +220,6 @@ void xtables_option_tfcall(struct xtables_target *t)
 	if (test_config_type & TEST_CONFIG_TFCALL_FAIL)
 		call_error("xtables_option_tfcall");
 
-	t = &xt_target;
-
 	return;
 }
 
@@ -235,8 +231,6 @@ void xtables_option_mpcall(unsigned int c, char **argv, bool invert,
 	if (test_config_type & TEST_CONFIG_MPCALL_FAIL)
 		call_error("xtables_option_mpcall");
 
-	m = &xt_match;
-
 	return;
 }
 
@@ -248,8 +242,6 @@ void xtables_option_tpcall(unsigned int c, char **argv, bool invert,
 	if (test_config_type & TEST_CONFIG_TPCALL_FAIL)
 		call_error("xtables_option_tpcall");
 
-	t = &xt_target;
-
 	return;
 }
 
diff --git a/vpn/vpn-provider.c b/vpn/vpn-provider.c
index cc325967..4bcb8373 100644
--- a/vpn/vpn-provider.c
+++ b/vpn/vpn-provider.c
@@ -2952,22 +2952,6 @@ void vpn_provider_set_auth_error_limit(struct vpn_provider *provider,
 	provider->auth_error_limit = limit;
 }
 
-bool __vpn_provider_check_routes(struct vpn_provider *provider)
-{
-	if (!provider)
-		return false;
-
-	if (provider->user_routes &&
-			g_hash_table_size(provider->user_routes) > 0)
-		return true;
-
-	if (provider->routes &&
-			g_hash_table_size(provider->routes) > 0)
-		return true;
-
-	return false;
-}
-
 void *vpn_provider_get_data(struct vpn_provider *provider)
 {
 	return provider->driver_data;
diff --git a/vpn/vpn-rtnl.c b/vpn/vpn-rtnl.c
index 5a02d779..a6b07858 100644
--- a/vpn/vpn-rtnl.c
+++ b/vpn/vpn-rtnl.c
@@ -64,8 +64,6 @@ static GSList *watch_list = NULL;
 static unsigned int watch_id = 0;
 
 static GSList *update_list = NULL;
-static guint update_interval = G_MAXUINT;
-static guint update_timeout = 0;
 
 struct interface_data {
 	int index;
@@ -147,61 +145,6 @@ void vpn_rtnl_remove_watch(unsigned int id)
 	}
 }
 
-static void trigger_rtnl(int index, void *user_data)
-{
-	struct vpn_rtnl *rtnl = user_data;
-
-	if (rtnl->newlink) {
-		unsigned short type = __vpn_ipconfig_get_type_from_index(index);
-		unsigned int flags = __vpn_ipconfig_get_flags_from_index(index);
-
-		rtnl->newlink(type, index, flags, 0);
-	}
-}
-
-static GSList *rtnl_list = NULL;
-
-static gint compare_priority(gconstpointer a, gconstpointer b)
-{
-	const struct vpn_rtnl *rtnl1 = a;
-	const struct vpn_rtnl *rtnl2 = b;
-
-	return rtnl2->priority - rtnl1->priority;
-}
-
-/**
- * vpn_rtnl_register:
- * @rtnl: RTNL module
- *
- * Register a new RTNL module
- *
- * Returns: %0 on success
- */
-int vpn_rtnl_register(struct vpn_rtnl *rtnl)
-{
-	DBG("rtnl %p name %s", rtnl, rtnl->name);
-
-	rtnl_list = g_slist_insert_sorted(rtnl_list, rtnl,
-							compare_priority);
-
-	vpn_ipconfig_foreach(trigger_rtnl, rtnl);
-
-	return 0;
-}
-
-/**
- * vpn_rtnl_unregister:
- * @rtnl: RTNL module
- *
- * Remove a previously registered RTNL module
- */
-void vpn_rtnl_unregister(struct vpn_rtnl *rtnl)
-{
-	DBG("rtnl %p name %s", rtnl, rtnl->name);
-
-	rtnl_list = g_slist_remove(rtnl_list, rtnl);
-}
-
 static const char *operstate2str(unsigned char operstate)
 {
 	switch (operstate) {
@@ -322,13 +265,6 @@ static void process_newlink(unsigned short type, int index, unsigned flags,
 					GINT_TO_POINTER(index), interface);
 	}
 
-	for (list = rtnl_list; list; list = list->next) {
-		struct vpn_rtnl *rtnl = list->data;
-
-		if (rtnl->newlink)
-			rtnl->newlink(type, index, flags, change);
-	}
-
 	for (list = watch_list; list; list = list->next) {
 		struct watch_data *watch = list->data;
 
@@ -346,7 +282,6 @@ static void process_dellink(unsigned short type, int index, unsigned flags,
 	struct rtnl_link_stats stats;
 	unsigned char operstate = 0xff;
 	const char *ifname = NULL;
-	GSList *list;
 
 	memset(&stats, 0, sizeof(stats));
 	extract_link(msg, bytes, NULL, &ifname, NULL, &operstate, &stats);
@@ -356,13 +291,6 @@ static void process_dellink(unsigned short type, int index, unsigned flags,
 						ifname, index, operstate,
 						operstate2str(operstate));
 
-	for (list = rtnl_list; list; list = list->next) {
-		struct vpn_rtnl *rtnl = list->data;
-
-		if (rtnl->dellink)
-			rtnl->dellink(type, index, flags, change);
-	}
-
 	switch (type) {
 	case ARPHRD_ETHER:
 	case ARPHRD_LOOPBACK:
@@ -428,7 +356,6 @@ static void extract_ipv6_route(struct rtmsg *msg, int bytes, int *index,
 static void process_newroute(unsigned char family, unsigned char scope,
 						struct rtmsg *msg, int bytes)
 {
-	GSList *list;
 	char dststr[INET6_ADDRSTRLEN], gatewaystr[INET6_ADDRSTRLEN];
 	int index = -1;
 
@@ -465,21 +392,12 @@ static void process_newroute(unsigned char family, unsigned char scope,
 
 		if (!IN6_IS_ADDR_UNSPECIFIED(&dst))
 			return;
-	} else
-		return;
-
-	for (list = rtnl_list; list; list = list->next) {
-		struct vpn_rtnl *rtnl = list->data;
-
-		if (rtnl->newgateway)
-			rtnl->newgateway(index, gatewaystr);
 	}
 }
 
 static void process_delroute(unsigned char family, unsigned char scope,
 						struct rtmsg *msg, int bytes)
 {
-	GSList *list;
 	char dststr[INET6_ADDRSTRLEN], gatewaystr[INET6_ADDRSTRLEN];
 	int index = -1;
 
@@ -516,14 +434,6 @@ static void process_delroute(unsigned char family, unsigned char scope,
 
 		if (!IN6_IS_ADDR_UNSPECIFIED(&dst))
 			return;
-	} else
-		return;
-
-	for (list = rtnl_list; list; list = list->next) {
-		struct vpn_rtnl *rtnl = list->data;
-
-		if (rtnl->delgateway)
-			rtnl->delgateway(index, gatewaystr);
 	}
 }
 
@@ -1017,78 +927,6 @@ static int send_getroute(void)
 	return queue_request(hdr);
 }
 
-static gboolean update_timeout_cb(gpointer user_data)
-{
-	__vpn_rtnl_request_update();
-
-	return TRUE;
-}
-
-static void update_interval_callback(guint min)
-{
-	if (update_timeout > 0)
-		g_source_remove(update_timeout);
-
-	if (min < G_MAXUINT) {
-		update_interval = min;
-		update_timeout = g_timeout_add_seconds(update_interval,
-						update_timeout_cb, NULL);
-	} else {
-		update_timeout = 0;
-		update_interval = G_MAXUINT;
-	}
-}
-
-static gint compare_interval(gconstpointer a, gconstpointer b)
-{
-	guint val_a = GPOINTER_TO_UINT(a);
-	guint val_b = GPOINTER_TO_UINT(b);
-
-	return val_a - val_b;
-}
-
-unsigned int __vpn_rtnl_update_interval_add(unsigned int interval)
-{
-	guint min;
-
-	if (interval == 0)
-		return 0;
-
-	update_list = g_slist_insert_sorted(update_list,
-			GUINT_TO_POINTER(interval), compare_interval);
-
-	min = GPOINTER_TO_UINT(g_slist_nth_data(update_list, 0));
-	if (min < update_interval) {
-		update_interval_callback(min);
-		__vpn_rtnl_request_update();
-	}
-
-	return update_interval;
-}
-
-unsigned int __vpn_rtnl_update_interval_remove(unsigned int interval)
-{
-	guint min = G_MAXUINT;
-
-	if (interval == 0)
-		return 0;
-
-	update_list = g_slist_remove(update_list, GINT_TO_POINTER(interval));
-
-	if (update_list)
-		min = GPOINTER_TO_UINT(g_slist_nth_data(update_list, 0));
-
-	if (min > update_interval)
-		update_interval_callback(min);
-
-	return min;
-}
-
-int __vpn_rtnl_request_update(void)
-{
-	return send_getlink();
-}
-
 int __vpn_rtnl_init(void)
 {
 	struct sockaddr_nl addr;
diff --git a/vpn/vpn-rtnl.h b/vpn/vpn-rtnl.h
index aa640a66..514fe02f 100644
--- a/vpn/vpn-rtnl.h
+++ b/vpn/vpn-rtnl.h
@@ -40,24 +40,6 @@ unsigned int vpn_rtnl_add_newlink_watch(int index,
 
 void vpn_rtnl_remove_watch(unsigned int id);
 
-#define VPN_RTNL_PRIORITY_LOW      -100
-#define VPN_RTNL_PRIORITY_DEFAULT     0
-#define VPN_RTNL_PRIORITY_HIGH      100
-
-struct vpn_rtnl {
-	const char *name;
-	int priority;
-	void (*newlink) (unsigned short type, int index,
-					unsigned flags, unsigned change);
-	void (*dellink) (unsigned short type, int index,
-					unsigned flags, unsigned change);
-	void (*newgateway) (int index, const char *gateway);
-	void (*delgateway) (int index, const char *gateway);
-};
-
-int vpn_rtnl_register(struct vpn_rtnl *rtnl);
-void vpn_rtnl_unregister(struct vpn_rtnl *rtnl);
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/vpn/vpn.h b/vpn/vpn.h
index 477cb227..1f8c8fcd 100644
--- a/vpn/vpn.h
+++ b/vpn/vpn.h
@@ -73,7 +73,6 @@ void __vpn_ipconfig_cleanup(void);
 #include "vpn-provider.h"
 
 char *__vpn_provider_create_identifier(const char *host, const char *domain);
-bool __vpn_provider_check_routes(struct vpn_provider *provider);
 int __vpn_provider_append_user_route(struct vpn_provider *provider,
 				int family, const char *network,
 				const char *netmask, const char *gateway);
@@ -104,9 +103,6 @@ int __vpn_rtnl_init(void);
 void __vpn_rtnl_start(void);
 void __vpn_rtnl_cleanup(void);
 
-unsigned int __vpn_rtnl_update_interval_add(unsigned int interval);
-unsigned int __vpn_rtnl_update_interval_remove(unsigned int interval);
-int __vpn_rtnl_request_update(void);
 int __vpn_rtnl_send(const void *buf, size_t len);
 
 int __vpn_config_init(void);
